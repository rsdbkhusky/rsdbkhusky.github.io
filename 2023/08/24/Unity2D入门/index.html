<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Unity2D入门 | 燃烧的冰块_husky's blog</title><meta name="keywords" content="编程,代码"><meta name="author" content="rsdbk_husky,rsdbk_husky@foxmail.com"><meta name="copyright" content="rsdbk_husky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity 代码编辑器 建议使用Vscode，建议安装两个插件：  窗口 窗口一览  窗口布局的设置 可使用「菜单栏-窗口-布局」中的操作来加载、导入、导出窗口布局。 游戏视图中模拟器的选择   长宽比适中：Apple iPhone 13 Pro Max   长宽比过小：Apple iPad Mini 4   长宽比过大：Samsung Galaxy Z Fold2 5G   俯视角渲染模式的设置">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity2D入门">
<meta property="og:url" content="http://rsdbkhusky.github.io/2023/08/24/Unity2D%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="燃烧的冰块_husky&#39;s blog">
<meta property="og:description" content="Unity 代码编辑器 建议使用Vscode，建议安装两个插件：  窗口 窗口一览  窗口布局的设置 可使用「菜单栏-窗口-布局」中的操作来加载、导入、导出窗口布局。 游戏视图中模拟器的选择   长宽比适中：Apple iPhone 13 Pro Max   长宽比过小：Apple iPad Mini 4   长宽比过大：Samsung Galaxy Z Fold2 5G   俯视角渲染模式的设置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/cover.png">
<meta property="article:published_time" content="2023-08-24T13:00:00.000Z">
<meta property="article:modified_time" content="2023-08-24T14:06:02.098Z">
<meta property="article:author" content="rsdbk_husky">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/cover.png"><link rel="shortcut icon" href="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.png"><link rel="canonical" href="http://rsdbkhusky.github.io/2023/08/24/Unity2D%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity2D入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-24 22:06:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E5%A4%B4%E5%83%8F.png" onerror="onerror=null;src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">180</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/%E6%A8%A1%E6%9D%BF%E5%BA%93/"><i class="fa-fw fas fa-th"></i><span> 模板库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">燃烧的冰块_husky's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/%E6%A8%A1%E6%9D%BF%E5%BA%93/"><i class="fa-fw fas fa-th"></i><span> 模板库</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity2D入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-24T13:00:00.000Z" title="发表于 2023-08-24 21:00:00">2023-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-24T14:06:02.098Z" title="更新于 2023-08-24 22:06:02">2023-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity2D入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Unity</h1>
<h2 id="代码编辑器">代码编辑器</h2>
<p>建议使用Vscode，建议安装两个插件：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-34.png" height=250>
<h2 id="窗口">窗口</h2>
<h3 id="窗口一览">窗口一览</h3>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-17.png" height=500>
<h3 id="窗口布局的设置">窗口布局的设置</h3>
<p>可使用「菜单栏-窗口-布局」中的操作来加载、导入、导出窗口布局。</p>
<h3 id="游戏视图中模拟器的选择">游戏视图中模拟器的选择</h3>
<ul>
<li>
<p>长宽比适中：Apple iPhone 13 Pro Max</p>
</li>
<li>
<p>长宽比过小：Apple iPad Mini 4</p>
</li>
<li>
<p>长宽比过大：Samsung Galaxy Z Fold2 5G</p>
</li>
</ul>
<h2 id="俯视角渲染模式的设置">俯视角渲染模式的设置</h2>
<h3 id="透视叠层的排序方法的设置">透视叠层的排序方法的设置</h3>
<p>「菜单栏-编辑-项目设置-图形-摄像机设置」中，「透明度排序模式」值改为「自定义轴」，「透明度排序轴」的「x、y、z」改为你想要的用于渲染排序的权值。</p>
<h3 id="图片轴心的设置">图片轴心的设置</h3>
<p>点击「项目视图-你要更改轴心的图片」，更改「检查视图-Sprite模式-轴心」的值为「自定义」。点击下方的「SpriteEditor」，弹出窗口，「轴点单位模式」的「Normalized」是轴心坐标相对于图片大小的比例，「Pixels」是轴心坐标的像素数，注意编辑结束关闭该窗口前需点击「应用」。</p>
<p>大量同种图片可批量设置轴心。</p>
<h3 id="场景视图中操作点的设置">场景视图中操作点的设置</h3>
<p>更改完图片轴心后，若点击场景视图中选中的对象的操作点未改变，则可以试一下更改场景视图上部的值为「轴心」：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image.png" height=90>
<h3 id="对象Sprite排序点的设置">对象Sprite排序点的设置</h3>
<p>选中你想更改的对象，更改「检查视图-SpriteRenderer-Sprite排序点」的值为「轴心」。</p>
<h2 id="Transform">Transform</h2>
<h3 id="检查视图设置">检查视图设置</h3>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-32.png" height=80>
<h3 id="函数调用">函数调用</h3>
<p>因为是第一次将编写脚本相关的知识，所以先引入一些前置知识。</p>
<p>建议在「项目视图-Assets」下创建一个文件夹「Scripts」，在该文件夹下创建一个C#类型文件。</p>
<p>这是新建C#脚本后的初始内容：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NAME</span><span class="comment">/*脚本名*/</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中这个类的名称一定要与脚本文件的名称保持一致，且一定要继承<code>MonoBehaviour</code>，否则无法在Unity中使用。</p>
<p>可以使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在命令行中输出<code>Hello world!</code>，用于调试。</p>
<p>前置知识引入完毕。</p>
<p>一般来说如果需要使用脚本所在对象自身的某个组件会使用<code>GetComponent</code>，但因为任何对象都有「Transform」组件，所以Unity中自带一个名为<code>transform</code>的属性可以直接使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector3 transform.localPosition</span><br><span class="line">Vector3 transform.position</span><br><span class="line">Vector3 transform.localEulerAngles</span><br><span class="line">Vector3 transform.eulerAngles</span><br><span class="line">Vector3 transform.localScale</span><br><span class="line">Vector3 transform.lossyScale</span><br></pre></td></tr></table></figure>
<p>这六个属性的含义分别是「相对于父级的位置」、「全局位置」、「相对于父级的旋转」、「全局旋转」、「相对于父级的缩放」、「全局缩放」。</p>
<p>除了<code>lossyScale</code>是只读的，其他都是可读可写的。更改时不能只更改单个维度，如<code>transform.position.x = 1f</code>，只能一并更改，如<code>transform.position = new Vector3(1f, 0f, 0f)</code>。</p>
<p><code>localEulerAngles</code>和<code>eulerAngles</code>在被赋值时可以被赋任意值，但其会将每一个维度上的值都化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>360</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,360)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">360</span><span class="mclose">)</span></span></span></span> 的值，读取时只会读到这个范围的值。另外<code>localRotation</code>和<code>rotation</code>这两个属性的使用相对复杂，可见后文「四元数与旋转」一章。</p>
<h2 id="SpriteRenderer">SpriteRenderer</h2>
<h3 id="检查视图设置-2">检查视图设置</h3>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-33.png" height=205>
<ul>
<li>
<p>「翻转」</p>
<p>勾选后贴图沿镜面翻转，常用于减少贴图量、动画量。</p>
</li>
<li>
<p>「Sprite排序点」</p>
<p>见之前章节「俯视角渲染模式的设置-对象Sprite排序点的设置」。</p>
</li>
<li>
<p>「排序图层」和「图层顺序」</p>
<p>点击「排序图层-AddSortingLayer」即可进入管理图层列表。</p>
<p>「排序图层」和「图层顺序」都是值越高渲染时越靠上。</p>
<p>「排序图层」和「图层顺序」和「透视叠层的排序方法」，这三者的优先级是递减的。</p>
</li>
</ul>
<h3 id="函数调用-2">函数调用</h3>
<p>要使用脚本所在对象自身的「SpriteRenderer」组件，就需要<code>GetComponent</code>函数获取了，建议获取组件的代码放在<code>Awake</code>函数中：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SpriteRenderer sr;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    sr = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用属性：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> sr.flipX</span><br><span class="line"><span class="built_in">bool</span> sr.flipY</span><br><span class="line"><span class="built_in">string</span> sr.sortingLayerName</span><br><span class="line"><span class="built_in">int</span> sr.sortingOrder</span><br></pre></td></tr></table></figure>
<p>这四个属性的含义分别是「翻转x轴」、「翻转y轴」、「排序图层」、「图层顺序」。</p>
<p>均为可读可写。</p>
<h2 id="代码相关补充知识">代码相关补充知识</h2>
<h3 id="变量的赋值位置">变量的赋值位置</h3>
<p>建议如果是需要在编辑器检查窗口中调值的<code>public</code>变量，在声明时赋值；而如果是不需要在编辑器检查窗口中调值的<code>private</code>变量，在<code>Awake</code>函数中赋值。</p>
<p>如果你想让一个变量在每次启动游戏时被赋为某一个值，而你却在声明时赋值，且你又在编辑器检查窗口中调了它的值，则在进入游戏时他不会是你在代码中声明变量时赋的值，而是你调的值。</p>
<h3 id="常用标签属性">常用标签属性</h3>
<p>标签属性能是你的脚本在编辑器检查窗口中有着不一样的显示。</p>
<p>使用方法是在代码中声明变量前加上一些内容，例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;NAME&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> a;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> b;</span><br><span class="line">[<span class="meta">Space(30)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> c;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-27.png" height=100>
<ul>
<li>
<p><code>[Header(&quot;XXX&quot;)]</code></p>
<p>标题。</p>
</li>
<li>
<p><code>[Space]</code>/<code>[Space(XXX)]</code></p>
<p>一段空行，参数可有可无。</p>
</li>
<li>
<p><code>[Tooltip(&quot;XXX&quot;)]</code></p>
<p>将鼠标悬停在检查窗口的变量名上可显示提示。</p>
</li>
<li>
<p><code>[SerializeField]</code></p>
<p>强制序列化并显示在检查窗口中。</p>
</li>
<li>
<p><code>[System.NonSerialized]</code></p>
<p>强制不序列化并不显示在检查窗口中。</p>
</li>
</ul>
<p>另外还有一个<code>[HideInInspector]</code>，和<code>[System.NonSerialized]</code>有相似之处，但不建议使用，原因是他可能会让代码让我们认为的值和实际值不同。</p>
<h3 id="对象的标签">对象的标签</h3>
<p>不要将标签属性和对象标签搞混了，对象的标签是这个：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-38.png" height=265>
<p>对象本身（<code>GameObject</code>）和上面的任意组件（例如<code>Transform</code>），都有两个和对象的标签相关的属性和方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.tag = <span class="string">&quot;NAME&quot;</span>;</span><br><span class="line">transform.CompareTag(<span class="string">&quot;NAME&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>tag</code>可读可写，<code>CompareTag</code>返回<code>bool</code>值。</p>
<h3 id="对象的名称">对象的名称</h3>
<p>在脚本中可以使用<code>GameObject</code>类下的属性<code>name</code>读取或修改对象的名称：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(gameObject.name);</span><br><span class="line">gameObject.name = <span class="string">&quot;NEWNAME&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="输入系统-InputSystem">输入系统(InputSystem)</h2>
<h3 id="输入系统的设置">输入系统的设置</h3>
<p>「菜单栏-编辑-项目设置-玩家-设置Windows，Mac，Linux-其他设置-配置-活动输入处理」的值改为「输入系统包（新）」。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-1.png" height=400>
<h3 id="安装InputSystem">安装InputSystem</h3>
<p>点击「工具栏-窗口-包管理器」，弹出新窗口，新窗口左上方「包：XXX」改为「包：Unity注册表」搜索「InputSystem」，点击右下角「安装」。</p>
<h3 id="创建InputControl文件">创建InputControl文件</h3>
<p>建议在「项目视图-Assets」下创建一个文件夹「Settings」，在该文件夹下创建一个「InputActions」类型文件，建议重命名为「InputControls」。</p>
<h3 id="设置InputControl文件">设置InputControl文件</h3>
<p>双击打开新窗口，开始编辑。新建一个「ActionMap」。</p>
<h4 id="ActionMap，Action和Binding">ActionMap，Action和Binding</h4>
<p>可以发现「ActionMap」，「Action」，「Binding」形成了共三层的从属关系，每个「ActionMap」包含几个「Action」，每个「Action」包含几个「Binding」。</p>
<p>在游戏中的不同的按键使用场景，例如开始界面和游戏界面，按键有不同的功能，这时需要不同「ActionMap」来管理按键。</p>
<p>不同的设备有不同的按键，为了使游戏对多种设备兼容，一个「Action」需要有多个「Binding」，当然也可以是同一设备上同一按键操作绑定给多个按键，例如w和上箭头。</p>
<h4 id="Action的设置">Action的设置</h4>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-13.png" height=120>
<ul>
<li>
<p>「动作」</p>
<p>「ActionType」有三个选项，这里只介绍其中的「按钮」和「值」。</p>
<ul>
<li>
<p>「按钮」</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-14.png" height=70>
<p>「初始状态检测(InitialStateCheck)」检测该按钮初始时是否处于激发态上，并根据判断结果的是否来决定是否一开始就执行操作。</p>
</li>
<li>
<p>「值」</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-25.png" height=70>
<p>多用于持续更改的状态的输入，如鼠标的位置，手柄的状态。</p>
<p>如果有多个设备绑定这个Action，只会发送其中一个设备（最受控制的）的输入。</p>
</li>
</ul>
</li>
<li>
<p>「Interactions」</p>
<p>在「Binding」中也可设置「Interactions」，但只作用于该「Binding」，在「Action」中设置可作用于所有子「Binding」。</p>
<p>所有输入检测模式都会发出3种信息，并将这些信息传给被调用的函数，分别是「started」、「performed」、「canceled」。接下来介绍不同输入检测模式何时发出这些信息。</p>
<ul>
<li>
<p>「Default」</p>
<p>没有添加「Interactions」时，即默认时，是这种状态。</p>
<p>当输入设备响应会调用「started」回调（例如按钮按下，或者鼠标开始拖动）；当设备响应中时会调用「performed」回调（在「started」后触发，调用一次，若为「值」的话，当值发生变化会再次触发，例如遥感，按住之后每次偏移位置都会触发一次）；当输入设备结束响应会调用「canceled」回调（例如按钮松开，或者鼠标停止拖动）。若为「PassThrough」的时候，只会调用「performed」回调。</p>
<p>一般使用「按钮」时不使用「Default」；使用「值」时使用「Default」就可以了。</p>
</li>
<li>
<p>「Press」</p>
<p>模拟按钮。</p>
<p>所有该类输入模式的「started」都于键被按下是发出，「canceled」都于键被松开时发出。</p>
<p>其子模式「PressOnly」的「performed」于键被按下时发出；「ReleaseOnly」的「performed」于键被松开时发出；「PressAndRelease」的「performed」于键被按下或松开时都会发出。</p>
</li>
<li>
<p>「Tap」</p>
<p>模拟短按按钮。</p>
<p>「started」于键被按下时发出。若「MaxTapDuriation」时间内松开键，触发「performed」，否则触发「canceled」。</p>
</li>
<li>
<p>「Hold」</p>
<p>模拟长按按钮。</p>
<p>「started」于键被按下时发出；「canceled」于键被松开时发出。如果在「MaxTapDuriation」时间后仍未松开，则此时触发「performed」。</p>
</li>
<li>
<p>「SlowTap」</p>
<p>模拟长按按钮，虽然叫什么什么Tap，实际上和「Hold」更像。</p>
<p>「started」于键被按下时发出。如果在「MaxTapDuriation」时间内松开键，则松开时触发「canceled」，否则松开时触发「performed」。</p>
</li>
<li>
<p>「MultiTap」</p>
<p>模拟连按短按按钮。</p>
<p>「started」于第一次键被按下时发出，包括第一次在内，若连续短按「TapCount」次，且满足每次短按的时长不超过「MaxTapDuration」，短按与短按之间时长不超过「MaxTapSpacing」，则在最后一次短按松开时触发「performed」，否则在要求不满足时触发「canceled」，且停止判定。</p>
</li>
</ul>
</li>
</ul>
<h4 id="Binding的设置">Binding的设置</h4>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-16.png" height=120>
<ul>
<li>
<p>Binding</p>
<p>常用的「Path」有键盘上的各个键（可通过监听来添加），和「Press(Touchscreen)」、「Position(Touchscreen)」。</p>
</li>
</ul>
<h3 id="PlayerInput组件的添加和配置">PlayerInput组件的添加和配置</h3>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-5.png" height=500>
<p>添加组件「PlayerInput」，将InputControl文件填入，将「Behavior」改为「InvokeUnityEvents」，然后下方会出现「事件」，展开。将层级视图中的某对象填入，再选择要调用的函数（当然，得先写一段脚本并安装在该对象上，这样才有的可调用），这样，从硬件设备的信息输入到调用函数的一条信息传递链就完成了。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-3.png" height=250>
<h3 id="3D图标的设置">3D图标的设置</h3>
<p>添加完「PlayerInput」组件后，会发现场景视图中该对象操作点位置处出现了一个这样的图标，看起来很碍事：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-8.png" height=80>
<p>例如摄像机也有这种图标：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-9.png" height=80>
<p>如果想关闭，进行如下操作：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-10.png" height=160>
<h3 id="编写脚本">编写脚本</h3>
<h4 id="头文件和函数格式">头文件和函数格式</h4>
<p>如果希望该脚本中的一些函数能使用<code>InputAction</code>里的内容，需要在头文件处加上：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br></pre></td></tr></table></figure>
<p>被调用的函数的格式应为：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NAME</span>(<span class="params">InputAction.CallbackContext context</span>)</span>&#123;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>访问修饰符需要为<code>public</code>才能在Unity中「PlayerInput」组件的函数列表中找到。但有趣的是，如果先将访问修饰符设为<code>public</code>，再在「PlayerInput」组件的函数列表中找到该函数，后将访问修饰符改为<code>private</code>，虽然组件的函数列表中找不到了，但是能正常运行且不会报错。</p>
<p>这里不加<code>InputAction.CallbackContext context</code>也能成功调用，但那里面是「PlayerInput」传给被调用函数的信息，包括各种输入设备传来的信息，一般都会使用。</p>
<h4 id="信息类型的判断">信息类型的判断</h4>
<p>这是三个bool值，用于判断传来的是哪种信息。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.started</span><br><span class="line">context.canceled</span><br><span class="line">context.performed</span><br></pre></td></tr></table></figure>
<h4 id="获取和使用点击屏幕的位置">获取和使用点击屏幕的位置</h4>
<p>为获取点击屏幕的位置，首先要将「Binding」设为「Position(Touchscreen)」；将「动作」设为「值」。</p>
<p>通过<code>context.ReadValue</code>可以读取「动作」为「值」的信息的内容，例如屏幕位置是二维向量信息，我们使用下方代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screenposition = context.ReadValue&lt;Vector2&gt;()</span><br></pre></td></tr></table></figure>
<p>直接使用<code>context.ReadValue</code>获取的是点击屏幕的位置，单位是像素。使用Unity内置函数将其转换为世界坐标：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worldposition = Camera.main.ScreenToWorldPoint(screenposition);</span><br></pre></td></tr></table></figure>
<p>在一个可以向前、向左、向右跳跃的跑酷游戏中，我们需要根据点击屏幕的位置和玩家控制的对象的位置判断跳跃方向。一种方法是将这两个位置作为向量做差，再取其单位向量，设定阈值，判断单位向量横坐标或纵坐标是否超过阈值，效果如图：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-31.png" height=300>
<p>代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Direction</span><br><span class="line">&#123;</span><br><span class="line">    Up, Left, Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">Vector2 offset = (worldposition - (Vector2)transform.position).normalized;</span><br><span class="line"><span class="keyword">private</span> Direction dir;</span><br><span class="line"><span class="keyword">if</span> (offset.x &lt;= <span class="number">-0.7f</span>) dir = Direction.Left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (offset.x &lt; <span class="number">0.7f</span>) dir = Direction.Up;</span><br><span class="line"><span class="keyword">else</span> dir = Direction.Right;</span><br></pre></td></tr></table></figure>
<h2 id="2D刚体-Rigidbody2D">2D刚体(Rigidbody2D)</h2>
<p>「2D刚体」的「BodyType」有3个选项。分别是「Dynamic」、「Kinematic」和「Static」。</p>
<p>若对象有「2D刚体」组件，禁止使用「变换(Transform)」组件来控制对象，而应使用后者的函数或变量来操纵，否则可能出现bug。</p>
<p>尽管经常将「2D刚体」表述为相互碰撞，但实际上发生碰撞的是每个刚体所连接的「2D碰撞体」。如果没有碰撞体，刚体不能相互碰撞。</p>
<p>一般来说，值的判断放在「Update」中，而物理内容放在「FixedUpdate」中。</p>
<h3 id="Dynamic">Dynamic</h3>
<p>Dynamic具有可用的全套属性，可互动性最高，一般例如玩家自身控制的对象等所使用。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-4.png" height=300>
<ul>
<li>
<p>「模拟的」：如果不希望该物体参与物理交互，请取消勾选。注意，取消勾选该选项与移除该组件效果不同，因为移除该组件的效果等同于「Static」，这一点之后也会提到。</p>
</li>
<li>
<p>「重力大小」：大于0的话对象会像下落，俯视角游戏需将其值设为0。</p>
</li>
<li>
<p>「碰撞检测」：有「离散的」和「持续」两个选项。</p>
<ul>
<li>
<p>「离散的」：通过计算对象以当前速度移动一个极小时间后的位置来判断碰撞，消耗性能较少，但若速度过快可能会穿模。</p>
</li>
<li>
<p>「持续」：通过计算对象间的下一个碰撞点来判断碰撞，消耗性能较多，但不会因速度过快而穿模。</p>
</li>
</ul>
</li>
<li>
<p>「插值」：有三个选项，一般使用「外推」。</p>
</li>
<li>
<p>「Constraints-冻结旋转」：若勾选上则不会旋转，一般勾选。</p>
</li>
</ul>
<h3 id="Kinematic">Kinematic</h3>
<p>Kinematic设计为在模拟条件下移动，如果没有勾选「使用完全运动学联系」，则只能与「Dynamic」交互，且与「Dynamic」碰撞时可视为质量无穷大，即其运动状态不会改变。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-6.png" height=225>
<h3 id="Static">Static</h3>
<p>Static设计为在模拟条件下（游戏运行时）完全不动。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-7.png" height=95>
<p>需要注意的是，如果对象有「2D碰撞体」或其他碰撞体组件却没有「2D刚体」组件，则效果完全等同于有「2D刚体」组件且为「Static」状态。</p>
<h3 id="三种BodyType之间的触发和碰撞关系">三种BodyType之间的触发和碰撞关系</h3>
<h4 id="条件">条件</h4>
<p>要使两个对象之间发生触发或碰撞关系，需同时满足下面3个条件：</p>
<ul>
<li>
<p>两个对象都有「2D碰撞体」或其他碰撞体组件。</p>
</li>
<li>
<p>两个对象都没有不勾选「模拟的」的「2D刚体」。注意可以没有「2D刚体」，其效果等同于「Static」。</p>
</li>
<li>
<p>还需满足：</p>
<ul>
<li>
<p>若两个对象的「2D碰撞体」组件有至少一个勾选了「是触发器」（详见「2D碰撞体-检查视图设置」），还需满足如下条件即可发生触发关系：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-35.png" height=250>
</li>
<li>
<p>若两个对象的「2D碰撞体」组件均未勾选「是触发器」还需满足如下条件即可发生碰撞关系：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-36.png" height=250>
</li>
</ul>
</li>
</ul>
<h4 id="游戏中效果">游戏中效果</h4>
<ul>
<li>
<p>触发关系</p>
<p>在游戏中不会有任何体现。</p>
</li>
<li>
<p>碰撞关系</p>
<p>在游戏中体现为两个物体以不过快的速度相遇时会发生碰撞而不会重叠（实际上也会有些重叠，只不过肉眼难以发现），运动状态被改变。但以过快的速度相遇时会发生互相穿过等意料之外的情况。</p>
</li>
</ul>
<h4 id="代码中效果">代码中效果</h4>
<ul>
<li>
<p>触发关系</p>
<p>分别在刚开始接触的一刻，接触期间，刚结束接触的一刻自动触发<code>OnTriggerEnter2D</code>、<code>OnTriggerStay2D</code>、<code>OnTriggerExit2D</code>三个Unity自带函数。使用方法如：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D other</span>)</span>&#123;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>
<p>传参<code>other</code>是与其发生关系的对象的「2D碰撞体」组件。</p>
<p>两个对象发生关系时，两者的脚本均会同时触发相同的函数。</p>
<p>每次开始接触或结束接触<code>OnTriggerEnter2D</code>和<code>OnTriggerExit2D</code>只会触发一遍。而<code>OnTriggerStay2D</code>会一直触发。注意，如果「休眠模式」设置的不是「从不休眠」，两物体会因为休眠而在移动很微弱或不移动时停止调用<code>OnTriggerStay2D</code>。</p>
</li>
<li>
<p>碰撞关系</p>
<p>分别在刚开始接触的一刻，接触期间，刚结束接触的一刻自动触发<code>OnCollisionEnter2D</code>、<code>OnCollisionStay2D</code>、<code>OnCollisionExit2D</code>三个Unity自带函数。</p>
<p>其他与「触发关系」相同。</p>
</li>
</ul>
<h2 id="2D碰撞体-Collider2D">2D碰撞体(Collider2D)</h2>
<h3 id="场景视图中的显示设置">场景视图中的显示设置</h3>
<p>勾选「菜单栏-编辑-项目设置-2D物理-Gizmos-始终显示碰撞器」即可在场景视图中始终显示碰撞体，无需选中对象即可看到。</p>
<p>也可在代码中设置<code>bool</code>类型<code>Physics2D.alwaysShowColliders</code>的值来控制是否始终显示碰撞器，不过这种方法只能在开始运行后生效。</p>
<h3 id="检查视图设置-3">检查视图设置</h3>
<p>2D碰撞体有很多种，我们以最常用的「BoxCollider2D」为例。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-11.png" height=220>
<ul>
<li>
<p>「编辑碰撞器」：可以快速拖拽编辑碰撞体大小。</p>
</li>
<li>
<p>「是触发器」：若不勾选，则该碰撞体是一个能进行碰撞的实体，两个都未勾选该选项的碰撞体碰撞后他们的运动状态会变化。若勾选，则表明你只想要让该碰撞体作为触发器发送信号，不希望他们像实体一样发生碰撞改变运动状态。</p>
</li>
<li>
<p>「偏移、大小、边缘半径」：参考下方图片。</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-12.png" height=350>
</li>
</ul>
<h2 id="使用缓动函数控制移动">使用缓动函数控制移动</h2>
<h3 id="跨类跨文件的调用">跨类跨文件的调用</h3>
<p>放在不同目录，不同文件下的所有代码中的所有命名空间，所有类在Unity进行编译的时候都相当于放在一起。所以跨文件的调用相当于同文件的调用。接下来我们探讨跨类调用的方法。</p>
<p>注意，这里讨论的不是跨组件的调用，跨组件的调用使用<code>GetComponent</code>等函数。</p>
<h4 id="方法一：实例化">方法一：实例化</h4>
<p>直接将想使用的类实例化即可：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> A classA = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(classA.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，因为某种原因，实例化的类如果里面套着类，那个套在里面的类没有办法是用，编译器会报错，如果想使用类里套的类，应对其直接示例化。例如首先有这样一个嵌套类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> c = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会编译错误：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> A classA = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(classA.B.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样编译成功：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> A.B classB = <span class="keyword">new</span> A.B();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(classB.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二：静态">方法二：静态</h4>
<p>用<code>static</code>将类定义成静态的就可以不实例化直接调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义的缓动函数">自定义的缓动函数</h3>
<p>很多人使用<code>Vector3.Lerp</code>函数来模拟缓动，也有人使用<code>Vector3.SmoothDamp</code>，但他们都有两个问题：</p>
<ul>
<li>
<p>无法使对象的坐标移动到完全与目标点坐标相等，例如你想从0移到3，最后只会无限逼近3，也就是2.999…。</p>
</li>
<li>
<p>种类不够丰富。</p>
</li>
</ul>
<p>我们可以使用非Unity自带的<a target="_blank" rel="noopener" href="https://figurebed-1306986731.file.myqcloud.com/tmpe/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0.cs">自定义缓动函数</a>，主体部分来源于<a target="_blank" rel="noopener" href="https://github.com/sass00n1/StartEasing">一个github库</a>，经过了我的加工。注意，该代码额外地使用了<code>using System;</code>。</p>
<p>自定义缓动函数的格式：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> Easing.Work(<span class="built_in">float</span> ori, <span class="built_in">float</span> des, <span class="keyword">ref</span> <span class="built_in">float</span> nowtime, <span class="built_in">float</span> tottime, <span class="built_in">float</span> deltime, Func&lt;<span class="built_in">float</span>, <span class="built_in">float</span>, <span class="built_in">float</span>&gt; mode)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>ori</code>：最初值。</p>
</li>
<li>
<p><code>des</code>：最终值。</p>
</li>
<li>
<p><code>nowtime</code>：当前距本次运动开始的时间，开始运动前要将其赋值为0，但运动过程中不要更改它的值。</p>
</li>
<li>
<p><code>tottime</code>：本次运动总时间。</p>
</li>
<li>
<p><code>deltime</code>：本次更新距上一次更新时间。建议将该函数放在<code>Update</code>函数中使用，且<code>deltime</code>传入<code>Time.deltaTime</code>。</p>
</li>
<li>
<p><code>mode</code>：运动模式。在<code>Easing.Mode</code>的子类中有各种可选模式，可以对照<a target="_blank" rel="noopener" href="https://easings.net/zh-cn">缓动函数速查表</a>。</p>
</li>
<li>
<p>返回值：经过这次更新的值。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.position = <span class="keyword">new</span> Vector3(transform.position.x,</span><br><span class="line">                                    Easing.Work(<span class="number">0f</span>, <span class="number">3f</span>, <span class="keyword">ref</span> nowtime, <span class="number">2f</span>, Time.deltaTime, Easing.Mode.Bounce.EaseInOut),</span><br><span class="line">                                    transform.position.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动画">动画</h2>
<p>动画文件分为「动画(Animation)」和「动画器控制器(AnimatorController)」两种，后者用于控制前者，两者搭配使用。动画组件也有「Animation」和「Animator」两种，但「Animation」组件已经过时，我们只使用后者。</p>
<p>建议在「项目视图-Assets」下创建一个文件夹「Animations」，之后所有的动画文件都会存储在此。</p>
<p>两种文件在Unity中打开的效果如图：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-19.png" height=400>
<h3 id="Animator组件">Animator组件</h3>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-20.png" height=185>
<p>需将「AnimatorController」文件填入「控制器」中。</p>
<h3 id="Animation文件">Animation文件</h3>
<h4 id="检查窗口基本设置">检查窗口基本设置</h4>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-22.png" height=210>
<ul>
<li>
<p>「循环时间」：若勾选，则该动画为循环动画；若不勾选，超出动画时间后动画显示的状态是最后一帧。</p>
</li>
<li>
<p>「循环动作」：若勾选，则对一次动画播放完和下一次动画播放前的过渡进行处理。</p>
</li>
</ul>
<h4 id="动画窗口基本设置和添加关键帧">动画窗口基本设置和添加关键帧</h4>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-21.png" height=240>
<p>若没有设置一秒帧数的位置，在显示设置中勾选「ShowSampleRate」即可出现。</p>
<p>注意，只有在场景视图或层级视图中选中含「Animator」组件，且该组件填入了含该「Animation」文件的「AnimatorController」文件，才能使用「选择同一AnimatorController下的Animation」和拖拽加入新的关键帧。</p>
<h4 id="添加事件和对事件的设置">添加事件和对事件的设置</h4>
<p>点击「添加事件」可以在当前帧添加事件。注意不要在同一帧处添加多个事件，否则在窗口中这几个事件会重叠。</p>
<p>事件的图标：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-15.png" height=200>
<p>点击该图标，检查窗口中显示如下。选择想要触发的函数即可。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-26.png" height=90>
<h4 id="关键帧记录模式">关键帧记录模式</h4>
<p>点击「启用/禁用关键帧记录模式」可以开启关键帧记录模式，开启该模式后，动画窗口的时间轴呈红色，关闭时呈蓝色。</p>
<p>开启该模式后，在「场景视图」、「检查视图」等中进行该对象的任何信息的更改将被记录在当前帧作为关键帧，保存在动画中。两个关键帧之间的这些帧将作为两个关键帧的过渡。例如我在0:00处设置缩放为1，将时间轴拖动到1:00，设置缩放为2，那么这1秒的动画就是该对象逐渐变大：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-69.png" height=300>
<h3 id="AnimatorController文件">AnimatorController文件</h3>
<h4 id="动画器窗口">动画器窗口</h4>
<p>自带三个状态：</p>
<ul>
<li>
<p>「Entry」状态：从这里进入。</p>
</li>
<li>
<p>「Exit」状态：如果进入根状态机的「Exit」状态，则回到「Entry」状态；如果进入子状态机的「Exit」状态，则退出该子状态机，返回父层级。</p>
</li>
<li>
<p>「AnyState」状态：只能指出，不能指入。表示任意状态的特殊状态。如果希望任意状态满足某些转移条件都能转移，可以使用该状态。</p>
</li>
</ul>
<p>右键状态节点，可以添加转移、设置默认状态（「Entry」指向的状态）。</p>
<p>在左侧「参数」栏中可编辑参数。</p>
<h4 id="状态在检查窗口中的显示">状态在检查窗口中的显示</h4>
<p>点击状态节点，检查窗口中显示相关信息：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-18.png" height=320>
<p>没有什么常用的东西。</p>
<h4 id="转移在检查窗口中的显示">转移在检查窗口中的显示</h4>
<p>点击转移边，检查窗口中显示相关信息：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-23.png" width=310>
<ul>
<li>
<p>「Transitions」和「Conditions」</p>
<p>这两栏分别位于最上方和最下方。其中「Transitions」是「Conditions」的父层级，也就是一个「Transitions」可以包含多个「Conditions」。在能否转移的判断中，「Transitions」之间是或的关系，「Conditions」之间是与的关系。</p>
</li>
<li>
<p>「有退出时间」、「退出时间」</p>
<p>若勾选，则只有在「退出时间」设置的时间点处可以进行转移。动画的起始时间为0，结束时间点1，「退出时间」的值也是相对于0和1的，例如设为0.3则为动画播放了30%的那个时间点；若不勾选，则随时可转移。</p>
<p>建议将之前「Animation文件-检查窗口基本设置-循环时间」勾选，「退出时间」设为0~1之间的数。</p>
</li>
<li>
<p>「固定持续时间」、「过渡持续时间」、「过渡偏移」</p>
<p>用来设置动画转移时的过渡效果，不常用，一般将其值都设为0。</p>
<p>注意，若开启该功能，在有持续时间的转移过程中，若指向的状态此时已达到作为指出状态再转移的条件，也不能再转移，必须等到持续时间结束后再满足条件，才能转移。</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-24.png" height=120>
</li>
</ul>
<h3 id="编写脚本-2">编写脚本</h3>
<h4 id="修改参数">修改参数</h4>
<p>像「Rigidbody2D」那样，在脚本中我们也需要先声明一个<code>Animator</code>类的变量，并获取它，比如我们声明的变量名叫<code>anim</code>。</p>
<p>使用以下代码可以更改该<code>Animator</code>类的变量所对应的「Animator」组件所含的「AnimatorController文件」中相应名称的参数的值。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anim.SetBool(<span class="string">&quot;NAME1&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">anim.SetInteger(<span class="string">&quot;NAME2&quot;</span>, <span class="number">25</span>);</span><br><span class="line">anim.SetFloat(<span class="string">&quot;NAME3&quot;</span>, <span class="number">2.5f</span>);</span><br><span class="line">anim.SetTrigger(<span class="string">&quot;NAME4&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>值得一提的是Trigger这种参数。他有点像bool，但不同的是它只能在代码中，也就是<code>SetTrigger</code>的时候由<code>false</code>变为<code>true</code>，就是说如果连着多次使用<code>SetTrigger</code>；并且只能在转移时由<code>true</code>变为<code>false</code>，就是说如果有一个转移的条件是一个Trigger参数，此时该Trigger为<code>true</code>，进行转移，同时值变为<code>false</code>。</p>
<h4 id="使用动画事件">使用动画事件</h4>
<p>在「Animation文件-添加事件和对事件的设置」章节中，我们已经知道了触发事件如何调用函数。需要注意的是函数的格式，无需使用<code>public</code>，使用<code>private</code>即可，且不需要传参：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NAME</span>(<span class="params"></span>)</span>&#123;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自适应相机">自适应相机</h2>
<p>接下来我们将写一个名叫<code>CameraControl</code>的脚本，该脚本将被安在摄像机上。</p>
<h3 id="相机跟随">相机跟随</h3>
<p>我们想让相机始终跟随玩家，即让玩家操控的对象始终在屏幕中的某一位置。</p>
<p>首先获取玩家操控的对象上的「Transform」组件，先声明一个<code>Transform</code>变量：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform player;</span><br></pre></td></tr></table></figure>
<p>然后在Unity中将该对象拖拽到该位置即可。</p>
<p>每帧根据该对象的坐标更改摄像机坐标，但要注意为了避免摄像机抖动，每一帧需要等该对象的坐标更新完成后在更新摄像机的坐标，于是需要将更新摄像机坐标的语句放在<code>LateUpdate</code>中：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.position = <span class="keyword">new</span> Vector3(transform.position.x, player.position.y + OffsetRatio * CameraHeight, transform.position.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>OffsetRatio * CameraHeight</code>是偏移量，因为我们不想让该对象处于屏幕正中，具体在后面会提到。</p>
<h3 id="相机自适应屏幕（窗口）大小">相机自适应屏幕（窗口）大小</h3>
<p>例如在一个跑酷游戏中，我们制作了一个长条状的地图。有两种长宽比不同的屏幕，我们想要这两种屏幕中显示的宽度相等：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-30.png" height=250>
<p>我们需要了解几个Unity自带变量（常量）：</p>
<ul>
<li>
<p><code>Screen.width</code>和<code>Screen.height</code></p>
<p>当前屏幕（窗口）的宽和高，单位是像素，只读。</p>
</li>
<li>
<p><code>Camera.main.orthographicSize</code></p>
<p>当前摄像机捕捉范围的沿y轴长度的一半，单位是Unity编辑器中的单位长度，可读可写。</p>
</li>
</ul>
<p>我们还需自己声明几个变量，这些变量的访问修饰符应被设为<code>public</code>以便在Unity编辑器检查窗口中调值和在其他地方调用：</p>
<ul>
<li>
<p><code>CameraWidth</code>和<code>CameraHeight</code></p>
<p>当前摄像机捕捉范围的沿x轴和y轴长度。注意，因为屏幕长宽比是确定的，所以摄像机的长宽比也是确定的，所以这两个变量知道一个就能确定另一个。所以应使用<code>[System.NonSerialized]</code>将其中一个设为在检查窗口中不可见。</p>
</li>
<li>
<p><code>OffsetRatio</code></p>
<p>玩家控制对象距摄像机中心的沿y轴长度与摄像机捕捉范围的沿y轴长度的比例。</p>
</li>
</ul>
<p>最终，我们根据<code>Screen.width</code>和<code>Screen.height</code>以及提前设置的<code>CameraWidth</code>和<code>OffsetRatio</code>来确定<code>Camera.main.orthographicSize</code>的值：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CameraHeight = ((<span class="built_in">float</span>)Screen.height * CameraWidth) / (<span class="built_in">float</span>)Screen.width;</span><br><span class="line">Camera.main.orthographicSize = CameraHeight / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="传递信息">传递信息</h2>
<h3 id="传递信息函数之间的区别">传递信息函数之间的区别</h3>
<p>传递信息函数内置于Unity，可以直接使用。</p>
<ul>
<li>
<p><code>SendMessage</code></p>
<p>调用本对象中所有相应名称的函数。</p>
</li>
<li>
<p><code>SendMessageUpwards</code></p>
<p>调用本对象和本对象的所有父级对象中所有相应名称的函数。</p>
</li>
<li>
<p><code>BroadcastMessage</code></p>
<p>调用本对象和本对象的所有子孙级对象中所有相应名称的函数。</p>
</li>
</ul>
<h3 id="传递信息函数的相同用法">传递信息函数的相同用法</h3>
<p>被调用函数的访问修饰符可以为<code>private</code>。</p>
<p>以<code>SendMessage</code>为例，其他两个函数的声明与之完全相同。</p>
<p>函数的声明：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"><span class="built_in">string</span> methodName,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="built_in">object</span> parameter = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        SendMessageOptions options = SendMessageOptions.RequireReceiver</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>用法例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SendMessage(<span class="string">&quot;NAME&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NAME</span>(<span class="params"></span>)</span>&#123;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>methodName</code>：要调用的函数名。这里有一个技巧，当需要用到任意变量、类型或成员的名称作为字符串常量时，可以使用C#自带的<code>nameof</code>，例如：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SendMessage(<span class="keyword">nameof</span>(NAME));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NAME</span>(<span class="params"></span>)</span>&#123;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>parameter</code>：传参。</p>
<p><code>null</code>就是传0个参，给<code>parameter</code>赋不为<code>null</code>的值就是传1个参，但是不能传多个。如果传了0个参，则只能被含有0个参数的相应名称的函数接收；如果传了1个参，则可以被含有0或1个参数的相应名称的函数接收；含有多个参数的相应名称的函数永远不能被调用。</p>
<p>如果想传多个，可以使用数组：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendMessage(<span class="keyword">nameof</span>(NAME), <span class="keyword">new</span> <span class="built_in">object</span>[]&#123;<span class="number">3</span>, <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>options</code>：是否必须被接收。</p>
<p>有两种赋值<code>SendMessageOptions.RequireReceiver</code>和<code>SendMessageOptions.DontRequireReceiver</code>，前者表示如果没有任何函数接收，则报错；后者不报错。</p>
</li>
</ul>
<h2 id="定时调用函数">定时调用函数</h2>
<ul>
<li>
<p><code>Invoke</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"><span class="built_in">string</span> methodName, <span class="built_in">float</span> time</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>time</code>时间后调用同<code>MonoBehaviour</code>下的名为<code>methodName</code>的函数。</p>
</li>
<li>
<p><code>InvokeRepeating</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InvokeRepeating</span>(<span class="params"><span class="built_in">string</span> methodName, <span class="built_in">float</span> time, <span class="built_in">float</span> repeatRate</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>time</code>时间后第一次调用同<code>MonoBehaviour</code>下的名为<code>methodName</code>的函数，之后每隔<code>repeatRate</code>时间再调用一次。</p>
</li>
<li>
<p><code>CancelInvoke</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CancelInvoke</span>(<span class="params"><span class="built_in">string</span> methodName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CancelInvoke</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>第一种停止调用同<code>MonoBehaviour</code>下的名为<code>methodName</code>的函数；第二种停止调用同<code>MonoBehaviour</code>下的所有挂起的函数。</p>
</li>
<li>
<p><code>IsInvoking</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsInvoking</span>(<span class="params"><span class="built_in">string</span> methodName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsInvoking</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>第一种检测同<code>MonoBehaviour</code>下的名为<code>methodName</code>的函数是否被挂起；第二种检测同<code>MonoBehaviour</code>下是否有任意被挂起的函数。</p>
</li>
</ul>
<h2 id="启用与禁用">启用与禁用</h2>
<h3 id="对象的启用和禁用">对象的启用和禁用</h3>
<p>对于一个对象而言，当且仅当他和他的所有父级的checkbox都是被勾选的状态时他是启用状态，反之是禁用状态。</p>
<p>这三个<code>GameObject</code>类的方法和属性用于设置或读取和启用禁用有关的信息：</p>
<ul>
<li>
<p><code>SetActive</code>：方法，无返回值，有一个<code>bool</code>类型的传参，表示将脚本所在对象的checkbox勾选或取消勾选。</p>
</li>
<li>
<p><code>activeSelf</code>：属性，<code>bool</code>类型，表示脚本所在对象的checkbox有无勾选。</p>
</li>
<li>
<p><code>activeInHierarchy</code>：属性，<code>bool</code>类型，表示脚本所在对象是否处于启用状态。</p>
</li>
</ul>
<p>脚本所在对象的<code>GameObject</code>类可以直接在代码中使用，名叫<code>gameObject</code>，如将脚本所在对象checkbox取消勾选：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameObject.SetActive(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>注意，禁用脚本组件或脚本组件所在对象，会停止调用<code>Update</code>等函数，但不会影响<code>OnTriggerStay2D</code>等函数和已挂起的<code>Invoke</code>。</p>
<h3 id="组件的启用和禁用">组件的启用和禁用</h3>
<p>对于一个组件而言，当且仅当其所在对象是启用状态，且组件的checkbox勾选时他才是启用状态，反之是禁用状态。</p>
<p>所有有checkbox的组件都可以使用以下属性来控制checkbox（有些组件无checkbox，如Transform）：</p>
<ul>
<li><code>enable</code>：属性，<code>bool</code>类型，表示checkbox是否勾选。</li>
</ul>
<h2 id="组件和对象的生成与销毁">组件和对象的生成与销毁</h2>
<h3 id="对象的生成">对象的生成</h3>
<p>使用<code>Instantiate</code>函数生成对象，该函数共有5种重载：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">Instantiate</span>(<span class="params">Object original</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">Instantiate</span>(<span class="params">Object original, Transform parent</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">Instantiate</span>(<span class="params">Object original, Transform parent, <span class="built_in">bool</span> instantiateInWorldSpace</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">Instantiate</span>(<span class="params">Object original, Vector3 position, Quaternion rotation</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">Instantiate</span>(<span class="params">Object original, Vector3 position, Quaternion rotation, Transform parent</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>其中1、2种可实现的功能被包含在第3种中；第4种可实现的功能被包含在第5种中，所以只要弄懂第3、5种重载就能理解<code>Instantiate</code>函数了。</p>
<p>共有传参：</p>
<ul>
<li>
<p><code>original</code>：用于生成对象的模板，生成的对象相当于它的克隆。可以是预制体，也可以是游戏中的对象。</p>
</li>
<li>
<p><code>parent</code>：对象生成后在层级视图中的父级，注意传参的是父级对象的「Transform」组件，不是父级本身（在Unity中，「Transform」组件本来就有储存父级子级的作用）。若函数中没有该传参，则相当于<code>null</code>，也就是作为根层级。</p>
</li>
</ul>
<p>前3种重载的特有传参：</p>
<ul>
<li><code>instantiateInWorldSpace</code>：若为<code>true</code>，则生成的对象的位置、旋转、缩放三种值的全局值与模板对象相等；反之，生成的对象的三种值的局部值（相对于父级）与模板对象相等。若函数中没有该传参，则相当于<code>true</code>。</li>
</ul>
<p>后2种重载的特有传参：</p>
<ul>
<li><code>position</code>和<code>rotation</code>：如果含这两种传参，则生成的对象的相应值为传参的值。注意，不是和模板对象的值叠加，是覆盖。</li>
</ul>
<h3 id="组件的添加">组件的添加</h3>
<p>使用<code>GameObject.AddComponent</code>函数在指定对象上添加指定组件，例如下面的代码表示在本脚本所在的对象的父级上添加「Rigidbody2D」组件：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GameObject gob = transform.parent.gameObject;</span><br><span class="line">Rigidbody2D rb;</span><br><span class="line">rb = gob.AddComponent&lt;Rigidbody2D&gt;();</span><br></pre></td></tr></table></figure>
<p>注意，该函数不会覆盖对象上原有的组件。也就是说，如果该组件不能在同一对象上有多个，且该对象上已经有了一个该组件，则添加失败，返回<code>null</code>。</p>
<h3 id="对象和组件的销毁">对象和组件的销毁</h3>
<p>使用<code>Destory</code>，既可以销毁对象，也可以销毁组件。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params">Object obj, <span class="built_in">float</span> time = <span class="number">0f</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>obj</code>：要销毁的对象或组件，如果是对象，则会销毁该对象以及所有子孙级对象。</p>
</li>
<li>
<p><code>time</code>：在<code>time</code>时间后执行操作。</p>
</li>
</ul>
<p>使用<code>DontDestroyOnLoad</code>，可以在切换场景（之后会讲解）期间保留指定对象。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DontDestroyOnLoad</span>(<span class="params">Object obj</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>obj</code>：可以是对象也可以是组件。会保留组件所在对象以及所有子孙级对象。</li>
</ul>
<h2 id="查找对象">查找对象</h2>
<h3 id="GameObject-Find">GameObject.Find</h3>
<p>使用示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject go = GameObject.Find(<span class="string">&quot;NAME&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>&quot;NAME&quot;</code>不一定仅仅是对象的名称，可以是一个路径。<br>
且查找方法有按绝对路径查找和按相对路径查找。绝对路径查找的格式<code>/XXX/XXX</code>，相对路径查找的格式<code>XXX/XXX</code>。</p>
<p>这里的相对路径不是相对于该脚本所在对象的相对路径，而是相对于任意对象的相对路径，例如<code>GameObject.Find(&quot;a/b&quot;)</code>是寻找对象名称是<code>b</code>，父级名称是<code>a</code>的对象，而祖父级没有要求，可以是任意对象或<code>null</code>。</p>
<p>若有多个满足要求的查找结果，则函数会返回哪个难以控制，所以要避免出现多个满足要求的查找结果。</p>
<p>若查找的对象为隐藏对象，即本身或任何父级被禁用，则是否能查到难以控制，所以要避免用<code>GameObject.Find</code>查找隐藏对象，例如：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-39.png" height=70>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Debug.Log(GameObject.Find(<span class="string">&quot;/a/b/c&quot;</span>) != <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line">Debug.Log(GameObject.Find(<span class="string">&quot;/a/d&quot;</span>) != <span class="literal">null</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>c和d都被设为禁用，唯一不同在于c多了一个父级，结果c能被找到，d无法被找到。</p>
<h3 id="Transform-Find">Transform.Find</h3>
<p>使用示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transform tr = transform.Find(<span class="string">&quot;NAME&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从使用示例中可看出<code>Transform.Find</code>与<code>GameObject.Find</code>的一些不同，前者是调用一个具体的<code>Transform</code>类的函数，后者是调用静态的<code>GameObject</code>的函数。这也说明前者的调用结果与被调用的那个<code>Transform</code>类有关，具体见下文。</p>
<p>按绝对路径查找和<code>GameObject.Find</code>的相同。</p>
<p>按相对路径查找和<code>GameObject.Find</code>的不同。是按照相对于该「Transform」组件所在对象的相对路径查找。且可以查找隐藏对象。</p>
<h2 id="父子关系的查询与管理">父子关系的查询与管理</h2>
<p>Unity中的父子关系，也就是层级关系，被存储于<code>Transform</code>类中，所以父子关系的查询与管理的相关属性和方法都在<code>Transform</code>类中，使用例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.parent = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这些属性和方法分两种，与父级相关和与儿级相关。</p>
<h3 id="与父级相关">与父级相关</h3>
<ul>
<li>
<p><code>parent</code></p>
<p>属性，父级的<code>Transform</code>类，可读可写。</p>
<p>注意，试图更改该属性，或调用<code>SetParent</code>函数以使新的父级被设为当前的子孙级的做法无效，不会产生任何变化，且不会报错。</p>
</li>
<li>
<p><code>SetParent</code></p>
<p>方法，有两种重载：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetParent</span>(<span class="params">Transform parent</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetParent</span>(<span class="params">Transform parent, <span class="built_in">bool</span> worldPositionStays</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>parent</code>：将其设为新的父级。</p>
</li>
<li>
<p><code>worldPositionStays</code>：若为<code>true</code>，则变换后的位置、旋转、缩放三种值的全局值与变换前相等；反之，变换后的三种值的局部值（相对于父级）与变换前相等。第一种重载相当于该参数为<code>true</code>。</p>
</li>
</ul>
</li>
<li>
<p><code>SetAsFirstSibling</code>和<code>SetAsLastSibling</code>和<code>SetSiblingIndex</code></p>
<p>三个方法，前两个没有传参，第三个有一个<code>int</code>传参。</p>
<p>这三个函数都是改变该对象作为其父级的儿子的下标，分别表示下标改为第一个（0），改为最后一个，改为指定值。注意，若<code>SetSiblingIndex</code>传入的参数，也就是指定的下标值，不在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,\mathrm{childcount})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">childcount</span></span><span class="mclose">)</span></span></span></span>中（包括负数），则不会报错，而是相当于调用<code>SetAsLastSibling</code>。</p>
</li>
</ul>
<h3 id="与儿级相关">与儿级相关</h3>
<ul>
<li>
<p><code>childCount</code></p>
<p>属性，子集个数，只读。</p>
</li>
<li>
<p><code>DetachChildren</code></p>
<p>方法，没有传参，将所有子级（不包括孙级）的<code>parent</code>设为<code>null</code>。</p>
</li>
<li>
<p><code>GetChild</code></p>
<p>方法，有一个<code>int</code>传参，表示想要的子级的下标，返回值为该子级的<code>Transform</code>类。</p>
<p>注意，如果传入的参数，也就是指定的下标值，不在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,\mathrm{childcount})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">childcount</span></span><span class="mclose">)</span></span></span></span>中，会报错。</p>
</li>
</ul>
<h2 id="四元数与旋转">四元数与旋转</h2>
<h3 id="四元数的简介">四元数的简介</h3>
<p>四元数是一种广泛用于计算机等领域的数学工具，本质是超复数，可以用于表示三维空间中的旋转等。四元数和欧拉角相比优点有不会有万象锁锁死的问题；和矩阵乘法相比优点有较为简洁，只需存储四个数字。Unity中的旋转就是通过四元数来存储和实现的。</p>
<h3 id="四元数的用法">四元数的用法</h3>
<p>四元数类名为<code>Quaternion</code>。</p>
<p>四元数用于存储旋转的操作。</p>
<p>四元数类里的属性<code>x/y/z</code>不是欧拉角的绕x/y/z轴的旋转角度，注意到四元数类里还有一个属性<code>w</code>，这四个变量就是四元数。</p>
<p><code>Transform.rotation</code>就是四元数，他表示旋转的状态。</p>
<p>四元数之间常用的操作有赋值和乘法。四元数之间可以赋值（废话），但要注意的是，如果你使用某种方法构建了四元数表示某种旋转操作（后面会讲），不要直接把它赋值给<code>rotation</code>，因为旋转操作只是将一种状态转化为另一种状态的桥梁，不是最终的结果。</p>
<p>四元数之间可以相乘，Unity重载了四元数类的<code>*</code>运算符：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="keyword">operator</span>*(Quaternion lhs, Quaternion rhs);</span><br></pre></td></tr></table></figure>
<p>注意，四元数的乘法是不遵守交换律的，这是由于旋转本身就不遵守交换律，由于我们现在只探讨2D游戏，只会用到绕z轴旋转，不会体现这一点，就先不深入研究。一般使用<code>新状态=旧状态*操作</code>，也就是<code>状态*=操作</code>，例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Quaternion q = Quaternion.identity;</span><br><span class="line">transform.rotation *= q;</span><br></pre></td></tr></table></figure>
<p>四元数还可以和向量相乘，<code>*</code>运算符还有另一种重载，用于旋转向量：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="keyword">operator</span>*(Quaternion rota, Vector3 point);</span><br></pre></td></tr></table></figure>
<p>作用就是将<code>point</code>向量进行<code>rota</code>旋转操作，返回旋转后的向量，注意顺序不能反，否则会有编译错误。</p>
<h3 id="构建四元数">构建四元数</h3>
<p>首先是四元数类的一个静态只读属性：</p>
<ul>
<li>
<p><code>identity</code></p>
<p>表示无旋转。</p>
<p>与表示状态的四元数相乘时，相当于没乘：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.rotation *= Quaternion.identity;</span><br></pre></td></tr></table></figure>
<p>直接赋值给表示状态的四元数时，相当于设置成欧拉角三个维度的值都为0：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.rotation = Quaternion.identity;</span><br><span class="line">Debug.Log(transform.eulerAngles == Vector3.zero); <span class="comment">// True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后的这几种方法构建出来的四元数表示旋转操作，即应该使用乘法将其与表示状态的四元数相乘。</p>
<ul>
<li>
<p><code>AngleAxis</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">AngleAxis</span>(<span class="params"><span class="built_in">float</span> angle, Vector3 axis</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回的四元数表示绕指定轴旋转指定角度。指定轴：过对象轴心且方向为<code>axis</code>的轴；指定角度：<code>angle</code>度，其中绕转方向的判定方法为用左手握住轴，伸出大拇指并指向轴向量所指的方向，另外四个手指的绕转方向即为指定方向（类似右手螺旋定则只不过是左手）。</p>
</li>
<li>
<p><code>Euler</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">Euler</span>(<span class="params"><span class="built_in">float</span> x, <span class="built_in">float</span> y, <span class="built_in">float</span> z</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">Euler</span>(<span class="params">Vector3 euler</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回的四元数表示先围绕z轴旋转z度，再围绕x轴旋转x度，最后围绕y轴旋转y度（这里的xyz轴都是局部轴）的操作，绕转方向的判定方法同<code>AngleAxis</code>。</p>
</li>
<li>
<p><code>FromToRotation</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">FromToRotation</span>(<span class="params">Vector3 fromDirection, Vector3 toDirection</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回的四元数表示从向量<code>fromDirection</code>旋转到向量<code>toDirection</code>的操作，即旋转的方向和度数与之相同。</p>
</li>
<li>
<p><code>Inverse</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">Inverse</span>(<span class="params">Quaternion rota</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回的四元数表示<code>rota</code>的逆操作，即向相反方向旋转相同度数。</p>
</li>
</ul>
<p>接下来这一大类方法既可以构造表示旋转操作的四元数，也可以构造表示状态的四元数。</p>
<ul>
<li>
<p><code>Lerp/LerpUnclamped/Slerp/SlerpUnclamped</code></p>
<p>这四个方法都返回一个四元数，表示插值的结果，四个方法传参完全一样，以<code>Lerp</code>为例：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">Lerp</span>(<span class="params">Quaternion <span class="keyword">from</span>, Quaternion to, <span class="built_in">float</span> t</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><code>from</code>的比率是0，<code>to</code>的比率是1，插值结果的比率是<code>t</code>。</p>
<p>插值函数一般放在<code>Update</code>或<code>FixedUpdate</code>中，用于逐帧变换：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform tr;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line"><span class="keyword">private</span> Quaternion q1, q2;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    q1 = transform.rotation;</span><br><span class="line">    q2 = tr.rotation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    transform.rotation = Quaternion.Slerp(q1, q2, speed * time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上方代码是传入了两个表示旋转状态的四元数参数，并且将返回值赋值给<code>rotation</code>；也可以传入两个表示旋转操作的四元数参数，并且将返回值和状态值相乘，如：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> time;</span><br><span class="line"><span class="keyword">private</span> Quaternion initial;</span><br><span class="line"><span class="keyword">private</span> Quaternion q1, q2;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    initial = transform.rotation;</span><br><span class="line">    q1 = Quaternion.identity;</span><br><span class="line">    q2 = Quaternion.AngleAxis(<span class="number">80</span>, Vector3.forward);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    time += Time.deltaTime;</span><br><span class="line">    transform.rotation = initial * Quaternion.Slerp(q1, q2, speed * time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>XXX</code>和<code>XXXUnclamped</code>的区别：前者的<code>t</code>被限制在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 间，当然你可以传入不在这个区间里的数，但是小于0的数效果等同于0，大于1的数效果等同于1.</p>
<p><code>Lerp</code>和<code>Slerp</code>的区别：<code>Lerp</code>是线性插值，多用于位移变换；<code>Slerp</code>是球形插值，多用于旋转变换。如果在旋转变换中使用<code>Lerp</code>，变换的速度会随着时间变化而变化，比如有可能越来越慢，最后趋近于速度为0；而在旋转变换中使用<code>Slerp</code>是均匀的。</p>
<p>可以将插值函数和自定义缓动函数搭配使用。</p>
</li>
</ul>
<p>最后这几种方法构建出来的四元数表示旋转的状态。</p>
<ul>
<li>
<p><code>RotateTowards</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">RotateTowards</span>(<span class="params">Quaternion <span class="keyword">from</span>, Quaternion to, <span class="built_in">float</span> maxDegreesDelta</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回的四元数表示从<code>from</code>的旋转状态向<code>to</code>的旋转状态旋转<code>maxDegreesDelta</code>度数，但是不会超过<code>to</code>。有异议的是传入负数的情况，文档中说反向旋转不会超过与<code>to</code>相反的方向，但是经我测试可以超出。</p>
<p>与插值函数有类似的地方，但是插值函数确定插值位置的是比率，而该函数是具体的度数。</p>
</li>
<li>
<p><code>LookRotation</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">LookRotation</span>(<span class="params">Vector3 forw, Vector3 upw = Vector3.up</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回的四元数表示的是旋转的状态而非操作，所以应使用赋值而非乘法。</p>
<p>z轴将与<code>forw</code>对齐，X 轴与<code>forw</code>和<code>upw</code>的差积对齐，y轴与z轴和x轴的差积对齐。如果<code>forw</code>或<code>upw</code>量值为零或<code>forw</code>和<code>upw</code>共线，则返回<code>Quaternion.identity</code>。</p>
<p>例如下方代码让该对象绕z轴旋转使其x轴始终指向<code>tr</code>：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transform tr;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.rotation = Quaternion.LookRotation(Vector3.forward, Quaternion.AngleAxis(<span class="number">90</span>, Vector3.forward) * (tr.position - transform.position));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Physics2D">Physics2D</h2>
<h3 id="碰撞体检测的返回信息">碰撞体检测的返回信息</h3>
<p>在Physics2D中，有关碰撞体检测到的对象的返回信息会存储在<code>RaycastHit2D</code>类中，下面是<code>RaycastHit2D</code>类中的常用属性：</p>
<ul>
<li>
<p><code>transform/collider/rigidbody</code>：检测到的对象的变换、碰撞体、刚体（如果没有就是<code>null</code>）。</p>
</li>
<li>
<p><code>point</code>：<code>Vector2</code>类型，检测到该物体的检测点，下一小节中也会提到这个概念。</p>
</li>
<li>
<p><code>distance</code>：<code>float</code>类型，从发出检测射线的原点到检测点的距离。</p>
</li>
</ul>
<h3 id="碰撞体检测的方式">碰撞体检测的方式</h3>
<p>碰撞体检测就是确定出一个检测区域，检测有无碰撞体与该区域相交，有多少。其中怎样确定这个区域取决于使用的「检测模型」和「检测模式」，而返回值是一个还是多个和占用内存的情况取决于「返回方法」。每一个函数都是一种「检测模型」、「检测模式」和「返回方法」的组合，所以能明白这3件事所有碰撞体检测的函数都不在话下了。</p>
<h4 id="检测模型">检测模型</h4>
<p>「检测模型」比较好理解，就是各种几何图形，例如<code>Box</code>（矩形）、<code>Circle</code>（圆形）、<code>Capsule</code>（胶囊形）、<code>Line</code>（线段）、<code>Ray</code>（射线）、<code>Point</code>（点）等。函数会有一些传参来确定这些图形的坐标和大小。如<code>Box</code>的<code>Vector2</code>类型参数<code>origin</code>、<code>size</code>和<code>angle</code>，分别表示中心点坐标，大小，旋转角度。</p>
<h4 id="检测模式">检测模式</h4>
<p>首先，两种检测模式都有3个共有的参数，<code>layerMask</code>和<code>minDepth	/maxDepth</code>，不常用。</p>
<ul>
<li>
<p><code>OverlapXXX</code>：相交检测，顾名思义就是检测有无碰撞体和「检测模型」相交，也就是检测区域就是这个模型的区域。没有特有的参数。</p>
</li>
<li>
<p><code>XXXCast</code>：射线检测，由「检测模型」的区域上的所有点向某个特定方向发射有特定长度的射线（或者叫线段），所有射线所形成的区域就是检测区域。也可以理解成将「检测模型」向某个特定的方向拖动特定距离，所有扫过的面积就是检测区域。有两个特有参数：</p>
<ul>
<li>
<p><code>direction</code>：<code>Vector2</code>类型，表示特定方向，其模长没有意义。</p>
</li>
<li>
<p><code>distance</code>：<code>float</code>类型，默认值为<code>Mathf.Infinity</code>，表示特定长度。</p>
</li>
</ul>
<p>以<code>BoxCast</code>为例，下方代码的检测区域如图：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Physics2D.BoxCast(<span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> Vector2(<span class="number">2</span>, <span class="number">3</span>), <span class="number">30</span>, <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">2</span>), <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-40.png" height=250>
<p>注意，检测区域并非只有边界，整个区域都是检测区域。</p>
</li>
</ul>
<h4 id="返回方法">返回方法</h4>
<p>在函数名中，返回方法体现为后缀：</p>
<ul>
<li>
<p>无后缀：没有特有的参数。相交检测模式的返回值为<code>Collider2D</code>，射线检测模式的返回值为<code>RaycastHit2D</code>。如果能检测到多个，射线检测模式会返回最近的（<code>RaycastHit2D.distance</code>最小），相交检测模式会返回哪个不确定。如果没有检测到，返回<code>null</code>。</p>
</li>
<li>
<p><code>XXXAll</code>：没有特有的参数。相交检测模式的返回值为<code>Collider2D[]</code>，射线检测模式的返回值为<code>RaycastHit2D[]</code>。如果能检测到多个，射线检测模式返回的数组中元素的顺序是按<code>RaycastHit2D.distance</code>递增。</p>
</li>
<li>
<p><code>XXXNonAlloc</code>：有特定的参数<code>results</code>，相交检测模式的<code>results</code>的类型为<code>Collider2D[]</code>，射线检测模式类型为<code>RaycastHit2D[]</code>。返回值为<code>int</code>类型，表示检测到的碰撞体个数。传入<code>results</code>时无需给其中元素赋值，但是要给数组设置合适的大小，因为检测过程中如果出现数组大小不够的情况也不会扩大数组，超出部分舍弃。比较节省内存，因此需要反复执行的话建议使用。</p>
</li>
</ul>
<h3 id="可视化碰撞体检测">可视化碰撞体检测</h3>
<p>在调试过程中，我们看不到检测区域，调试起来比较困难，使用Unity自带的<code>Debug</code>工具，我们可以自己写一套可视化碰撞体检测。以「检测模型」为<code>Box</code>的六种函数为例：<a target="_blank" rel="noopener" href="https://figurebed-1306986731.file.myqcloud.com/tmpe/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A2%B0%E6%92%9E%E4%BD%93%E6%A3%80%E6%B5%8B.cs">可视化碰撞体检测</a>。</p>
<p>使用方法和<code>Physics2D</code>中的碰撞检测函数完全一致，只不过<code>Physics2D</code>换成了<code>m_Physics2D</code>。</p>
<h2 id="使用C-事件解耦">使用C#事件解耦</h2>
<h3 id="耦合和解耦">耦合和解耦</h3>
<p>耦合是一个软件结构内不同模块之间互连程度的度量。耦合度越高，代码间独立性越差，高耦合是我们不想看到的。解耦是解开耦合，降低耦合度的行为。</p>
<h3 id="C-事件的用法">C#事件的用法</h3>
<h4 id="前置-创建C-函数对象">前置-创建C#函数对象</h4>
<p>C#函数对象中常用的有<code>Func</code>和<code>Action</code>两种：</p>
<ul>
<li>
<p><code>Func</code>：有返回值的函数，定义方法：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">float</span>, <span class="built_in">bool</span>, <span class="built_in">int</span>&gt; NAME;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;&gt;</code>中的最后一个类型为返回值的类型，前面的按顺序为函数传参的类型。例如该行代码表示定义了一个传参类型依次为<code>float</code>、<code>bool</code>，返回值为<code>int</code>的函数。</p>
</li>
<li>
<p><code>Action</code>：无返回值的函数，定义方法：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;<span class="built_in">float</span>, <span class="built_in">bool</span>&gt; NAME;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&gt;</code>中的类型按顺序为函数传参的类型。如果没有任何传参，则无需写<code>&lt;&gt;</code>，例如：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action NAME;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>C#函数对象常用于函数传参、C#事件等：</p>
<ul>
<li>
<p>函数传参：函数本身也可以作为参数：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span>(<span class="params">Func&lt;<span class="built_in">float</span>, <span class="built_in">float</span>, <span class="built_in">float</span>&gt; func</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>C#事件：见下文。</p>
</li>
</ul>
<h4 id="定义C-事件">定义C#事件</h4>
<p>C#事件本质是一个函数对象，使用方法是在定义时加上<code>event</code>关键字，且关键字只能用于函数（<code>Func</code>、<code>Action</code>等），不能用于变量。定义例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; eve;</span><br></pre></td></tr></table></figure>
<p>一般我们会单独创建一个类，在其中定义C#事件，因为这是C#自带，所以不用继承<code>MonoBehaviour</code>，也不需要使用<code>UnityEngine</code>等命名空间，但是因为需要使用<code>Func</code>、<code>Action</code>等，需要使用命名空间<code>System</code>。</p>
<h4 id="注册和注销">注册和注销</h4>
<p>C#事件的作用是一并调用一些函数，那么调用那些函数呢？答案是所有注册表上的函数，也就是已注册未注销的函数，注册和注销的方法就是使用C#事件的<code>+=</code>和<code>-=</code>，左侧是C#事件的对象名，右侧是要注册/注销的函数名，注意注册/注销的函数的参数和返回值类型要与C#事件一致：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">a</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; eve;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">b</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a.eve += func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a.eve -= func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">func</span>(<span class="params"><span class="built_in">int</span> para</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="keyword">nameof</span>(func) + <span class="string">&quot; &quot;</span> + para);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际应用时，通常在Unity自带的<code>OnEnable</code>函数中将想调用的函数注册，在<code>OnDisable</code>函数中将函数注销。这两个函数分别在脚本刚开始启用/禁用时被调用。</p>
<h4 id="创建调用函数">创建调用函数</h4>
<p>C#事件有一个特性就是除了在定义该函数对象的类中，其他位置除了<code>+=</code>和<code>-=</code>这两个方法其他方法禁用，但是我们还需要在定义该函数对象的类外调用这个C#事件，那我们就需要先在在定义该函数对象的类中创建一个调用函数。如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">a</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">event</span> Action&lt;<span class="built_in">int</span>&gt; eve;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Calleve</span>(<span class="params"><span class="built_in">int</span> para</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        eve?.Invoke(para);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>?.</code>是一种语法糖，表示如果不为<code>null</code>才执行，上方代码的第6行等同于：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (eve != <span class="literal">null</span>) eve.Invoke(para);</span><br></pre></td></tr></table></figure>
<p><code>Invoke</code>是C#事件的一个方法，用于调用所有在该事件上注册的函数，调用顺序是按照注册顺序，如果函数还带有返回值（<code>Func</code>类型），<code>Invoke</code>会返回最后一个注册的函数的返回值。</p>
<h4 id="整体逻辑">整体逻辑</h4>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-41.png" height=250>
<p>C#事件起到一个控制枢纽的作用，他记录下需要被调用的函数，时机到时，只要调用C#事件，就能调用诸多函数。并且调用C#事件的语句处（上图中<code>c</code>类）不需要知道之后C#事件又调用了谁，这是由被调用函数在自己的类中（上图中<code>b</code>类）的注册和注销决定的，这有效地做到了解耦。</p>
<h2 id="时间">时间</h2>
<h3 id="读取和设置循环执行的事件函数的时间">读取和设置循环执行的事件函数的时间</h3>
<p><code>Update</code>和<code>FixedUpdate</code>是最常用的两种循环执行的事件函数，使用Unity自带的<code>Time</code>类里的属性可以读取和设置他们的相关时间信息，常用的如下，这些属性都是<code>float</code>类型而且是静态，所以无需实例化，直接使用即可：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-37.png" height=170>
<p>每个属性有3个关键字，分别是：</p>
<ul>
<li>
<p>有无<code>fixed</code></p>
<ul>
<li>
<p>无<code>fixed</code>：在<code>Update</code>中指本次<code>Update</code>开始执行的时刻的时间（这里的时间指从游戏开始计时，以秒为单位的总时间）；在<code>FixedUpdate</code>中指本次<code>FixedUpdate</code>开始执行的时刻的时间。</p>
</li>
<li>
<p>有<code>fixed</code>：在<code>Update</code>中指上一次<code>FixedUpdate</code>开始执行的时刻的时间；在<code>FixedUpdate</code>中指本次<code>FixedUpdate</code>开始执行的时刻的时间。</p>
</li>
</ul>
</li>
<li>
<p>有无<code>delta</code></p>
<p>如有<code>delta</code>，其值等于该函数中无<code>delta</code>的同类属性减去上一次调用同种函数时无<code>delta</code>的同类属性。例如先后执行了<code>Update</code>、<code>FixedUpdate</code>、<code>Update</code>，按顺序称为函数1、2、3，则在函数3中的<code>deltatime</code>等于函数3中的<code>time</code>减去函数1中的<code>time</code>。</p>
</li>
<li>
<p>有无<code>unscaled</code></p>
<p>如有<code>unscaled</code>，则表示不受时间缩放（之后会讲）影响；反之表示受其影响。</p>
</li>
</ul>
<p>以上的这些所有的属性中，只有<code>fixedDeltaTime</code>可读可写，其他都是只读。他也是最常用的属性之一，用于读取和更改<code>FixedUpdate</code>的执行间隔。</p>
<h3 id="时间缩放">时间缩放</h3>
<p>改变<code>Time</code>类里的属性<code>timeScale</code>可控制时间缩放，用于慢动作和暂停。其值越小时间流动越慢。值为0时，相当于游戏暂停，不会调用<code>FixedUpdate</code>函数。</p>
<p>如果变更了<code>timeScale</code>，建议也将<code>fixedDeltaTime</code>变更相同的倍数。例如<code>timeScale</code>乘<code>0.5</code>，建议将<code>fixedDeltaTime</code>也乘<code>0.5</code>。</p>
<h2 id="加载场景">加载场景</h2>
<p>和场景有关的类、方法和属性在命名空间<code>SceneManagement</code>中，需要使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br></pre></td></tr></table></figure>
<h3 id="SceneManager">SceneManager</h3>
<p>使用<code>SceneManagement</code>命名空间中的<code>SceneManager</code>类可以对场景进行控制。</p>
<p>Unity支持多场景，也就是同时存在多个场景，但是这样做相对复杂，很多情况下使用单场景即可。而如果使用单场景，大部分<code>SceneManager</code>类里的方法就没有必要使用。所以需要掌握的函数方法不多：</p>
<ul>
<li>
<p><code>LoadSceneAsync</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">string</span> sceneName, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">int</span> sceneBuildIndex, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>sceneName</code>：需要加载的场景的名称（就是文件名，不需要加后缀）。</p>
</li>
<li>
<p><code>sceneBuildIndex</code>：需要加载的场景在「BuildSettings（生成设置）」中的下标。</p>
</li>
<li>
<p><code>mode</code>：生成方式（详见下一小节）。</p>
</li>
</ul>
<p>需要注意的是，就算使用名称生成场景，也需要在「菜单栏-文件-生成设置-Build中场景」中添加该场景才能正常生成。</p>
</li>
<li>
<p><code>GetActiveScene</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SceneManagement.<span class="function">Scene <span class="title">GetActiveScene</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>返回当前活动的场景。可以通过对其加载来重新开始游戏。</p>
</li>
</ul>
<h3 id="LoadSceneMode">LoadSceneMode</h3>
<p>使用<code>SceneManagement</code>命名空间中的<code>LoadSceneMode</code>枚举量可以选择加载场景的方式。该枚举量有两种取值：</p>
<ul>
<li>
<p><code>Single</code>：关闭所有已存在的场景，加载新的场景。</p>
</li>
<li>
<p><code>Additive</code>：不关闭任何已存在的场景，加载新的场景。</p>
</li>
</ul>
<h3 id="AsyncOperation">AsyncOperation</h3>
<p><code>AsyncOperation</code>类并不是<code>SceneManagement</code>命名空间中的。</p>
<p><code>LoadSceneAsync</code>的返回值就是一个<code>AsyncOperation</code>类，用它我们可以读取和设置加载场景的进度和加载结束后是否立即激活，以下是它的常用属性：</p>
<ul>
<li>
<p><code>progress</code>：<code>float</code>类型，只读，取值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。表示加载进度。</p>
</li>
<li>
<p><code>isDone</code>：<code>bool</code>类型，只读。表示加载是否已经完成。</p>
</li>
<li>
<p><code>allowSceneActivation</code>：<code>bool</code>类型，可读可写。表示加载完成后是否激活场景。其实如果该属性设置为<code>false</code>，场景加载的进度也不会停在100%处，而是停在90%处，<code>isDone</code>保持为<code>false</code>。设置为<code>true</code>后场景才会激活。</p>
</li>
</ul>
<p>该类还有一个事件：</p>
<ul>
<li><code>completed</code>：返回值为<code>void</code>，有一个<code>AsyncOperation</code>类型的参数的事件（关于事件的具体用法请见前文「使用C#事件解耦」）。在场景加载完成后调用所有注册在该事件上的函数，如果处理程序是在操作完成后注册的，并且已调用 complete 事件，则将同步调用该处理程序。</li>
</ul>
<h2 id="UI">UI</h2>
<p>首先我们将介绍添加UI的基本方法和注意事项，然后将围绕与UI有关的组件来介绍。</p>
<h3 id="添加UI">添加UI</h3>
<p>在「层级窗口」中右键选择「UI」即可添加UI：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-42.png" height=350>
<p>注意到如果你的场景中没有UI，不管你添加任何UI，都会自动添加名叫「EventSystem」的对象，且你添加的UI会作为名叫「Canvas」的对象的子级：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-43.png" height=60>
<h3 id="基本类组件">基本类组件</h3>
<h4 id="StandaloneInputModule">StandaloneInputModule</h4>
<p>在检查视图中打开自动创建的叫「EventSystem」的对象，在「StandaloneInputModule」组件中会有一段报错，这是因为他还在使用旧版的输入系统，点击下方按钮即可切换成新输入系统：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-29.png" height=290>
<h4 id="Canvas">Canvas</h4>
<p>自动添加的名叫「Canvas」的对象会自带名叫「Canvas」的组件，任何UI对象都必须含「Canvas」组件或为含「Canvas」组建的对象的子孙级。</p>
<p>可以创建多个含「Canvas」组件的对象。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-28.png" height=112>
<ul>
<li>
<p>渲染模式：有三种取值：</p>
<ul>
<li>
<p>屏幕空间-覆盖</p>
<p>这种状态下UI并非场景中存在的物体，而是最后在画面渲染的之后添加在画面上的，你可以理解为这些UI被画在你的屏幕上。正因如此，他们会挡在场景中所有对象的前面。暂停菜单、按钮、得分显示等适合使用该种渲染模式。</p>
<p>在此状态下，该组件所在对象的「RectTransform」组件被其驱动而无法在检查视图中编辑。</p>
<p>在此状态下的UI对象在场景视图中显示为远远大于其他对象的物体，这是为了方便区分他们和场景中实际存在的物体。</p>
</li>
<li>
<p>屏幕空间-摄像机</p>
<p>这种状态下UI是场景中存在的物体，与其它的所有物体一起渲染，所以也会与其他物体产生遮挡关系。</p>
<p>在此状态下，该组件所在对象始终面对摄像机。这表明在此状态下，该组件所在对象的「RectTransform」组件被其驱动而无法在检查视图中编辑。</p>
</li>
<li>
<p>世界空间</p>
<p>这种状态下UI是场景中存在的物体，与其它的所有物体一起渲染，所以也会与其他物体产生遮挡关系。</p>
<p>在此状态下，该组件所在对象不必面对摄像机。这表明在此状态下，该组件所在对象的「RectTransform」组件不被其驱动而可以在检查视图中编辑。</p>
</li>
</ul>
</li>
<li>
<p>像素完美：是否应该无锯齿精确渲染UI。</p>
</li>
</ul>
<h4 id="RectTransform">RectTransform</h4>
<p>「RectTransform」是创建UI对象时自带的能代替「Transform」的功能更强大的组件。</p>
<h5 id="中心、轴心和锚点">中心、轴心和锚点</h5>
<p>我们在之前就介绍过中心和轴心，我们再来回顾一下，然后介绍功能更强大的锚点：</p>
<ul>
<li>
<p>中心：几何中心，对于一个矩形来说，就是对角线的交点。</p>
</li>
<li>
<p>轴心：一个基准点，图标为蓝色圆圈：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-44.png" height=80>
</li>
<li>
<p>锚点：锚点共有四个，他们是一个矩形的四个顶点，这个矩形也可以缩成一条线段或一个点，图标为顶点处的四个小箭头：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-45.png" height=120>
</li>
</ul>
<h5 id="矩形变换的功能">矩形变换的功能</h5>
<p>每个「RectTransform」组件都有一个矩形变换区域（后简称为“区域”），这个区域是一个矩形。被「Canvas」驱动的区域就是长宽比和屏幕一致的矩形。</p>
<p>「RectTransform」功能强大就在于他能根据不同的屏幕长宽比而调整区域的位置和大小。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-46.png" height=350>
<h6 id="锚点的确定">锚点的确定</h6>
<p>锚点不能超出父级的区域，四个锚点组成的矩形平行于父级的区域。</p>
<p>锚点的位置在父级的区域中的比例是确定的，又因为不能超出，所以两个属于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 的数就可以确定一个锚点；又因为锚点矩形平行于父级区域，所以确定两个对角锚点即可确定四个锚点。</p>
<h6 id="旋转缩放前区域的确定">旋转缩放前区域的确定</h6>
<p>因为区域还可以做相对于轴心的旋转和缩放（之后会讲），我们将做相对于轴心的旋转和缩放之前的区域叫前区域，之后的叫后区域。</p>
<p>前区域是平行于父级的区域和锚点矩形的矩形。他的四个顶点分别对应四个锚点，每个顶点与每个锚点的沿xy两个轴向的偏移距离是固定的，单位为Unity单位长度。</p>
<h6 id="轴心的确定">轴心的确定</h6>
<p>轴心的位置在前区域中的比例是确定的，且可以超出前区域。</p>
<h6 id="对区域进行旋转缩放">对区域进行旋转缩放</h6>
<p>前区域只是为了方便理解矩形变换的中间量，后区域才是最终的结果。</p>
<p>后区域由前区域相对于轴心旋转和缩放而来。</p>
<p>如果UI对象的父子关系比较复杂，有多层关系，再进行旋转和缩放的话其效果可能会难以控制。所以除了用于特殊效果外，尽量少使用旋转和缩放。</p>
<h5 id="检查视图中的设置">检查视图中的设置</h5>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-47.png" height=205>
<h3 id="视觉类组件">视觉类组件</h3>
<h4 id="Image">Image</h4>
<p>「Image」组件是用于显示图像的UI组件，除了单独使用，许多其他的UI组件也需要依赖于他。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-53.png" height=203>
<p>未赋值源图像时，有一些属性不会显示。</p>
<ul>
<li>
<p>可遮盖：如果勾选，则可被其父级的「Mask」组件（详见之后的小节）遮盖；反之不会。</p>
</li>
<li>
<p>图像类型：控制图像的特殊显示类型，使其呈现和原图不一样的效果：</p>
<ul>
<li>
<p>简单：与原图效果相同。</p>
</li>
<li>
<p>已切片</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-54.png" height=54>
<p>该种图像类型是将原图切成九宫格，当图片被伸缩时，四个角区域的大小不变；四个边区域只有一个维度伸缩，另一个维度不变；中心区域两个维度都伸缩：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-55.png" height=180>
<p>而九宫格的设置是在原图的「SpriteEditor」，和设置图片的轴心（详见前文「俯视角渲染模式的设置」一章）是在一个位置。在「项目视图」中点击该图片，然后在「检查视图-SpriteEditor」中拖动绿色框：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-56.png" height=300>
<ul>
<li>
<p>填充中心：是否填充中心区域。</p>
</li>
<li>
<p>每单位像素乘数：将四个角区域和四个边区域不缩放的维度进行缩放。这个数越大，这些区域越小。</p>
</li>
</ul>
</li>
<li>
<p>已平铺</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-57.png" height=57>
<p>同样是是将原图切成九宫格，当图片被伸缩时同样是四个角区域的大小不变。不同的是四个边区域是有一个维度平铺，另一个维度不变；中心区域两个维度都平铺。</p>
<p>平铺就是划定范围大于原图范围时，图片重复排列一直延伸到达到划定范围；划定范围小于原图范围时就将原图缩小到划定范围。</p>
</li>
<li>
<p>已填充</p>
<p>分为很多种填充模式，如水平、竖直、旋转：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-58.png" height=180>
<p>常用于制作进度条。</p>
</li>
</ul>
</li>
</ul>
<p>如果想获取更多系统自带的源图像，可通过以下方法：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-70.png" height=250>
<h4 id="Mask">Mask</h4>
<p>「Mask」组件的作用是将创建一个遮罩，其所在对象的所有子孙对象的UI图像只能在遮罩的范围内显示，UI图像处于遮罩范围外的部分不可见：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-67.png" height=320>
<p>必须有一个「Image」组件与「Mask」组件在同一个对象上才能使「Mask」起作用，这个「Image」为「Mask」提供遮罩图像。Alpha值等于0的像素有遮罩，不可见；Alpha值不等于0的像素没有遮罩，可见。</p>
<p>勾选「显示遮罩图形」后，遮罩图像也会被显示；反之会被隐藏。</p>
<h3 id="互动类组件">互动类组件</h3>
<h4 id="Button">Button</h4>
<h5 id="按钮对象的创建">按钮对象的创建</h5>
<p>再层级视图中右键选择相应对象即可创建，需要注意的是有两个按钮：「按钮TextMeshPro」和「旧版-按钮」。创建按钮时会自带一个子物体「Text」，这两种按钮唯一的区别就是这个字物体上的组件是「Text」还是「TextMeshPro」。也可以将该子物体删掉，除了无法在按钮上写字之外对正常使用没有影响。</p>
<p>创建出来的按钮对象会自带「Button」组件。</p>
<h5 id="检查视图中的设置-2">检查视图中的设置</h5>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-49.png" height=335>
<ul>
<li>
<p>Interactable：是否允许该按钮输入信息。如果取消勾选，该按钮仍可见，但是不接收信息。</p>
</li>
<li>
<p>过渡：有四种取值：</p>
<ul>
<li>
<p>无：按钮的外观始终不会发生变化。</p>
</li>
<li>
<p>颜色色彩：按钮的每个状态对应一种颜色。注意不是这种颜色的纯色，而是该颜色和「目标图形」的图片叠加的结果。</p>
</li>
<li>
<p>Sprite交换：按钮的每个状态对应一张Sprite图片。</p>
</li>
<li>
<p>动画：使用动画控制按钮的每个状态以及状态间的切换。</p>
</li>
</ul>
<p>按钮的状态将在下一小结展开。</p>
</li>
<li>
<p>持续淡化时间</p>
<p>状态间过渡的时间，「过渡」为「颜色色彩」时特有。</p>
</li>
<li>
<p>鼠标单击()</p>
<p>每当鼠标点击按钮后松开时，执行列表中所有的方法。</p>
<p>只有访问关键字为<code>public</code>，返回值为<code>void</code>，无传参或传参只有一个且为<code>bool</code>、<code>int</code>、<code>float</code>、<code>string</code>、<code>Object</code>中的一个的方法才能加入此列表。</p>
</li>
</ul>
<h5 id="按钮状态">按钮状态</h5>
<p>按钮共有5种状态，分别是：</p>
<ul>
<li>
<p>正常：未进行任何操作时。</p>
</li>
<li>
<p>高亮：鼠标放在该按钮上，但是并未点击。</p>
</li>
<li>
<p>按下：鼠标点击按钮但未松开。</p>
</li>
<li>
<p>选择：鼠标点击按钮然后松开后，且重新点击其他位置之前。</p>
</li>
<li>
<p>禁用：「Interactable」取消勾选时。</p>
</li>
</ul>
<p>处于按下状态或选择状态时，按「Enter」键也可以触发按钮。</p>
<p>值得注意的是，如果「游戏视图」中使用的是「模拟器」，则无法显示高亮状态，应使用「游戏」。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-48.png" height=200>
<h5 id="使用代码添加和去除监听函数">使用代码添加和去除监听函数</h5>
<p>所有以上和以下脚本的属性都可以通过代码来读取和修改，监听函数同样可以通过代码添加，只不过方法较更改属性更复杂，需要展开讲解，就以「Button」组件为例：</p>
<p>需要使用UI的命名空间才能使用UI类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br></pre></td></tr></table></figure>
<p>在脚本中添加以下代码，并挂在和「Button」组件的同一对象上：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;func&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Button b = GetComponent&lt;Button&gt;();</span><br><span class="line">    b.onClick.AddListener(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>RemoveListener</code>和<code>RemoveAllListeners</code>可以去除监听函数。</p>
<p>以上代码相当于在「检查视图」中的「鼠标单击()」列表中添加或去除了<code>func</code>函数。但是注意在代码中添加的监听函数并不会在「检查视图」中的「鼠标单击()」显示，这和一般修改属性不同。还要注意无法使用<code>RemoveListener</code>和<code>RemoveAllListeners</code>去除手动在列表中添加的监听函数。</p>
<h4 id="Slider">Slider</h4>
<h5 id="滑动条对象的创建">滑动条对象的创建</h5>
<p>在层级视图中右键选择相应对象即可创建。创建按钮时会自带一系列子物体：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-51.png" height=140>
<ul>
<li>
<p>Background：大小不变的背景</p>
</li>
<li>
<p>Fill：大小随拖动而改变的进度条</p>
</li>
<li>
<p>Handle：用于拖动的手柄。</p>
</li>
</ul>
<p>创建出来的按钮对象会自带「Slider」组件。</p>
<h5 id="检查视图中的设置-3">检查视图中的设置</h5>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-50.png" height=480>
<p>大部分属性和用法和「Bottom」完全相同，这部分不会再提及。接下来介绍剩下的属性中常用的：</p>
<ul>
<li>
<p>方向：分为从左到右、从右到左、从下到上、从上到下。处于按下状态或选择状态时，如果是前两种方向，按「→」、「←」键也可以调节；如果是后两种方向，按「↑」、「↓」键也可以调节。</p>
</li>
<li>
<p>MinValue/MaxValue：能拖动到的最小/大值。</p>
</li>
<li>
<p>整数：若勾选，则取值只能为整数。</p>
</li>
<li>
<p>值改变时(Single)</p>
<p>每当值改变时，执行列表中所有的方法。</p>
<p>只有访问关键字为<code>public</code>，返回值为<code>void</code>，无传参或传参只有一个且为<code>bool</code>、<code>int</code>、<code>float</code>、<code>string</code>、<code>Object</code>中的一个的方法才能加入此列表。</p>
</li>
</ul>
<h4 id="Scrollbar">Scrollbar</h4>
<p>「Scrollbar」是滚动条自带的组件，而滚动条一般不独立使用，一般配合滚动视图使用。</p>
<h5 id="滚动条对象的创建">滚动条对象的创建</h5>
<p>在层级视图中右键选择相应对象即可创建。创建滚动条时会自带一系列子物体：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-60.png" height=90>
<p>其中对象Scrollbar和Handle上各有一个「Image」组件，在「游戏视图」中分别体现为滚动条的背景和手柄，而SlidingArea上无「Image」组件，所以没有图像的显示，作用仅为限制手柄滚动的范围。</p>
<h5 id="检查视图中的设置-4">检查视图中的设置</h5>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-59.png" height=450>
<p>仅介绍特有且常用的属性：</p>
<ul>
<li>
<p>大小：取值为从0到1的浮点数，控制手柄的长度。</p>
</li>
<li>
<p>步骤数量：取值为从0到11的整数。取值为0或1时，可以连续移动；反之，不能连续移动，只有步骤数量个位置可以移动到。</p>
</li>
</ul>
<h4 id="ScrollRect">ScrollRect</h4>
<p>「ScrollRect」是滚动视图自带的组件，滚动视图是一个沿x轴及y轴滚动的窗口，需要用到多种组件。</p>
<h5 id="滚动视图对象的创建">滚动视图对象的创建</h5>
<p>在层级视图中右键选择相应对象即可创建。创建滚动视图时会自带一系列子物体：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-61.png" height=160>
<p>其中对象ScrollView和Content上各有一个「Image」组件，在「游戏视图」中分别体现为整个矩形区域的背景和滚动条之间的内容区域。</p>
<p>对象Viewport上虽然有「Image」组件，但是该组件并不是用于显示图像，而是用于给「Mask」组件提供遮罩范围，所以Viewport没有图像的显示，作用仅为遮罩。</p>
<p>对象ScrollbarHorizontal和ScrollbarVertical分别为水平和竖直的滚动条，其子级和作用与直接创建的滚动条完全一致。</p>
<h5 id="检查视图中的设置-5">检查视图中的设置</h5>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-62.png" height=400>
<ul>
<li>
<p>内容：需要滚动显示的内容。</p>
</li>
<li>
<p>水平/竖直：启用水平/竖直滚动。</p>
</li>
<li>
<p>运动类型</p>
<ul>
<li>
<p>不受限制的：滚动超出Content的范围后，没有任何回弹的作用。</p>
</li>
<li>
<p>弹性的：滚动超出范围后，有回弹的作用。如果选择该种运动类型，会有特有属性「弹性」，用于控制松开鼠标后回弹的速度，值越小回弹越快。</p>
</li>
<li>
<p>已钳制：无法滚动超出Content的范围。</p>
</li>
</ul>
</li>
<li>
<p>惯性：如果勾选，则松开鼠标后Content还会向前移动，像惯性一样；如果取消勾选则停止滑动后Content立即停止移动。</p>
<p>如果勾选，则会有特有属性「减速率」，用于控制松开鼠标后减速（加速）的速率。值为0时效果和取消勾选相同；值为1时将一直保持该速度滑动；值属于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时减速；值属于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mo>+</mo><mi mathvariant="normal">∞</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,+\infty)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">+</span><span class="mord">∞</span><span class="mclose">)</span></span></span></span> 时加速。</p>
</li>
<li>
<p>滚动灵敏度：顾名思义。</p>
</li>
<li>
<p>可视性</p>
<ul>
<li>
<p>永久：永远不隐藏相应的滚动条。</p>
</li>
<li>
<p>自动隐藏：该滚动条所控制的维度上，Content的长度小于等于显示区域的长度时，隐藏该滚动条。但是显示区域不会扩展到该滚动条原来所在的区域上：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-63.png" height=150>
</li>
<li>
<p>自动隐藏并展开视口：该滚动条所控制的维度上，Content的长度小于等于显示区域的长度时，隐藏该滚动条。且显示区域会扩展到该滚动条原来所在的区域上：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-64.png" height=150>
</li>
</ul>
</li>
<li>
<p>间距：「可视性」设为「自动隐藏并展开视口」时的特有属性。</p>
<p>Scrollbar与Viewport的矩形变换区域之间的间距，正数表示相离，负数表示相交。</p>
<p>因为UI图像的四周一般有一圈透明的区域，导致除去这一圈透明之后的图像大小小于矩形变换区域的大小，所以一般要将这个值设成一个负值。</p>
<p>数值为0的效果：</p>
  <img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-65.png" height=150>
</li>
</ul>
<h3 id="自适应布局">自适应布局</h3>
<h4 id="自适应屏幕的背景图">自适应屏幕的背景图</h4>
<p>「CanvasScaler」是创建「画布(Canvas)」对象时自带的组件，用于缩放所有子孙级UI对象，以自适应不同分辨率的屏幕。</p>
<p>通常会创建一个UI背景，方法是先创建一个「面板(Panel)」对象，然后将你想作为背景的图片赋值给该对象的「Image」组件。然后我们设置该对象的「RectTransform」组件：将缩放全设为1，四个锚点全置于屏幕中央，矩形变换区域也置于屏幕中央。</p>
<p>这时因为屏幕长宽比与背景图长宽比不一致，可能会出现背景图无法覆盖整个屏幕的情况，需要用到「画布」对象上的「CanvasScaler」组件：</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-66.png" height=130>
<p>参考分辨率设为背景图的分辨率，其他与上图保持一致即可。</p>
<h4 id="自适应UI组">自适应UI组</h4>
<p>自动布局系统中非常重要的两个概念：布局元素和布局控制器。</p>
<p>布局元素就是参与自适应布局的UI元素，任何一个UI对象都可以作为布局元素，布局元素有以下6种属性：最小宽（高）度、最佳宽（高）度、弹性宽（高）度，默认值都是0。如果想更改这些值，需要用到组件「LayoutElement」。</p>
<p>布局元素只提供自己的这6种属性的值，而不直接设置自己的尺寸，但是给布局控制器通过这些值来计算他们的尺寸和位置。</p>
<h5 id="LayoutElement">LayoutElement</h5>
<p>用于更改布局元素的布局属性。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-71.png" height=175>
<ul>
<li>
<p>忽略布局：若勾选，则布局控制器将不会让该布局元素参与布局。</p>
</li>
<li>
<p>6种属性：</p>
<ul>
<li>
<p>最小XX：布局时该布局元素长度将不会小于该值（当然布局控制器需要开启「控制子对象大小」才能改变布局元素的长度，之后会讲），即使长度超出布局控制器的矩形变换区域。</p>
</li>
<li>
<p>最佳XX：如果所有布局元素的最小XX已得到分配，且还有剩余空间，则分配最佳XX。布局元素将按照他们 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>最佳XX</mtext><mo>−</mo><mtext>最小XX</mtext></mrow><annotation encoding="application/x-tex">\text{最佳XX}-\text{最小XX}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord cjk_fallback">最佳</span><span class="mord">XX</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">最小</span><span class="mord">XX</span></span></span></span></span> 的比例将剩余空间按比例分配，直到所有布局元素的长度同时达到最佳XX或剩余空间被分配完。</p>
</li>
<li>
<p>弹性XX：如果所有布局元素都达到最佳XX后仍有剩余空间（当然还需要布局控制器开启「子力扩展」，之后会讲），将分配弹性XX。布局元素将按照他们弹性XX的比例将剩余空间按比例全部分配。</p>
</li>
</ul>
</li>
<li>
<p>布局优先：当一个对象上有不止一个包含布局属性的组件，则取该值最高的那个。</p>
</li>
</ul>
<h5 id="HorizontalLayoutGroup和VerticalLayoutGroup">HorizontalLayoutGroup和VerticalLayoutGroup</h5>
<p>这两个组件分别用于水平布局和竖直布局，使用时将该组件作为添加到某对象上，然后将所有需要参与布局的布局元素作为其子对象。</p>
<p>两者的功能相对应，用法相似，这里以「Horizontal Layout Group」为例。</p>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-72.png" height=220>
<ul>
<li>
<p>填充：页边距。注意当内容过大导致左右页边距冲突时，如果「子级对齐」是从左到右，则满足左侧页边距；反之满足右侧。</p>
</li>
<li>
<p>间距：最小间距，即使长度超出布局控制器的矩形变换区域。如果「控制子对象大小」不勾选而「子力大小」勾选，则实际间距大小可以超出该值。</p>
</li>
<li>
<p>子级对齐：x轴y轴两个维度上都有对齐一侧、对齐另一侧、居中三个选项。</p>
</li>
<li>
<p>反向排列：如果不勾选，则布局元素排列顺序为在层级视图中由上到下的顺序；勾选则反之。</p>
</li>
<li>
<p>控制子对象大小：如果不勾选，则不能改变布局元素，也就是子级的矩形变换区域的大小，所以在这种情况下最小XX、最佳XX、弹性XX都无法分配，而间距大小可以改变；反之则可以改变布局元素的大小。</p>
</li>
<li>
<p>子力扩展：如果不勾选，则布局元素的最佳XX分配完后不会分配弹性XX，间距也不会扩大；反之则要求布局元素、间距、页边距必须铺满整个布局控制器的矩形变换区域。</p>
</li>
</ul>
<h5 id="GridLayoutGroup">GridLayoutGroup</h5>
<p>该组件用于网状布局。</p>
<p>和水平布局和竖直布局不同，网状布局会忽略所有布局元素的布局属性，并统一分配一样的长宽给每个布局元素。</p>
<h2 id="协程">协程</h2>
<h3 id="C-迭代器">C#迭代器</h3>
<p>因为Unity协程的实现基于C#迭代器，这里先对迭代器做简单讲解。</p>
<h4 id="迭代器的概念和基本用法">迭代器的概念和基本用法</h4>
<p>迭代器是用于按顺序遍历容器中的所有元素的接口。C#中迭代器有两个接口：<code>IEnumerator</code>和<code>IEnumerable</code>。这两个接口作用有所不同，我们暂时不用了解他们具体的区别，只需要理解迭代器即可。</p>
<p>迭代器支持两种功能，分别是按顺序给容器中的所有元素赋值和按顺序读取所有元素。其中读取用的就是<code>foreach</code>语句：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; b = CreateIE();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而按顺序给所有元素赋值的操作比较复杂，涉及到<code>yield</code>关键字。</p>
<h4 id="yield关键字">yield关键字</h4>
<p>这是一个返回迭代器中元素的函数方法，其中用到了<code>yield</code>关键字。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">CreateIE</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>yield</code>关键字后可以跟<code>return</code>，也可以跟<code>break</code>。</p>
<ul>
<li>
<p><code>yield break;</code>：终止当前函数，迭代结束。例如调用下方函数只会输出yes：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">CreateIE</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>yield return XXX;</code>：容器下一个元素是<code>XXX</code>。注意该语句不会迭代结束。例如下方函数生成的迭代器中的元素依次为<code>0 2 4 6 8</code>;</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">CreateIE</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于<code>yield</code>语句和迭代器，还有很重要的一点需要注意，迭代器的调用不会立即执行，例如以下代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">char</span>&gt; <span class="title">CreateIE</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    Console.Write(<span class="string">&quot;2 &quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    Console.Write(<span class="string">&quot;3 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IEnumerable&lt;<span class="built_in">char</span>&gt; numbers = CreateIE();</span><br><span class="line">    Console.Write(<span class="string">&quot;a &quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">char</span> i <span class="keyword">in</span> numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">$&quot;<span class="subst">&#123;i&#125;</span> &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 1 b 2 c 3</span><br></pre></td></tr></table></figure>
<p>注意所有字母均在主函数中输出，数字均在<code>CreateIE</code>函数中输出。我们发现并非在调用<code>CreateIE</code>函数后函数中的语句就执行完了，而是等到迭代器中的元素需要被读取时，每次需要被读取一个值，就在<code>CreateIE</code>函数中执行语句直到遇到一个<code>yield return</code>，返回这个值；需要读取下一个值时，再在<code>CreateIE</code>中执行语句。</p>
<p>这和多线程不一样，多线程是几个线程一并执行。而<code>CreateIE</code>是和主函数不断交替执行语句的权力。</p>
<h3 id="Unity协程">Unity协程</h3>
<h4 id="Unity自带函数开始和停止协程">Unity自带函数开始和停止协程</h4>
<p>协程全称协同程序。</p>
<p>Unity中和协程有关的部分用到的迭代器都是<code>IEnumerator</code>。</p>
<p>Unity有3个函数用于开始/停止协程：</p>
<ul>
<li>
<p><code>StartCoroutine</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params">IEnumerator routine</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Coroutine <span class="title">StartCoroutine</span>(<span class="params"><span class="built_in">string</span> methodName, <span class="built_in">object</span> <span class="keyword">value</span> = <span class="literal">null</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>传参可以为迭代器，也可以为返回值为迭代器的函数的名称以及该函数的传参，如果是后者，传参只能为0或1个。</p>
<p>返回值为协程类<code>Coroutine</code>。</p>
<p>销毁该脚本或是如果脚本所在对象已禁用也会停止协程；禁用该脚本不会停止协程。</p>
</li>
<li>
<p><code>StopCoroutine</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">IEnumerator routine</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params"><span class="built_in">string</span> methodName</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopCoroutine</span>(<span class="params">Coroutine routine</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>传参为迭代器时注意，<code>StopCoroutine</code>和开始协程时<code>StartCoroutine</code>传入的应是同一个实例化的迭代器，例如这个是错误的：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Func</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">StartCoroutine(Func());</span><br><span class="line">StopCoroutine(Func());</span><br></pre></td></tr></table></figure>
<p>这个是正确的：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Func</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">IEnumerator ie = Func();    </span><br><span class="line">StartCoroutine(ie);</span><br><span class="line">StopCoroutine(ie);</span><br></pre></td></tr></table></figure>
<p>还要注意，传参为迭代器的<code>StopCoroutine</code>只能终止传参为迭代器的<code>StartCoroutine</code>创建的的协程；字符串的也只能终止用字符串创建的；但是传参为<code>Coroutine</code>的都可以终止。</p>
</li>
<li>
<p><code>StopAllCoroutines</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StopAllCoroutines</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>停止该脚本上的所有协程。</p>
</li>
</ul>
<h4 id="迭代器生成函数的逻辑和yield关键字">迭代器生成函数的逻辑和yield关键字</h4>
<p>我们在上一节了解到，一个返回值类型为迭代器的函数，每次调用<code>yield return</code>之后，会将执行语句的权力交还给主程序，等到下次需要时主程序再将执行语句的权力交还给该函数。对于Unity而言，这个主程序交还权力给该函数的时间是下一帧，也就是每帧协程都会运行到下一个<code>yield</code>。而具体在每帧的何时运行，可见<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/ExecutionOrder.html">Unity文档-事件函数的执行顺序</a>。</p>
<p>而<code>yield return XXX;</code>中<code>XXX</code>的不同也会由不同的效果：</p>
<ul>
<li>
<p><code>yield return null;</code>/<code>yield return 任何数字;</code>：挂起直到下一帧。</p>
</li>
<li>
<p><code>yield return asyncOperation类;</code>：挂起直到该异步操作结束。</p>
</li>
<li>
<p><code>yield return Coroution类</code>：挂起直到该协程结束。</p>
</li>
<li>
<p><code>yield return Func(XXX)</code>：挂起直到该函数结束。</p>
</li>
<li>
<p><code>yield return new WaitForSeconds(0.3f);</code>：挂起直到0.3秒后，会受时间缩放影响。</p>
</li>
<li>
<p><code>yield return new WaitForSecondsRealtime(float);</code>：挂起直到0.3秒后，不会受时间缩放影响。</p>
</li>
<li>
<p><code>yield return new WaitUntil(bool);</code>：挂起直到输入的参数为<code>true</code>。</p>
</li>
<li>
<p><code>yield return new WaitWhile(bool);</code>：挂起直到输入的参数为<code>false</code>。</p>
</li>
</ul>
<h4 id="使用协程制作加载界面">使用协程制作加载界面</h4>
<p>利用以下代码，可以制作一个有加载进度条和百分比数字的加载场景：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Slider slider;</span><br><span class="line"><span class="keyword">public</span> Text text;</span><br><span class="line"><span class="keyword">private</span> AsyncOperation operation;</span><br><span class="line"><span class="function">IEnumerator <span class="title">ILoad</span>(<span class="params"><span class="built_in">string</span> scenename</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    operation = SceneManager.LoadSceneAsync(scenename);</span><br><span class="line">    <span class="keyword">while</span>(!operation.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        slider.<span class="keyword">value</span> = operation.progress;</span><br><span class="line">        text.text = (operation.progress * <span class="number">100</span>).ToString() + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StartCoroutine(ILoad(<span class="string">&quot;Title&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="本地保存数据">本地保存数据</h2>
<h3 id="C-文件IO">C#文件IO</h3>
<p>本地保存数据需要将数据从本地文件写入和读出。</p>
<p>与控制台IO不同的是，文件IO用到的不是<code>Console</code>，而是<code>File</code>静态类，使用前需要<code>using</code>命名空间：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br></pre></td></tr></table></figure>
<p><code>File</code>类中常用的静态方法：</p>
<ul>
<li>
<p><code>WriteAllText</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteAllText</span>(<span class="params"><span class="built_in">string</span> path, <span class="built_in">string</span>? contents</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>创建一个指定路径的新文件，向其中写入指定的字符串，然后关闭文件。如果目标文件已存在，则覆盖该文件。</p>
</li>
<li>
<p><code>ReadAllLines</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span>[] <span class="title">ReadAllLines</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>打开一个指定路径的文件，逐行读取文件中的所有文本，然后关闭此文件。每行的内容各存入<code>string[]</code>的一个位置，<code>\n</code>和<code>\r</code>不会被存入。</p>
<p>使用前应先用<code>Exists</code>判断该文件是否存在。</p>
</li>
<li>
<p><code>Exists</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Exists</span>(<span class="params"><span class="built_in">string</span> path</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>判断指定路径的文件是否存在。</p>
</li>
</ul>
<h3 id="设置保存文件的路径">设置保存文件的路径</h3>
<p>保存文件需要地址，而且需要在不同系统、不同用户的电脑上找到合适的地址，这就要用到Unity自带的静态属性：</p>
<ul>
<li><code>Application.persistentDataPath</code>：<code>string</code>类型，可以用于保存数据的文件夹的地址，在不同系统中不同。</li>
</ul>
<p>注意到这是文件夹地址，而该文件夹中的文件地址需要在末尾加上<code>/FILENAME</code>。</p>
<h3 id="序列化插件">序列化插件</h3>
<p>虽然掌握了C#文件IO的方法，但本地保存数据时如果一个一个将需要保存的数据值按顺序输入到文件中，再在需要用的时候一个一个按顺序从中读取并赋值，未免过于繁杂。</p>
<p>使用序列化插件可以一个函数将要输出的所有数据由其他类型变成一个字符串类型以便输出，还可以一个函数将该字符串变回去。</p>
<p>在「菜单栏-窗口-包管理器-左上角加号-添加来自gitURL的包」中输入「com.unity.nuget.newtonsoft-json」下载序列化插件。</p>
<p>在代码中需要<code>using</code>命名空间：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br></pre></td></tr></table></figure>
<p>常用的有两个方法，分别用于序列化和反序列化，他们都是静态类<code>JsonConvert</code>的静态方法：</p>
<ul>
<li>
<p><code>SerializeObject</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">SerializeObject</span>(<span class="params"><span class="built_in">object</span>? <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>将传参序列化，返回序列化后的字符串。例如将<code>new List&lt;int&gt;&#123;3, 1, 4, 7&#125;</code>序列化，返回的字符串是<code>&quot;[3,1,4,7]&quot;</code></p>
</li>
<li>
<p><code>DeserializeObject</code></p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T? DeserializeObject&lt;T&gt;(<span class="built_in">string</span> <span class="keyword">value</span>);</span><br></pre></td></tr></table></figure>
<p>将传参反序列化。</p>
</li>
</ul>
<h3 id="本地保存数据的代码实现">本地保存数据的代码实现</h3>
<p>下方代码中<code>a</code>、<code>b</code>、<code>c</code>就是要本地保存的数据。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> path;</span><br><span class="line"><span class="built_in">string</span>[] readcontent;</span><br><span class="line"><span class="built_in">string</span> writecontent;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> a;</span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; b;</span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; c;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    path = Application.persistentDataPath + <span class="string">&quot;/data.sav&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Read</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (File.Exists(path))</span><br><span class="line">    &#123;</span><br><span class="line">        readcontent = File.ReadAllLines(path);</span><br><span class="line">        a = JsonConvert.DeserializeObject&lt;<span class="built_in">float</span>&gt;(readcontent[<span class="number">0</span>]);</span><br><span class="line">        b = JsonConvert.DeserializeObject&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(readcontent[<span class="number">1</span>]);</span><br><span class="line">        c = JsonConvert.DeserializeObject&lt;List&lt;<span class="built_in">string</span>&gt;&gt;(readcontent[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">3.1415926f</span>;</span><br><span class="line">        b = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        c = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;Unity!&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    writecontent += JsonConvert.SerializeObject(a) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    writecontent += JsonConvert.SerializeObject(b) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    writecontent += JsonConvert.SerializeObject(c) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    File.WriteAllText(path, writecontent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="音频">音频</h2>
<p>Unity中音频系统常用组件是「AudioSource」和「AudioListener」，分别是声音的发出者和声音的接收者。一个项目中只需要有一个「AudioListener」，一般都在MainCamera上，但可以有多个「AudioSource」。</p>
<p>音乐文件被称作「AudioClip」，可以是任意音频文件类型。可以在<a target="_blank" rel="noopener" href="https://assetstore.unity.com/zh?locale=zh-CN">Unity资源商店</a>中挑选合适的素材。</p>
<p>这三者在代码中的类名就叫<code>AudioSource</code>、<code>AudioListener</code>和<code>AudioClip</code>。</p>
<h3 id="AudioSource">AudioSource</h3>
<h4 id="检查视图设置-4">检查视图设置</h4>
<img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/image-74.png" width=310>
<p>常用属性如下：</p>
<ul>
<li>
<p>AudioClip：将需要播放的音频填在这里。</p>
</li>
<li>
<p>静音</p>
</li>
<li>
<p>唤醒时播放：在比<code>Awake</code>更早的时候就开始播放。注意如果想使用该功能，应在游戏运行前就在检查窗口中给「AudioClip」赋值，而不是在<code>Awake</code>或更晚的时候。</p>
</li>
<li>
<p>循环</p>
</li>
<li>
<p>音量</p>
</li>
<li>
<p>空间混合</p>
<p>空间混合就是设置2D模式和3D模式所占比例。</p>
<p>Unity的音频系统分为两种模式：2D和3D。其实这两种模式和几D没关系，2D模式就是指音量大小音调等都与「AudioSource」和「AudioListener」之间的距离无关，「AudioSource」发出什么声音「AudioListener」就接收到什么样的声音；3D模式是考虑两者之间的距离等因素，比较贴近实际。</p>
<p>在2D游戏中使用3D模式时要注意，MainCamera的默认z轴坐标值是-10，而一般对象的z轴坐标值是0。这种情况下就算音源对象和MainCamera的x轴y轴坐标都相同他们间仍有10的距离，也达不到最大声音。所以建议将MainCamera的z轴坐标设为0，并将其「裁剪平面-近」设置为0，否则看不到z轴坐标为0的对象。</p>
</li>
<li>
<p>多普勒级别：如需关闭多普勒效应，该值设为0。</p>
</li>
<li>
<p>音量衰减/最小距离/最大距离：参考下方图像设置。</p>
</li>
</ul>
<h4 id="代码编写">代码编写</h4>
<p><code>AudioSource</code>类的常用属性和方法：</p>
<ul>
<li>
<p><code>clip</code>：属性，类型为<code>AudioClip</code>。就是检查视图中的「AudioClip」。</p>
</li>
<li>
<p><code>Play</code>：方法，无返回值无传参。开始播放。</p>
</li>
</ul>
<!-- # 参考

- CSDN博主「王王王渣渣」：https://blog.csdn.net/wangjiangrong/article/details/104020387

- 知乎作者「树懒卡农」：https://zhuanlan.zhihu.com/p/577458058
和其github资源：https://github.com/sass00n1/StartEasing -->
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rsdbk_husky@foxmail.com">rsdbk_husky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rsdbkhusky.github.io/2023/08/24/Unity2D%E5%85%A5%E9%97%A8/">http://rsdbkhusky.github.io/2023/08/24/Unity2D%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rsdbkhusky.github.io" target="_blank">燃烧的冰块_husky's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81/">代码</a></div><div class="post_share"><div class="social-share" data-image="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"><img class="prev-cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" onerror="onerror=null;src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2023年度总结</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/24/%E3%80%8A%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/2022/06/%E3%80%8A%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/cover.jfif" onerror="onerror=null;src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《高等数学》笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/21/Bear%20and%20Prime%20100/" title="Luogu CF679A Bear and Prime 100"><img class="cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Luogu CF679A Bear and Prime 100</div></div></a></div><div><a href="/2021/07/21/Buying%20Feed%20G/" title="Luogu P4544 [USACO10NOV]Buying Feed G"><img class="cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Luogu P4544 [USACO10NOV]Buying Feed G</div></div></a></div><div><a href="/2021/07/21/Buying%20Feed,%20II%20S/" title="Luogo P2616 [USACO10JAN]Buying Feed, II S"><img class="cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Luogo P2616 [USACO10JAN]Buying Feed, II S</div></div></a></div><div><a href="/2021/10/06/Luogu%20U182676%20%E5%AE%8C%E5%85%A8%E5%9B%BE%E5%88%87%E5%89%B2/" title="Luogu U182676 完全图切割"><img class="cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/2021/10/06/Luogu%20U182676%20%E5%AE%8C%E5%85%A8%E5%9B%BE%E5%88%87%E5%89%B2/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-06</div><div class="title">Luogu U182676 完全图切割</div></div></a></div><div><a href="/2021/07/21/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA/" title="OI中的数论"><img class="cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/2021/07/21/OI中的数论/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">OI中的数论</div></div></a></div><div><a href="/2021/07/21/Guess%20the%20Array/" title="Luogu CF727C Guess the Array"><img class="cover" src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-21</div><div class="title">Luogu CF727C Guess the Array</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E5%A4%B4%E5%83%8F.png" onerror="this.onerror=null;this.src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="avatar"/></div><div class="author-info__name">rsdbk_husky</div><div class="author-info__description">using namespace determination</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">180</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rsdbkhusky"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">如遇到文章中 LaTeX 炸掉的情况，可使用科学上网的方式尝试加载，也可直接在文章下方评论提醒我。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Unity</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">代码编辑器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E4%B8%80%E8%A7%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">窗口一览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">窗口布局的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E8%A7%86%E5%9B%BE%E4%B8%AD%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.3.</span> <span class="toc-text">游戏视图中模拟器的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AF%E8%A7%86%E8%A7%92%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">俯视角渲染模式的设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E5%8F%A0%E5%B1%82%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">透视叠层的排序方法的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E8%BD%B4%E5%BF%83%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">图片轴心的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%86%E5%9B%BE%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%82%B9%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">场景视图中操作点的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1Sprite%E6%8E%92%E5%BA%8F%E7%82%B9%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.4.</span> <span class="toc-text">对象Sprite排序点的设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transform"><span class="toc-number">1.4.</span> <span class="toc-text">Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.4.1.</span> <span class="toc-text">检查视图设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">函数调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpriteRenderer"><span class="toc-number">1.5.</span> <span class="toc-text">SpriteRenderer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">检查视图设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">函数调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="toc-number">1.6.</span> <span class="toc-text">代码相关补充知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.6.1.</span> <span class="toc-text">变量的赋值位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">常用标签属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">1.6.3.</span> <span class="toc-text">对象的标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">1.6.4.</span> <span class="toc-text">对象的名称</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F-InputSystem"><span class="toc-number">1.7.</span> <span class="toc-text">输入系统(InputSystem)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.7.1.</span> <span class="toc-text">输入系统的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85InputSystem"><span class="toc-number">1.7.2.</span> <span class="toc-text">安装InputSystem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAInputControl%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">创建InputControl文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEInputControl%E6%96%87%E4%BB%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">设置InputControl文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActionMap%EF%BC%8CAction%E5%92%8CBinding"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">ActionMap，Action和Binding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Action%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">Action的设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binding%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">Binding的设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PlayerInput%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.5.</span> <span class="toc-text">PlayerInput组件的添加和配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D%E5%9B%BE%E6%A0%87%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.7.6.</span> <span class="toc-text">3D图标的设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC"><span class="toc-number">1.7.7.</span> <span class="toc-text">编写脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.7.7.1.</span> <span class="toc-text">头文件和函数格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.7.7.2.</span> <span class="toc-text">信息类型的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BD%BF%E7%94%A8%E7%82%B9%E5%87%BB%E5%B1%8F%E5%B9%95%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.7.7.3.</span> <span class="toc-text">获取和使用点击屏幕的位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D%E5%88%9A%E4%BD%93-Rigidbody2D"><span class="toc-number">1.8.</span> <span class="toc-text">2D刚体(Rigidbody2D)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic"><span class="toc-number">1.8.1.</span> <span class="toc-text">Dynamic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kinematic"><span class="toc-number">1.8.2.</span> <span class="toc-text">Kinematic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Static"><span class="toc-number">1.8.3.</span> <span class="toc-text">Static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8DBodyType%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A7%A6%E5%8F%91%E5%92%8C%E7%A2%B0%E6%92%9E%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.4.</span> <span class="toc-text">三种BodyType之间的触发和碰撞关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E4%B8%AD%E6%95%88%E6%9E%9C"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">游戏中效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%95%88%E6%9E%9C"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">代码中效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D%E7%A2%B0%E6%92%9E%E4%BD%93-Collider2D"><span class="toc-number">1.9.</span> <span class="toc-text">2D碰撞体(Collider2D)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.9.1.</span> <span class="toc-text">场景视图中的显示设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE-3"><span class="toc-number">1.9.2.</span> <span class="toc-text">检查视图设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.10.</span> <span class="toc-text">使用缓动函数控制移动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E7%B1%BB%E8%B7%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.10.1.</span> <span class="toc-text">跨类跨文件的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">方法一：实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%9D%99%E6%80%81"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">方法二：静态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BC%93%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">自定义的缓动函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">1.11.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator%E7%BB%84%E4%BB%B6"><span class="toc-number">1.11.1.</span> <span class="toc-text">Animator组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation%E6%96%87%E4%BB%B6"><span class="toc-number">1.11.2.</span> <span class="toc-text">Animation文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%AA%97%E5%8F%A3%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">检查窗口基本设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E7%AA%97%E5%8F%A3%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%85%B3%E9%94%AE%E5%B8%A7"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">动画窗口基本设置和添加关键帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%AF%B9%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">添加事件和对事件的设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B8%A7%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.2.4.</span> <span class="toc-text">关键帧记录模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AnimatorController%E6%96%87%E4%BB%B6"><span class="toc-number">1.11.3.</span> <span class="toc-text">AnimatorController文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%99%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">动画器窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9C%A8%E6%A3%80%E6%9F%A5%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">状态在检查窗口中的显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E5%9C%A8%E6%A3%80%E6%9F%A5%E7%AA%97%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%98%BE%E7%A4%BA"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">转移在检查窗口中的显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC-2"><span class="toc-number">1.11.4.</span> <span class="toc-text">编写脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">修改参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E7%94%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">使用动画事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E7%9B%B8%E6%9C%BA"><span class="toc-number">1.12.</span> <span class="toc-text">自适应相机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E6%9C%BA%E8%B7%9F%E9%9A%8F"><span class="toc-number">1.12.1.</span> <span class="toc-text">相机跟随</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E6%9C%BA%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%8F%E5%B9%95%EF%BC%88%E7%AA%97%E5%8F%A3%EF%BC%89%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.12.2.</span> <span class="toc-text">相机自适应屏幕（窗口）大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF"><span class="toc-number">1.13.</span> <span class="toc-text">传递信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.1.</span> <span class="toc-text">传递信息函数之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E5%90%8C%E7%94%A8%E6%B3%95"><span class="toc-number">1.13.2.</span> <span class="toc-text">传递信息函数的相同用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.</span> <span class="toc-text">定时调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E4%B8%8E%E7%A6%81%E7%94%A8"><span class="toc-number">1.15.</span> <span class="toc-text">启用与禁用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8"><span class="toc-number">1.15.1.</span> <span class="toc-text">对象的启用和禁用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8"><span class="toc-number">1.15.2.</span> <span class="toc-text">组件的启用和禁用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">1.16.</span> <span class="toc-text">组件和对象的生成与销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.16.1.</span> <span class="toc-text">对象的生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0"><span class="toc-number">1.16.2.</span> <span class="toc-text">组件的添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">1.16.3.</span> <span class="toc-text">对象和组件的销毁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.17.</span> <span class="toc-text">查找对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GameObject-Find"><span class="toc-number">1.17.1.</span> <span class="toc-text">GameObject.Find</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform-Find"><span class="toc-number">1.17.2.</span> <span class="toc-text">Transform.Find</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="toc-number">1.18.</span> <span class="toc-text">父子关系的查询与管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E7%88%B6%E7%BA%A7%E7%9B%B8%E5%85%B3"><span class="toc-number">1.18.1.</span> <span class="toc-text">与父级相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%84%BF%E7%BA%A7%E7%9B%B8%E5%85%B3"><span class="toc-number">1.18.2.</span> <span class="toc-text">与儿级相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%97%8B%E8%BD%AC"><span class="toc-number">1.19.</span> <span class="toc-text">四元数与旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.19.1.</span> <span class="toc-text">四元数的简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.19.2.</span> <span class="toc-text">四元数的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%9B%9B%E5%85%83%E6%95%B0"><span class="toc-number">1.19.3.</span> <span class="toc-text">构建四元数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Physics2D"><span class="toc-number">1.20.</span> <span class="toc-text">Physics2D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E4%BD%93%E6%A3%80%E6%B5%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E4%BF%A1%E6%81%AF"><span class="toc-number">1.20.1.</span> <span class="toc-text">碰撞体检测的返回信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E4%BD%93%E6%A3%80%E6%B5%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.20.2.</span> <span class="toc-text">碰撞体检测的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.20.2.1.</span> <span class="toc-text">检测模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.20.2.2.</span> <span class="toc-text">检测模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%96%B9%E6%B3%95"><span class="toc-number">1.20.2.3.</span> <span class="toc-text">返回方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A2%B0%E6%92%9E%E4%BD%93%E6%A3%80%E6%B5%8B"><span class="toc-number">1.20.3.</span> <span class="toc-text">可视化碰撞体检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8C-%E4%BA%8B%E4%BB%B6%E8%A7%A3%E8%80%A6"><span class="toc-number">1.21.</span> <span class="toc-text">使用C#事件解耦</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%A6%E5%90%88%E5%92%8C%E8%A7%A3%E8%80%A6"><span class="toc-number">1.21.1.</span> <span class="toc-text">耦合和解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.21.2.</span> <span class="toc-text">C#事件的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-%E5%88%9B%E5%BB%BAC-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">前置-创建C#函数对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89C-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">定义C#事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80"><span class="toc-number">1.21.2.3.</span> <span class="toc-text">注册和注销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.2.4.</span> <span class="toc-text">创建调用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91"><span class="toc-number">1.21.2.5.</span> <span class="toc-text">整体逻辑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4"><span class="toc-number">1.22.</span> <span class="toc-text">时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.22.1.</span> <span class="toc-text">读取和设置循环执行的事件函数的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%BC%A9%E6%94%BE"><span class="toc-number">1.22.2.</span> <span class="toc-text">时间缩放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF"><span class="toc-number">1.23.</span> <span class="toc-text">加载场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SceneManager"><span class="toc-number">1.23.1.</span> <span class="toc-text">SceneManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadSceneMode"><span class="toc-number">1.23.2.</span> <span class="toc-text">LoadSceneMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncOperation"><span class="toc-number">1.23.3.</span> <span class="toc-text">AsyncOperation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UI"><span class="toc-number">1.24.</span> <span class="toc-text">UI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0UI"><span class="toc-number">1.24.1.</span> <span class="toc-text">添加UI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">1.24.2.</span> <span class="toc-text">基本类组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StandaloneInputModule"><span class="toc-number">1.24.2.1.</span> <span class="toc-text">StandaloneInputModule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Canvas"><span class="toc-number">1.24.2.2.</span> <span class="toc-text">Canvas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RectTransform"><span class="toc-number">1.24.2.3.</span> <span class="toc-text">RectTransform</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E3%80%81%E8%BD%B4%E5%BF%83%E5%92%8C%E9%94%9A%E7%82%B9"><span class="toc-number">1.24.2.3.1.</span> <span class="toc-text">中心、轴心和锚点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2%E5%8F%98%E6%8D%A2%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.24.2.3.2.</span> <span class="toc-text">矩形变换的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%9A%E7%82%B9%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.24.2.3.2.1.</span> <span class="toc-text">锚点的确定</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%A9%E6%94%BE%E5%89%8D%E5%8C%BA%E5%9F%9F%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.24.2.3.2.2.</span> <span class="toc-text">旋转缩放前区域的确定</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%B4%E5%BF%83%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.24.2.3.2.3.</span> <span class="toc-text">轴心的确定</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E6%97%8B%E8%BD%AC%E7%BC%A9%E6%94%BE"><span class="toc-number">1.24.2.3.2.4.</span> <span class="toc-text">对区域进行旋转缩放</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.24.2.3.3.</span> <span class="toc-text">检查视图中的设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E8%A7%89%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">1.24.3.</span> <span class="toc-text">视觉类组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Image"><span class="toc-number">1.24.3.1.</span> <span class="toc-text">Image</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mask"><span class="toc-number">1.24.3.2.</span> <span class="toc-text">Mask</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E5%8A%A8%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">1.24.4.</span> <span class="toc-text">互动类组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Button"><span class="toc-number">1.24.4.1.</span> <span class="toc-text">Button</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.24.4.1.1.</span> <span class="toc-text">按钮对象的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE-2"><span class="toc-number">1.24.4.1.2.</span> <span class="toc-text">检查视图中的设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E7%8A%B6%E6%80%81"><span class="toc-number">1.24.4.1.3.</span> <span class="toc-text">按钮状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%8E%BB%E9%99%A4%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0"><span class="toc-number">1.24.4.1.4.</span> <span class="toc-text">使用代码添加和去除监听函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Slider"><span class="toc-number">1.24.4.2.</span> <span class="toc-text">Slider</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E6%9D%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.24.4.2.1.</span> <span class="toc-text">滑动条对象的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE-3"><span class="toc-number">1.24.4.2.2.</span> <span class="toc-text">检查视图中的设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scrollbar"><span class="toc-number">1.24.4.3.</span> <span class="toc-text">Scrollbar</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.24.4.3.1.</span> <span class="toc-text">滚动条对象的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE-4"><span class="toc-number">1.24.4.3.2.</span> <span class="toc-text">检查视图中的设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScrollRect"><span class="toc-number">1.24.4.4.</span> <span class="toc-text">ScrollRect</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.24.4.4.1.</span> <span class="toc-text">滚动视图对象的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE-5"><span class="toc-number">1.24.4.4.2.</span> <span class="toc-text">检查视图中的设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80"><span class="toc-number">1.24.5.</span> <span class="toc-text">自适应布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%B1%8F%E5%B9%95%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE"><span class="toc-number">1.24.5.1.</span> <span class="toc-text">自适应屏幕的背景图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94UI%E7%BB%84"><span class="toc-number">1.24.5.2.</span> <span class="toc-text">自适应UI组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LayoutElement"><span class="toc-number">1.24.5.2.1.</span> <span class="toc-text">LayoutElement</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HorizontalLayoutGroup%E5%92%8CVerticalLayoutGroup"><span class="toc-number">1.24.5.2.2.</span> <span class="toc-text">HorizontalLayoutGroup和VerticalLayoutGroup</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GridLayoutGroup"><span class="toc-number">1.24.5.2.3.</span> <span class="toc-text">GridLayoutGroup</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.25.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.25.1.</span> <span class="toc-text">C#迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.25.1.1.</span> <span class="toc-text">迭代器的概念和基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.25.1.2.</span> <span class="toc-text">yield关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.25.2.</span> <span class="toc-text">Unity协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity%E8%87%AA%E5%B8%A6%E5%87%BD%E6%95%B0%E5%BC%80%E5%A7%8B%E5%92%8C%E5%81%9C%E6%AD%A2%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.25.2.1.</span> <span class="toc-text">Unity自带函数开始和停止协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%BB%E8%BE%91%E5%92%8Cyield%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.25.2.2.</span> <span class="toc-text">迭代器生成函数的逻辑和yield关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%88%B6%E4%BD%9C%E5%8A%A0%E8%BD%BD%E7%95%8C%E9%9D%A2"><span class="toc-number">1.25.2.3.</span> <span class="toc-text">使用协程制作加载界面</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number">1.26.</span> <span class="toc-text">本地保存数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%96%87%E4%BB%B6IO"><span class="toc-number">1.26.1.</span> <span class="toc-text">C#文件IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.26.2.</span> <span class="toc-text">设置保存文件的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%8F%92%E4%BB%B6"><span class="toc-number">1.26.3.</span> <span class="toc-text">序列化插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.26.4.</span> <span class="toc-text">本地保存数据的代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91"><span class="toc-number">1.27.</span> <span class="toc-text">音频</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AudioSource"><span class="toc-number">1.27.1.</span> <span class="toc-text">AudioSource</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E8%A7%86%E5%9B%BE%E8%AE%BE%E7%BD%AE-4"><span class="toc-number">1.27.1.1.</span> <span class="toc-text">检查视图设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-number">1.27.1.2.</span> <span class="toc-text">代码编写</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/28/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" title="2024年度总结"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" onerror="this.onerror=null;this.src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="2024年度总结"/></a><div class="content"><a class="title" href="/2024/12/28/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" title="2024年度总结">2024年度总结</a><time datetime="2024-12-28T09:10:00.000Z" title="发表于 2024-12-28 17:10:00">2024-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" title="2023年度总结"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/img/self/%E9%80%8F%E6%98%8E.png" onerror="this.onerror=null;this.src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="2023年度总结"/></a><div class="content"><a class="title" href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" title="2023年度总结">2023年度总结</a><time datetime="2023-12-31T11:00:00.000Z" title="发表于 2023-12-31 19:00:00">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/24/Unity2D%E5%85%A5%E9%97%A8/" title="Unity2D入门"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/2023/08/Unity2D%E5%85%A5%E9%97%A8/cover.png" onerror="this.onerror=null;this.src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="Unity2D入门"/></a><div class="content"><a class="title" href="/2023/08/24/Unity2D%E5%85%A5%E9%97%A8/" title="Unity2D入门">Unity2D入门</a><time datetime="2023-08-24T13:00:00.000Z" title="发表于 2023-08-24 21:00:00">2023-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/24/%E3%80%8A%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《高等数学》笔记"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/2022/06/%E3%80%8A%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/cover.jfif" onerror="this.onerror=null;this.src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="《高等数学》笔记"/></a><div class="content"><a class="title" href="/2022/06/24/%E3%80%8A%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《高等数学》笔记">《高等数学》笔记</a><time datetime="2022-06-24T12:50:00.000Z" title="发表于 2022-06-24 20:50:00">2022-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/13/%E6%9D%A8%E8%A1%A8/" title="杨表"><img src="https://figurebed-1306986731.file.myqcloud.com/blog/2022/05/%E6%9D%A8%E8%A1%A8/cover.png" onerror="this.onerror=null;this.src='https://figurebed-1306986731.file.myqcloud.com/blog/img/self/404.png'" alt="杨表"/></a><div class="content"><a class="title" href="/2022/05/13/%E6%9D%A8%E8%A1%A8/" title="杨表">杨表</a><time datetime="2022-05-13T13:43:00.000Z" title="发表于 2022-05-13 21:43:00">2022-05-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By rsdbk_husky</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'figurebed-7gmnyyjva99351aa',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'figurebed-7gmnyyjva99351aa',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>