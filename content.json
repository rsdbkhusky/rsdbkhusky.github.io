{"meta":{"title":"燃烧的冰块_husky's blog","subtitle":"using namespace determination","description":"using namespace determination","author":"rsdbk_husky","url":"http://rsdbkhusky.github.io","root":"/"},"pages":[{"title":"分类","date":"un55fin55","updated":"un55fin55","comments":true,"path":"categories/index.html","permalink":"http://rsdbkhusky.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"un55fin55","updated":"un55fin55","comments":true,"path":"link/index.html","permalink":"http://rsdbkhusky.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"un55fin55","updated":"un55fin55","comments":true,"path":"tags/index.html","permalink":"http://rsdbkhusky.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《托马斯微积分》摘要","slug":"《托马斯微积分》摘要","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2022/01/27/《托马斯微积分》摘要/","link":"","permalink":"http://rsdbkhusky.github.io/2022/01/27/%E3%80%8A%E6%89%98%E9%A9%AC%E6%96%AF%E5%BE%AE%E7%A7%AF%E5%88%86%E3%80%8B%E6%91%98%E8%A6%81/","excerpt":"","text":"本摘要包含《托马斯微积分》第 0~4 章，省略了一些难度较高的、OI 中应该不需要的小节。 预备知识 一对一函数 反函数 对数 三角函数 参数曲线，参数方程 极限和连续 普通极限 非正式定义 正式定义 性质 求值 单侧极限 定义 性质 与无穷有关的极限 定义 性质 求值 渐近线 &amp; 终极形态 定义 求值 连续 定义 判定 性质 斜率 &amp; 切线 变化率 &amp; 导数 导数 普通导数 定义 性质 求值 单侧导数 高阶导数 参数曲线的斜率 此处略过 P209 下半部分 ~ P226 上半部分。 导数的应用 求极值 定义 性质 求值 罗尔定理与中值定理 微分方程 求函数形状 定义 性质 此处略过 P280 下半部分 ~ P338。 积分 不定积分 定义 性质 求值 定积分 定义 性质 求值","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"STL大总结","slug":"STL大总结","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2022/01/18/STL大总结/","link":"","permalink":"http://rsdbkhusky.github.io/2022/01/18/STL%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"收下吧，这是我最后的 STL 了。 容器 序列式容器 包含：array、vector、deque、list。 .fill(val) .assgin(bgit, edit) / .assgin(cnt, val) .erase(...) 返回值：指向删掉的一个（段）元素的之后的位置的迭代器。 传参格式 .erase(it) .erase(bgit, edit) .insert(...) 新插入的值在 it 之前。 返回值：均返回第一个插入的元素的迭代器（即下标最小的）。 传参格式 .insert(it, val) .insert(it, cnt, val) .insert(it, bgit, edit) .insert(it, initlist) 示例： 1a.insert(begin(a) + 2, &#123;10, 11, 12, 13&#125;); .emplace(it, val) 不能完全替代 insert，只能插入一个元素。 返回插入的元素的迭代器。 .emplace_back(val) 可替代 push_back。 .emplace_front(val) 可替代 push_front。 .capacity() .resize(size) .shrink_to_fit() 所有可增大 size 的函数均可增大 capacity，但上述函数中只有 shrink_to_fit 可减小 capacity。 关联式容器 包含：map、multimap、set、multiset。 因为 map 系和 set 系的查询类的成员函数在传参上有很多相同的不同点，所以以下规定下文中 Btt（by the type）：如果讨论的是 map 系，则 “Btt” 为键值，如果讨论的是 set 系，则 “Btt” 为权值，btt 为类型与 Btt 相同的变量。 .find(btt) 返回首个 Btt 与 btt 相等的元素的迭代器。 .count(btt) 返回 Btt 与 btt 相等的元素的个数。 .lower_bound(btt) .upper_bound(btt) .equal_range(btt) 返回一个 pair 对象，其中包含两个迭代器，其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。 .erase(...) 返回值：对于传参为迭代器的，返回指向删掉的一个（段）元素的之后的位置的迭代器；对于传参基于 btt 的，返回删掉的元素个数。 传参格式 .erase(btt) 删掉 Btt 为 btt 的全部元素。 .erase(it) .erase(bgit, edit) .insert(...) 规定下文中 Btt：如果讨论的是 map 系，则 “Btt” 为键值权值二元组，如果讨论的是 set 系，则 “Btt” 为权值。 返回值（这里提到的返回值只适用于下面三种传参格式） 插入一个元素，非 multi 系返回 pair&lt;iterator, bool&gt;，multi 系返回 iterator 插入成功，iterator 为该元素迭代器，bool 为 true。 插入失败（set 和 map 中已有 Btt 与其相同的元素），iterator 回与他 Btt 相同的那个元素的迭代器，bool 为 false。 插入多个元素，返回 void。 传参格式 .insert(btt) .insert(it, beit, edit) .insert(it, initlist) .emplace(...) 返回值：同 insert。 传参格式 .emplace(btt) 注意这里如果写成这样会 CE。 12map&lt;int, int&gt; m;m.emplace(&#123;1, 2&#125;); 原因是编译器把 &#123;1, 2&#125; 当成初始化列表了，虽然你的意思是 &#123;1, 2&#125; 是个 pair 二元组。用 make_pair 就可以了。 .emplace(key, val)（对于 map 系） 相当于将创建新键值对所需的数据作为参数直接传入。 上文中 Btt 的概念解释的不是很清楚，我在这里再梳理一遍。对于 set 系而言，一个元素只由一个部分组成，就是他本身的权值，所以 Btt 就是权值。而对于 map 系而言，一个元素由两部分组成，键值和权值，查询、删除时，只需要键值就可以找到相应的元素，所以这时候 Btt 为键值；而插入时需要提供完整的信息，所以 Btt 为键值权值二元组。 无序关联式容器中 Btt 的定义方法与关联式容器的相同。 无序关联式容器 包含：unordered_map、unordered_multimap、unordered_set、unordered_multiset。 与无序式容器的不同点 内部存储的元素是无序的。 成员函数没有 lower_bound、upper_bound，但是有 equal_range。 unordered 系的操作不都是 O(1)O(1)O(1) 的，其通过指定键查找对应的值的操作平均时间复杂度为 O(1)O(1)O(1)，但对于插入操作，其复杂度相当于非 unordered 系，且常数大于非 unordered 系。 容器适配器 包含：stack、queue、priority_queue。 容器适配器需要依赖基础容器，而且对于基础容器有一些要求，对于每种适配器满足要求，可以作为其基础容器的容器是：（加粗的为默认使用的） stack：vector、deque、list。 queue：deque、list。 priority_queue：vector、deque。 算法函数 只列举我认为比较生僻但是在算法竞赛中能派上用场的。 stable_sort(bgit, edit) 稳定排序。 partial_sort(bgit, mdit, edit) 部分排序，参与排序的部分为 [bgit,edit)[\\mathrm{bgit}, \\mathrm{edit})[bgit,edit)，排好的部分为 [bgit,mdit)[\\mathrm{bgit}, \\mathrm{mdit})[bgit,mdit)。复杂度 O(nlog⁡m)O(n\\log m)O(nlogm)。 nth_element(bgit, mdit, egit) 寻找 kkk 小数，参与寻找的部分为 [bgit,edit)[\\mathrm{bgit}, \\mathrm{edit})[bgit,edit)，寻找到的 kkk 大值下标为 mdit\\mathrm{mdit}mdit（也就是 k=mdit−bgit+1k=\\mathrm{mdit}-\\mathrm{bgit}+1k=mdit−bgit+1），且满足所有左侧的数都比在大小关系中都比他靠左，右侧的数都比在大小关系中都比他靠右，复杂度 O(n)O(n)O(n)。 merge(bgit1, edit1, bgit2, edit2, it3) 将 [bgit1,edit1)[\\mathrm{bgit_1},\\mathrm{edit_1})[bgit1​,edit1​) 和 [bgit2,edit2)[\\mathrm{bgit_2},\\mathrm{edit_2})[bgit2​,edit2​) 做归并排序存入以 it3\\mathrm{it_3}it3​ 为开始的容器中。 inplace_merge(bgit, mdit, edit) 将 [bgit,mdit)[\\mathrm{bgit},\\mathrm{mdit})[bgit,mdit) 和 [mdit,edit)[\\mathrm{mdit},\\mathrm{edit})[mdit,edit) 做归并排序存入以 bgit\\mathrm{bgit}bgit 为开始的容器中。 find(bgit, edit, val) 返回第一个等于 val 的元素的迭代器，否则返回指向 edit 的迭代器。 find_if(bgit, edit, func) 返回第一个使 func == true 的元素迭代器，否则返回指向 edit 的迭代器。 find_if_not(bgit, edit, func) 与 find_if 正好相反。 equal_range(bgit, edit, val) 用法和效果和前面容器的成员函数一样。 swap_ranges(bgit1, edit1, bgit2) 交换 [bgit1,edit1)[\\mathrm{bgit_1},\\mathrm{edit_1})[bgit1​,edit1​) 和 [bgit2,bgit2+edit1−bgit1)[\\mathrm{bgit_2},\\mathrm{bgit_2}+\\mathrm{edit_1}-\\mathrm{bgit_1})[bgit2​,bgit2​+edit1​−bgit1​)。 next_permutation(bgit, edit) / prev_permutation(bgit, edit) 这俩函数应该没有人不认识，我就是想提一下他们的复杂度：O(n)O(n)O(n)。 参考文献 C 语言中文网 STL 教程 CppReference 亲手の实验","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"半平面交","slug":"半平面交","date":"un66fin66","updated":"un22fin22","comments":true,"path":"2022/01/15/半平面交/","link":"","permalink":"http://rsdbkhusky.github.io/2022/01/15/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/","excerpt":"","text":"本文缺少有力证明，且部分内容完全由个人添加，网上无法找到类似结论。可能存在错误。若读者发现错误可在评论区反馈 大型 Hack 现场 恕我直言，现在网上很多 OJ 的半平面交模板题数据都太水了，而且有一些特殊的性质（下文中有提及），导致一些有缺陷的代码能够 AC。 半平面交主流模板（数据水），推荐模板（相对强一些），难用的模板（数据据说强，但是 POJ 的功能和使用体验……）。 主要有 3 个需要注意的地方： 半平面交大小为 0。 半平面交大小为 ∞\\infty∞。 存在两条排完序后相邻的向量的极角差大于 π\\piπ。 对于主流模板而言，这三条都没有 hack，第一条没有 hack 是因为数据水，后两条因为模板本身具有特殊性质（给出了至少一个凸包）而不会出现。 情况 1，这种情况下如果有方向相反的向量且这两个向量的半平面无交集，那么在找交点时会出现呐呐呐 nan 或 -nan ，判一下 nan 或 -nan 即可，接下来有个我并不会证的结论：如果没有刚才那种情况，双端队列中最后会只有两个向量，不用特判，因为两个向量只会转化两个交点，面积就是 0。 情况 2 很好判，判一下做完半平面交后双端队列中相邻元素极角差是否有 ≥π\\ge\\pi≥π 的即可。 情况 3 的话比较复杂，也是一个我发现的 hack，目前我没有在网上找到题解提到过。hack 数据： 第一行一个整数 nnn 表示向量个数，接下来 nnn 行每行四个整数 x1,y1,x2,y2x_1,y_1,x_2,y_2x1​,y1​,x2​,y2​ 表示向量起点、终点横纵坐标。 123432 4 0 02 4 4 04 1 0 2 图示： 我目测遇到这种情况换一下 --ri 和 ++le 的顺序即可，但是没有严格证明（太菜了）。如果实在不行的话遇到这种情况 O(n)O(n)O(n) 处理一下也可以，因为显然只会遇到一次。 代码 代码中只有对于情况 1 的特判，没有 2、3 的。 12345678910111213141516171819202122232425262728293031struct Line &#123; Point a, b; double angle; inline bool operator&lt;(const Line sec) const &#123; if (!cmp(angle, sec.angle)) &#123; return area(a, b, sec.b) &lt; 0; &#125; return angle &lt; sec.angle; &#125;&#125; line[MAXn * MAXm + 10]; int cntline;int le = 1, ri, que[MAXn * MAXm + 10];signed main() &#123; // ... sort(line + 1, line + 1 + cntline); for (int i = 1; i &lt;= cntline; ++i) &#123; if (!cmp(line[i].angle, line[i - 1].angle)) continue; while (le &lt; ri &amp;&amp; area(line[i].a, line[i].b, str_int_str(line[que[ri - 1]].a, line[que[ri - 1]].b, line[que[ri]].a, line[que[ri]].b)) &lt;= 0) --ri; while (le &lt; ri &amp;&amp; area(line[i].a, line[i].b, str_int_str(line[que[le]].a, line[que[le]].b, line[que[le + 1]].a, line[que[le + 1]].b)) &lt;= 0) ++le; que[++ri] = i; &#125; while (le &lt; ri - 1 &amp;&amp; area(line[que[le]].a, line[que[le]].b, str_int_str(line[que[ri - 1]].a, line[que[ri - 1]].b, line[que[ri]].a, line[que[ri]].b)) &lt;= 0) --ri; while (le &lt; ri - 1 &amp;&amp; area(line[que[ri]].a, line[que[ri]].b, str_int_str(line[que[le]].a, line[que[le]].b, line[que[le + 1]].a, line[que[le + 1]].b)) &lt;= 0) ++le; // ... double ans = pol_area(point, cntpoint); if (isfinite(ans)) &#123; printf(&quot;%.3lf\\n&quot;, ans); &#125; else &#123; puts(&quot;0.000&quot;); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"小结论积累","slug":"小结论积累","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/12/16/小结论积累/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/16/%E5%B0%8F%E7%BB%93%E8%AE%BA%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"带约数 ∑\\sum∑ 变连续 ∑\\sum∑ 设d′=dn∑d∣n=∑d′=1d′&lt;∞\\begin{gather} \\text{设}d&#x27;=\\dfrac{d}{n}\\\\ \\sum\\limits_{d\\mid n}=\\sum\\limits_{d&#x27;=1}^{d&#x27;&lt;\\infty}\\\\ \\end{gather} 设d′=nd​d∣n∑​=d′=1∑d′&lt;∞​​​ 又一个求约数个数的公式 设d(n)为n约数个数d(nm)=∑d∣n∑g∣m[(d,g)=1]\\begin{gather} \\text{设}d(n)\\text{为}n\\text{约数个数}\\\\ d(nm)=\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid m}[(d,g)=1]\\\\ \\end{gather} 设d(n)为n约数个数d(nm)=d∣n∑​g∣m∑​[(d,g)=1]​​ 构造莫反 设f(n)=∑⋯[(i,j)=n]设F(n)=∑⋯[n∣i∧n∣j]则F(n)=∑n∣df(d)\\begin{gather} \\text{设}f(n)=\\sum\\limits_{\\cdots}[(i,j)=n]\\\\ \\text{设}F(n)=\\sum\\limits_{\\cdots}[n\\mid i\\land n\\mid j]\\\\ \\text{则}F(n)=\\sum\\limits_{n\\mid d}f(d) \\end{gather} 设f(n)=⋯∑​[(i,j)=n]设F(n)=⋯∑​[n∣i∧n∣j]则F(n)=n∣d∑​f(d)​​ 含约数的 ∑\\sum∑ 改变变量定义的顺序 ∑i=1i≤n∑d∣i=∑d=1d≤n∑d∣ii≤n\\begin{gather} \\sum\\limits_{i=1}^{i\\le n}\\sum\\limits_{d\\mid i}=\\sum\\limits_{d=1}^{d\\le n}\\sum\\limits_{d\\mid i}^{i\\le n}\\\\ \\end{gather} i=1∑i≤n​d∣i∑​=d=1∑d≤n​d∣i∑i≤n​​​ 含约数的 ∑\\sum∑ 改变变量定义的顺序2 ∑d∣n∑g∣nd=∑g∣n∑d∣ng\\begin{gather} \\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}=\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}} \\end{gather} d∣n∑​g∣dn​∑​=g∣n∑​d∣gn​∑​​​ ∑\\sum∑ 的基本运算 设 AAA 为任意算式，若 AAA 中不含 ∑1\\sum_1∑1​ 中定义的变量，则 ∑1A=A∑1\\sum_1 A=A\\sum_1∑1​A=A∑1​。 设 A,BA,BA,B 为任意算式，若 ∑2\\sum_2∑2​ 及 BBB 中不含 ∑1\\sum_1∑1​ 中定义的变量，则 ∑1A∑2B=(∑1A)(∑2B)\\sum_1 A\\sum_2 B=(\\sum_1 A)(\\sum_2 B)∑1​A∑2​B=(∑1​A)(∑2​B)。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"莫比乌斯函数 & 莫比乌斯反演","slug":"莫比乌斯函数 & 莫比乌斯反演","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/12/15/莫比乌斯函数 & 莫比乌斯反演/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/15/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%20&%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","excerpt":"","text":"一. 莫比乌斯函数 定义 设正整数 nnn，根据唯一分解定理分解为 p1c1p2c2⋯pkckp_1^{c_1}p_2^{c_2}\\cdots p_k^{c_k}p1c1​​p2c2​​⋯pkck​​。 莫比乌斯函数可定义为 μ(n)={0(∃i,ci&gt;1)(−1)k(else)\\mu(n)=\\begin{cases}0&amp;(\\exists i,c_i&gt;1)\\\\(-1)^k&amp;(else)\\end{cases}μ(n)={0(−1)k​(∃i,ci​&gt;1)(else)​ 性质 莫比乌斯函数是积性函数，分类讨论可证得。 因此我们可以用线性筛法筛莫比乌斯函数。 ∑d∣nμ(d)={1(n=1)0(n&gt;1)\\sum\\limits_{d\\mid n}\\mu(d)=\\begin{cases}1&amp;(n=1)\\\\0&amp;(n&gt;1)\\end{cases}d∣n∑​μ(d)={10​(n=1)(n&gt;1)​ 证明： n=1n=1n=1 时，显然成立。 n&gt;1n&gt;1n&gt;1 时： ∑d∣nμ(d)=∑i=0i≤c1∑j=0j≤c2⋯∑x=0x≤ckμ(p1ip2j⋯pkx)=∑i=0i≤1∑j=0j≤1⋯∑x=0x≤1μ(p1ip2j⋯pkx)=∑i=0i≤k(ki)(−1)i=(−1+1)k=0\\begin{gather} \\sum\\limits_{d\\mid n}\\mu(d)=\\sum\\limits_{i=0}^{i\\le c_1}\\sum\\limits_{j=0}^{j\\le c_2}\\cdots\\sum\\limits_{x=0}^{x\\le c_k}\\mu(p_1^ip_2^j\\cdots p_k^x)\\\\ =\\sum\\limits_{i=0}^{i\\le 1}\\sum\\limits_{j=0}^{j\\le 1}\\cdots\\sum\\limits_{x=0}^{x\\le 1}\\mu(p_1^ip_2^j\\cdots p_k^x)\\\\ =\\sum\\limits_{i=0}^{i\\le k}\\binom{k}{i}(-1)^i\\\\ =(-1+1)^k\\\\ =0\\\\ \\end{gather} d∣n∑​μ(d)=i=0∑i≤c1​​j=0∑j≤c2​​⋯x=0∑x≤ck​​μ(p1i​p2j​⋯pkx​)=i=0∑i≤1​j=0∑j≤1​⋯x=0∑x≤1​μ(p1i​p2j​⋯pkx​)=i=0∑i≤k​(ik​)(−1)i=(−1+1)k=0​​ 二. 莫比乌斯反演 第一定理 若 F(n)=∑d∣nf(d)F(n)=\\sum\\limits_{d\\mid n}f(d)F(n)=d∣n∑​f(d)，则 f(n)=∑d∣nμ(d)F(nd)f(n)=\\sum\\limits_{d\\mid n}\\mu(d)F(\\dfrac{n}{d})f(n)=d∣n∑​μ(d)F(dn​) 证明： 若证f(n)=∑d∣nμ(d)F(nd)即证f(n)=∑d∣nμ(d)∑g∣ndf(g)即证f(n)=∑d∣n∑g∣ndμ(d)f(g)\\begin{gather} \\text{若证}f(n)=\\sum\\limits_{d\\mid n}\\mu(d)F(\\dfrac{n}{d})\\\\ \\text{即证}f(n)=\\sum\\limits_{d\\mid n}\\mu(d)\\sum\\limits_{g\\mid \\frac{n}{d}}f(g)\\\\ \\text{即证}f(n)=\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}\\mu(d)f(g)\\\\ \\end{gather} 若证f(n)=d∣n∑​μ(d)F(dn​)即证f(n)=d∣n∑​μ(d)g∣dn​∑​f(g)即证f(n)=d∣n∑​g∣dn​∑​μ(d)f(g)​​ 我们在这里需要证明 ∑d∣n∑g∣nd=∑g∣n∑d∣ng\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}=\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}d∣n∑​g∣dn​∑​=g∣n∑​d∣gn​∑​。 什么情况下这两者等价呢？我们可以这样理解，每个 ∑\\sum∑，形如 ∑i=1i≤n\\sum\\limits_{i=1}^{i\\le n}i=1∑i≤n​ 的也好，形如 ∑d∣n\\sum\\limits_{d\\mid n}d∣n∑​ 的也罢，相当于是往后传递了若干次数，比如 ∑d∣6\\sum\\limits_{d\\mid 6}d∣6∑​ 往后传递的数的集合为 {1,2,3,6}\\{1,2,3,6\\}{1,2,3,6}。两个 ∑\\sum∑ 就相当于传递了若干次数对。那么，设 ∑d∣n∑g∣nd\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}d∣n∑​g∣dn​∑​ 向后传递的数对构成的集合为 S1S_1S1​，∑g∣n∑d∣ng\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}g∣n∑​d∣gn​∑​ 向后传递的数对构成的集合为 S2S_2S2​（其中数对的第一个位置表示 ddd，第二个位置表示 ggg）。如果我们能证明 S1=S2S_1=S_2S1​=S2​，我们就能证明 ∑d∣n∑g∣nd=∑g∣n∑d∣ng\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}=\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}d∣n∑​g∣dn​∑​=g∣n∑​d∣gn​∑​。 因为每次向后传递的是一个数对，所以我们可以用一个矩阵来表示 S1S_1S1​ 和 S2S_2S2​。 因为 ddd 严格单调，对于每个 ddd，ggg 也严格单调，所以 S1S_1S1​，S2S_2S2​ 中均没有重复元素。我们可以用一个 0/10/10/1 矩阵来表示 S1S_1S1​ 和 S2S_2S2​。 例如 n=6n=6n=6 时 ∑d∣n∑g∣nd\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}d∣n∑​g∣dn​∑​ 对应的 0/10/10/1 矩阵：（每一行代表一个 ddd 的值，每一列代表一个 ggg 的值，省略 000） [123456111112113114561]\\begin{bmatrix} &amp;1&amp;2&amp;3&amp;4&amp;5&amp;6\\\\ 1&amp;1&amp;1&amp;1&amp; &amp; &amp;1\\\\ 2&amp;1&amp; &amp;1&amp; &amp; &amp; \\\\ 3&amp;1&amp;1&amp; &amp; &amp; &amp; \\\\ 4&amp; &amp; &amp; &amp; &amp; &amp; \\\\ 5&amp; &amp; &amp; &amp; &amp; &amp; \\\\ 6&amp;1&amp; &amp; &amp; &amp; &amp; \\\\ \\end{bmatrix} ⎣⎡​123456​11111​211​311​4​5​61​⎦⎤​ 根据这个例子，我们大概能猜出结论，这个矩阵一定是沿对角线对称的，我们来证明： 若a[i][j]=1 ⟺ j∣ni ⟺ i∣nj ⟺ a[j][i]=1若a[i][j]=0 ⟺ j∤ni ⟺ i∤nj ⟺ a[j][i]=0\\begin{gather} \\text{若}a[i][j]=1\\\\ \\iff j\\mid \\dfrac{n}{i}\\\\ \\iff i\\mid \\dfrac{n}{j}\\\\ \\iff a[j][i]=1\\\\ \\text{若}a[i][j]=0\\\\ \\iff j\\nmid \\dfrac{n}{i}\\\\ \\iff i\\nmid \\dfrac{n}{j}\\\\ \\iff a[j][i]=0\\\\ \\end{gather} 若a[i][j]=1⟺j∣in​⟺i∣jn​⟺a[j][i]=1若a[i][j]=0⟺j∤in​⟺i∤jn​⟺a[j][i]=0​​ 由此证得该矩阵沿对角线对称，由于这条性质，当 ∑d∣n∑g∣nd\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}d∣n∑​g∣dn​∑​ 中 ddd 与 ggg 更换位置变成 ∑g∣n∑d∣ng\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}g∣n∑​d∣gn​∑​ 后，表示成的矩阵不变（注意虽然公式中 d,gd,gd,g 交换位置，但矩阵每一行仍代表一个 ddd 的值，每一列仍代表一个 ggg 的值。用向后传数对的方式理解，数对的第一个位置仍表示 ddd，第二个位置仍表示 ggg）。故 S1=S2S_1=S_2S1​=S2​，证得 ∑d∣n∑g∣nd=∑g∣n∑d∣ng\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}=\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}d∣n∑​g∣dn​∑​=g∣n∑​d∣gn​∑​。 接着主线证明： 即证f(n)=∑g∣n∑d∣ngμ(d)f(g)即证f(n)=∑g∣nf(g)∑d∣ngμ(d)\\begin{gather} \\text{即证}f(n)=\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}\\mu(d)f(g)\\\\ \\text{即证}f(n)=\\sum\\limits_{g\\mid n}f(g)\\sum\\limits_{d\\mid \\frac{n}{g}}\\mu(d)\\\\ \\end{gather} 即证f(n)=g∣n∑​d∣gn​∑​μ(d)f(g)即证f(n)=g∣n∑​f(g)d∣gn​∑​μ(d)​​ 根据莫比乌斯函数的性质，发现右部的很多项都乘有 000，消去乘有 000 的项可得： 即证f(n)=f(n)\\begin{gather} \\text{即证}f(n)=f(n) \\end{gather} 即证f(n)=f(n)​​ 显然成立，证毕。 本证明过程由个人独自完成，且引入了数对和矩阵辅助证明，所以难免有些啰嗦，读者可以思考简化证明过程。 第二定理 若 F(n)=∑n∣df(d)F(n)=\\sum\\limits_{n\\mid d}f(d)F(n)=n∣d∑​f(d)，则 f(n)=∑n∣dμ(dn)F(d)f(n)=\\sum\\limits_{n\\mid d}\\mu(\\dfrac{d}{n})F(d)f(n)=n∣d∑​μ(nd​)F(d) 证明： 前面和第一定理推导过程相同，一直到这一步： 即证f(n)=∑n∣d∑d∣gμ(dn)f(g)\\begin{gather} \\text{即证}f(n)=\\sum\\limits_{n\\mid d}\\sum\\limits_{d\\mid g}\\mu(\\dfrac{d}{n})f(g)\\\\ \\end{gather} 即证f(n)=n∣d∑​d∣g∑​μ(nd​)f(g)​​ 这里开始和第一公式的推导不一样了。设 d′=dnd&#x27;=\\dfrac{d}{n}d′=nd​，则 d=d′nd=d&#x27;nd=d′n，带入得： 即证f(n)=∑n∣g∑d′∣gnμ(d′)f(g)\\begin{gather} \\text{即证}f(n)=\\sum\\limits_{n\\mid g}\\sum\\limits_{d&#x27;\\mid \\frac{g}{n}}\\mu(d&#x27;)f(g)\\\\ \\end{gather} 即证f(n)=n∣g∑​d′∣ng​∑​μ(d′)f(g)​​ 解释：n∣d∣gn\\mid d\\mid gn∣d∣g 所以 ggg 一定能去遍 nnn 的所有倍数，d′d&#x27;d′ 是 dn\\dfrac{d}{n}nd​，所以一定有 d′∣gnd&#x27;\\mid \\dfrac{g}{n}d′∣ng​。 有人可能会问，这个怎么无法用证第一定理时那样用数对和矩阵的方式证明呢，因为确实 ∑n∣d∑d∣g≠∑n∣g∑d∣g\\sum\\limits_{n\\mid d}\\sum\\limits_{d\\mid g}\\neq\\sum\\limits_{n\\mid g}\\sum\\limits_{d\\mid g}n∣d∑​d∣g∑​=n∣g∑​d∣g∑​，但是这里这两个 ∑\\sum∑ 号后面并不会用到 ddd 的值，只会用到 d′d&#x27;d′，所以只需要保证 d′d&#x27;d′ 不变就行了。 对应到矩阵上来说，以 n=2n=2n=2 举例，∑n∣d∑d∣g\\sum\\limits_{n\\mid d}\\sum\\limits_{d\\mid g}n∣d∑​d∣g∑​ 对应的矩阵： [12345612111341561]\\begin{bmatrix} &amp;1&amp;2&amp;3&amp;4&amp;5&amp;6\\\\ 1&amp; &amp; &amp; &amp; &amp; &amp; \\\\ 2&amp; &amp;1&amp; &amp;1&amp; &amp;1\\\\ 3&amp; &amp; &amp; &amp; &amp; &amp; \\\\ 4&amp; &amp; &amp; &amp;1&amp; &amp; \\\\ 5&amp; &amp; &amp; &amp; &amp; &amp; \\\\ 6&amp; &amp; &amp; &amp; &amp; &amp;1\\\\ \\end{bmatrix} ⎣⎡​123456​1​21​3​411​5​611​⎦⎤​ ∑n∣g∑d∣g\\sum\\limits_{n\\mid g}\\sum\\limits_{d\\mid g}n∣g∑​d∣g∑​： [123456111121113141561]\\begin{bmatrix} &amp;1&amp;2&amp;3&amp;4&amp;5&amp;6\\\\ 1&amp; &amp;{\\color{red}1}&amp; &amp;{\\color{red}1}&amp; &amp;{\\color{red}1}\\\\ 2&amp; &amp;1&amp; &amp;1&amp; &amp;1\\\\ 3&amp; &amp; &amp; &amp; &amp; &amp;{\\color{red}1}\\\\ 4&amp; &amp; &amp; &amp;1&amp; &amp; \\\\ 5&amp; &amp; &amp; &amp; &amp; &amp; \\\\ 6&amp; &amp; &amp; &amp; &amp; &amp;1\\\\ \\end{bmatrix} ⎣⎡​123456​1​211​3​4111​5​61111​⎦⎤​ 可以看到两者中有不同之处的行所对应的 d′∉Zd&#x27;\\notin\\mathbb{Z}d′∈/Z（12\\dfrac{1}{2}21​ 和 32\\dfrac{3}{2}23​）。 继续证明： 即证f(n)=∑n∣g∑d′∣gnμ(d′)f(g)\\begin{gather} \\text{即证}f(n)=\\sum\\limits_{n\\mid g}\\sum\\limits_{d&#x27;\\mid \\frac{g}{n}}\\mu(d&#x27;)f(g)\\\\ \\end{gather} 即证f(n)=n∣g∑​d′∣ng​∑​μ(d′)f(g)​​ 接下来就和第一定理的过程完全一样了。 应用 如果有两个函数 f(n)f(n)f(n) 和 F(n)F(n)F(n)，F(n)F(n)F(n) 好求，f(n)f(n)f(n) 不好求，而两者间又有 F(n)=∑d∣nf(d)F(n)=\\sum\\limits_{d\\mid n}f(d)F(n)=d∣n∑​f(d) 或者 F(n)=∑n∣df(d)F(n)=\\sum\\limits_{n\\mid d}f(d)F(n)=n∣d∑​f(d) 的关系，可以使用莫反。 小技巧：遇到 ∑d∣n\\sum\\limits_{d\\mid n}d∣n∑​ 的时候，可以设 d′=dnd&#x27;=\\dfrac{d}{n}d′=nd​，则 d=d′nd=d&#x27;nd=d′n，代入可得转化为 ∑d′=1d′&lt;∞\\sum\\limits_{d&#x27;=1}^{d&#x27;&lt;\\infty}d′=1∑d′&lt;∞​，这样变量就是连续的了。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"整除分块","slug":"整除分块","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2021/12/14/整除分块/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/14/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/","excerpt":"","text":"一. 核心定理 整除分块，又称数论分块，其核心是一个定理。 定理：设 diff⁡\\operatorname{diff}diff 函数为求不同数值的个数，如 diff⁡{1,1,3,4,6,6,6}=4\\operatorname{diff}\\{1,1,3,4,6,6,6\\}=4diff{1,1,3,4,6,6,6}=4，则 diff⁡i=1i≤n⌊ni⌋\\mathop{\\operatorname{diff}}\\limits_{i=1}^{i\\le n}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloori=1diffi≤n​⌊in​⌋ 最大不超过 2n2\\sqrt{n}2n​。 证明： 考虑 i∈[1,n]i\\in[1,\\sqrt{n}]i∈[1,n​]，最多 n\\sqrt{n}n​ 个。所以 diff⁡i=1i≤n⌊ni⌋\\mathop{\\operatorname{diff}}\\limits_{i=1}^{i\\le\\sqrt{n}}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloori=1diffi≤n​​⌊in​⌋ 最大不超过 n\\sqrt{n}n​。 考虑 i∈(n,n]i\\in(\\sqrt{n},n]i∈(n​,n]，⌊ni⌋\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor⌊in​⌋ 的值单调不增。⌊n⌈n⌉⌋\\left\\lfloor\\dfrac{n}{\\left\\lceil\\sqrt{n}\\right\\rceil}\\right\\rfloor⌊⌈n​⌉n​⌋ 的值最大为 n\\sqrt{n}n​，⌊nn⌋\\left\\lfloor\\dfrac{n}{n}\\right\\rfloor⌊nn​⌋ 为 111。所以 diff⁡i=⌈n⌉i≤n⌊ni⌋\\mathop{\\operatorname{diff}}\\limits_{i=\\left\\lceil\\sqrt{n}\\right\\rceil}^{i\\le n}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloori=⌈n​⌉diffi≤n​⌊in​⌋ 最大不超过 n\\sqrt{n}n​。 证毕。 二. 确定分界点 上一个标题中，我们认识到整除分块复杂度的正确性。这一个标题将会讲解如何确定块与块之间的分界点。 设 gn(x)g_n(x)gn​(x) 为大于等于 xxx 且被 nnn 整除的值与 xxx 被 nnn 整除的值相同的最大整数。可用公式表示为： ⌊nx⌋=⌊ngn(x)⌋,⌊nx⌋&gt;⌊ngn(x)+1⌋\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor=\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor,\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor&gt;\\left\\lfloor\\dfrac{n}{g_n(x)+1}\\right\\rfloor ⌊xn​⌋=⌊gn​(x)n​⌋,⌊xn​⌋&gt;⌊gn​(x)+1n​⌋ 定理：gn(x)=⌊n⌊nx⌋⌋g_n(x)=\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloorgn​(x)=⌊⌊xn​⌋n​⌋ 证明：只要证明了上面“可用公式表示为”的两个式子成立，即可完成证明。 证明第一个式子 首先引入三个显然的东西： ⌊n⌋≤n\\left\\lfloor n\\right\\rfloor\\le n⌊n⌋≤n。 如果 n≤mn\\le mn≤m，那么 ⌊n⌋≤⌊m⌋\\left\\lfloor n\\right\\rfloor\\le \\left\\lfloor m\\right\\rfloor⌊n⌋≤⌊m⌋。 如果 n∈Zn\\in \\mathbb{Z}n∈Z，那么 ⌊n⌋=n\\left\\lfloor n\\right\\rfloor=n⌊n⌋=n。 开始证明： 证明 x≤⌊n⌊nx⌋⌋x\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloorx≤⌊⌊xn​⌋n​⌋ nx≥⌊nx⌋又∵nx,⌊nx⌋≠0⟹nnx≤n⌊nx⌋⟹⌊nnx⌋≤⌊n⌊nx⌋⌋⟹⌊x⌋≤⌊n⌊nx⌋⌋⟹x≤⌊n⌊nx⌋⌋\\begin{gather} \\dfrac{n}{x}\\ge\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\\\ \\text{又}\\because\\dfrac{n}{x},\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\ne0\\\\ \\Longrightarrow\\dfrac{n}{\\frac{n}{x}}\\le\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\\\ \\Longrightarrow\\left\\lfloor\\dfrac{n}{\\frac{n}{x}}\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor\\\\ \\Longrightarrow\\left\\lfloor x\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor\\\\ \\Longrightarrow x\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor\\\\ \\end{gather} xn​≥⌊xn​⌋又∵xn​,⌊xn​⌋=0⟹xn​n​≤⌊xn​⌋n​⟹⌊xn​n​⌋≤⌊⌊xn​⌋n​⌋⟹⌊x⌋≤⌊⌊xn​⌋n​⌋⟹x≤⌊⌊xn​⌋n​⌋​​ 这条结论在接下来的证明中一直会用到。 这一步相当于是证明了 x≤gn(x)x\\le g_n(x)x≤gn​(x)。 证明 ⌊nx⌋≥⌊ngn(x)⌋\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\ge\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor⌊xn​⌋≥⌊gn​(x)n​⌋ x≤gn(x)又∵x,gn(x)≠0⟹nx≥ngn(x)⟹⌊nx⌋≥⌊ngn(x)⌋\\begin{gather} x\\le g_n(x)\\\\ \\text{又}\\because x,g_n(x)\\ne0\\\\ \\Longrightarrow\\dfrac{n}{x}\\ge\\dfrac{n}{g_n(x)}\\\\ \\Longrightarrow\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\ge\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor\\\\ \\end{gather} x≤gn​(x)又∵x,gn​(x)=0⟹xn​≥gn​(x)n​⟹⌊xn​⌋≥⌊gn​(x)n​⌋​​ 证明 ⌊nx⌋≤⌊ngn(x)⌋\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor⌊xn​⌋≤⌊gn​(x)n​⌋ 即证⌊nx⌋≤⌊n⌊n⌊nx⌋⌋⌋设x′=⌊nx⌋即证x′≤⌊n⌊n⌊x′⌋⌋⌋,该式已被证明\\begin{gather} \\text{即证}\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{\\left\\lfloor \\frac{n}{x}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor\\\\ \\text{设}x&#x27;=\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\\\ \\text{即证}x&#x27;\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{\\left\\lfloor x&#x27;\\right\\rfloor}\\right\\rfloor}\\right\\rfloor,\\text{该式已被证明}\\\\ \\end{gather} 即证⌊xn​⌋≤⎣⎢​⌊⌊xn​⌋n​⌋n​⎦⎥​设x′=⌊xn​⌋即证x′≤⎣⎢​⌊⌊x′⌋n​⌋n​⎦⎥​,该式已被证明​​ 综上所述，⌊nx⌋=⌊ngn(x)⌋\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor=\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor⌊xn​⌋=⌊gn​(x)n​⌋ 证明第二个式子 我们先设一下带余除法，带余除法是数论证明的常用手段，它能有效地消掉下去整号。 设 n=kx+b (0≤b&lt;x)n=kx+b~(0\\le b&lt;x)n=kx+b (0≤b&lt;x)，则 ⌊nx⌋=k\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor=k⌊xn​⌋=k。 设 n=pk+q (0≤q&lt;k)n=pk+q~(0\\le q&lt;k)n=pk+q (0≤q&lt;k)，则 ⌊nk⌋=p\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor=p⌊kn​⌋=p。 若证⌊nx⌋&gt;⌊ngn(x)+1⌋即证⌊nx⌋&gt;⌊n⌊n⌊nx⌋⌋+1⌋即证k&gt;⌊n⌊nk⌋+1⌋即证k&gt;⌊np+1⌋\\begin{gather} \\text{若证}\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor&gt;\\left\\lfloor\\dfrac{n}{g_n(x)+1}\\right\\rfloor\\\\ \\text{即证}\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor&gt;\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{\\left\\lfloor \\frac{n}{x}\\right\\rfloor}\\right\\rfloor+1}\\right\\rfloor\\\\ \\text{即证}k&gt;\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{k}\\right\\rfloor+1}\\right\\rfloor\\\\ \\text{即证}k&gt;\\left\\lfloor\\dfrac{n}{p+1}\\right\\rfloor\\\\ \\end{gather} 若证⌊xn​⌋&gt;⌊gn​(x)+1n​⌋即证⌊xn​⌋&gt;⎣⎢​⌊⌊xn​⌋n​⌋+1n​⎦⎥​即证k&gt;⌊⌊kn​⌋+1n​⌋即证k&gt;⌊p+1n​⌋​​ 这里需要先证一个小结论：若 a,b,c∈Z,a&gt;⌊bc⌋a,b,c\\in\\mathbb{Z},a&gt;\\left\\lfloor\\dfrac{b}{c}\\right\\rfloora,b,c∈Z,a&gt;⌊cb​⌋，则 ac&gt;bac&gt;bac&gt;b。 ∵a∈Z,a&gt;⌊bc⌋∴a&gt;bc∴ac&gt;b\\begin{gather} \\because a\\in\\mathbb{Z},a&gt;\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\\\ \\therefore a&gt;\\dfrac{b}{c}\\\\ \\therefore ac&gt;b\\\\ \\end{gather} ∵a∈Z,a&gt;⌊cb​⌋∴a&gt;cb​∴ac&gt;b​​ 接着主线的证明： 即证k(p+1)&gt;n即证n&lt;pk+k又∵n=pk+q,q&lt;k.该式成立\\begin{gather} \\text{即证}k(p+1)&gt;n\\\\ \\text{即证}n&lt;pk+k\\\\ \\text{又}\\because n=pk+q,q&lt;k.\\text{该式成立} \\end{gather} 即证k(p+1)&gt;n即证n&lt;pk+k又∵n=pk+q,q&lt;k.该式成立​​ 综上所述，gn(x)=⌊n⌊nx⌋⌋g_n(x)=\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloorgn​(x)=⌊⌊xn​⌋n​⌋。 三. 应用 主要用于解决求类似 ∑i=1i≤n⌊ni⌋\\sum\\limits_{i=1}^{i\\le n}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloori=1∑i≤n​⌊in​⌋ 的式子，如果直接暴力求时间复杂度是 O(n)O(n)O(n) 的，使用整除分块可以降到 O(n)O(\\sqrt{n})O(n​)。 求 ∑i=1i≤n⌊ni⌋\\sum\\limits_{i=1}^{i\\le n}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloori=1∑i≤n​⌊in​⌋ 的代码示例： 12345for (int l = 1, r = 1; ; r = (n / (n / l))) &#123; ans += (n / l) * (min(r, n) - l + 1); l = r + 1; if (l &gt; n) break;&#125; 注意 l &gt; n 后运行这个语句会出现除零错，所以要在每个循环体的末尾判 break 而非 for 的第二个位置。 例题： [CQOI2007]余数求和 [POI2007]ZAP-Queries","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"VisualStudio常用设置","slug":"VisualStudio常用设置","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/12/12/VisualStudio常用设置/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/12/VisualStudio%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"文章中的的设置纯属个性化设置，依据自身喜好而定。 “选项”菜单 从“顶部栏/调试/选项”即可打开“选项”菜单，也有其他打开“选项”菜单的方法。 接下来的 6 条操作都是在“选项”菜单中完成的。 主题：（“环境/视觉体验/颜色主题/”） 深色 字体：（“环境/字体与颜色/”） consolas 粗体 键盘：（“环境/键盘/ -&gt; 搜索‘编辑.切换行注释’”） 快捷键设为&quot;ctrl+/&quot; 代码格式设置：（“文本编辑器/「你要设置的语言」/代码样式/格式设置/”） 看着改改（根据个人口味） 如果是大括号不换行的选手，发现编辑代码的时候大括号自动换行，检查一下这里是不是勾选“在}后自动格式化程序块”了，如果是的话取消勾选。 底部状态栏：（“环境/常规/显示状态栏/”） 取消勾选 引用和作者更改项：（“文本编辑器/所有语言/CodeLens/启用CodeLens/”） 取消勾选 “属性”菜单 此条面向 c++ 选手。 在编译 c++ 代码时，如果你的代码中有 scanf 等编译器认为不安全的函数，可能无法成功编译。如果你想使用这些函数，你需要看一看这一条。 从“顶部栏/调试/调试属性”即可打开“属性”菜单，或从“顶部栏/项目/属性”打开。 打开“属性”菜单后，进入“配置属性/C、C++/预处理器/预处理器定义/编辑/”，加入“_CRT_SECURE_NO_WARNINGS”即可。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"软件","slug":"软件","permalink":"http://rsdbkhusky.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Gdb中输出格式优化","slug":"Gdb中print的各种参数对效果的影响","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/12/12/Gdb中print的各种参数对效果的影响/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/12/Gdb%E4%B8%ADprint%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E5%AF%B9%E6%95%88%E6%9E%9C%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"gdb 打开 / 关闭输出格式优化的命令 1set p [options] on/off 常用的 options 参数 array array-index pretty 在输出不同种类变量时各种格式优化参数的效果 array array-indexes pretty 关联式容器：set，map…… −-− −-− √\\surd√ 序列式容器：vector…… √\\surd√ √\\surd√ −-− 容器适配器：stack，priority_queue…… √\\surd√ √\\surd√ −-− 普通数组 √\\surd√ √\\surd√ −-− 结构体数组 √\\surd√ √\\surd√ ×\\times× √\\surd√：添加会提升效果。 ×\\times×：添加会降低效果。 −-−：添不添加对效果不影响。 （这里的效果纯属个人观点） 图片示例：","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"双指针优化dp & Luogu P1973 [NOI2011] NOI 嘉年华","slug":"双指针优化dp & Luogu P1973 [NOI2011] NOI 嘉年华","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/10/13/双指针优化dp & Luogu P1973 [NOI2011] NOI 嘉年华/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/13/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P1973%20[NOI2011]%20NOI%20%E5%98%89%E5%B9%B4%E5%8D%8E/","excerpt":"","text":"题目传送门 一. 思路 首先进行离散化，将所有区间左右端点离散化，离散成 mmm 个“离散点”，只有这些地方才可能设置为断点，不然一定是不优的。 首先考虑朴素 DP，设 secl,rsec_{l,r}secl,r​ 为完全被包含在离散点 l∼rl\\sim rl∼r 内的区间总数，直接 O(n3)O(n^3)O(n3) 暴力求就好了。 prei,jpre_{i,j}prei,j​：离散点 1∼i1\\sim i1∼i 内包含的区间，一个组分到 jjj 个区间时，另一组能分到的最大值。我们的方程应该写成这样： prei,j=max⁡k=1k&lt;i{prek,j+seck,i,prek,j−seck,i}pre_{i,j}=\\max\\limits_{k=1}^{k&lt;i}\\{pre_{k,j}+sec_{k,i},pre_{k,j-sec_{k,i}}\\} prei,j​=k=1maxk&lt;i​{prek,j​+seck,i​,prek,j−seck,i​​} 然后没有限制条件下的答案就是 max⁡j=1n{min⁡(prem,j,j)}\\max\\limits_{j=1}^n\\{\\min(pre_{m,j},j)\\}j=1maxn​{min(prem,j​,j)} sufi,jsuf_{i,j}sufi,j​：离散点 i∼mi\\sim mi∼m 内包含的区间，一个组分到 jjj 个区间时，另一组能分到的最大值，与 preprepre 相似。 di,jd_{i,j}di,j​：限制为离散点 i∼ji\\sim ji∼j 间不能有断点的情况下分到的区间较少的组别中区间数量的最大值，有状转方程： dl,r=max⁡x=1mmax⁡y=1m{min⁡(x+secl,r+y,prel,x+sufr,y)}d_{l,r}=\\max_{x=1}^{m}\\max_{y=1}^{m}\\left\\{\\min\\left(x+sec_{l,r}+y,pre_{l, x}+suf_{r, y}\\right)\\right\\} dl,r​=x=1maxm​y=1maxm​{min(x+secl,r​+y,prel,x​+sufr,y​)} 要求编号为 iii 的区间（左端点为 leile_ilei​，右端点 riiri_irii​）不能被舍弃下的答案是： ansi=max⁡l=1leimax⁡r=riim{dl,r}ans_{i}=\\max _{l=1}^{le_{i}} \\max _{r=ri_{i}}^{m}\\left\\{d_{l, r}\\right\\} ansi​=l=1maxlei​​r=rii​maxm​{dl,r​} 可以看到，整个解题过程的瓶颈就是 2D⁡/2D⁡2\\operatorname{D}/2\\operatorname{D}2D/2D 的求 di,jd_{i,j}di,j​ 的过程，我们无法承受 O(n4)O(n^4)O(n4) 的复杂度，要考虑优化，我们发现对于固定的 l,rl,rl,r，固定一个 xxx 后，有一个 yyy 使 min⁡(x+secl,r+y,prel,x+sufr,y)\\min\\left(x+sec_{l,r}+y,pre_{l,x}+suf_{r,y}\\right)min(x+secl,r​+y,prel,x​+sufr,y​) 最大，设这个值为 yx′y&#x27;_xyx′​ ，根据 preipre_iprei​ 的性质，jjj 不变时，prei,jpre_{i,j}prei,j​ 随着 jjj 增大而减小。 假设我们已求出了 yx′y&#x27;_{x}yx′​，现在考虑 yx+a′y&#x27;_{x+a}yx+a′​（aaa 为正整数），x+ax+ax+a 相对于 xxx，yyy 不变，x+secl,r+yx+sec_{l,r}+yx+secl,r​+y 的值增加，prel,x+sufr,ypre_{l,x}+suf_{r,y}prel,x​+sufr,y​ 的值减小。yx′+by&#x27;_x+byx′​+b （bbb 为正整数）相对于 yx′y&#x27;_xyx′​，xxx 不变，x+secl,r+yx+sec_{l,r}+yx+secl,r​+y 的值增加，prel,x+sufr,ypre_{l,x}+suf_{r,y}prel,x​+sufr,y​ 的值减小。 所以得出结论，yx+a′≤yx′y&#x27;_{x+a}\\le y&#x27;_xyx+a′​≤yx′​，因为 &gt;yx′&gt;y&#x27;_x&gt;yx′​ 的决策，对 xxx 是不优的，那么对于 x+ax+ax+a 就更不优了。 设 gl,r,x(y)=min⁡(x+secl,r+y,prel,x+sufr,y)g_{l,r,x}(y)=\\min\\left(x+sec_{l,r}+y,pre_{l,x}+suf_{r,y}\\right)gl,r,x​(y)=min(x+secl,r​+y,prel,x​+sufr,y​)（在接下来的推导中都将 lll 和 rrr 当作常量，所以简写为 gx(y)g_x(y)gx​(y)），仔细想想可以发现，该函数有一个极值，即 x+secl,r+y=prel,x+sufr,yx+sec_{l,r}+y=pre_{l,x}+suf_{r,y}x+secl,r​+y=prel,x​+sufr,y​ 时，当然因为取值都是整数他们有可能没有相等的时刻，这里指的是连成平滑曲线后的函数。并且函数 gx(y)g_x(y)gx​(y) 极点的一侧单调。 请注意现在的一个函数对应的是一个状态，横坐标对应的是决策。 于是我们尝试画出这个图象，刚才我们已经证出两条性质： opopop（最优决策）具有单调性。 gi(j)g_i(j)gi​(j) 极点的一侧具有单调性。 （图像仅供参考，不代表实际上就长这样，该图象只显示出了对解题有用的特征） opopop（最优决策）具有单调性。 gi(j)g_i(j)gi​(j) 极点的一侧具有单调性。 根据这两条性质，可以直接用一个指针从右往左扫，向上“爬坡”，到顶点后就记录这个值，并转到下一条函数： 转移的代码实现： 12345678910for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = i + 1; j &lt;= cntmap; ++j) &#123; int y = n; for (int x = 0; x &lt;= n; ++x) &#123; while (y &amp;&amp; min(x+sec[i][j]+y,pre[i][x]+suf[j][y])&lt;=min(x+sec[i][j]+y-1,pre[i][x]+suf[j][y-1])) --y; d[i][j] = max(d[i][j], min(x + sec[i][j] + y, pre[i][x] + suf[j][y])); &#125; ans = max(ans, d[i][j]); &#125;&#125; 二. 细节 很重要，也很致命。 向上“爬坡”时，我们需要比较指针当前位置和指针下一个位置作为决策哪一个更优，有人会用 &lt;=，有人会用 &lt;，如果你用 &lt;，你会获得 0{\\color{Red}0}0 分的好成绩。问题在哪呢？如果有一个这样的函数： 我们的代码实现和理论是有一定区别的，通常会自动忽略一些不可能是最优的决策，以本体为例，比如有这样的一个“区间”，里面刚好包含两个重合的区间（还记得加和不加引号的“区间”分别代表什么吗？）： 我们当然不会舍弃这两个区间其中任意一个，因为完全可以不舍弃。但确实有一种选择是舍弃其中一个，虽然这样不优，但我们在代码中做的是将所选“区间”中区间的数量作为权值 secsecsec，计算的时候加上 secsecsec，就相当于忽略了舍弃一个区间这种情况，这就导致我在输出数组 sufsufsuf 中的值时，看到了这样的一幕： 可以看到，sufsufsuf 函数不是单调的了，这是因为我的输入数据有两个区间是重合的，我们在计算 sufsufsuf 时没有算只丢弃他们之中一个这种情况，对于朴素 DP 自然无伤大雅，但双指针优化 DP 要求函数有严格的单调不降性。用图像来说话就是出现了这种情况： 注意：上面这个函数表示的是数组里存的值，是用计算机算出来的值，而非实际的函数，如果函数确实就长这样他根本就满足不了双指针优化的前提条件！ 因为满足 sufi≥sufi+asuf_i\\ge suf_{i+a}sufi​≥sufi+a​（aaa 为正整数），可以将这个坑填平： 填坑代码实现： 1234567891011for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = n - 1; ~j; --j) &#123; pre[i][j] = max(pre[i][j], pre[i][j + 1]); &#125;&#125;for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = n - 1; ~j; --j) &#123; suf[i][j] = max(suf[i][j], suf[i][j + 1]); &#125;&#125; 三. 代码 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 2e2;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n;int cntmap, mapup[MAXn * 2 + 10]; map&lt;int, int&gt; mapdown;int le[MAXn + 10], ri[MAXn + 10];int sec[MAXn * 2 + 10][MAXn * 2 + 10];int pre[MAXn * 2 + 10][MAXn + 10], suf[MAXn * 2 + 10][MAXn + 10], d[MAXn * 2 + 10][MAXn * 2 + 10], ans;signed main() &#123; read(n); for (int i = 1, l, len, r; i &lt;= n; ++i) &#123; read(l, len); r = l + len; le[i] = l; ri[i] = r; mapup[++cntmap] = l; mapup[++cntmap] = r; &#125; sort(mapup + 1, mapup + 1 + cntmap); cntmap = unique(mapup + 1, mapup + 1 + cntmap) - (mapup + 1); for (int i = 1; i &lt;= cntmap; ++i) &#123; mapdown[mapup[i]] = i; &#125; for (int i = 1; i &lt;= n; ++i) &#123; le[i] = mapdown[le[i]]; ri[i] = mapdown[ri[i]]; &#125; for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = i + 1; j &lt;= cntmap; ++j) &#123; for (int k = 1; k &lt;= n; ++k) &#123; if (le[k] &gt;= i &amp;&amp; ri[k] &lt;= j) ++sec[i][j]; &#125; &#125; &#125; memset(pre, 0xc0, sizeof(pre)); pre[1][0] = 0; for (int i = 2; i &lt;= cntmap; ++i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; for (int k = 1; k &lt; i; ++k) &#123; pre[i][j] = max(pre[i][j], max(pre[k][j - sec[k][i]], pre[k][j] + sec[k][i])); &#125; &#125; &#125; for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = n - 1; ~j; --j) &#123; pre[i][j] = max(pre[i][j], pre[i][j + 1]); &#125; &#125; memset(suf, 0xc0, sizeof(suf)); suf[cntmap][0] = 0; for (int i = cntmap - 1; i; --i) &#123; for (int j = 0; j &lt;= n; ++j) &#123; for (int k = cntmap; k &gt; i; --k) &#123; suf[i][j] = max(suf[i][j], max(suf[k][j - sec[i][k]], suf[k][j] + sec[i][k])); &#125; &#125; &#125; for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = n - 1; ~j; --j) &#123; suf[i][j] = max(suf[i][j], suf[i][j + 1]); &#125; &#125; for (int i = 1; i &lt;= cntmap; ++i) &#123; for (int j = i + 1; j &lt;= cntmap; ++j) &#123; int y = n; for (int x = 0; x &lt;= n; ++x) &#123; while (y &amp;&amp; min(x + sec[i][j] + y, pre[i][x] + suf[j][y]) &lt;= min(x + sec[i][j] + y - 1, pre[i][x] + suf[j][y - 1])) --y; d[i][j] = max(d[i][j], min(x + sec[i][j] + y, pre[i][x] + suf[j][y])); &#125; ans = max(ans, d[i][j]); &#125; &#125; printf(&quot;%d\\n&quot;, ans); for (int i = 1; i &lt;= n; ++i) &#123; int partans = 0; for (int j = le[i]; j; --j) &#123; for (int k = ri[i]; k &lt;= cntmap; ++k) &#123; partans = max(partans, d[j][k]); &#125; &#125; printf(&quot;%d\\n&quot;, partans); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogu U182676 完全图切割","slug":"Luogu U182676 完全图切割","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2021/10/06/Luogu U182676 完全图切割/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/06/Luogu%20U182676%20%E5%AE%8C%E5%85%A8%E5%9B%BE%E5%88%87%E5%89%B2/","excerpt":"","text":"题目传送门 （题目非原创） 一. 思路 没有连通性限制的情况 fi,jf_{i, j}fi,j​：iii 个点所有连边情况的简单无向图（无重边自环，不要求连通），每种情况边数 jjj 次方的和。 考虑 fff 的递推式，因为没有连通性要求，边随便连，可以考虑每加入一个点，他和其他所有点的连边情况，显然，如果原来有 i−1i - 1i−1 个点，加入一个点，新连边的所有情况 {C⁡i−10×新连0边C⁡i−11×新连1边⋯C⁡i−1i−1×新连i-1边\\begin{cases}\\operatorname{C}_{i-1}^{0}\\times\\text{新连0边}\\\\\\operatorname{C}_{i-1}^{1}\\times\\text{新连1边}\\\\\\cdots\\\\\\operatorname{C}_{i-1}^{i-1}\\times\\text{新连i-1边}\\\\\\end{cases}⎩⎨⎧​Ci−10​×新连0边Ci−11​×新连1边⋯Ci−1i−1​×新连i-1边​，设集合 Ti={C⁡i−10个0C⁡i−11个1⋯C⁡i−1i−1个i-1T_i=\\begin{cases}\\operatorname{C}_{i-1}^{0}\\text{个0}\\\\\\operatorname{C}_{i-1}^{1}\\text{个1}\\\\\\cdots\\\\\\operatorname{C}_{i-1}^{i-1}\\text{个i-1}\\\\\\end{cases}Ti​=⎩⎨⎧​Ci−10​个0Ci−11​个1⋯Ci−1i−1​个i-1​，集合 FiF_iFi​ 表示 iii 个点所有连边情况的简单无向图的边数构成的集合。那么： ∵Fi={z∣z=x+y,x∈Fi−1,y∈Ti}&amp;fi,j=∑z∈Fizj∴fi,j=∑x∈Fi−1∑y∈Ti(x+y)j\\begin{gather} \\because F_i=\\left\\{z\\mid z=x+y,x\\in F_{i-1},y\\in T_i\\right\\}\\\\ \\And f_{i,j}=\\sum\\limits_{z\\in F_i}z^j\\\\ \\therefore f_{i,j}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^j\\\\ \\end{gather} ∵Fi​={z∣z=x+y,x∈Fi−1​,y∈Ti​}&amp;fi,j​=z∈Fi​∑​zj∴fi,j​=x∈Fi−1​∑​y∈Ti​∑​(x+y)j​​ fi,jf_{i,j}fi,j​ 对于不同的 jjj 继续拆解这个式子： fi,0=∑x∈Fi−1∑y∈Ti(x+y)0=∑x∈Fi−1∑y∈Ti1=∣Fi−1∣∣Ti∣=fi−1,0×2i−1\\begin{gather} f_{i,0}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^0\\\\ =\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}1\\\\ =\\left|F_{i-1}\\right|\\left|T_{i}\\right|\\\\ =f_{i-1,0}\\times2^{i-1}\\\\ \\end{gather} fi,0​=x∈Fi−1​∑​y∈Ti​∑​(x+y)0=x∈Fi−1​∑​y∈Ti​∑​1=∣Fi−1​∣∣Ti​∣=fi−1,0​×2i−1​​ fi,1=∑x∈Fi−1∑y∈Ti(x+y)1=∑y∈Ti∑x∈Fi−1x+∑x∈Fi−1∑y∈Tiy=∣Ti∣∑x∈Fi−1x+∣Fi−1∣∑y∈Tiy=2i−1×fi−1+fi−1,0×∑y∈Tiy\\begin{gather} f_{i,1}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^1\\\\ =\\sum\\limits_{y\\in T_{i}}\\sum\\limits_{x\\in F_{i-1}}x+\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}y\\\\ =\\left|T_{i}\\right|\\sum\\limits_{x\\in F_{i-1}}x+\\left|F_{i-1}\\right|\\sum\\limits_{y\\in T_{i}}y\\\\ =2^{i-1}\\times f_{i-1}+f_{i-1,0}\\times\\sum\\limits_{y\\in T_{i}}y\\\\ \\end{gather} fi,1​=x∈Fi−1​∑​y∈Ti​∑​(x+y)1=y∈Ti​∑​x∈Fi−1​∑​x+x∈Fi−1​∑​y∈Ti​∑​y=∣Ti​∣x∈Fi−1​∑​x+∣Fi−1​∣y∈Ti​∑​y=2i−1×fi−1​+fi−1,0​×y∈Ti​∑​y​​ fi,2=∑x∈Fi−1∑y∈Ti(x+y)2=∑x∈Fi−1∑y∈Ti(x2+y2+2xy)=∑y∈Ti∑x∈Fi−1x2+∑x∈Fi−1∑y∈Tiy2+2∑x∈Fi−1x∑y∈Tiy=2i−1×fi−1,2+fi−1,0×∑y∈Tiy2+2×fi−1,1×∑y∈Tiy\\begin{gather} f_{i,2}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^2\\\\ =\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x^2+y^2+2xy)\\\\ =\\sum\\limits_{y\\in T_{i}}\\sum\\limits_{x\\in F_{i-1}}x^2+\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}y^2+2\\sum\\limits_{x\\in F_{i-1}}x\\sum\\limits_{y\\in T_{i}}y\\\\ =2^{i-1}\\times f_{i-1,2}+f_{i-1,0}\\times \\sum\\limits_{y\\in T_{i}}y^2+2\\times f_{i-1,1}\\times \\sum\\limits_{y\\in T_{i}}y \\end{gather} fi,2​=x∈Fi−1​∑​y∈Ti​∑​(x+y)2=x∈Fi−1​∑​y∈Ti​∑​(x2+y2+2xy)=y∈Ti​∑​x∈Fi−1​∑​x2+x∈Fi−1​∑​y∈Ti​∑​y2+2x∈Fi−1​∑​xy∈Ti​∑​y=2i−1×fi−1,2​+fi−1,0​×y∈Ti​∑​y2+2×fi−1,1​×y∈Ti​∑​y​​ 可以预处理出 2i2^i2i、∑y∈Tiy\\sum\\limits_{y\\in T_{i}}yy∈Ti​∑​y 和 ∑y∈Tiy2\\sum\\limits_{y\\in T_{i}}y^2y∈Ti​∑​y2。 有连通性限制的情况 di,jd_{i, j}di,j​：iii 个点所有保证连通的连边情况的简单无向图，每种情况边数 jjj 次方的和。 DiD_iDi​：iii 个点所有保证连通的连边情况的简单无向图的边数构成的集合。 正难则反，不方便直接推出符合条件的情况，可以用总的情况减去不符合的情况。随意选一个点作为基准，枚举这个点所在连通块的大小，显然这个点所在连通块一定连通~~（废话）~~，剩余点连通性随意，如果节点总数 iii 基准节点所在连通块大小为 kkk，除去那个基准节点一定被选，剩余点中要选 k−1k-1k−1 个作为连通块中的其他节点，方案数 C⁡i−1k−1\\operatorname{C}_{i-1}^{k-1}Ci−1k−1​。 di,j=fi,j−∑k=1k&lt;i(C⁡i−1k−1×∑z∈{z∣z=x+y,x∈Dk,y∈Fi−k}zj)=fi,j−∑k=1k&lt;i(C⁡i−1k−1×∑x∈Dk∑y∈Fi−k(x+y)j)\\begin{gather} d_{i,j}=f_{i,j}-\\sum\\limits_{k=1}^{k&lt;i}\\left(\\operatorname{C}_{i-1}^{k-1}\\times\\sum_{z\\in\\left\\{z\\mid z=x+y,x\\in D_k,y\\in F_{i-k}\\right\\}}z^j\\right)\\\\ =f_{i,j}-\\sum\\limits_{k=1}^{k&lt;i}\\left(\\operatorname{C}_{i-1}^{k-1}\\times\\sum\\limits_{x\\in D_k}\\sum\\limits_{y\\in F_{i-k}}(x+y)^j\\right) \\end{gather} di,j​=fi,j​−k=1∑k&lt;i​⎝⎛​Ci−1k−1​×z∈{z∣z=x+y,x∈Dk​,y∈Fi−k​}∑​zj⎠⎞​=fi,j​−k=1∑k&lt;i​⎝⎛​Ci−1k−1​×x∈Dk​∑​y∈Fi−k​∑​(x+y)j⎠⎞​​​ 道理和无连通性限制的情况是相同的。 这里为了偷懒节约篇幅 di,jd_{i,j}di,j​ 对于不同的 jjj 的具体过程就不写了，只写最终式，如果读者真正明白了 fi,jf_{i,j}fi,j​ 的推导是可以自己推出 di,jd_{i,j}di,j​ 的。 di,0=fi,0−∑k=1k&lt;i(C⁡i−1k−1×dj,0×fi−j,0)d_{i,0}=f_{i,0}-\\sum\\limits_{k=1}^{k&lt;i}\\left(\\operatorname{C}_{i-1}^{k-1}\\times d_{j,0}\\times f_{i-j,0}\\right) di,0​=fi,0​−k=1∑k&lt;i​(Ci−1k−1​×dj,0​×fi−j,0​) di,1=fi,1−∑k=1k&lt;i(C⁡i−1k−1×(fi−j,0×dj,1+dj,0×fi−j,1))d_{i,1}=f_{i,1}-\\sum\\limits_{k=1}^{k&lt;i}\\left(\\operatorname{C}_{i-1}^{k-1}\\times(f_{i-j,0}\\times d_{j,1}+d_{j,0}\\times f_{i-j,1})\\right) di,1​=fi,1​−k=1∑k&lt;i​(Ci−1k−1​×(fi−j,0​×dj,1​+dj,0​×fi−j,1​)) di,2=fi,2−∑k=1k&lt;i(C⁡i−1k−1×(fi−j,0×dj,2+dj,0×fi−j,2+2×dj,1×fi−j,1))d_{i,2}=f_{i,2}-\\sum\\limits_{k=1}^{k&lt;i}\\left(\\operatorname{C}_{i-1}^{k-1}\\times(f_{i-j,0}\\times d_{j,2}+d_{j,0}\\times f_{i-j,2}+2\\times d_{j,1}\\times f_{i-j,1})\\right) di,2​=fi,2​−k=1∑k&lt;i​(Ci−1k−1​×(fi−j,0​×dj,2​+dj,0​×fi−j,2​+2×dj,1​×fi−j,1​)) 二.代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e3;int mod, C[MAXn + 10][MAXn + 10], row1[MAXn + 10], row2[MAXn + 10], sum[MAXn + 10], sumpower[MAXn + 10], power2[MAXn + 10];void Init(int top) &#123; for (int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; row1[i] = i; row2[i] = (i * i) % mod; for (int j = 1; j &lt; i; ++j) &#123; C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; row1[i] = (row1[i] + C[i][j] * j) % mod; row2[i] = (row2[i] + C[i][j] * (j * j) % mod) % mod; &#125; &#125; power2[0] = 1; for (int i = 1; i &lt;= top; ++i) &#123; sum[i] = (sum[i - 1] + i) % mod; sumpower[i] = (sumpower[i - 1] + i * i) % mod; power2[i] = (power2[i - 1] * 2) % mod; &#125;&#125;int n, d[MAXn + 10][3], f[MAXn + 10][3];signed main() &#123; cin &gt;&gt; n &gt;&gt; mod; Init(n); f[1][0] = d[1][0] = 1; f[1][1] = f[1][2] = d[1][1] = d[1][2] = 0; for (int i = 2; i &lt;= n; ++i) &#123; f[i][0] = (f[i - 1][0] * power2[i - 1]) % mod; f[i][1] = ((f[i - 1][1] * power2[i - 1]) % mod + (f[i - 1][0] * row1[i - 1]) % mod) % mod; f[i][2] = ((f[i - 1][2] * power2[i - 1]) % mod + (f[i - 1][0] * row2[i - 1]) % mod + (2 * f[i - 1][1]) % mod * row1[i - 1] % mod) % mod; d[i][0] = f[i][0]; d[i][1] = f[i][1]; d[i][2] = f[i][2]; for (int j = 1; j &lt; i; ++j) &#123; d[i][0] = (d[i][0] - (C[i - 1][j - 1] * (d[j][0] * f[i - j][0] % mod) % mod)) % mod; d[i][1] = (d[i][1] - (C[i - 1][j - 1] * ((f[i - j][0] * d[j][1] % mod) + (d[j][0] * f[i - j][1] % mod)) % mod)) % mod; d[i][2] = (d[i][2] - (C[i - 1][j - 1] * ((f[i - j][0] * d[j][2] % mod) + (d[j][0] * f[i - j][2] % mod) + (2 * d[j][1] * f[i - j][1] % mod)) % mod)) % mod; &#125; &#125; cout &lt;&lt; (d[n][2] % mod + mod) % mod &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"线段树套矩阵 & Luogu P7453 [THUSCH2017] 大魔法师","slug":"线段树套矩阵 & Luogu P7453 [THUSCH2017] 大魔法师","date":"un00fin00","updated":"un66fin66","comments":true,"path":"2021/09/05/线段树套矩阵 & Luogu P7453 [THUSCH2017] 大魔法师/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E7%9F%A9%E9%98%B5%20&%20Luogu%20P7453%20[THUSCH2017]%20%E5%A4%A7%E9%AD%94%E6%B3%95%E5%B8%88/","excerpt":"","text":"题目传送门 本文分思路（线段树套矩阵的原理），细节和卡常，代码三个部分，大家可以直接跳到自己想看的章节。 零. 前置知识 1. 线段树 为什么我的链接指向的是线段树 2， 而不是 1？自然是因为本题中线段树含有区间乘的要求（虽然没了区间加），强烈建议要写这道题的同学先熟练写出这道题（我就是线段树没写对调了好长时间）。 2. 矩阵运算 建议将矩阵进行封装并重载运算符，因为在本体的大码量下不重载个运算符写起来真的很难受。 一. 线段树套矩阵（思路） 如果这题只要求我们维护一种元素，或是各种元素之间没有影响，那这就是个线段树的板题。关键是这几种元素会相互影响。 但是我们发现，这些操作其实都可以通过矩阵乘法来实现。比如操作一（G 矩阵就是我代码中变量名为 G 的矩阵）： 操作四： （其他操作的转移矩阵见“三. 代码”） 线段树上的矩阵只需开 1×41 \\times 41×4（而我开了 4×44 \\times 44×4，不过也卡过去了），其中三列的上维护三种元素，另一列维护常数 111。 转移矩阵需要开 4×44 \\times 44×4。 那么每个操作就是将一个区间上的所有矩阵乘上一个数矩阵，如果把一个矩阵看作一个数，那这就是线段树裸题，所以，把一个支持区间乘和求区间和的线段树的 mul 数组（乘法懒标记）和 sum 数组（区间和）的数据类型改为 4×44 \\times 44×4 矩阵或 1×41 \\times 41×4 向量，mul[xxx] = 1 改为 mul[xxx] = I （I：单位矩阵）就行了。 二. 卡常 不要使用 long long，有溢出风险的地方用强制转换就好了。 使用快读或： 123std::ios::sync_with_stdio(false);std::cin.tie(nullptr);std::cout.tie(nullptr); 开 O2。 如果还卡不过去，那就应该试试将线段树上的 4×44 \\times 44×4 矩阵换成 1×41 \\times 41×4 的向量。 三. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;cstdio&gt;#include&lt;cstring&gt;#define re registertypedef long long ll;const int MAXn = 2e5 + 5e4;const int MAXmat = 4;const int MOD = 998244353;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;struct Mat &#123; int mat[MAXmat][MAXmat]; Mat() &#123; memset(mat, 0, sizeof(mat)); &#125; Mat(int a[MAXmat][MAXmat]) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = a[i][j]; &#125; &#125; &#125; inline void operator=(Mat x) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = x.mat[i][j]; &#125; &#125; &#125; inline Mat operator+(Mat x) &#123; Mat ans; for (int i = 0; i &lt; MAXmat; ++i) &#123; for (int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = ((ll)mat[i][j] + x.mat[i][j]) % MOD; &#125; &#125; return ans; &#125; inline Mat operator*(Mat x) &#123; Mat ans; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int k = 0; k &lt; MAXmat; ++k) &#123; int a = mat[i][k]; for (re int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = ((ll)a * x.mat[k][j] + ans.mat[i][j]) % MOD; &#125; &#125; &#125; return ans; &#125; inline Mat operator^(int x) &#123; Mat ans, base; for (re int i = 0; i &lt; MAXmat; ++i) &#123; ans.mat[i][i] = 1; &#125; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; base.mat[i][j] = mat[i][j]; &#125; &#125; while (x) &#123; if (x &amp; 1) &#123; ans = ans * base; &#125; base = base * base; x &gt;&gt;= 1; &#125; return ans; &#125;&#125;;int I_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat I(I_);int le[MAXn * 4 + 10], ri[MAXn * 4 + 10];Mat sum[MAXn * 4 + 10], mul[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = (sum[id &lt;&lt; 1] + sum[(id &lt;&lt; 1) + 1]);&#125;inline void pushdown(int id) &#123; sum[id &lt;&lt; 1] = (sum[id &lt;&lt; 1] * mul[id]); sum[(id &lt;&lt; 1) + 1] = (sum[(id &lt;&lt; 1) + 1] * mul[id]); mul[id &lt;&lt; 1] = (mul[id &lt;&lt; 1] * mul[id]); mul[(id &lt;&lt; 1) + 1] = (mul[(id &lt;&lt; 1) + 1] * mul[id]); mul[id] = I;&#125;void BuildUseArr(int id, int l, int r, Mat *a) &#123; le[id] = l; ri[id] = r; mul[id] = I; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(id &lt;&lt; 1, l, mid, a); BuildUseArr((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;void Mul(int id, int l, int r, Mat k) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; mul[id] = (mul[id] * k); sum[id] = (sum[id] * k); &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Mul(id &lt;&lt; 1, l, r, k); if (r &gt; mid) Mul((id &lt;&lt; 1) + 1, l, r, k); pushup(id); &#125;&#125;Mat Sum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; Mat ans; if (l &lt;= mid) ans = Sum(id &lt;&lt; 1, l, r); if (r &gt; mid) ans = (ans + Sum((id &lt;&lt; 1) + 1, l, r)); return ans; &#125;&#125;int n, m;Mat a[MAXn + 10], G;int A_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;1, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat A(A_);int B_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 1, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat B(B_);int C_[MAXmat][MAXmat] = &#123; &#123;1, 0, 1, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat C(C_);int D_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;, // [3][0] = v&#125;;Mat D(D_);int E_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;, // [1][1] = v&#125;;Mat E(E_);int F_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 1&#125;, // [3][2] = v&#125;;Mat F(F_);signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i].mat[0][0]), read(a[i].mat[0][1]), read(a[i].mat[0][2]); a[i].mat[0][3] = 1; &#125; BuildUseArr(1, 1, n, a); read(m); for (re int i = 1, opt, l, r, v; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(l), read(r); Mul(1, l, r, A); break; case 2: read(l), read(r); Mul(1, l, r, B); break; case 3: read(l), read(r); Mul(1, l, r, C); break; case 4: read(l), read(r), read(v); D.mat[3][0] = v; Mul(1, l, r, D); break; case 5: read(l), read(r), read(v); E.mat[1][1] = v; Mul(1, l, r, E); break; case 6: read(l), read(r), read(v); F.mat[3][2] = v; Mul(1, l, r, F); break; case 7: read(l), read(r); G = Sum(1, l, r); printf(&quot;%d %d %d\\n&quot;, G.mat[0][0], G.mat[0][1], G.mat[0][2]); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P2518 [HAOI2010]计数","slug":"计数","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2021/09/02/计数/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/02/%E8%AE%A1%E6%95%B0/","excerpt":"","text":"题目传送门 一. 思路 1. 拆分原数（数位DP思想） 求某个区间的数中满足某个条件的数的个数，这是典型的数位 DP 题的套路。于是我们可以试着拆分这个数，把 [0, 原数) 这个区间按位拆成一些区间： 我们只需计算出所有整块区间中满足条件的数并求和就好了。 2. 处理每个区间（多重集排列） 所谓符合要求，就是由原数中的每一位上的非零数和任意个零按位拼凑而成。看似这个要求不好处理，实则完全可以通过多重集排列得出。 多重集排列，将一个可以有重复元素的集合中的元素进行排列的方案数，如：{1, 3, 3}，多重集排列：[1, 3, 3]，[3, 1, 3]，[3, 3, 1]，共三种。这篇文章中设多重集排列的符号为 Pmult⁡(cnt1,cnt2…cntn)\\operatorname{Pmult}(cnt_1, cnt_2 \\ldots cnt_n)Pmult(cnt1​,cnt2​…cntn​)，如 {1, 3, 3} 的排列是 Pmult⁡(1,2)\\operatorname{Pmult}(1, 2)Pmult(1,2)。 应用到这题上来就是例如 [0, 1000) 这个区间，首位是 “0”，除了首位外还有 3 位，有两个非零数字 “1”，“2”。答案就是 一个 “1”，一个 “2”，一个 “0”（“0” 的个数为除首位外的位数 - 非零位数），即 Pmult⁡(1,1,1)\\operatorname{Pmult}(1, 1, 1)Pmult(1,1,1)。 多重集排列的计算公式就是： Pmult⁡(cnt1,cnt2…cntn)=C⁡sumcntcnt1×C⁡sumcnt−cnt1cnt2×…×C⁡sumcnt−cnt1−cnt2−…−cntn−1cntn (sumcnt=∑i=1ncnti)\\operatorname{Pmult}(cnt_1, cnt_2 \\ldots cnt_n) = \\operatorname{C}_{sumcnt}^{cnt_1} \\times \\operatorname{C}_{sumcnt - cnt_1}^{cnt_2} \\times \\ldots \\times \\operatorname{C}_{sumcnt - cnt_1 - cnt_2 - \\ldots - cnt_{n - 1}}^{cnt_n}~~~~(sumcnt = \\sum\\limits_{i = 1}^n cnt_i) Pmult(cnt1​,cnt2​…cntn​)=Csumcntcnt1​​×Csumcnt−cnt1​cnt2​​×…×Csumcnt−cnt1​−cnt2​−…−cntn−1​cntn​​ (sumcnt=i=1∑n​cnti​) 简略证明就是你有 sumcntsumcntsumcnt 个空，先将 cnt1cnt_1cnt1​ 个相同物品放进去，就是 C⁡sumcntcnt1\\operatorname{C}_{sumcnt}^{cnt_1}Csumcntcnt1​​ 种，空的数量变为 sumcnt−cnt1sumcnt - cnt_1sumcnt−cnt1​ 个，以此类推。 3. 代码实现中的细节： 拆分原数是从高位往低位。每一次处理完一位处理下一位之前，如果这一位非零，将 cnt 数组中这一位数字的数量减一，因为之后处理的更低位中，高位是确定的，也就是说无法在使用高位的这个数字了。如 “1020” 处理完 [0, 1000) 后，之后所有区间的千位都是 “1”， “1” 无法再参与排列，所以直接 --cnt[1]。 处理某个非零位时，先枚举该位，将还剩下的数（还剩下 “x”，即 cnt[x] &gt; 0）中小于改位原数的依次填到该位，再用多重集排列算出剩下的位的排列数。（具体见代码） 遇到为零的位如 “1020” 中个位和百位，他们拆分出的区间没有数，直接跳过就好，不浪费程序运行时间。 二. 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans; // cnt[x]: &quot;x&quot;数还可参与排列的数量，也就是&quot;x&quot;在当前位和比当前位低的位中的数量。 // cnt[10]: 在当前位和比当前位低的位中&quot;0&quot;的数量。 // sumcnt: Sum&#123;cnt[1] ~ cnt[9]&#125;，用于计算&quot;0&quot;的个数。signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P3225 [HNOI2012]矿场搭建","slug":"矿场搭建","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/08/18/矿场搭建/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/18/%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/","excerpt":"","text":"一. 思路 0. 前置知识：割点，v-dcc（再说一遍，无向图有的是双连通分量，没有强连通分量一说！）。 ​ 这里推荐几道模板题，学习 Tarjan 建议把他们都 A 了： dcc 割边：Luogu Std。 dcc 割点：Luogu Std。 e-dcc：Luogu Std。 v-dcc：Luogu Std。 scc：Luogu Std。 scc 缩点：Luogu。 （没有找到双连通分量的缩点模板，知道的小伙伴欢迎在评论中补充） 蓝书上这部分讲的很详细。 那么接下来我们以这个图为例讲解此题： 命名三个双连通分量为：A，B，C。红色的为割点。 1. 一个包含一个割点的双连通分量（A，C） 非割点坍塌： 没有关系，比如 A 中 1 号点坍塌，3 号点中的人可以来到割点（2 号点），然后去往其他双连通分量中的出口逃生。 割点坍塌： 比如 2 号塌了，1 号和 3 号中就必须有一个出口。 综上，对于包含一个割点的双连通分量，需要建 111 个出口，方案数为 size⁡−1\\operatorname{size} - 1size−1。（size⁡\\operatorname{size}size：该 dcc 大小）。 2. 一个包含两个及以上个割点的双连通分量（B） 非割点坍塌：（同 1 - 1） 割点坍塌： 这次情况不同了，塌了一个割点，还有至少一个割点可以供里面的工人离开这个 dcc。 综上，对于包含两个及以上个割点的双连通分量，根本无需建出口。 看到这里，很多人有 问题 了：如果全是包含两个及以上个割点的 dcc，所有人总想着往其他 dcc 跑，其他 dcc 却也没出口怎么办。那么恭喜你，这种情况根本不可能成立。比如有一圈像 B 一样的 dcc 拼在一起： 但再仔细看，一当形成环，割点就直接没有了，也就是说上图 4 个红色点都应该是白色的，这就是第三种情况（待会要讲）。 而如果环不合拢，两端必然存在包含一个割点的 dcc，也就自然能成功逃离： 3. 环 如果是一个环，看上去建一个出口就行了，但还要考虑出口坍塌的情况！所以需要建 222 个出口。方案数为 C⁡size⁡2=size⁡×(size⁡−1)2\\operatorname{C}^2_{\\operatorname{size}} = \\dfrac{\\operatorname{size} \\times (\\operatorname{size} - 1)}{2}Csize2​=2size×(size−1)​。 4. 最终结果 出口数：将所有 dcc 建的出口数相加。 方案数：将所有 dcc 的方案数相乘。（乘法原理） 二. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e4;const int MAXm = 3e5;template &lt;class T&gt;inline void read(T&amp; a) &#123; re char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); re T x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125;a = x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int top, stk[MAXn + 10], cntdcc;vector&lt;int&gt; dcc[MAXn + 10];bool is[MAXn + 10];int root, cntdfs, dfs[MAXn + 10], low[MAXn + 10];void Init() &#123; cntnex = top = root = cntdfs = 0; memset(head, 0, sizeof(head)); memset(nex, 0, sizeof(nex)); memset(to, 0, sizeof(to)); memset(stk, 0, sizeof(stk)); memset(is, 0, sizeof(is)); memset(dfs, 0, sizeof(dfs)); memset(low, 0, sizeof(low)); for (re int i = 1; i &lt;= cntdcc; ++i) &#123; dcc[i].clear(); &#125; cntdcc = 0;&#125;void Tarjan(int cur) &#123; int times = 0; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; ++cntdcc; dcc[cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (dfs[cur] &lt;= low[to[i]]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; is[cur] = 1; &#125; ++cntdcc; int instk; do &#123; instk = stk[top--]; dcc[cntdcc].push_back(instk); &#125; while (instk != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; else &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; &#125;&#125;int n, m;signed main() &#123; int T = 0; while (~scanf(&quot;%lld&quot;, &amp;m)) &#123; if (m == 0) &#123; break; &#125; ++T; n = 0; Init(); for (re int i = 1, u, v; i &lt;= m; ++i) &#123; read(u), read(v); n = max(n, u); n = max(n, v); if (u == v) &#123; continue; &#125; Insert(u, v); Insert(v, u); &#125; for (re int i = n; i; --i) &#123; if (!dfs[i]) &#123; root = i; Tarjan(i); &#125; &#125;// 除核心以外的都是纯板子// ---------------核心--------------- int ans1 = 0, ans2 = 1; for (re int i = 1; i &lt;= cntdcc; ++i) &#123; int cnt = 0; for (re vector&lt;int&gt;::iterator j = dcc[i].begin(); j != dcc[i].end(); ++j) &#123; if (is[*j]) &#123; ++cnt; &#125; &#125; if (cnt == 1) &#123; ++ans1; ans2 *= dcc[i].size() - 1; &#125; else if (cnt == 0) &#123; ans1 += 2; ans2 *= dcc[i].size() * (dcc[i].size() - 1) / 2; &#125; &#125;// ---------------核心--------------- printf(&quot;Case %lld: %lld %lld\\n&quot;, T, ans1, ans2); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Luogu CF679A Bear and Prime 100","slug":"Bear and Prime 100","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Bear and Prime 100/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Bear%20and%20Prime%20100/","excerpt":"","text":"CF679A Bear and Prime 100 一. 审题： 1. 前提条件： 无 2. 询问 &amp; 输入： 询问：（最多 202020 次） 输出一个数 xxx，代表询问 xxx 是否是被猜数的约数。 输入： 读入一个字符 yes 或 no 代表这个数是否是被猜数的约数。 3. 输出： 该数是否是素数。 二. 思路 我们知道质数的因数有且只有 111 和自己，也就是 111 和一个质数。所以第一感觉是把 1−1001-1001−100 的质数问一遍。但很快发现询问次数不够。而且也用不着，因为，如果只问 1-50 内的质数： 如果有2个及以上的 yesyesyes 回答，直接判断为合数。 如果有一个 yesyesyes 回答，51−10051-10051−100 不可能有因数，那样所猜数就超100了。 如果无 yesyesyes 回答，51−10051-10051−100 必有且只有一个因数，就是他本身呀。 所以问 51−10051-10051−100 的质数是无意义的。 问完质数还不够，例如 4 就判断不出来，因为本交互程序只判断有没有这个因数，不能说出该因数个数。所以还得判断质数的平方数（100100100 以内的） 三. 代码 因为每个输出后都跟了endl，所以不需要加fflush(stdout)。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int primes[20] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47&#125;; //1-50内质数，共15个int sq_nums[10] = &#123;4, 9, 25, 49&#125;; //质数的平方数(100以内的) string feedback; //交互返回的字符串bool once; //是否已经返回过一次yes了int main() &#123; for (int i = 0; i &lt; 15; ++i) &#123; cout &lt;&lt; primes[i] &lt;&lt; endl; cin &gt;&gt; feedback; if (feedback == &quot;yes&quot;) &#123; if (!once) &#123; once = 1; &#125; else &#123; cout &lt;&lt; &quot;composite&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; cout &lt;&lt; sq_nums[i] &lt;&lt; endl; cin &gt;&gt; feedback; if (feedback == &quot;yes&quot;) &#123;//这些平方数本来就是合数，所以只要返回1次yes就可以判断了 cout &lt;&lt; &quot;composite&quot; &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; &quot;prime&quot; &lt;&lt; endl; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogo P2616 [USACO10JAN]Buying Feed, II S","slug":"Buying Feed, II S","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Buying Feed, II S/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Buying%20Feed,%20II%20S/","excerpt":"","text":"P2616 USACO10 JANBuying Feed, II S 放在前面：为对应“普及-”的难度，本文讲解的是 O(nW2)O(nW^2)O(nW2) 复杂度的朴素 DP，如想挑战更高难度请进 Here，并欢迎大家来该题题解看我的另一篇博客上的 O(nW)O(nW)O(nW) 解法。 一. 变量声明： WWW：代替题目中的 KKK，到家时应带的饲料吨数，相当于背包中的背包最大承重（weight）。 nnn：代替题目中的 NNN，商店数量，相当于背包问题中的物品数。 xix_ixi​：同题目中的 xix_ixi​。 wiw_iwi​：代替题目中的 fif_ifi​，商店 iii 食物数量。 viv_ivi​：代替题目中的 cic_ici​，商店 iii 食物单价。 二. 思路 1. 思考解法 路线上后面的商店不会影响路线前半部分的最优解，符合无后效性。 有最大容量 WWW，有可选择的物品，每个物品有重量和价值，明显是背包类问题。 所以考虑背包 DP。 2. 初始状态 di,j={0(i=0 ∧ j=0)∞(else)d_{i,j}=\\begin{cases} 0&amp;(i=0~\\land~j=0)\\\\ \\infty&amp;(else) \\end{cases}di,j​={0∞​(i=0 ∧ j=0)(else)​ 3. 结束状态 dhome⁡,Wd_{\\operatorname{home},W}dhome,W​ （home⁡\\operatorname{home}home：见代码和代码中的注释） 4. 确定状态转移方程 di,jd_{i,j}di,j​：已经经过前 iii 个商店（已到 iii 号商店买了东西但还没有往 i+1i+1i+1 号走）且恰好一共买了 jjj 份食物时最少花费的费用。 本题就是一道改装版的多重背包问题，就加了一个转移花费，转移花费怎么求呢？iii 店与上一家店距离差为 xi−xi−1x_i-x_{i-1}xi​−xi−1​，若在 iii 号店买的食物份数为 kkk ，在 iii 店购物后车上的食物份数为 jjj（jjj 和 kkk 这两个量都是 for 循环枚举出来的），则这段路上车辆运送的食物数为 j−kj-kj−k。转移花费就是 (xi−xi−1)×(j−k)(x_i-x_{i-1})\\times (j-k)(xi​−xi−1​)×(j−k)。 综上所述，状转方程：di,j=min⁡k=0k⩽wi{di−1,j−k+(xi−xi−1)×(j−k)+vi×k}d_{i,j}=\\min_{k=0}^{k\\leqslant w_i}\\left\\{d_{i-1,j-k}+(x_i-x_{i-1})\\times (j-k)+v_i\\times k\\right\\}di,j​=mink=0k⩽wi​​{di−1,j−k​+(xi​−xi−1​)×(j−k)+vi​×k} 三. 代码 代码中有一些例如构造函数和重载运算符一样的技巧，这些暂时不会也不妨碍理解算法，只需看 main 函数中的内容就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define re registerconst int MAXn = 500;const int MAXW = 10000;template &lt;class T&gt; //模板函数inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;inline int min(int a, int b) &#123; return a &lt; b ? a : b;&#125;struct Shop &#123; int x; int w; int v; Shop(): x(0), w(0), v(0)&#123;&#125; //构造函数 Shop(int x_, int w_, int v_): x(x_), w(w_), v(v_) &#123;&#125; //同上 inline bool operator &lt; (Shop &amp;a) &#123; //重载运算符 return this-&gt;x &lt; a.x; &#125;&#125;;Shop shop[MAXn + 10];int W, n, d[MAXn + 10][MAXW + 10];int main() &#123; int E; read(W), read(E), read(n); shop[0] = Shop(0, 0, 0); //本人将起点和终点（家）时当做食物数为 0 的商店，这样能避免特判，所以“home”就是n+1 for (re int i = 1, x, w, v; i &lt;= n; ++i) &#123; read(x), read(w), read(v); shop[i] = Shop(x, w, v); &#125; shop[n + 1] = Shop(E, 0, 0); //同上 sort(shop, shop + n + 2); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (re int i = 1; i &lt;= n + 1; ++i) &#123; //i：当前阶段是在哪个店 for (re int j = W; j &gt;= 0; --j) &#123; //j：当前状态要求车上有多少饲料 for (re int k = 0; k &lt;= shop[i].w; ++k) &#123; //k：当前转移中要从本店买多少饲料 if (j &lt; k) continue; d[i][j] = min(d[i][j], d[i - 1][j - k] + (shop[i].x - shop[i - 1].x) * (j - k) + k * shop[i].v); &#125; &#125; &#125; printf(&quot;%d&quot;, d[n + 1][W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogu P4544 [USACO10NOV]Buying Feed G","slug":"Buying Feed G","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Buying Feed G/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Buying%20Feed%20G/","excerpt":"","text":"P4544 USACO10NOV Buying Feed G 放在前面：本方法时间复杂度为 O(nW)O(nW)O(nW) ，单调队列优化 DP。本题还有一道弱化版，欢迎大佬切完这题顺便把那题也切了，并欢迎大家来该题题解看我的另一篇博客。 一. 变量声明： WWW：代替题目中的 KKK，到家时应带的饲料吨数，相当于背包中的背包最大承重（weight）。 nnn：代替题目中的 NNN，商店数量，相当于背包问题中的物品数。 xix_ixi​：同题目中的 xix_ixi​。 wiw_iwi​：代替题目中的 fif_ifi​，商店 iii 食物数量。 viv_ivi​：代替题目中的 cic_ici​，商店 iii 食物单价。 二. 思路 1. 思考解法 路线上后面的商店不会影响路线前半部分的最优解，符合无后效性。 有最大容量 WWW，有可选择的物品，每个物品有重量和价值，明显是背包类问题。 所以考虑背包 DP。 2. 初始状态 di,j={0(i=0 ∧ j=0)∞(else)d_{i,j}=\\begin{cases} 0&amp;(i=0~\\land~j=0)\\\\ \\infty&amp;(else) \\end{cases}di,j​={0∞​(i=0 ∧ j=0)(else)​ 3. 结束状态 dhome⁡,Wd_{\\operatorname{home},W}dhome,W​ （home⁡\\operatorname{home}home：见代码和代码中的注释） 4. 确定状态转移方程 di,jd_{i,j}di,j​：已经经过前 iii 个商店（已到 iii 号商店买了东西但还没有往 i+1i+1i+1 号走）且恰好一共买了 jjj 份食物时最少花费的费用。 本题就是一道改装版的多重背包问题，就加了一个转移花费，转移花费怎么求呢？iii 店与上一家店距离差为 xi−xi−1x_i-x_{i-1}xi​−xi−1​，若在 iii 号店之前买的食物份数一共为 kkk ，在 iii 店购物后车上的食物份数为 jjj，则这段路上车辆运送的食物数为 kkk。转移花费就是 (xi−xi−1)×k2(x_i-x_{i-1})\\times k^2(xi​−xi−1​)×k2。 综上所述，朴素状转方程：di,j=min⁡k=0k⩽j{di−1,k+(xi−xi−1)×k2+vi×(j−k)}d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2+v_i\\times (j-k)\\right\\}di,j​=mink=0k⩽j​{di−1,k​+(xi​−xi−1​)×k2+vi​×(j−k)} 5. 单调队列优化（重点） 枚举 iii 复杂度为 O(n)O(n)O(n)，枚举 jjj 复杂度为 O(W)O(W)O(W)，枚举 kkk 最坏情况下复杂度也是 O(W)O(W)O(W)。总复杂度 O(nW2)O(nW^2)O(nW2) 显然会超。那么让我们观察一下状转方程： di,j=min⁡k=0k⩽j{di−1,k+(xi−xi−1)×k2+vi×(j−k)}~~~~~~~~d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2+v_i\\times (j-k)\\right\\} di,j​=k=0mink⩽j​{di−1,k​+(xi​−xi−1​)×k2+vi​×(j−k)} ⟹di,j=min⁡k=0k⩽j{di−1,k+(xi−xi−1)×k2−vi×k+vi×j}\\Longrightarrow d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times k+v_i\\times j\\right\\} ⟹di,j​=k=0mink⩽j​{di−1,k​+(xi​−xi−1​)×k2−vi​×k+vi​×j} 重点一 ：观察上面这个拆了个括号的方程，左边是我们要去求的状态，在该状态下，iii 和 jjj 是已知的，因为该状态就是由 iii 和 jjj 定义的，iii 和 jjj 在一个具体的状态下为常量（或者换一种解释：iii 和 jjj 是用 for 循环枚举出来的，所以我们当然知道他的值）。所以我们可以将 vi×jv_i\\times jvi​×j 提出括号。可得： ⟹di,j=min⁡k=0k⩽j{di−1,k+(xi−xi−1)×k2−vi×k}+vi×j\\Longrightarrow d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times k\\right\\}+v_i\\times j ⟹di,j​=k=0mink⩽j​{di−1,k​+(xi​−xi−1​)×k2−vi​×k}+vi​×j 重点二：这个方程中的变量只有 kkk，而又有 k⩽jk\\leqslant jk⩽j，因为在 iii 店购物后的食物数不可能低于购物前。那么我们就可以使用单调队列优化。单调队列中存放的就是 min⁡\\minmin 内的部分 di−1,k+(xi−xi−1)×k2−vi×kd_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times kdi−1,k​+(xi​−xi−1​)×k2−vi​×k （在这里我们把它称作 calci,kcalc_{i,k}calci,k​），对于每一个 iii ，将 jjj 从 000 到 WWW 枚举一遍，对于每个 jjj 先将它作为 kkk 计算 calci,kcalc_{i,k}calci,k​ 并放到单调队列中，再先计算状态 di.jd_{i.j}di.j​。 三. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define re register#define int long longconst int MAXn = 500;const int MAXW = 10000;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;template &lt;class T&gt;inline T min(T a, T b) &#123; return a &lt; b ? a : b;&#125;struct Shop &#123; int x; int w; int v; Shop(): x(0), w(0), v(0)&#123;&#125; Shop(int x_, int w_, int v_): x(x_), w(w_), v(v_) &#123;&#125; inline bool operator &lt; (Shop &amp;a) &#123; return this-&gt;x &lt; a.x; &#125;&#125;;Shop shop[MAXn + 10];int W, n, d[MAXn + 10][MAXW + 10];int head, tail, que[MAXW + 10];inline int calc(int i, int k) &#123; return d[i - 1][k] + (shop[i].x - shop[i - 1].x) * k * k - shop[i].v * k;&#125;signed main() &#123; int E; read(W), read(E), read(n); shop[0] = Shop(0, 0, 0); //本人将起点和终点（家）时当做食物数为 0 的商店，这样能避免特判，所以“home”就是n+1 for (re int i = 1, x, w, v; i &lt;= n; ++i) &#123; read(x), read(w), read(v); shop[i] = Shop(x, w, v); &#125; shop[n + 1] = Shop(E, 0, 0); //同上 sort(shop, shop + n + 2); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (re int i = 1; i &lt;= n + 1; ++i) &#123; //i：当前阶段是在哪个店 head = 1; tail = 0; for (re int j = 0; j &lt;= W; ++j) &#123; //j：当前状态要求在此处商店购买后车上有多少饲料 while (calc(i, que[tail]) &gt; calc(i, j) &amp;&amp; head &lt;= tail) --tail; if (j - que[head] &gt; shop[i].w &amp;&amp; head &lt;= tail) ++head; que[++tail] = j; d[i][j] = calc(i, que[head]) + shop[i].v * j; &#125; &#125; printf(&quot;%lld&quot;, d[n + 1][W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Luogu CF727C Guess the Array","slug":"Guess the Array","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Guess the Array/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Guess%20the%20Array/","excerpt":"","text":"CF727C Guess the Array 注：本文含交互题 endl 与 fflush 不同种类的配合使用效果的 测试（见 “四”） 一. 审题： 1. 前提条件： 一个数 nnn 代表数组中数的个数。 2. 询问 &amp; 输入： 询问： 输出两个数 xxx，yyy 。代表询问 axa_xax​ 和 aya_yay​ 的和。 格式：? x y 输入： 读入一个数代表这两个数的和。 3. 输出： 数组中所有数的值。格式：! a[1] a[2] a[3] ... a[n] 二. 思路 1. 思考解法 我们可以不一口气把 nnn 次都询问完（当然最后肯定是都要询问完的），既然 nnn 个数询问 nnn 次一定有解，那么我们可以先询问 a1+a2a_1+a_2a1​+a2​ ， a2+a3a_2+a_3a2​+a3​ 以及 a3+a1a_3+a_1a3​+a1​ 。这样就能先计算出 a1a_1a1​，a2a_2a2​ 以及 a3a_3a3​。 只要有了一个数的具体值，我们每询问一次就可以算出一个数的具体值，这样一气呵成，避免了一口气询问完后堆积过多条件无从下手的情况。 2. 具体实现 前三个数： 解法有很多，如 {x+y=ay+z=bz+x=c\\ \\ \\ \\ \\begin{cases}x+y=a\\\\y+z=b\\\\z+x=c\\end{cases} ⎩⎨⎧​x+y=ay+z=bz+x=c​ ⟹2x+2y+2z=a+b+c\\Longrightarrow 2x+2y+2z=a+b+c ⟹2x+2y+2z=a+b+c ⟹x+y+z=a+b+c2\\Longrightarrow x+y+z=\\dfrac{a+b+c}{2} ⟹x+y+z=2a+b+c​ ⟹x=a+b+c2−b\\Longrightarrow x=\\dfrac{a+b+c}{2}-b ⟹x=2a+b+c​−b yyy，zzz 同理。 剩下的数： 接下来询问a1+a4a_1+a_4a1​+a4​，a1+a5a_1+a_5a1​+a5​ . . . a1+ana_1+a_na1​+an​。 三. 代码 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5000;int n;int add12,add13,add23; //addxy:第x个和第y个数的和int add[MAXn + 10]; //add[x]:第1个和第x个数的和int first; //第一个数的值int main() &#123; scanf(&quot;%d&quot;, &amp;n); cout &lt;&lt; &quot;? 1 2&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add12); cout &lt;&lt; &quot;? 2 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add23); cout &lt;&lt; &quot;? 1 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add13);//这里用了endl就不需要fflush(stdout)了 first = (add13 - add23 + add12) &gt;&gt; 1;//读入前三个数间两两值得和，并计算第一个数 for (int i = 4 ; i &lt;= n; ++i) &#123; cout &lt;&lt; &quot;? 1 &quot; &lt;&lt; i &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add[i]); &#125;//读入第1个数和第4-n个数间两两的值 cout &lt;&lt; &quot;! &quot; &lt;&lt; first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add12 - first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add23 - add12 + first; fflush(stdout); for(int i = 4; i &lt;= n; ++i) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; add[i] - first; &#125;&#125; 四. endl 与 fflush 对交互题来说，弄清楚 endl 和 fflush 怎么用格外重要。不多废话了，直接摆上测试结果： 结论：endl 后面 不用跟 fflush，但如果没有 endl （或是用 printf）要加上 fflush(stdout)。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"OI中的数论","slug":"OI中的数论","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/07/21/OI中的数论/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA/","excerpt":"","text":"一. 质数 概念 φ(n)\\varphi(n)φ(n)：1∼n1\\sim n1∼n 中与 nnn 互质的数的个数。 如果当 a,ba, ba,b 互质时，有 f(a×b)=f(a)×(b)f(a\\times b)=f(a)\\times (b)f(a×b)=f(a)×(b)。那么称函数 fff 为积性函数。若 fff 是积性函数，且在算术基本定理中 n=∏i=1mpicin=\\prod_{i=1}^{m}p_{i}^{c_{i}}n=∏i=1m​pici​​，则显然 f(n)=∏i=1mf(pici)f(n)=\\prod_{i=1}^{m}f\\left(p_{i}^{c_{i}}\\right)f(n)=∏i=1m​f(pici​​)。 性质 1∼n1\\sim n1∼n 中质数的个数：约 nln⁡n\\dfrac{n}{\\ln n}lnnn​。 欧拉函数 ∀n&gt;1,1∼n\\forall n&gt;1,1 \\sim n∀n&gt;1,1∼n 中与 nnn 互质的数的和为 n2×φ(n)\\dfrac{n}{2}\\times\\varphi(n)2n​×φ(n)。 证明：因为 gcd⁡(n,x)=gcd(n,n−x)\\gcd(n,x)=gcd(n,n-x)gcd(n,x)=gcd(n,n−x)，所以 1∼n1\\sim n1∼n 中与 nnn 互质的数总是成对出现，平均值为 n2\\dfrac{n}{2}2n​，总和为 n2×φ(n)\\dfrac{n}{2}\\times\\varphi(n)2n​×φ(n)。 若 a,ba, ba,b 互质, 则 φ(a×b)=φ(a)×φ(b)\\varphi(a\\times b)=\\varphi(a)\\times\\varphi(b)φ(a×b)=φ(a)×φ(b)。 证明：根据下文欧拉函数单点计算公式直接得出。 设 ppp 为质数，若 p∣np \\mid np∣n 且 p2∣np^{2} \\mid np2∣n，则 φ(n)=φ(np)×p\\varphi(n)=\\varphi(\\dfrac{n}{p})\\times pφ(n)=φ(pn​)×p. 证明：由条件得 nnn 与 np\\dfrac{n}{p}pn​ 质因子种类相同，只是指数不同，将 φ(n)\\varphi(n)φ(n) 和 φ(np)\\varphi(\\dfrac{n}{p})φ(pn​) 根据下文单点计算公式拆分发现他们的商为 ppp。 设 ppp 为质数，若 p∣np \\mid np∣n 但 p2∤np^{2} \\nmid np2∤n，则 φ(n)=φ(np)×(p−1)\\varphi(n)=\\varphi(\\dfrac{n}{p})\\times(p-1)φ(n)=φ(pn​)×(p−1)。 证明：由条件得 ppp 与 np\\dfrac{n}{p}pn​ 互质，由性质 2 可得 φ(n)=φ(np)×φ(p)=φ(np)×(p−1)\\varphi(n)=\\varphi(\\dfrac{n}{p})\\times\\varphi(p)=\\varphi(\\dfrac{n}{p})\\times(p-1)φ(n)=φ(pn​)×φ(p)=φ(pn​)×(p−1)。 ∑d∣nφ(d)=n\\sum_{d\\mid n}\\varphi(d)=n∑d∣n​φ(d)=n。 证明：设 n,mn,mn,m 互质，n=p1c1p2c2⋯n=p_1^{c_1}p_2^{c_2}\\cdotsn=p1c1​​p2c2​​⋯，m=p1′ c1′p2′ c2′⋯m=p_1&#x27;^{~c_1&#x27;}p_2&#x27;^{~c_2&#x27;}\\cdotsm=p1′ c1′​​p2′ c2′​​⋯。 ∑d∣nmφ(d)=∑i=0c1∑j=0c2⋯∑k=0c1′∑l=0c2′⋯φ(p1ip2j⋯p1′ kp2′ l⋯ )=∑i=0c1∑j=0c2⋯φ(p1ip2j⋯ )∑k=0c1′∑l=0c2′⋯φ(p1′ kp2′ l⋯ )=∑f∣nφ(f)∑g∣mφ(g)\\begin{gather} \\sum_{d\\mid nm}\\varphi(d)=\\sum\\limits_{i=0}^{c_1}\\sum\\limits_{j=0}^{c_2}\\cdots\\sum\\limits_{k=0}^{c_1&#x27;}\\sum\\limits_{l=0}^{c_2&#x27;}\\cdots\\varphi(p_1^ip_2^j\\cdots p_1&#x27;^{~k}p_2&#x27;^{~l}\\cdots)\\\\ =\\sum\\limits_{i=0}^{c_1}\\sum\\limits_{j=0}^{c_2}\\cdots\\varphi(p_1^ip_2^j\\cdots)\\sum\\limits_{k=0}^{c_1&#x27;}\\sum\\limits_{l=0}^{c_2&#x27;}\\cdots\\varphi(p_1&#x27;^{~k}p_2&#x27;^{~l}\\cdots)\\\\ =\\sum_{f\\mid n}\\varphi(f)\\sum_{g\\mid m}\\varphi(g)\\\\ \\end{gather} d∣nm∑​φ(d)=i=0∑c1​​j=0∑c2​​⋯k=0∑c1′​​l=0∑c2′​​⋯φ(p1i​p2j​⋯p1′ k​p2′ l​⋯)=i=0∑c1​​j=0∑c2​​⋯φ(p1i​p2j​⋯)k=0∑c1′​​l=0∑c2′​​⋯φ(p1′ k​p2′ l​⋯)=f∣n∑​φ(f)g∣m∑​φ(g)​​ 所以 ∑d∣nφ(d)\\sum_{d\\mid n}\\varphi(d)∑d∣n​φ(d) 是积性函数。 设 nnn 的质因子种类共 kkk 种。 ∑d∣nφ(d)=∏i=1i≤k∑f∣piciφ(f)=∏i=1i≤k∑j=0j≤ciφ(pij)由等比数列求和公式可得∑j=0j≤ciφ(pij)=pici=∏i=1i≤kpici=n\\begin{gather} \\sum_{d\\mid n}\\varphi(d)=\\prod_{i=1}^{i\\le k}\\sum_{f\\mid p_i^{c_i}}\\varphi(f)\\\\ =\\prod_{i=1}^{i\\le k}\\sum_{j=0}^{j\\le c_i}\\varphi(p_i^j)\\\\ \\text{由等比数列求和公式可得}\\sum_{j=0}^{j\\le c_i}\\varphi(p_i^j)=p_i^{c_i}\\\\ =\\prod_{i=1}^{i\\le k}p_i^{c_i}\\\\ =n\\\\ \\end{gather} d∣n∑​φ(d)=i=1∏i≤k​f∣pici​​∑​φ(f)=i=1∏i≤k​j=0∑j≤ci​​φ(pij​)由等比数列求和公式可得j=0∑j≤ci​​φ(pij​)=pici​​=i=1∏i≤k​pici​​=n​​ 公式 单点计算公式：φ(n)=n×p1−1p1×p2−1p2×⋯×pm−1pm=n×∏质数p∣n(1−1p)\\varphi(n)=n \\times \\dfrac{p_{1}-1}{p_{1}} \\times \\dfrac{p_{2}-1}{p_{2}} \\times \\cdots \\times \\dfrac{p_{m}-1}{p_{m}}=n \\times \\prod_{\\text{质数} p \\mid n}\\left(1-\\dfrac{1}{p}\\right)φ(n)=n×p1​p1​−1​×p2​p2​−1​×⋯×pm​pm​−1​=n×∏质数p∣n​(1−p1​)。 感性理解：对于 nnn 的每个质因子 ppp 来说，1∼n1\\sim n1∼n 中有这个质因子的数在所有数中的比例为 1p\\dfrac{1}{p}p1​，这部分肯定无法与 nnn 互质，剩下 p−1p\\dfrac{p-1}{p}pp−1​ 可能与 nnn 互质，这是考虑一个质因子的情况。考虑所有质因子的情况就是 ∏质数p∣n(1−1p)\\prod_{\\text{质数}p\\mid n}\\left(1-\\dfrac{1}{p}\\right)∏质数p∣n​(1−p1​)，再乘上 1∼n1\\sim n1∼n 中整数个数。 递推式：φ(p×i)=φ(i)×{p(p∣i)p−1(p∤i)\\varphi(p\\times i)=\\varphi(i)\\times\\begin{cases}p&amp;(p\\mid i)\\\\p-1&amp;(p\\nmid i)\\end{cases}φ(p×i)=φ(i)×{pp−1​(p∣i)(p∤i)​。 由性质 3、4 可得。 代码 单点质数筛 试除法 区间质数筛 埃氏筛 线性筛 自由区间质数筛 双筛法（筛小素数再筛区间素数） 单点质因数分解 试除法 单点欧拉函数——质因数分解（求值公式） 区间欧拉函数——线性法（积性性质） 自由区间欧拉函数——双筛法（求值公式） 二. 约数 性质 nnn 的约数个数上界：2n2\\sqrt{n}2n​。 试除法的推论。 1∼n1\\sim n1∼n 每个数约数个数的总和：约 nlog⁡nn\\log nnlogn。 倍数法的推论： 估算每个数的约数和比较难，可以反过来考虑每个数的贡献，即每个数会作为多少个数（1∼n1\\sim n1∼n 内）的约数。 1∼n1\\sim n1∼n 的贡献分别是 n1,n2,n3⋯nn\\dfrac{n}{1},\\dfrac{n}{2},\\dfrac{n}{3}\\cdots\\dfrac{n}{n}1n​,2n​,3n​⋯nn​，可发现个数约是 nlog⁡nn\\log nnlogn。 0∼2×1090\\sim 2\\times 10^90∼2×109 中约数个数最多的数的约数个数是 160016001600。 公式 正约数个数：(c1+1)×(c2+1)×⋯×(cm+1)=∏i=1m(ci+1)\\left(c_{1}+1\\right) \\times\\left(c_{2}+1\\right) \\times \\cdots \\times\\left(c_{m}+1\\right)=\\prod_{i=1}^{m}\\left(c_{i}+1\\right)(c1​+1)×(c2​+1)×⋯×(cm​+1)=∏i=1m​(ci​+1)。 正约数和：(1+p1+p12+⋯+p1c1)×⋯×(1+pm+pm2+⋯+pmcm)=∏i=1m(∑j=0ci(pi)j)\\left(1+p_{1}+p_{1}^{2}+\\cdots+p_{1}^{c_{1}}\\right) \\times\\cdots \\times\\left(1+p_{m}+p_{m}^{2}+\\cdots+p_{m}^{c_{m}}\\right)=\\prod_{i=1}^{m}\\left(\\sum_{j=0}^{c_{i}}\\left(p_{i}\\right)^{j}\\right)(1+p1​+p12​+⋯+p1c1​​)×⋯×(1+pm​+pm2​+⋯+pmcm​​)=∏i=1m​(∑j=0ci​​(pi​)j)。 证明：使用组合数证明即可。 代码 gcd lcmgcd~lcmgcd lcm 单点约数筛 试除法 区间约数筛 倍数法（埃氏） 三. 余数 概念 对于 ∀a∈[0,m−1]\\forall a \\in[0, m-1]∀a∈[0,m−1]，合 {a+km}(k∈Z)\\{a+k m\\}(k \\in \\mathbb{Z}){a+km}(k∈Z) 的所有数模 mmm 同余，余数都是 a0a_{0}a0​ 该集合称为一个模 mmm 的同余类，简记为 aˉ\\bar{a}aˉ 。 模 mmm 的同余类一共有 mmm 个，分别为 0‾,1‾,2‾,⋯ ,m−1‾\\overline{0}, \\overline{1}, \\overline{2}, \\cdots, \\overline{m-1}0,1,2,⋯,m−1​ 。它们构成 mmm 的完全剩余系。 1∼m1 \\sim m1∼m 中与 mmm 互质的数代表的同余类共有 φ(m)\\varphi(m)φ(m) 个，它们构成 mmm 的简化剩余系。 例如, 模 10 的简化剩余系为 {1‾,3‾,7‾,9‾}\\{\\overline{1}, \\overline{3}, \\overline{7}, \\overline{9}\\}{1,3,7,9} 。 乘法封闭：集合中的任意两个元素进行乘法运算，得到的结果还在这个集合中。 简化剩余系的性质：mmm 的简化剩余系关于 mmm 乘法封闭。 证明：设 mmm 的简化剩余系中两数为 a,ba,ba,b，则 a×ba\\times ba×b 也与 mmm 互质，根据余数的性质， a×b mod ma\\times b\\bmod ma×bmodm 也与 mmm 互质。 若整数 b,mb, mb,m 互质，并且 b∣ab \\mid ab∣a，则存在一个整数 xxx，使得 a/b≡a×x( mod m)a / b \\equiv a \\times x(\\bmod m)a/b≡a×x(modm) 。称 xxx 为 bbb 的模 mmm 乘法逆元，记为 b−1( mod m)b^{-1}(\\bmod m)b−1(modm)。因为 a/b≡a×b−1≡a/b×b×b−1( mod m)a / b \\equiv a \\times b^{-1} \\equiv a / b \\times b \\times b^{-1}(\\bmod m)a/b≡a×b−1≡a/b×b×b−1(modm)，所以 b×b−1≡1( mod m)b \\times b^{-1} \\equiv 1(\\bmod m)b×b−1≡1(modm)。 定理 / 公式 欧拉定理：若正整数 x,nx, nx,n 互质，则 xφ(n)≡1( mod n)x^{\\varphi(n)} \\equiv 1(\\bmod n)xφ(n)≡1(modn)，其中 φ(n)\\varphi(n)φ(n) 为欧拉函数。 证明：设集合 SSS 为 nnn 的简化剩余系，记作 {a‾1,a‾2⋯a‾φ(n)}\\{\\overline{a}_1,\\overline{a}_2\\cdots\\overline{a}_{\\varphi(n)}\\}{a1​,a2​⋯aφ(n)​}，TTT 为 nnn 的简化剩余系中所有数乘上 xxx 构成的集合，记作 {x×a‾1,x×a‾2⋯x×a‾φ(n)}\\{\\overline{x\\times a}_1,\\overline{x\\times a}_2\\cdots \\overline{x\\times a}_{\\varphi(n)}\\}{x×a​1​,x×a​2​⋯x×a​φ(n)​}。 证明所有 TTT 中元素都在 SSS 中： 因为 x,nx,nx,n 互质，所以 gcd⁡(x,n)=1\\gcd(x,n)=1gcd(x,n)=1，所以 gcd⁡(x mod n,n)=1\\gcd(x\\bmod n, n)=1gcd(xmodn,n)=1。又因为简化剩余系具有乘法封闭的性质，所以 x×ai∈Sx\\times a_i\\in Sx×ai​∈S 证明所有 TTT 中元素在模意义下不重复： 反证法。若 aia_iai​ 和 aja_jaj​ 是 SSS 中两个不同元素，且 x×ai≡x×aj( mod n)x\\times a_i\\equiv x\\times a_j(\\bmod n)x×ai​≡x×aj​(modn)，则 x×(ai−aj)≡0( mod n)x\\times(a_i-a_j)\\equiv0(\\bmod n)x×(ai​−aj​)≡0(modn)。又因为 x≢0( mod n)x\\not\\equiv 0(\\bmod n)x≡0(modn)，所以 ai−aj≡0( mod n)a_i-a_j\\equiv 0(\\bmod n)ai​−aj​≡0(modn)，ai≡aj( mod n)a_i\\equiv a_j(\\bmod n)ai​≡aj​(modn)。矛盾。 证明 S=TS=TS=T： 因为 1 和 2，又因为 SSS、TTT 中元素数量相等，所以 S=TS=TS=T。 证明定理： ∵xφ(n)a1a2⋯aφ(n)≡(xa1)(xa2)⋯(xaφ(n))≡a1a2⋯aφ(n)( mod n)∴aφ(n)≡1( mod n)\\begin{gather} \\because x^{\\varphi(n)}a_1a_2\\cdots a_{\\varphi(n)}\\equiv (xa_1)(xa_2)\\cdots(xa_{\\varphi(n)})\\equiv a_1a_2\\cdots a_{\\varphi(n)}(\\bmod n)\\\\ \\therefore a^{\\varphi(n)}\\equiv 1(\\bmod n)\\\\ \\end{gather} ∵xφ(n)a1​a2​⋯aφ(n)​≡(xa1​)(xa2​)⋯(xaφ(n)​)≡a1​a2​⋯aφ(n)​(modn)∴aφ(n)≡1(modn)​​ 费马小定理：若 ppp 是质数，则对于任意整数 aaa，有 ap≡a( mod p)a^{p} \\equiv a(\\bmod p)ap≡a(modp)。 欧拉定理中 nnn 为质数，两边同乘 aaa 的情况。 欧拉定理推论1：若正整数 a,na, na,n 互质，则对于任意正整数 bbb，有 ab≡ab mod φ(n)( mod n)a^{b} \\equiv a^{b \\bmod \\varphi(n)}(\\bmod n)ab≡abmodφ(n)(modn)。 证明：设 b=k×φ(n)+rb=k\\times \\varphi(n)+rb=k×φ(n)+r。 ∵ab≡ab( mod n),aφ(n)≡1( mod n)∴ab×(1−1)k≡ab×((aφ(n))−1)k( mod n)ab≡ab mod φ(n)( mod n)\\begin{gather} \\because a^b\\equiv a^b(\\bmod n),a^{\\varphi(n)}\\equiv 1(\\bmod n)\\\\ \\therefore a^b\\times (1^{-1})^k\\equiv a^b\\times ((a^{\\varphi(n)})^{-1})^k(\\bmod n)\\\\ a^b\\equiv a^{b \\bmod \\varphi(n)}(\\bmod n)\\\\ \\end{gather} ∵ab≡ab(modn),aφ(n)≡1(modn)∴ab×(1−1)k≡ab×((aφ(n))−1)k(modn)ab≡abmodφ(n)(modn)​​ 欧拉定理推论2：当 a,na, na,n 不一定互质且 b&gt;φ(n)b&gt;\\varphi(n)b&gt;φ(n) 时, 有 ab≡ab mod φ(n)+φ(n)( mod n)a^{b} \\equiv a^{b \\bmod \\varphi(n)+\\varphi(n)}(\\bmod n)ab≡abmodφ(n)+φ(n)(modn)。 证明：略。 裴蜀定理：对于任意整数 a,ba, ba,b，存在一对整数 x,yx, yx,y，满足 ax+by=gcd⁡(a,b)a x+b y=\\operatorname{gcd}(a, b)ax+by=gcd(a,b)。 证明： b=0b=0b=0 时，有 {x=0y=1\\begin{cases}x=0\\\\y=1\\end{cases}{x=0y=1​ 满足。 b&gt;0b&gt;0b&gt;0 时。设 b×x′+(a mod b)×y′=gcd⁡(b,a mod b)b\\times x&#x27;+(a\\bmod b)\\times y&#x27;=\\gcd(b,a\\bmod b)b×x′+(amodb)×y′=gcd(b,amodb)。 b×x′+(a−⌊ab⌋×b)×y′=gcd(a,b)a×y′+b×(x′−⌊ab⌋×y′)=gcd(a,b)b\\times x&#x27;+(a-\\left\\lfloor \\dfrac{a}{b}\\right\\rfloor\\times b)\\times y&#x27;=gcd(a,b)\\\\ a\\times y&#x27;+b\\times(x&#x27;-\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor\\times y&#x27;)=gcd(a,b) b×x′+(a−⌊ba​⌋×b)×y′=gcd(a,b)a×y′+b×(x′−⌊ba​⌋×y′)=gcd(a,b) 所以，有 {x=y′y=x′−⌊ab⌋×y′\\begin{cases}x=y&#x27;\\\\y=x&#x27;-\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor\\times y&#x27;\\end{cases}{x=y′y=x′−⌊ba​⌋×y′​ 满足。 方程 ax+by=ca x+b y=cax+by=c 的通解：x=cdx0+kbd,y=cdy0−kad(k∈Z)x=\\frac{c}{d} x_{0}+k \\frac{b}{d},\\quad y=\\frac{c}{d} y_{0}-k \\frac{a}{d}(k \\in \\mathbb{Z})x=dc​x0​+kdb​,y=dc​y0​−kda​(k∈Z)。 代码 exgcdexgcdexgcd 求逆元 单点——exgcdexgcdexgcd、费马小定理 区间——线性求逆元 任意 nnn 数——前缀积 crtcrtcrt","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P1654 OSU!","slug":"OSU!","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/07/21/OSU!/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/OSU!/","excerpt":"","text":"P1654 OSU! 放在前面：这是一道期望dp大水题，属于那种看题解一看就会，自己写一写就废的那种。 一. 思路 （不想看我前面唠叨就直接看代码吧） 1. 确定状态转移方程 did_idi​：iii 次操作后得的分数。则 E(di)E(d_i)E(di​)：iii 次操作后期望的的分数。 第 iii 轮后，得分发生了怎样的变化了呢？我们先只看从最近一次失败后算起的成功的一段，iii 轮前得分是 x3x^3x3，如果低 iii 次成功，iii 轮后是 (x+1)3=x3+3x2+3x+1(x+1)^3=x^3+3x^2+3x+1(x+1)3=x3+3x2+3x+1，反之是 000。变化了 3x2+3x+13x^2+3x+13x2+3x+1。再加上之前的得分 di−1d_{i-1}di−1​。 综上所述，已知成败情况的状转方程： xi={0(fail)xi−1+1(success)x_i=\\begin{cases}0&amp;(fail)\\\\x_{i-1}+1&amp;(success)\\end{cases}xi​={0xi−1​+1​(fail)(success)​ x2i={0(fail)x2i−1+2xi−1+1(success){x^2}_i=\\begin{cases}0&amp;(fail)\\\\{x^2}_{i-1}+2x_{i-1}+1&amp;(success)\\end{cases}x2i​={0x2i−1​+2xi−1​+1​(fail)(success)​ di=di−1+{0(fail)3x2i−1+3xi−1+1(success)d_i=d_{i-1}+\\begin{cases}0&amp;(fail)\\\\3{x^2}_{i-1}+3x_{i-1}+1&amp;(success)\\end{cases}di​=di−1​+{03x2i−1​+3xi−1​+1​(fail)(success)​ 设第 iii 次成功的几率为 probiprob_iprobi​。 综上所述，期望状转方程： E(x)i=probi×(E(x)i−1+1)+(1−probi)×0=probi×(E(x)i−1+1)E(x2)i=probi×(E(x2)i−1+2E(x)i−1+1)+(1−probi)×0=probi×(E(x2)i−1+2E(x)i−1+1)E(d)i=E(d)i−1+probi×(3E(x2)i−1+3E(x)i−1+1)+(1−probi)×0=E(d)i−1+probi×(3E(x2)i−1+3E(x)i−1+1)\\begin{aligned} E(x)_i&amp;=prob_i\\times (E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &amp;=prob_i\\times (E(x)_{i-1}+1) \\\\ E({x^2})_i&amp;=prob_i\\times(E({x^2})_{i-1}+2E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &amp;=prob_i\\times(E({x^2})_{i-1}+2E(x)_{i-1}+1) \\\\ E(d)_i&amp;=E(d)_{i-1}+prob_i\\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &amp;=E(d)_{i-1}+prob_i\\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1) \\\\ \\end{aligned} E(x)i​E(x2)i​E(d)i​​=probi​×(E(x)i−1​+1)+(1−probi​)×0=probi​×(E(x)i−1​+1)=probi​×(E(x2)i−1​+2E(x)i−1​+1)+(1−probi​)×0=probi​×(E(x2)i−1​+2E(x)i−1​+1)=E(d)i−1​+probi​×(3E(x2)i−1​+3E(x)i−1​+1)+(1−probi​)×0=E(d)i−1​+probi​×(3E(x2)i−1​+3E(x)i−1​+1)​ 2. 坑点 E(a2)≠E(a)2E(a^2)\\ne E(a)^2E(a2)=E(a)2 也就是说，不能将状转方程中的 E(x2)E(x^2)E(x2) 用 E(x)E(x)E(x) 表示。 d≠x3d\\ne x^3d=x3 ddd 比 x3x^3x3 还额外需要考虑之前的累计得分，也就是 did_idi​ 要加上 di−1d_{i-1}di−1​。 E(d)E(d)E(d)、E(x2)E(x^2)E(x2) 和 E(x)E(x)E(x) 更新的顺序 如果你不开数组，就要格外注意这一点。ddd 的期望状转方程中用到 E(d)E(d)E(d)、 E(x2)E(x^2)E(x2) 和 E(x)E(x)E(x)；x2x^2x2 的用到 E(x2)E(x^2)E(x2) 和 E(x)E(x)E(x)；xxx 的只用到自己，并且用的都是上一阶段的。所以先刷新 E(d)E(d)E(d)，再刷新 E(x2)E(x^2)E(x2)，最后 E(x)E(x)E(x)。 二. 代码 123456789101112#include&lt;cstdio&gt;int n; double prob, d, x2, x;int main() &#123; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; scanf(&quot;%lf&quot;, &amp;prob); d = d + prob * (3 * x2 + 3 * x + 1); x2 = prob * (x2 + 2 * x + 1); x = prob * (x + 1); &#125; printf(&quot;%.1lf&quot;, d);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P2432 zxbsmk爱查错","slug":"zxbsmk爱查错","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/zxbsmk爱查错/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/zxbsmk%E7%88%B1%E6%9F%A5%E9%94%99/","excerpt":"","text":"P2432 zxbsmk爱查错 一. 审题： 1.已知&amp;输入： 给出一个长度为 LLL 的文本串。 给出 WWW 个单词串。 2.目标&amp;输出： 在文本串中删除尽量少的字母使得文本串只有由词串构成，输出这个最少删除的字母数。 二. 思路 1. 思考解法 文本串后面的内容不会影响文本串前半部分的最优解，符合无后效性。 若把文本串右端位置作为状态，文本串右端位置较靠右的状态需要通过文本串右端位置较靠左的状态得到（如 did_idi​ 需要通过 d0…di−1d_0 \\dots d_{i-1}d0​…di−1​ 的其中之一得到），符合子问题重叠性。 所以考虑DP。 2. 确定状态转移方程 did_idi​：前 iii 个子母的文本串中最少删除的字母数。 txtidxtxtidxtxtidx：用该第 jjj 个单词串匹配前 iii 个子母的文本串，匹配完时文本串的下标。（3. 中有详解） delcntdelcntdelcnt：用该第 jjj 个单词串匹配前 iii 个子母的文本串，匹配过程中失配的次数。（3. 中有详解） seccessmatchseccessmatchseccessmatch：用该第 jjj 个单词串匹配前 iii 个子母的文本串，是否匹配成功。（3. 中有详解） 综上所述，状转方程：di=min⁡j=1W{di−1+1(seccessmatch=false)dtxtidx+delcnt(seccessmatch=true)d_i=\\min_{j=1}^{W}\\begin{cases}d_{i-1}+1&amp;(seccessmatch=false)\\\\d_{txtidx}+delcnt&amp;(seccessmatch=true)\\end{cases}di​=minj=1W​{di−1​+1dtxtidx​+delcnt​(seccessmatch=false)(seccessmatch=true)​ 3.细节&amp;详解 反正跟字符串有关题的题解，没图我是看不懂。 比如文本串是 cabbcxyz ，我们现在正在求 d5d_5d5​ （i=5i=5i=5） 用其中一个单词串 abc 匹配，用某个单词匹配时不用管其他单词。 初始时把 txtidxtxtidxtxtidx 设为 iii （也就是 555），wordidxwordidxwordidx 设为单词长度， delcntdelcntdelcnt 设为 000 。（注意 delnumdelnumdelnum 不是整个文本串删去的字母个数，而是当前情况下匹配过部分的文本串的删去字母个数。3. 中有详解） 初始时： 第一次匹配后： 第二次匹配后： 第三次匹配后： 第四次匹配后： 三. 代码 代码中有比较详细的注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXwordcnt = 600;//单词数量最大值 const int MAXwordlen = 25;//单词长度最大值 const int MAXtxtlen = 300;//文本长度最大值 int wordcnt/*单词数量*/, txtlen/*文本长度*/;char word[MAXwordcnt + 10][MAXwordlen + 10]/*单词*/, txt[MAXtxtlen + 10]/*文本*/;int d[MAXtxtlen];//DP数组 int main() &#123; scanf(&quot;%d %d&quot;, &amp;wordcnt, &amp;txtlen); scanf(&quot;%s&quot;, txt + 1); for (int i = 1; i &lt;= wordcnt; ++i) &#123; scanf(&quot;%s&quot;, word[i] + 1); &#125; d[0] = 0; for (int i = 1; i &lt;= txtlen; ++i) &#123; d[i] = d[i - 1] + 1;//如果没有单次得以再次位置匹配，需要删除的单词数++ for (int j = 1; j &lt;= wordcnt; ++j) &#123; int wordidx = strlen(word[j] + 1);//此时单词串的下标 int txtidx;//此时文本串的下标 int delcnt = 0;//当前情况下匹配过部分的文本串的删去字母个数 bool seccessmatch = 0;//是否匹配成功 for (txtidx = i; txtidx &gt;= 1; --txtidx) &#123; if (wordidx == 0) &#123;//wordidx == 0代表单词已经匹配完了 seccessmatch = 1; break; &#125; if (txt[txtidx] == word[j][wordidx]) &#123;//如果单词串与文本串在该位置相同... --wordidx; //那么匹配下一位 &#125; else &#123; //否则... ++delcnt; //需要删的个数++ &#125; &#125; if (wordidx == 0) &#123;//wordidx == 0代表单词已经匹配完了 seccessmatch = 1; &#125; if (seccessmatch) &#123; //如果成功匹配... d[i] = min(d[i], d[txtidx] + delcnt);//转移状态 &#125; &#125; &#125; printf(&quot;%d&quot;, d[txtlen]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"UVA 1025 城市里的间谍 A Spy in the Metro","slug":"城市里的间谍","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/城市里的间谍/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%9F%8E%E5%B8%82%E9%87%8C%E7%9A%84%E9%97%B4%E8%B0%8D/","excerpt":"","text":"UVA1025 城市里的间谍 A Spy in the Metro （本题有多倍经验哦） 一. 思路 1. 思考解法 时间 是个好的 DP 阶段，时间轴上靠后发生的不会影响前面的事，反映到本题上就是 Maria 之后怎么走不会影响现在的最优解，符合无后效性。 Maria 既可以乘向东的地铁，又可以乘向西的地铁，还可以呆着不动。那么一种情况可以由多种情况而来，多种情况也可以发展成一种情况，各种情况互相交织，符合子问题重叠性。 所以考虑 DP。 2. 前缀和初始化 题目给出了站的时间间距和每列地铁发车时的时间（只会从首末两站发车），事实上，地铁在前进中到达每站的时间就是个前缀和 （偷偷点开标签我们也可以看到前缀和），到达某站的时间就是前面所有站时间间距之和，当然还要加上发车时间。 3. DP 我采用的是 刷表法，当然，填表法 也可以。 所需条件： stabetistabet_istabeti​：站 i−1i-1i−1 与站 iii 间相隔的时间。 canrighti,j(canlefti,j)canright_{i,j}(canleft_{i,j})canrighti,j​(canlefti,j​)：iii 时刻 jjj 站是否有开向末站（首站）的火车。 di,jd_{i,j}di,j​：得到 iii 时刻在 jjj 站这种状态最少的停留时间。 通过前缀和我们已经得到 canrightcanrightcanright 以及canleftcanleftcanleft 数组。接下来就是状态转移了。 初始状态： 易得，应初始化为： di,j={0(i=0 ∧ j=1)∞(else)d_{i,j}=\\begin{cases}0&amp;(i=0~\\land~j=1)\\\\\\infty&amp;(else)\\end{cases}di,j​={0∞​(i=0 ∧ j=1)(else)​ 其中 ∞\\infty∞ 代表无法到达。 状态转移： 因为本题的阶段之间不像普通的0/1背包那样只会由上一阶段转移到，而是也会由很多个单位时间之前的阶段转移到（站与站之间的时间不止1），所以我选择多维数组而非滚动数组。 首先，无论此刻此站有没有地铁，都可以在本站等待，这是普遍的转移；另外，如果此刻此站恰好有地铁，可以做特殊的转移。 综上所述，状转方程：（因为是刷表法，状转方程不方便写在一个括号里，蒟蒻就这么写了 qwq） （self⁡\\operatorname{self}self 代表自己） di,j=min⁡(self⁡, di−1,j+1)(i&gt;0)di+stabetj+1,j+1=min⁡(self⁡, di,j)(canrighti,j=true)di+stabetj,j−1=min⁡(self⁡, di,j)(canlefti,j=true)\\begin{aligned} &amp;d_{i,j}=\\min(\\operatorname{self},~d_{i-1,j}+1)&amp;(i&gt;0) \\\\ &amp;d_{i+stabet_{j+1},j+1}=\\min(\\operatorname{self},~d_{i,j})&amp;(canright_{i,j}=true) \\\\ &amp;d_{i+stabet_j,j-1}=\\min(\\operatorname{self},~d_{i,j})&amp;(canleft_{i,j}=true) \\\\ \\end{aligned} ​di,j​=min(self, di−1,j​+1)di+stabetj+1​,j+1​=min(self, di,j​)di+stabetj​,j−1​=min(self, di,j​)​(i&gt;0)(canrighti,j​=true)(canlefti,j​=true)​ 结果状态： dT,nd_{T,n}dT,n​ 二. 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 50;const int MAXT = 2000;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, T, stabet[MAXn + 10], rightcnt, leftcnt; bool canright[MAXT + 10][MAXn + 10], canleft[MAXT + 10][MAXn + 10]; int d[MAXT + 10][MAXn + 10]; int main() &#123; int k = 0; read(n); while (n) &#123; ++k; memset(canright, 0, sizeof(canright)); // memset(canleft, 0, sizeof(canleft)); //多组数据要初始化 memset(d, 0x3f, sizeof(d)); // read(T); for (int i = 2; i &lt;= n; ++i) &#123; read(stabet[i]); &#125; int time; // read(rightcnt); // for (int i = 1; i &lt;= rightcnt; ++i) &#123; // read(time); // canright[time][1] = 1; // for (int j = 2; j &lt;= n; ++j) &#123; // time += stabet[j]; // canright[time][j] = 1; // &#125; // &#125; //边读入边用前缀和计算canright和canleft数组 read(leftcnt); // for (int i = 1; i &lt;= leftcnt; ++i) &#123; // read(time); // canleft[time][n] = 1; // for (int j = n - 1; j &gt;= 1; --j) &#123; // time += stabet[j + 1]; // canleft[time][j] = 1; // &#125; // &#125; // d[0][1] = 0; for (int i = 0; i &lt;= T; ++i) &#123; // for (int j = 1; j &lt;= n; ++j) &#123; // if (i) // d[i][j] = min(d[i][j], // d[i - 1][j] + 1); // if (canright[i][j]) // d[i + stabet[j + 1]][j + 1] = min(d[i + stabet[j + 1]][j + 1], //动态规划 d[i][j] );// if (canleft[i][j]) // d[i + stabet[j]][j - 1] = min(d[i + stabet[j]][j - 1], // d[i][j] ); // &#125; // &#125; // if (d[T][n] == INF) &#123; printf(&quot;Case Number %d: impossible\\n&quot;, k); &#125; else &#123; printf(&quot;Case Number %d: %d\\n&quot;, k, d[T][n]); &#125; read(n); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"对拍","slug":"对拍","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/对拍/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%AF%B9%E6%8B%8D/","excerpt":"","text":"在 OI 赛制 中，代码只能交一次，这是比赛与 OJ 最大的不同。我们如果不能保证代码是正确的，就需要对拍： code1/2.cpp：暴力及正解代码。 random.cpp：随机数据生成器。 match.cpp：对拍程序： 一. 对拍程序 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstdlib&gt;int T = 100;signed main() &#123; while (T--) &#123; system(&quot;./random &gt; in.txt&quot;); system(&quot;./1 &lt; in.txt &gt; 1.txt&quot;); system(&quot;./2 &lt; in.txt &gt; 2.txt&quot;); if (system(&quot;diff -b 1.txt 2.txt&quot;)) &#123; printf(&quot;Error!!!\\n&quot;); exit(1); &#125; else &#123; printf(&quot;Ok\\n&quot;); &#125; &#125;&#125; 注意头文件。 二. 随机数程序 主推 mt19937 （需要 c++11）。随机数范围到 219937−12^{19937}-1219937−1。完全不用担心不够用，具体实例： 1234567#include&lt;random&gt;#include&lt;ctime&gt;using namespace std;mt19937 rd(time(0));int random(int l, int r) &#123; return rd() % (r - l + 1) + l;&#125; 三. 图像示例 Your browser does not support the video tag.","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"Luogu P3868 [TJOI2009]猜数字","slug":"猜数字","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/猜数字/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%8C%9C%E6%95%B0%E5%AD%97/","excerpt":"","text":"P3868 [TJOI2009]猜数字 一. 思路 首先拿道题看到条件给出两组数，其中一组互素，让猜一个数字。自然而然往 crt 上想。但为什么是 crt 呢？ ∀i∈[1,k]\\forall i \\in [1,k]∀i∈[1,k]，有 bi∣(n−ai)b_i \\mid (n - a_i)bi​∣(n−ai​)，这句话可以化为一组同余方程，再移项可得标准的 crt 格式： {n−a1≡0(mod⁡ b1)n−a2≡0(mod⁡ b2)⋯n−ak≡0(mod⁡ bk) ⟹{n≡a1(mod⁡ b1)n≡a2(mod⁡ b2)⋯n≡ak(mod⁡ bk)~~~~~~~~~~~~~~\\begin{cases} n - a_1 \\equiv 0 &amp;(\\operatorname{mod}~b_1) \\\\ n - a_2 \\equiv 0 &amp;(\\operatorname{mod}~b_2) \\\\ \\cdots \\\\ n - a_k \\equiv 0 &amp;(\\operatorname{mod}~b_k) \\\\ \\end{cases} \\\\ ~\\\\ \\Longrightarrow\\begin{cases} n \\equiv a_1 &amp;(\\operatorname{mod}~b_1) \\\\ n \\equiv a_2 &amp;(\\operatorname{mod}~b_2) \\\\ \\cdots \\\\ n \\equiv a_k &amp;(\\operatorname{mod}~b_k) \\\\ \\end{cases} ⎩⎨⎧​n−a1​≡0n−a2​≡0⋯n−ak​≡0​(mod b1​)(mod b2​)(mod bk​)​ ⟹⎩⎨⎧​n≡a1​n≡a2​⋯n≡ak​​(mod b1​)(mod b2​)(mod bk​)​ 然后 crt 求解就好了。crt ——中国剩余定理就是提供了一个解同余方程组 {x≡a1(mod⁡ m1)x≡a2(mod⁡ m2)⋯x≡an(mod⁡ mn)\\begin{cases}x \\equiv a_1 &amp;(\\operatorname{mod}~m_1) \\\\ x \\equiv a_2 &amp;(\\operatorname{mod}~m_2) \\\\ \\cdots \\\\ x \\equiv a_n &amp;(\\operatorname{mod}~m_n) \\\\ \\end{cases}⎩⎨⎧​x≡a1​x≡a2​⋯x≡an​​(mod m1​)(mod m2​)(mod mn​)​ 的公式，即 x=∑i=1n{ai×Mi×ti}x = \\sum\\limits_{i = 1}^{n} \\{ a_i \\times M_i \\times t_i \\}x=i=1∑n​{ai​×Mi​×ti​}，其中 Mi=∏j=1nmjmiM_i = \\dfrac{\\prod\\limits_{j = 1}^{n}m_j}{m_i}Mi​=mi​j=1∏n​mj​​， ti=inv⁡(Mi)t_i = \\operatorname{inv}(M_i)ti​=inv(Mi​)。公式的推导详见 OI-Wiki。 二. 坑点 交代码上去一看，为什么只有 90 分？最后一个点 WA 掉了，并且显示第一行第一列输出了减号。看来是爆 long long 了。所以需要龟速快速乘防止爆 long long。（本蒟蒻不会long double） 三. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 10;template &lt;typename T&gt;inline T qmul(T x, T y, T mod) &#123; if (x == 0 || y == 0) return 0; T ret = 0; while (y) &#123; if (y &amp; 1) ret = ((ret % mod) + (x % mod)) % mod; y &gt;&gt;= 1; x = ((x % mod) + (x % mod)) % mod; &#125; return ret;&#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int a, int m) &#123; int k, inv; exgcd(a, m, inv, k); return (inv % m + m) % m;&#125;int crt(int cnta, int *a, int *m) &#123; int prod = 1, ans = 0; for (re int i = 1; i &lt;= cnta; ++i) &#123; prod *= m[i]; &#125; for (re int i = 1, M; i &lt;= cnta; ++i) &#123; M = prod / m[i]; ans = (ans + qmul(qmul(a[i], M, prod), inv(M, m[i]), prod)) % prod; &#125; return ans;&#125;int n, a[MAXn + 10], m[MAXn + 10];signed main() &#123; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;m[i]); &#125; printf(&quot;%lld\\n&quot;, crt(n, a, m));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P3601 签到题","slug":"签到题","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/签到题/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%AD%BE%E5%88%B0%E9%A2%98/","excerpt":"","text":"P3601 签到题 一. 思路 1≤l≤r≤10121 \\le l \\le r \\le 10^{12}1≤l≤r≤1012，r−l≤106r-l \\le 10^6r−l≤106。很显然，传统的用欧拉函数是积性函数这条性质的从 111 扫到区间右端的方法肯定不行。 虽然传统的方法不行。但欧拉函数还有一条有用的公式：φ(n)=n×∏i=1npi−1pi\\varphi(n)=n \\times \\prod\\limits_{i=1}^{n}\\dfrac{p_i-1}{p_i}φ(n)=n×i=1∏n​pi​pi​−1​ 。也就是说，我们只要知道 l∼rl \\sim rl∼r 中所有数的质因数分解就好了。不难发现一个数 nnn 的质因数中有一个或零个大于 n\\sqrt{n}n​ 。那么我们把小于等于 r\\sqrt{r}r​ 的质数姑且称为“小质数”；大于 r\\sqrt{r}r​ 的叫“大质数”。 先预处理出所有小质数（也就是 1∼1061 \\sim 10^61∼106 内的）开一个数组 invinvinv 每个位置预处理为下标的值（就是 φ(n)=n×∏i=1npi−1pi\\varphi(n)=n \\times \\prod\\limits_{i=1}^{n}\\dfrac{p_i-1}{p_i}φ(n)=n×i=1∏n​pi​pi​−1​ 中的等式右边的 nnn），然后用倍数法枚举所有小质数在 l∼rl \\sim rl∼r 区间中的倍数，将相应的 inviinv_iinvi​ 乘上 ∏i=1npi−1pi\\prod\\limits_{i=1}^{n}\\dfrac{p_i-1}{p_i}i=1∏n​pi​pi​−1​。 当然，不要忘了大质数，因为每个数至多有一个大质数，所以大质数也很好处理。开一个数组 bidprimebidprimebidprime 全初始化为下标。用倍数法枚举 primeiprime_iprimei​ 的倍数枚举到相应的 invjinv_jinvj​ 时，顺便把 bigprimejbigprime_jbigprimej​ 中所有的的因数 primeiprime_iprimei​ 剔除。最后就得到了每个数的大质数。 二. 细节 最重要的细节就是枚举小指数的倍数时从几枚举了。设该小质数为 ppp，区间左端点为 lll 。答案是 max⁡{p2,⌈lp⌉×p}\\max\\{ p^2, \\left\\lceil\\dfrac{l}{p}\\right\\rceil \\times p \\}max{p2,⌈pl​⌉×p}。 为什么呢？首先小于 p2p^2p2 的 ppp 的倍数在枚举 222，333 等比它更小的质数时就已经枚举过了。而 $\\left\\lceil\\dfrac{l}{p}\\right\\rceil \\times p $ 是大于等于 lll 的第一个 ppp 的倍数。 三. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register #define int long longconst int MAXprime = 1e6;const int MAXn = 1e6;const int MOD = 666623333;template &lt;class T&gt;inline T max(T a, T b) &#123; return a &gt; b ? a : b;&#125;int cntp, prime[MAXprime / 5 + 100];bool notp[MAXprime + 10];void PrimeSieve(int up) &#123; //线性筛不解释 notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) prime[++cntp] = i; int upj = up / i; for (re int j = 1; j &lt;= cntp &amp;&amp; prime[j] &lt;= upj; ++j) &#123; notp[i * prime[j]] = 1; if (!(i % prime[j])) break; &#125; &#125;&#125;int ans, l, r, phi[MAXn + 10], bigprime[MAXn + 10];signed main() &#123; PrimeSieve(MAXprime); scanf(&quot;%lld %lld&quot;, &amp;l, &amp;r); for (re int i = l; i &lt;= r; ++i) &#123; //初始化 phi[i - l] = bigprime[i - l] = i; &#125; for (re int i = 1; i &lt;= cntp; ++i) &#123; //倍数法：枚举所有小质数的倍数 for (re int j = max(prime[i] * prime[i], (int)ceil((double)l / prime[i]) * prime[i]); j &lt;= r; j += prime[i]) &#123; phi[j - l] = phi[j - l] / prime[i] * (prime[i] - 1); while (!(bigprime[j - l] % prime[i])) &#123; bigprime[j - l] /= prime[i]; &#125; &#125; &#125; for (re int i = l; i &lt;= r; ++i) &#123; //处理大质数 if (bigprime[i - l] &gt; 1) &#123; phi[i - l] = phi[i - l] / bigprime[i - l] * (bigprime[i - l] - 1); &#125; &#125; for (re int i = l; i &lt;= r; ++i) &#123; //求和 ans = (ans + i - phi[i - l]) % MOD; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"记一只小傻蜂","slug":"记一只小傻蜂","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/记一只小傻蜂/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E8%AE%B0%E4%B8%80%E5%8F%AA%E5%B0%8F%E5%82%BB%E8%9C%82/","excerpt":"","text":"今天，2021 年 6 月 28 日。 笃行楼 5 楼 第三机房，不足 40 cm 的狭窄门缝中，钻进了一只蜂。 这只蜂比较肥大，巨身修尾，青项金翅。 进来就盘旋在天花板上面，半天赶不下来。 傻死了，她要么一直撞灯管，要么一直盘旋着飞，给她掰了些饼干也不吃。 稍晚些的时候，杰从机房的外面进来了，但是杰哥要怎么把她从高度 4m 的高高天花板中再赶出去啊！ 天啊，她怎么一直在飞，真的不累吗。 放张照片： 又过了一会 她不知什么时候又飞到灯泡管上面了，半天一直没动静。 我好怕啊。 被杰哥一扫帚打下来，估计是没了。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rsdbkhusky.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"锁机","slug":"锁机","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/锁机/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%94%81%E6%9C%BA/","excerpt":"","text":"作为一名 OIerOIerOIer，我们时时刻刻都有被 jcjcjc 的风险。这事我们需要一款简单的锁机程序来锁死保护我们的电脑： 12345678910#include&lt;windows.h&gt; #include&lt;winable.h&gt; #include&lt;time.h&gt;int main() &#123; FreeConsole(); while(1) &#123; if (clock() &gt; 10000) break; BlockInput(1); &#125; &#125; 比如这就是一个 101010 秒钟的锁机 ，clock() 函数的单位是 msmsms。 如果无效试试用管理员身份运行。 小心别多数了个 000。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"Luogu P3833 [SHOI2012]魔法树","slug":"魔法树","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/魔法树/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%AD%94%E6%B3%95%E6%A0%91/","excerpt":"","text":"P3833 [SHOI2012]魔法树 放在前面的前面：本文有树剖图解 放在前面：一道树剖板子题，关于树剖的教程网上数不胜数，我就只 概述 一下，就不造轮子了，具体细节请见 OI WIKI。 一. 过程概述 0. 基础：邻接表，线段树。 1. 第一次 dfs： 求出该有根树（如果题目没明确根就任选一个）所有节点的父节点，深度，（以他为根的）子树的大小， 重儿子。 2. 第二次 dfs： 求出该有根树所有节点的 dfs 序—— dfsdfsdfs，每个 dfs 对应的节点编号—— dfsidxdfsidxdfsidx（i=dfsidxdfsii=dfsidx_{dfs_i}i=dfsidxdfsi​​），所在重链的链顶—— toptoptop，其子树中节点中 dfs 序最大的一个—— bottombottombottom。用途： dfsdfsdfs：若这棵树上本来就有权值需要用它辅助给线段树建树。本题中无用。 dfsidxdfsidxdfsidx：用他将线段树上节点的编号转化为线段树上节点的编号。 toptoptop：进行树链上操作时需要。（详见我的代码和 OI WIKI） bottombottombottom：进行子树上操作时需要。（详见我的代码和 OI WIKI） 3. 权值增减与查询： 详解见 OI WIKI，这里只放两张图： 树和dfs序： （madeby：大佬 EternalAlexander 的 OI Painter） 另一张dfs图： 有点先序遍历内味了，只不过不是根左右，而是根重轻。 由此也可发现：树上一条重链或一棵子树都是线段树上连续的一部分，这正是树剖的核心。 二. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include&lt;bits/stdc++.h&gt;using namespace std;#define re registertypedef long long LL;const int MAXn = 1e5;const int MAXm = MAXn - 1;template &lt;class T&gt;inline void read(T &amp;x) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T s(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;x = s;&#125;int cntnext, head[MAXn + 10], nex[MAXm + 10], to[MAXm + 10];//////inline void Insert(int from, int too) &#123; // nex[++cntnext] = head[from]; //邻接表 head[from] = cntnext; // to[cntnext] = too; //////&#125; struct Node &#123; //////线段树 LL sum; // int l; // int r; // LL add; //&#125;; //Node stt[MAXn * 4 + 10]; //void _BuildUseArray_(int nodeid, int l, int r, LL *array) &#123; // stt[nodeid].l = l; // stt[nodeid].r = r; // if (l == r) &#123; // stt[nodeid].sum = array[l]; // return; // &#125; // int mid = (l + r) &gt;&gt; 1; // _BuildUseArray_((nodeid &lt;&lt; 1), l, mid, array); // _BuildUseArray_((nodeid &lt;&lt; 1) + 1, mid + 1, r, array); // stt[nodeid].sum = (stt[(nodeid &lt;&lt; 1)].sum + stt[(nodeid &lt;&lt; 1) + 1].sum);&#125; //void _Build0_(int nodeid, int l, int r) &#123; // stt[nodeid].l = l; // stt[nodeid].r = r; // if (l == r) &#123; // return; // &#125; // int mid = (l + r) &gt;&gt; 1; // _Build0_((nodeid &lt;&lt; 1), l, mid); // _Build0_((nodeid &lt;&lt; 1) + 1, mid + 1, r); //&#125; //void _Spread_(int nodeid) &#123; // stt[(nodeid &lt;&lt; 1)].sum = ( stt[(nodeid &lt;&lt; 1)].sum + ((stt[(nodeid &lt;&lt; 1)].r - stt[(nodeid &lt;&lt; 1)].l + 1) * stt[nodeid].add) ); stt[(nodeid &lt;&lt; 1) + 1].sum = ( stt[(nodeid &lt;&lt; 1) + 1].sum + (stt[nodeid].add * (stt[(nodeid &lt;&lt; 1) + 1].r - stt[(nodeid &lt;&lt; 1) + 1].l + 1)) ); // stt[(nodeid &lt;&lt; 1)].add = (stt[(nodeid &lt;&lt; 1)].add + stt[nodeid].add); stt[(nodeid &lt;&lt; 1) + 1].add = (stt[(nodeid &lt;&lt; 1) + 1].add + stt[nodeid].add); // stt[nodeid].add = 0; /// &#125; ////////// 线段树 void _Add_(int nodeid, int l, int r, LL k) &#123; /// if (stt[nodeid].l &gt;= l &amp;&amp; stt[nodeid].r &lt;= r) &#123; // stt[nodeid].add = (stt[nodeid].add + k); // stt[nodeid].sum = (stt[nodeid].sum + k * (stt[nodeid].r - stt[nodeid].l + 1)); return; // &#125; // _Spread_(nodeid); // int mid = (stt[nodeid].l + stt[nodeid].r) &gt;&gt; 1; // if (l &lt;= mid) _Add_((nodeid &lt;&lt; 1), l, r, k); // if (mid &lt; r) _Add_((nodeid &lt;&lt; 1) + 1, l, r, k); // stt[nodeid].sum = (stt[(nodeid &lt;&lt; 1)].sum + stt[(nodeid &lt;&lt; 1) + 1].sum);&#125; //LL _Eva_(int nodeid, int l, int r) &#123; // if (stt[nodeid].l &gt;= l &amp;&amp; stt[nodeid].r &lt;= r) // return stt[nodeid].sum; // _Spread_(nodeid); // LL val = 0; // int mid = (stt[nodeid].l + stt[nodeid].r) &gt;&gt; 1; // if (l &lt;= mid) val = (val + _Eva_((nodeid &lt;&lt; 1), l, r)); // if (mid &lt; r) val = (val + _Eva_((nodeid &lt;&lt; 1) + 1, l, r)); return val; //&#125; //void BuildUseArray(int l, int r, LL *array) &#123; // _BuildUseArray_(1, l, r, array); //&#125; //void Build0(int l, int r) &#123; // memset(stt, 0, sizeof(stt)); // _Build0_(1, l, r); //&#125; //void Add(int l, int r, LL k) &#123; // _Add_(1, l, r, k); //&#125; //LL Eva(int l, int r) &#123; // return _Eva_(1, l, r); //&#125; //////线段树 int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];//树剖 int Dfs1(int nodeid, int fat, int deep) &#123; //// int size = 1; /// int maxsiz = 0; // int maxer = 0; // int eachsiz; // fa[nodeid] = fat; // dep[nodeid] = deep; // for (re int i = head[nodeid]; i; i = nex[i]) &#123; // eachsiz = Dfs1(to[i], nodeid, deep + 1); // size += eachsiz; // if (eachsiz &gt; maxsiz) &#123; // maxsiz = eachsiz; // maxer = to[i]; // &#125; // &#125; // siz[nodeid] = size; // hson[nodeid] = maxer; // return size; //&#125; // //int cntdfs, dfs[MAXn + 10], dfsidx[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10]; void Dfs2(int nodeid, int topp) &#123; // dfs[++cntdfs] = nodeid; // dfsidx[nodeid] = cntdfs; // top[nodeid] = topp; // if (hson[nodeid]) &#123; // Dfs2(hson[nodeid], topp); // for (int i = head[nodeid]; i; i = nex[i]) &#123; // if (to[i] != fa[nodeid] &amp;&amp; to[i] != hson[nodeid]) &#123; // Dfs2(to[i], to[i]); // &#125; // &#125; // &#125; // bottom[nodeid] = dfs[cntdfs]; //&#125; /// ////////// 树剖 void TreePathAdd(int x, int y, int k) &#123; /// while (top[x] != top[y]) &#123; // if (dep[top[x]] &gt; dep[top[y]]) &#123; // swap(x, y); // &#125; // Add(dfsidx[top[y]], dfsidx[y], k); // y = fa[top[y]]; // &#125; // if (dep[x] &gt; dep[y]) &#123; // swap(x, y); // &#125; // Add(dfsidx[x], dfsidx[y], k); //&#125; // //LL TreePathEva(int x, int y) &#123; // LL sum = 0; // while (top[x] != top[y]) &#123; // if (dep[top[x]] &gt; dep[top[y]]) &#123; // swap(x, y); // &#125; // sum += Eva(dfsidx[top[y]], dfsidx[y]); // y = fa[top[y]]; // &#125; // if (dep[x] &gt; dep[y]) &#123; // swap(x, y); // &#125; // sum += Eva(dfsidx[x], dfsidx[y]); // return sum; //&#125; // //void SonTreeAdd(int rootid, int k) &#123; // Add(dfsidx[rootid], dfsidx[bottom[rootid]], k); //&#125; // //LL SonTreeEva(int rootid) &#123; // return Eva(dfsidx[rootid], dfsidx[bottom[rootid]]); //&#125; //////树剖 int n, q;int main() &#123; read(n); Build0(1, n); for (re int i = 1, from, to; i &lt; n; ++i) &#123; read(from), read(to); Insert(from + 1, to + 1); &#125; Dfs1(1, 0, 1); Dfs2(1, 1); read(q); for (re int i = 1, from, to, val, opt, root; i &lt;= q; ++i) &#123; getchar(); opt = getchar(); switch (opt) &#123; case &#x27;A&#x27;: read(from), read(to), read(val); TreePathAdd(from + 1, to + 1, val); break; case &#x27;Q&#x27;: read(root); printf(&quot;%lld\\n&quot;, SonTreeEva(root + 1)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"卡时","slug":"卡时","date":"un22fin22","updated":"un66fin66","comments":true,"path":"2021/06/08/卡时/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/08/%E5%8D%A1%E6%97%B6/","excerpt":"","text":"众所周知，在各大计算机竞赛的赛场上，总会有那么一样东西令人头疼，令暴力爆零，令搜索欲哭无泪；在各大在线评测系统上，总会有那么三个字母教 n2n^2n2 失败，教 2n2^n2n 无奈，教 n!n!n! 一个点都拿不到。没错，那就是 T-L-E。 今天就来分享分享怎么避免这三个大字的出现。 正文 卡时，顾名思义，就是卡时间，用尽时间限制中的每一微秒，搜索的话就算没搜完，把局部最小值输出至少有可能 A，当然如果你的算法太差也顶多只能把 TLETLETLE 变成 WAWAWA 那么开始吧！ 1.代码 直接放代码：（递归同理我就不再放一遍了） 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#include&lt;ctime&gt;using namespace std;#define re registerint main() &#123; for (re int i = 0; ; ++i)&#123; if (i &gt;= 500000000 &amp;&amp; i % 1000000 == 0 &amp;&amp; clock() &gt;= 990) &#123; printf(&quot;How many done: %d\\n&quot;, i); printf(&quot;Time used: %.6lf\\n&quot;, (double) clock() / CLOCKS_PER_SEC); /*在这里输出“正解”*/ exit(EXIT_SUCCESS); &#125; /*在这里放程序的主体*/ &#125;&#125; 2.讲解 #include&lt;cmath&gt; 头文件记得加上 &quot;if (i &gt;= 500000000 &amp;&amp; i % 1000000 == 0 &amp;&amp; clock() &gt;= 990)&quot; 重点！ i &gt;= 500000000 ​ 500000000500000000500000000 是你估计的该循环体能在规定时间能执行的次数，往小估计一点！不然程序来不及判断 clock() &gt;= 990 就超时了。 i % 1000000 == 0 ​ 因为 clock 函数的常数很大，尽量少是执行他， 所以加这个来减少 clock() 的执行次数， 100000010000001000000 这个数别设太大，不然也容易没卡住而超时。 clock() &gt;= 990 ​ 整个卡时中最重要的部分，注意两点：一、990 这个数字取决于操作系统，因为 WindowsWindowsWindows 的 CLOCKS_PER_SEC 是 100010001000 , LinuxLinuxLinux 下是 100000010000001000000 ，也就是 WindowWindowWindow 的 clock() 返回值单位为毫秒， LinuxLinuxLinux 是微秒，也就是说这个卡时程序要是在 LinuxLinuxLinux 上测 990990990 应该为 990000990000990000。**二、**不要太贪了， 111 秒的题开个 980000980000980000 就行了，可别真开到开 100000010000001000000。 关于三者的顺序 ​ 我们知道，几个 &amp;&amp; 或 || 隔开的语句顺序不一样可能会有不同的结果，因为如果计算机通过靠前的语句能判断整个语句的布尔值就不会执行后面的，（如 &amp;&amp; 之间出现 false , || 之间出现 true ），所以，我们应该将耗时少的判定放在前面，耗时 &gt;= &lt;&lt;&lt; % &lt;&lt;&lt; clock()，所以我们按这个顺序放置。否则，卡时的耗时甚至要比搜索本身耗时高，得不偿失。 exit(EXIT_SUCCESS) “相当于 return 0 ，与 return 0 不同的是，无论他在哪执行（包括除 main 以外的函数），整个程序立即结束。依靠递归的搜索不能用 return 0 来停止，需要用它。 3.结果","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"运行时间测试","slug":"运行时间测试","date":"un22fin22","updated":"un66fin66","comments":true,"path":"2021/06/08/运行时间测试/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95/","excerpt":"","text":"有一天，我在网上看到有人说重载 max() 函数是一种有用的卡常技巧，今天就来测一下重载 max() 到底是有用还是帮了倒忙。 正文 1.代码 直接放代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;#define re registertypedef long long LL;LL numof = 100000000;/*在这里做初始化和准备工作*/inline int Max(int a, int b) &#123; return a &gt; b ? a : b;&#125;/*在这里做初始化和准备工作*/int main() &#123; printf(&quot;Time to do %lld is &quot;, numof) ; clock_t emptystart = clock(); for (re LL i = 0; i &lt; numof; ++i) &#123; &#125; clock_t emptyend = clock(); clock_t teststart = clock(); for (re LL i = 0; i &lt; numof; ++i) &#123; /*在这里放测试代码*/ max(13, 12); //Max(13, 12); /*在这里放测试代码*/ &#125; clock_t testend = clock(); printf(&quot;%.6lf\\n&quot;, (double) ((testend - teststart) - (emptyend - emptystart)) / CLOCKS_PER_SEC); &#125; 2.讲解 如果 numof 设得比较大最好加上 emptystart 和 emptyend 来排除循环本身的耗时。 123printf(&quot;%.6lf\\n&quot;, (double) ((testend - teststart) - (emptyend - emptystart)) / CLOCKS_PER_SEC); 很简单。 3.结果 C 自带的 max： 自制的 Max： 是有优化的，但效果并不明显 . . .","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"01分数规划","slug":"TemLib/01分数规划","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/01分数规划/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","excerpt":"","text":"P4377 USACO18OPEN Talent Show G 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 250;const int MAXW = 1e3;const double MAXfrac = 1e6;const double EPS = 1e-8;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, W, w[MAXn + 10], t[MAXn + 10]; double v[MAXn + 10];double d[MAXW + 10];double calc(double x) &#123; for (int i = 1; i &lt;= n; ++i) &#123; v[i] = (double)t[i] - (double)w[i] * x; &#125; memset(d, 0xc2, sizeof(d)); d[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = W; ~j; --j) &#123; int k = min(j + w[i], W); d[k] = max(d[k], d[j] + v[i]); &#125; &#125; return d[W];&#125;signed main() &#123; read(n, W); for (int i = 1; i &lt;= n; ++i) &#123; read(w[i], t[i]); &#125; double L = 0, R = MAXfrac; while (R - L &gt; EPS) &#123; double mid = (L + R) / 2; if (calc(mid) &gt; 0) &#123; L = mid; &#125; else &#123; R = mid; &#125; &#125; printf(&quot;%d\\n&quot;, int(L * 1000));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Ac自动机","slug":"TemLib/Ac自动机","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Ac自动机/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Ac%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"P3808 【模板】AC自动机（简单版） P3796 【模板】AC自动机（加强版） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXtxtlen = 1e6;const int MAXwrdlen = 70;const int MAXwrdcnt = 150;const int MAXnd = 1e6;int cntnd, son[MAXnd + 10][26], mat[MAXnd + 10];char txt[MAXtxtlen + 10], wrd[MAXwrdcnt + 10][MAXwrdlen + 10];int ltxt, lwrd;int fail[MAXnd + 10], ndidx[MAXwrdcnt + 10];int n;queue&lt;int&gt; q;void clear(queue&lt;int&gt; &amp;q) &#123; queue&lt;int&gt; empty; swap(q, empty);&#125;void Init() &#123; cntnd = ltxt = lwrd = n = 0; memset(son, 0, sizeof(son)); memset(mat, 0, sizeof(mat)); memset(txt, 0, sizeof(txt)); memset(wrd, 0, sizeof(wrd)); memset(fail, 0, sizeof(fail)); memset(ndidx, 0, sizeof(ndidx)); memset(mat, 0, sizeof(mat)); clear(q);&#125;void Insert(char *wrd, int wrdidx) &#123; int cur = 0; for (re int i = 1; i &lt;= lwrd; ++i) &#123; if (son[cur][wrd[i] - 97]) &#123; cur = son[cur][wrd[i] - 97]; &#125; else &#123; cur = son[cur][wrd[i] - 97] = ++cntnd; &#125; &#125; ndidx[wrdidx] = cur;&#125;void GetFail() &#123; for (re int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int cur = q.front(); q.pop(); for (re int i = 0; i &lt; 26; ++i) &#123; if (son[cur][i]) &#123; fail[son[cur][i]] = son[fail[cur]][i]; q.push(son[cur][i]); &#125; else &#123; son[cur][i] = son[fail[cur]][i]; &#125; &#125; &#125;&#125;void Work() &#123; int cur = 0; for (re int i = 1; i &lt;= ltxt; ++i) &#123; cur = son[cur][txt[i] - 97]; int x = cur; while (x) &#123; ++mat[x]; x = fail[x]; &#125; &#125;&#125;int main() &#123; while (true) &#123; Init(); scanf(&quot;%d&quot;, &amp;n); if (!n) break; for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, wrd[i] + 1); lwrd = strlen(wrd[i] + 1); Insert(wrd[i], i); &#125; GetFail(); scanf(&quot;%s&quot;, txt + 1); ltxt = strlen(txt + 1); Work(); int mx = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mat[ndidx[i]] &gt; mx) &#123; mx = mat[ndidx[i]]; &#125; &#125; printf(&quot;%d\\n&quot;, mx); for (re int i = 1; i &lt;= n; ++i) &#123; if (mat[ndidx[i]] == mx) &#123; printf(&quot;%s\\n&quot;, wrd[i] + 1); &#125; &#125; &#125; &#125; 每个字符串只算一次的 Work 函数。 12345678910111213int Work() &#123; int j = 0, ans = 0; for (re int i = 1; i &lt;= ltxt; ++i) &#123; j = son[j][txt[i] - 97]; int k = j; while (cnt[k] &amp;&amp; k) &#123; ans += cnt[k]; cnt[k] = 0; k = fail[k]; &#125; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Astar","slug":"TemLib/Astar","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Astar/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Astar/","excerpt":"","text":"A* 解八数码 Luogu P1379 八数码难题 1234567891011121314151617181920212223priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; pq;unordered_map&lt;string, int&gt; d;int Astar() &#123; d[bg] = 0; pq.push(make_pair(0 + Manh(bg), bg)); while (!pq.empty()) &#123; string sta = pq.top().second; pq.pop(); if (sta == ed) &#123; return d[sta]; &#125; Trans(sta); // Trans(string sta)函数将sta可转移到的状态存到deal数组里 int D = d[sta] + 1; for (int i = 1; i &lt;= cntdeal; ++i) &#123; if (!d.count(deal[i]) || d[deal[i]] &gt; D) &#123; d[deal[i]] = D; pq.push(make_pair(D + Manh(deal[i]), deal[i])); // Manh(string sta)函数求sta到end的总曼哈顿长度，即估价函数 &#125; &#125; &#125; return -1;&#125; A* 解k短路 Acwing 178. 第K短路 123456789101112131415161718192021222324int Astar(int s, int t, int kth) &#123; if (dis[s] == INF) return -1; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; int times = 0; pq.push(make_pair(0 + dis[s], s)); while (!pq.empty()) &#123; int cur = pq.top().second, dist = pq.top().first - dis[cur]; pq.pop(); if (cur == t) &#123; if (++times == kth) &#123; return dist; &#125; &#125; for (int i = head[cur]; i; i = nex[i]) &#123; pq.push(make_pair(dist + wei[i] + dis[to[i]], to[i])); &#125; &#125; return -1;&#125;signed main() &#123; // ... Dijkstra(t); // 反向边上跑 Dij printf(&quot;%d\\n&quot;, Astar(s, t, kth)); // 正向边上跑 A*&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"搜索","slug":"搜索","permalink":"http://rsdbkhusky.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"01背包","slug":"TemLib/01背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/01背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/01%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1048 [NOIP2005 普及组] 采药 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;LL n, W;LL d[MAXW + 10];inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = W; i &gt;= w; i--) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Bsgs","slug":"TemLib/Bsgs","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Bsgs/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Bsgs/","excerpt":"","text":"P3846 [TJOI2007] 可爱的质数/【模板】BSGS 123456789101112unordered_map&lt;int, int&gt; mp;int Bsgs(int a, int b, int p) &#123; if (1 % p == b % p) return 0; int k = sqrt(p) + 1; for (int i = 0, val = b % p; i &lt; k; ++i, val = val * a % p) &#123; mp[val] = i; &#125; for (int i = 1, ak = power(a, k, p), val = ak; i &lt;= k; ++i, val = val * ak % p) &#123; if (mp.count(val)) return k * i - mp[val]; &#125; return -1;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Cdq解三维偏序","slug":"TemLib/Cdq解三维偏序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Cdq解三维偏序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Cdq%E8%A7%A3%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F/","excerpt":"","text":"P3810 【模板】三维偏序（陌上花开） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXk = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int top, t[MAXk + 10];#define lowbit(x) (x &amp; (-x))void Add(int p, int v) &#123; while (p &lt;= top) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int n, k;struct Ele &#123; int a, b, c, cnt, ans;&#125;eletmp[MAXn + 10], ele[MAXn + 10];inline bool cmpc(Ele x, Ele y) &#123; if (x.c == y.c) &#123; if (x.b == y.b) &#123; return x.a &lt; y.a; &#125; return x.b &lt; y.b; &#125; return x.c &lt; y.c;&#125;inline bool cmpb(Ele x, Ele y) &#123; if (x.b == y.b) &#123; return x.a &lt; y.a; &#125; return x.b &lt; y.b;&#125;void cdq(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int j = l; for (int i = mid + 1; i &lt;= r; ++i) &#123; while (j &lt;= mid &amp;&amp; ele[i].b &gt;= ele[j].b) &#123; Add(ele[j].a, ele[j].cnt); ++j; &#125; ele[i].ans += EvaSum(ele[i].a); &#125; for (int i = l; i &lt; j; ++i) &#123; Add(ele[i].a, -ele[i].cnt); &#125; inplace_merge(ele + l, ele + 1 + mid, ele + 1 + r, cmpb);&#125;int ans[MAXn + 10], m;int main() &#123; read(n), read(k); top = k; for (int i = 1; i &lt;= n; ++i) &#123; read(eletmp[i].a), read(eletmp[i].b), read(eletmp[i].c); &#125; sort(eletmp + 1, eletmp + 1 + n, cmpc); for (int i = 1, j = 0; i &lt;= n; ++i) &#123; ++j; if (eletmp[i].a != eletmp[i + 1].a || eletmp[i].b != eletmp[i + 1].b || eletmp[i].c != eletmp[i + 1].c) &#123; ++m; ele[m].a = eletmp[i].a; ele[m].b = eletmp[i].b; ele[m].c = eletmp[i].c; ele[m].cnt = j; j = 0; &#125; &#125; cdq(1, m); for (int i = 1; i &lt;= m; ++i) &#123; ans[ele[i].ans + ele[i].cnt - 1] += ele[i].cnt; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"2-Sat","slug":"TemLib/2-Sat","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/2-Sat/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/2-Sat/","excerpt":"","text":"P4782 【模板】2-SAT 问题 1. 暴力判断做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e6;const int MAXm = 1e6;const int MAXnd = MAXn * 2;const int MAXeg = MAXm * 2;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int sta[MAXnd + 10];int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n, m;int top, stk[MAXnd + 10];inline int otherside(int cur) &#123; if (cur &gt; n) return cur - n; else return cur + n;&#125;bool Dfs(int cur) &#123; if (sta[cur] == 1) return 1; if (sta[cur] == -1) return 0; sta[cur] = 1; sta[otherside(cur)] = -1; stk[++top] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; if (!Dfs(to[i])) return 0; &#125; return 1;&#125;signed main() &#123; read(n, m); for (int i = 1, a, opta, b, optb; i &lt;= m; ++i) &#123; read(a, opta, b, optb); Insert(opta ? a : a + n, optb ? b + n : b); Insert(optb ? b : b + n, opta ? a + n : a); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (sta[i]) continue; top = 0; if (!Dfs(i)) &#123; while (top) &#123; sta[stk[top]] = sta[otherside(stk[top])] = 0; --top; &#125; if (!Dfs(i + n)) &#123; puts(&quot;IMPOSSIBLE&quot;); return 0; &#125; &#125; &#125; puts(&quot;POSSIBLE&quot;); for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d &quot;, sta[i + n] == 1 ? 1 : 0); &#125; puts(&quot;&quot;); return 0;&#125; 2. Tarjan 优化做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e6;const int MAXm = 1e6;const int MAXnd = MAXn * 2;const int MAXeg = MAXm * 2;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int head2[MAXnd + 10], cntnex2, nex2[MAXeg + 10], to2[MAXeg + 10];inline void Insert2(int u, int v) &#123; nex2[++cntnex2] = head2[u]; head2[u] = cntnex2; to2[cntnex2] = v;&#125;int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int top, stk[MAXnd + 10]; bool instk[MAXnd + 10];int cntscc;void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); &#125; else if (instk[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; Insert2(cntscc, x); &#125; while (x != cur); &#125;&#125;int n, m;inline int smallside(int x) &#123; return x &gt; n ? x - n : x;&#125;int chose[MAXnd + 10];signed main() &#123; read(n, m); for (int i = 1, a, b, opta, optb; i &lt;= m; ++i) &#123; read(a, opta, b, optb); Insert(opta ? a + n : a, optb ? b : b + n); Insert(optb ? b + n : b, opta ? a : a + n); &#125; for (int i = 1, topi = n * 2; i &lt;= topi; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125; for (int i = 1; i &lt;= cntscc; ++i) &#123; for (int j = head2[i]; j; j = nex2[j]) &#123; if (chose[smallside(to2[j])] == i) &#123; puts(&quot;IMPOSSIBLE&quot;); return 0; &#125; chose[smallside(to2[j])] = i; &#125; &#125; puts(&quot;POSSIBLE&quot;); memset(chose, 0, sizeof(chose)); for (int i = 1; i &lt;= cntscc; ++i) &#123; if (chose[smallside(to2[head2[i]])]) continue; for (int j = head2[i]; j; j = nex2[j]) &#123; chose[smallside(to2[j])] = to2[j] &gt; n ? -1 : 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d &quot;, chose[i] == 1 ? 1 : 0); &#125; puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Cyaron模板","slug":"TemLib/Cyaron模板","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/Cyaron模板/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Cyaron%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"推荐一款不错的数据生成器：CYaRon，一个基于Python的测试数据生成库。能够生成一部分信息竞赛中需要的数据，操作简单，易入门。 项目地址 部署及基本语法 详见 luogu 官方文档。 常用模板 数据生成 1234567891011121314151617from cyaron import *_n = ati([1, 7, 50, 1E4])_m = ati([1, 11, 100, 1E4])for i in range(1, 4): io = IO(file_prefix = &quot;name&quot;, data_id = i) n = _n[i] m = _m[i] s = randint(1, n) t = randint(1, n) graph = Graph.graph(n, m, weight_limit = 5) io.input_writeln(n, m, s, t) io.input_writeln(graph) io.output_gen(&quot;std&quot;) 对拍 12345678910111213141516171819from cyaron import *for i in range(1000): print(&quot;Case:&#123;0&#125;&quot;.format(i)) iostd = IO(&quot;name.in&quot;, &quot;name.stdout&quot;) iotest = IO(&quot;name.in&quot;, &quot;name.testout&quot;) n = randint(1, 3) m = randint(n - 1, 5) s = randint(1, n) t = randint(1, n) graph = Graph.UDAG(n, m, weight_limit = 10) iostd.input_writeln(n, m, s, t) iostd.input_writeln(graph.to_str(shuffle = True)) iostd.output_gen(&quot;./std&quot;) iotest.output_gen(&quot;./test&quot;) Compare.output(&quot;name.testout&quot;, std = &quot;name.stdout&quot;)","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Exgcd求逆元","slug":"TemLib/Exgcd求逆元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Exgcd求逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Exgcd%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 【模板】乘法逆元 此题不是求单个逆元的模板题，但可以用这道模板题检验这种求逆方法的正确性（没有WA） 123456789101112131415int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Floyd解最小环","slug":"TemLib/Floyd解最小环","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Floyd解最小环/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Floyd%E8%A7%A3%E6%9C%80%E5%B0%8F%E7%8E%AF/","excerpt":"","text":"P6175 无向图的最小环问题 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXn = 1e2; const int INF = 0x20202020; template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; '0' || c &gt; '9');register T x(c - '0');while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125; template &lt;typename T, typename ...Argv&gt; inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...); &#125; int n, m, ans = INF; int wei[MAXn + 10][MAXn + 10], dis[MAXn + 10][MAXn + 10]; signed main() &#123; read(n, m); memset(wei, 0x20, sizeof(wei)); memset(dis, 0x20, sizeof(dis)); for (int i = 1; i &lt;= n; ++i) &#123; wei[i][i] = dis[i][i] = 0; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); wei[u][v] = wei[v][u] = dis[u][v] = dis[v][u] = min(dis[u][v], w); &#125; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j || j == k || k == i) continue; ans = min(ans, wei[i][k] + wei[k][j] + dis[j][i]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125; if (ans == INF) &#123; printf(&quot;No solution.\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, ans); &#125; &#125;```","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Gcd Lcm","slug":"TemLib/Gcd Lcm","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Gcd Lcm/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Gcd%20Lcm/","excerpt":"","text":"P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题 1. 最大公约数(gcd) 辗转相除法 123int gcd(int a, int b) return b ? gcd(b, a % b) : a;&#125; 更相减损术 带取模的 123456789101112131415int gcd(int a, int b) &#123; int twice = 1; while (a % 2 == 0 &amp;&amp; b % 2 == 0) &#123; a /= 2, b /= 2; twice *= 2; &#125; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return twice * a;&#125; 不带取模的 12345678910int gcd(int a, int b) &#123; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return a;&#125; 2. 最小公倍数 123int lcm(int a, int b) &#123; return a / gcd(a, b) * b; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Johnson全源最短路","slug":"TemLib/Johnson全源最短路","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Johnson全源最短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Johnson%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P5905 【模板】Johnson 全源最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 3e3;const int MAXm = 6e3;const int INF = 1e9;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline void clear(priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; &amp;pq) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pqempty; pq = pqempty;&#125;int head[MAXn + 10], cntnex, nex[MAXm + MAXn + 10], from[MAXm + MAXn + 10], to[MAXm + MAXn + 10], wei[MAXm + MAXn + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; from[cntnex] = u; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m;int h[MAXn + 10], cntinque[MAXn + 10]; bool inque[MAXn + 10]; queue&lt;int&gt; q;bool Spfa(int sour) &#123; fill(begin(h), end(h), INF); h[sour] = 0; q.push(sour); inque[sour] = 1; ++cntinque[sour]; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (h[to[i]] &gt; h[cur] + wei[i]) &#123; h[to[i]] = h[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; ++cntinque[to[i]]; if (cntinque[to[i]] &gt; n + 1) &#123; return 0; &#125; &#125; &#125; &#125; &#125; return 1;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10]; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;void Dijkstra(int sour) &#123; memset(vis, 0, sizeof(vis)); fill(begin(dis), end(dis), INF); dis[sour] = 0; pq.push(make_pair(0, sour)); while (!pq.empty()) &#123; int cur = pq.top().second; pq.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; pq.push(make_pair(dis[to[i]], to[i])); &#125; &#125; &#125;&#125;signed main() &#123; read(n, m); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); Insert(u, v, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; Insert(n + 1, i, 0); &#125; if (!Spfa(n + 1)) &#123; puts(&quot;-1&quot;); return 0; &#125; for (int i = 1; i &lt;= cntnex; ++i) &#123; wei[i] = wei[i] + h[from[i]] - h[to[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int ans = 0; Dijkstra(i); for (int j = 1; j &lt;= n; ++j) &#123; if (dis[j] == INF) &#123; ans += j * INF; &#125; else &#123; ans += j * (dis[j] - h[i] + h[j]); &#125; &#125; printf(&quot;%lld\\n&quot;, ans); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Kmp","slug":"TemLib/Kmp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Kmp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Kmp/","excerpt":"","text":"P3375 【模板】KMP字符串匹配 wrd$$：$$txt$$：从 $$1$$ 开始。 $$lwrd$$：$$ltxt$$：闭区间，$$[1, l]$$。 $$sec_i$$：以 $$i$$ 为左端点的子串是单词串。 $$fail_j = k$$： 文本串 $$[1, k]$$ 的的后缀和整个文本串前缀最长公共部分的长度。 如果单词串上遍历到 $$j + 1$$ 时（还未确定单词串位置 $$j + 1$$ 是否能匹配成功），$$fail_j = k$$ 代表保证单词串 $$[1, k]$$。 一定是已匹配成功的。 也就是说应该判断 $$word_{j + 1}$$ 与 $$txt_i$$ 是否相等，而非 $$word_j$$，因为$$word_j$$ 之前已经匹配成功了。 ![](Kmp.png) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;using std::ios;using std::cin;using std::cout;const int MAXlwrd = 1e6;const int MAXltxt = 1e6;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10]; bool isbegin[MAXltxt + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;void Solve() &#123; int j = 0; for (int i = 1; i &lt;= ltxt; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != txt[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == txt[i]) ++j; if (j == lwrd) isbegin[i - lwrd + 1] = 1; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); Solve(); for (int i = 1; i &lt;= ltxt; ++i) &#123; if (isbegin[i]) &#123; cout &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; for (int i = 1; i &lt;= lwrd; ++i) &#123; cout &lt;&lt; fail[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Manacher","slug":"TemLib/Manacher","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Manacher/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Manacher/","excerpt":"","text":"P3805 【模板】manacher 算法 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e7 + 1e6;char str[MAXn * 2 + 10];int rad[MAXn * 2 + 10];void EvaRad(int len) &#123; for (int i = 1, l = 1, r = 0; i &lt;= len; ++i) &#123; if (i &gt; r) rad[i] = 0; else rad[i] = min(r - i, rad[r + l - i]); while (i + rad[i] &lt; len &amp;&amp; i - rad[i] &gt; 1 &amp;&amp; str[i + rad[i] + 1] == str[i - rad[i] - 1]) ++rad[i]; if (i + rad[i] &gt; r) &#123; r = i + rad[i]; l = i - rad[i]; &#125; &#125;&#125;char strfirst[MAXn + 10];int len1, len2, ans;signed main() &#123; scanf(&quot;%s&quot;, (strfirst + 1)); len1 = strlen(strfirst + 1); str[++len2] = &#x27;#&#x27;; for (int i = 1; i &lt;= len1; ++i) &#123; str[++len2] = strfirst[i]; str[++len2] = &#x27;#&#x27;; &#125; EvaRad(len2); for (int i = 1; i &lt;= len2; ++i) &#123; ans = max(ans, i &amp; 1 ? (rad[i] &amp; (~1)) : (rad[i] &amp; (~1)) + 1); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Splay","slug":"TemLib/Splay","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/Splay/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Splay/","excerpt":"","text":"题目 维护递增的中序遍历 P3369 【模板】普通平衡树 按题目要求维护的中序遍历（中序遍历维护序列） P3391 【模板】文艺平衡树 操作合集+Splay建树：P2042 [NOI2005] 维护数列 Splay 合并 P3224 [HNOI2012]永无乡 函数汇总 辅助操作 pushup(id)pushup(id)pushup(id) pushdown(id)pushdown(id)pushdown(id) side(id)side(id)side(id) rotate(id)rotate(id)rotate(id) splay(id,goal)splay(id, goal)splay(id,goal) find（该操作在新版本 Splay 中已被移除） 主操作 EvaPre(v)EvaPre(v)EvaPre(v) EvaNex(v)EvaNex(v)EvaNex(v) Insert(v)Insert(v)Insert(v) Delete(v)Delete(v)Delete(v) ValtoRank(v)ValtoRank(v)ValtoRank(v) RanktoVal(rank)RanktoVal(rank)RanktoVal(rank) pushdown(id)pushdown(id)pushdown(id) Reverser(rank,rank)Reverser(rank, rank)Reverser(rank,rank) Add(rank,cnt,a1a2⋯ )Del(rank,cnt)⋯Add(rank, cnt, a_1 a_2 \\cdots) Del(rank, cnt) \\cdotsAdd(rank,cnt,a1​a2​⋯)Del(rank,cnt)⋯ Build(cnt,a1,a2⋯ )Build(cnt, a_1, a_2 \\cdots)Build(cnt,a1​,a2​⋯) 模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int root, idxinf, idxninf;int cntnd, son[MAXn + 10][2], fa[MAXn + 10], siz[MAXn + 10], cnt[MAXn + 10], val[MAXn + 10];inline void pushup(int id) &#123; siz[id] = cnt[id] + siz[son[id][0]] + siz[son[id][1]];&#125;inline bool side(int id) &#123; return son[fa[id]][1] == id;&#125;inline void rotate(int id) &#123; int y = fa[id], z = fa[y], sideid = side(id), s = son[id][sideid ^ 1]; if (z) &#123;son[z][side(y)] = id;&#125; fa[id] = z; son[y][sideid] = s; if (s) &#123;fa[s] = y;&#125; son[id][sideid ^ 1] = y; fa[y] = id; pushup(y); pushup(id);&#125;inline void splay(int id, int goal = 0) &#123; int y, z; while (fa[id] != goal) &#123; y = fa[id], z = fa[y]; if (z != goal) &#123; if (side(id) == side(y)) rotate(y); else rotate(id); &#125; rotate(id); &#125; if (!goal) root = id;&#125;inline int ValtoRank(int v) &#123; int id = root, ans = 0; while (true) &#123; if (v &lt; val[id]) &#123; if (son[id][0]) id = son[id][0]; else break; &#125; else if (v == val[id]) &#123; ans += siz[son[id][0]]; break; &#125; else &#123; ans += siz[son[id][0]] + cnt[id]; if (son[id][1]) id = son[id][1]; else break; &#125; &#125; splay(id); return ans + 1;&#125;inline int RanktoId(int rk) &#123; int id = root; while (true) &#123; if (rk &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rk &lt;= siz[son[id][0]] + cnt[id]) &#123; break; &#125; else &#123; rk -= siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; &#125; splay(id); return id;&#125;inline int PreId(int v) &#123; int id = root, ans = idxninf; while (true) &#123; if (val[id] &lt; v) &#123; ans = val[id] &gt; val[ans] ? id : ans; if (son[id][1]) id = son[id][1]; else break; &#125; else &#123; if (son[id][0]) id = son[id][0]; else break; &#125; &#125; splay(id); return ans;&#125;inline int NexId(int v) &#123; int id = root, ans = idxinf; while (true) &#123; if (val[id] &gt; v) &#123; ans = val[id] &lt; val[ans] ? id : ans; if (son[id][0]) id = son[id][0]; else break; &#125; else &#123; if (son[id][1]) id = son[id][1]; else break; &#125; &#125; splay(id); return ans;&#125;inline void Insert(int v) &#123; int id = root, f = 0; while (id &amp;&amp; v != val[id]) &#123; f = id; id = son[id][v &gt; val[id]]; &#125; if (!id) &#123; id = ++cntnd; cnt[id] = 1; val[id] = v; fa[id] = f; if (f) son[f][v &gt; val[f]] = id; &#125; else &#123; ++cnt[id]; &#125; splay(id);&#125;inline void Delete(int v) &#123; int pre = PreId(v), nex = NexId(v); splay(pre), splay(nex, pre); int tar = son[nex][0]; if (tar) &#123; --cnt[tar]; if (cnt[tar]) &#123; splay(tar); &#125; else &#123; son[nex][0] = 0; &#125; &#125;&#125;int n;signed main() &#123; Insert(INF); idxinf = 1; Insert(-INF); idxninf = 2; read(n); for (int i = 1, opt, x; i &lt;= n; ++i) &#123; read(opt, x); if (opt == 1) Insert(x); else if (opt == 2) Delete(x); else if (opt == 3) printf(&quot;%d\\n&quot;, ValtoRank(x) - 1); else if (opt == 4) printf(&quot;%d\\n&quot;, val[RanktoId(x + 1)]); else if (opt == 5) printf(&quot;%d\\n&quot;, val[PreId(x)]); else if (opt == 6) printf(&quot;%d\\n&quot;, val[NexId(x)]); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"St表","slug":"TemLib/St表","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/St表/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/St%E8%A1%A8/","excerpt":"","text":"P3865 【模板】ST 表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXlog2n = 17;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, a[MAXn + 10], power[MAXlog2n + 10], st[MAXn + 10][MAXlog2n + 10];double ln2;void BuildSt() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; st[i][0] = a[i]; &#125; int maxidx = log(n) / ln2; for (re int idx = 1; idx &lt;= maxidx; ++idx) &#123; for (re int l = n - power[idx] + 1; l; --l) &#123; st[l][idx] = max(st[l][idx - 1], st[l + power[idx - 1]][idx - 1]); &#125; &#125;&#125;int EvaMax(int l, int r) &#123; int idx = log(r - l + 1) / ln2; return max(st[l][idx], st[r - power[idx] + 1][idx]);&#125;int m;int main() &#123; ln2 = log(2); power[0] = 1; for (re int i = 1; i &lt;= MAXlog2n; ++i) &#123; power[i] = power[i - 1] &lt;&lt; 1; &#125; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildSt(); for (re int i = 1, l, r; i &lt;= m; ++i) &#123; read(l), read(r); printf(&quot;%d\\n&quot;, EvaMax(l, r)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Treap","slug":"TemLib/Treap","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Treap/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Treap/","excerpt":"","text":"P3369 【模板】普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, son[MAXn + 10][2], siz[MAXn + 10], num[MAXn + 10], val[MAXn + 10], rd[MAXn + 10];inline void pushup(int cur) &#123; siz[cur] = siz[son[cur][0]] + siz[son[cur][1]] + num[cur];&#125;inline void rotate(int &amp;cur, int side) &#123; int y = son[cur][side ^ 1]; int z = son[y][side]; son[cur][side ^ 1] = z; son[y][side] = cur; pushup(cur); pushup(y); cur = y;&#125;inline void Insert(int &amp;cur, int v) &#123; if (!cur) &#123; cur = ++cntnd; siz[cur] = num[cur] = 1; val[cur] = v; rd[cur] = rand(); &#125; else if (v == val[cur]) &#123; ++siz[cur]; ++num[cur]; &#125; else &#123; int side = (v &gt; val[cur]); Insert(son[cur][side], v); if (rd[son[cur][side]] &gt; rd[cur]) &#123; rotate(cur, side ^ 1); &#125; else &#123; ++siz[cur]; &#125; &#125;&#125;inline void Delete(int &amp;cur, int v) &#123; if (!cur) &#123; ; &#125; else if (v == val[cur]) &#123; if (num[cur] &gt; 2) &#123; --num[cur]; &#125; else if (!son[cur][0] &amp;&amp; !son[cur][1]) &#123; --num[cur]; --siz[cur]; if (!siz[cur]) cur = 0; return; &#125; else if (son[cur][0] &amp;&amp; !son[cur][1]) &#123; rotate(cur, 1); Delete(son[cur][1], v); &#125; else if (!son[cur][0] &amp;&amp; son[cur][1]) &#123; rotate(cur, 0); Delete(son[cur][0], v); &#125; else &#123; int side = (rd[son[cur][0]] &lt; rd[son[cur][1]]); rotate(cur, side ^ 1); Delete(son[cur][side ^ 1], v); &#125; --siz[cur]; &#125; else &#123; int side = (v &gt; val[cur]); Delete(son[cur][side], v); pushup(cur); &#125;&#125;inline int valtorank(int cur, int v) &#123; if (!cur) return 0; if (v &lt; val[cur]) &#123; return valtorank(son[cur][0], v); &#125; else if (v &gt; val[cur]) &#123; return siz[son[cur][0]] + num[cur] + valtorank(son[cur][1], v); &#125; else &#123; return siz[son[cur][0]]; &#125;&#125;inline int ValtoRank(int cur, int v) &#123; return valtorank(cur, v) + 1;&#125;inline int RanktoVal(int cur, int rank) &#123; if (!cur) return -INF; if (rank &gt;= siz[son[cur][0]] + 1 &amp;&amp; rank &lt;= siz[son[cur][0]] + num[cur]) &#123; return val[cur]; &#125; else if (rank &lt;= siz[son[cur][0]]) &#123; return RanktoVal(son[cur][0], rank); &#125; else &#123; return RanktoVal(son[cur][1], rank - (siz[son[cur][0]] + num[cur])); &#125;&#125;inline int Pre(int cur, int v) &#123; if (!cur) return -INF; if (val[cur] &gt;= v) &#123; return Pre(son[cur][0], v); &#125; else &#123; return max(val[cur], Pre(son[cur][1], v)); &#125;&#125;inline int Nex(int cur, int v) &#123; if (!cur) return INF; if (val[cur] &lt;= v) &#123; return Nex(son[cur][1], v); &#125; else &#123; return min(val[cur], Nex(son[cur][0], v)); &#125;&#125;int n, root;signed main() &#123; read(n); for (int i = 1, opt, x; i &lt;= n; ++i) &#123; read(opt, x); if (opt == 1) Insert(root, x); else if (opt == 2) Delete(root, x); else if (opt == 3) printf(&quot;%d\\n&quot;, ValtoRank(root, x)); else if (opt == 4) printf(&quot;%d\\n&quot;, RanktoVal(root, x)); else if (opt == 5) printf(&quot;%d\\n&quot;, Pre(root, x)); else if (opt == 6) printf(&quot;%d\\n&quot;, Nex(root, x)); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Z函数","slug":"TemLib/Z函数","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Z函数/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Z%E5%87%BD%E6%95%B0/","excerpt":"","text":"话说这玩意和 Kmp 有啥关系要把它称为扩展 Kmp。 P5410 【模板】Z函数 一个串的 Z 函数 因为代码中 i != 1，所以可以省去边界判断。 123456789int z[MAXn + 10];void EvaZ(char *str, int n) &#123; z[1] = n; for (int i = 2, l = 0, r = 0; i &lt;= n; ++i) &#123; if (i &lt;= r) z[i] = min(r - i + 1, z[i - l + 1]); while (str[i + z[i]] == str[1 + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; &#125;&#125; 两个串的 Z 函数 设文本串为 ttt，模式串为 ppp。相当于让 s=p+⋄+ts=p+\\diamond+ts=p+⋄+t，求 sss 的 Z 函数。代码中定义了一个 Y 函数，省去了拼接操作，实际上做法是相同的，就是先求一下模式串的 Z 函数，再用一个 Y Box优化，文本串的 Y Box 和模式串的·前缀相同。 123456789int y[MAXn + 10];void EvaY(char *txt, char *wrd, int n, int m) &#123; EvaZ(wrd, m); for (int i = 1, l = 0, r = 0; i &lt;= n; ++i) &#123; if (i &lt;= r) y[i] = min(r - i + 1, z[i - l + 1]); while (i + y[i] &lt;= n &amp;&amp; 1 + y[i] &lt;= m &amp;&amp; txt[i + y[i]] == wrd[1 + y[i]]) ++y[i]; if (i + y[i] - 1 &gt; r) l = i, r = i + y[i] - 1; &#125;&#125; 自己糊的奇葩做法 既然可以先求模式串的 Z 函数，再用 Box 优化，为什么不能先求文本串的 Z 函数，再用 Box 优化呢？于是我糊了这个奇葩做法，Luogu 是可以过的，当然最劣复杂度……我没有算，应该是非线性的，所以考试时当然不要用。 1234567891011121314int y[MAXn + 10];void EvaY(char *txt, char *wrd, int n, int m) &#123; z[1] = n; while (1 + y[1] &lt;= n &amp;&amp; 1 + y[1] &lt;= m &amp;&amp; txt[1 + y[1]] == wrd[1 + y[1]]) ++y[1]; for (int i = 2, l = 0, r = 0; i &lt;= n; ++i) &#123; if (i &lt;= r) z[i] = min(r - i + 1, z[i - l + 1]); y[i] = min(z[i], y[i - l + 1]); while (i + y[i] &lt;= n &amp;&amp; 1 + y[i] &lt;= m &amp;&amp; txt[i + y[i]] == wrd[1 + y[i]]) ++y[i]; while (txt[i + z[i]] == txt[1 + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"三分","slug":"TemLib/三分","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/三分/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%89%E5%88%86/","excerpt":"","text":"P3382 【模板】三分法 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define re registerconst int MAXn = 13 + 1;const double EPS = 1e-6;int n;double l, r, a[MAXn + 10];double f(double x) &#123; double ans = 0; for (re int i = n; ~i; --i) &#123; ans = ans * x + a[i]; &#125; return ans;&#125;void ThreeDiv() &#123; if (r - l &lt; EPS) return; double mid = (l + r) / 2; if (f(mid - EPS) &gt; f(mid + EPS)) &#123; r = mid; &#125; else &#123; l = mid; &#125; ThreeDiv();&#125;int main() &#123; scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;l, &amp;r); for (re int i = n; ~i; --i) &#123; scanf(&quot;%lf&quot;, &amp;a[i]); &#125; ThreeDiv(); printf(&quot;%.5lf\\n&quot;, l);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"严格次小生成树","slug":"TemLib/严格次小生成树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/严格次小生成树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P4180 [BJWC2010]严格次小生成树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = 3e5;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m, root = 1;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int fat[MAXn + 10];int anc(int x) &#123; return fat[x] = fat[x] == x ? x : anc(fat[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fat[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fat[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];bool intree[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); intree[i] = 1; &#125; &#125; return ans;&#125;void mergemax(int &amp;ansmax, int &amp;anscmx, int max1, int cmx1, int max2, int cmx2) &#123; if (max1 &gt; max2) &#123; ansmax = max1; anscmx = max(max2, cmx1); &#125; else if (max1 &lt; max2) &#123; ansmax = max2; anscmx = max(max1, cmx2); &#125; else &#123; ansmax = max1; anscmx = max(cmx1, cmx2); &#125;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], maxx[MAXn * 4 + 10], cmax[MAXn * 4 + 10];void pushup(int id) &#123; mergemax(maxx[id], cmax[id], maxx[id &lt;&lt; 1], cmax[id &lt;&lt; 1], maxx[(id &lt;&lt; 1) + 1], cmax[(id &lt;&lt; 1) + 1]);&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; maxx[id] = a[l]; cmax[id] = -INF; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(id &lt;&lt; 1, l, mid, a); BuildUseArr((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;pair&lt;int, int&gt; Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return make_pair(maxx[id], cmax[id]); &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid &amp;&amp; r &gt; mid) &#123; int ansmax, anscmx; pair&lt;int, int&gt; left, right; left = Eva(id &lt;&lt; 1, l, r); right = Eva((id &lt;&lt; 1) + 1, l, r); mergemax(ansmax, anscmx, left.first, left.second, right.first, right.second); return make_pair(ansmax, anscmx); &#125; else if (l &lt;= mid) &#123; return Eva(id &lt;&lt; 1, l, r); &#125; else &#123; return Eva((id &lt;&lt; 1) + 1, l, r); &#125; &#125;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; ndwei[to[i]] = wei[i]; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125;&#125;pair&lt;int, int&gt; TreePathEva(int x, int y) &#123; int ansmax = -INF, anscmx = -INF; int tmpansmax, tmpanscmx; pair&lt;int, int&gt; tmp; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; tmp = Eva(1, nddfs[top[y]], nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; if (x == y) &#123; return make_pair(ansmax, anscmx); &#125; else &#123; tmp = Eva(1, nddfs[x] + 1, nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; return make_pair(ansmax, anscmx); &#125;&#125;int ans, diff = INF;signed main() &#123; cntnex = 1; read(n), read(m); int tmp = 0; for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); if (u == v) &#123; ++tmp; continue; &#125; edge[i - tmp] = Edge(u, v, w); &#125; m -= tmp; ans = Kruskal(); for (re int i = 1; i &lt;= m; ++i) &#123; Insert(edge[i].u, edge[i].v, edge[i].w); Insert(edge[i].v, edge[i].u, edge[i].w); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArr(1, 1, n, idxwei); for (re int i = 1; i &lt;= m; ++i) &#123; if (!intree[i]) &#123; pair&lt;int, int&gt; tmp = TreePathEva(edge[i].u, edge[i].v); if (tmp.first == edge[i].w) &#123; diff = min(diff, edge[i].w - tmp.second); &#125; else &#123; diff = min(diff, edge[i].w - tmp.first); &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans + diff);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"中国剩余定理(crt)","slug":"TemLib/中国剩余定理(crt)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/中国剩余定理(crt)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86(crt)/","excerpt":"","text":"P1495 【模板】中国剩余定理(CRT)/曹冲养猪 x=∑i=1nai×Mi×Mi−1(mod⁡ mi) mod⁡mx=\\sum\\limits_{i=1}^{n}a_i\\times M_i\\times M^{-1}_i(\\operatorname{mod}~m_i)~\\operatorname{mod}mx=i=1∑n​ai​×Mi​×Mi−1​(mod mi​) modm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 10;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;int n, a[MAXn + 10], m[MAXn + 10];int Crt() &#123; int ans = 0, mulm = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mulm = mulm * m[i]; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; int M = mulm / m[i]; ans = (ans + ((a[i] * M) % mulm * inv(M, m[i])) % mulm) % mulm; &#125; return ans;&#125;signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(m[i]), read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Crt());&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"主席树","slug":"TemLib/主席树","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/主席树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"Luogu P3834【模板】可持久化线段树 2（主席树） 1. 普通主席树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using std::map;using std::sort;using std::unique;const int MAXn = 2e5;const int MAXlogn = 20;const int MAXm = 2e5;const int MAXnd = MAXn * 4 + MAXm * MAXlogn;const int MAXroot = MAXm;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], sum[MAXnd + 10];int cntroot, root[MAXroot + 10];int end[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int Build0(int l, int r) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; ls[id] = Build0(l, mid); rs[id] = Build0(mid + 1, r); &#125; return id;&#125;int BuildUseArr(int l, int r, int *a) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; ls[id] = BuildUseArr(l, mid, a); rs[id] = BuildUseArr(mid + 1, r, a); pushup(id); &#125; return id;&#125;int Insert(int verid, int l, int r, int p, int k) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; sum[id] = sum[verid] + k; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; ls[id] = Insert(ls[verid], l, mid, p, k); rs[id] = rs[verid]; &#125; else &#123; ls[id] = ls[verid]; rs[id] = Insert(rs[verid], mid + 1, r, p, k); &#125; pushup(id); &#125; return id;&#125;map&lt;int, int&gt; mapdown; int cntmap, mapup[MAXn + 10];int n1, n2, m, a[MAXn + 10];int Query(int lid, int rid, int k) &#123; if (end[lid]) &#123; return mapup[end[lid]]; &#125; else &#123; if (k &lt;= sum[ls[rid]] - sum[ls[lid]]) &#123; return Query(ls[lid], ls[rid], k); &#125; else &#123; return Query(rs[lid], rs[rid], k - (sum[ls[rid]] - sum[ls[lid]])); &#125; &#125;&#125;signed main() &#123; read(n1, m); for (int i = 1; i &lt;= n1; ++i) &#123; read(a[i]); mapup[i] = a[i]; &#125; sort(mapup + 1, mapup + 1 + n1); n2 = unique(mapup + 1, mapup + 1 + n1) - mapup - 1; for (int i = 1; i &lt;= n2; ++i) &#123; mapdown[mapup[i]] = i; &#125; cntroot = -1; root[++cntroot] = Build0(1, n2); for (int i = 1; i &lt;= n1; ++i) &#123; ++cntroot; root[cntroot] = Insert(root[cntroot - 1], 1, n2, mapdown[a[i]], 1); &#125; for (int i = 1, l, r, k; i &lt;= m; ++i) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, Query(root[l - 1], root[r], k)); &#125;&#125; 2. 动态开点主席树 注释部分是二分答案的 O(nlog2n)O(nlog^2n)O(nlog2n) 查询做法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283int cntroot, root[MAXn + 10];int cntnd, rs[MAXnd + 10], ls[MAXnd + 10], le[MAXnd + 10], ri[MAXnd + 10], sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;void NewAdd(int id, int l, int r, int p, int v) &#123; le[id] = l, ri[id] = r; sum[id] = v; if (le[id] == ri[id]) &#123; ; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) NewAdd(ls[id] = ++cntnd, le[id], mid, p, v); else NewAdd(rs[id] = ++cntnd, mid + 1, ri[id], p, v); &#125;&#125;void VerAdd(int id, int verid, int p, int v) &#123; le[id] = le[verid], ri[id] = ri[verid]; sum[id] = sum[verid] + v; if (le[id] == ri[id]) &#123; ; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) &#123; rs[id] = rs[verid]; if (ls[verid]) VerAdd(ls[id] = ++cntnd, ls[verid], p, v); else NewAdd(ls[id] = ++cntnd, le[id], mid, p, v); &#125; else &#123; ls[id] = ls[verid]; if (rs[verid]) VerAdd(rs[id] = ++cntnd, rs[verid], p, v); else NewAdd(rs[id] = ++cntnd, mid + 1, ri[id], p, v); &#125; pushup(id); &#125;&#125;int SumSec(int id, int l, int r) &#123; if (!id) return 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += SumSec(ls[id], l, r); if (r &gt; mid) ans += SumSec(rs[id], l, r); return ans; &#125;&#125;// int Query(int L, int R, int rk) &#123;// int l = -MAXa, r = MAXa, mid;// while (l &lt; r) &#123;// mid = (l + r) &gt;&gt; 1;// if (SumSec(root[R], -MAXa, mid) - SumSec(root[L - 1], -MAXa, mid) &gt;= rk) &#123;// r = mid;// &#125; else &#123;// l = mid + 1;// &#125;// &#125;// return l;// &#125;int Query(int lid, int rid, int rk) &#123; if (le[rid] == ri[rid]) &#123; return le[rid]; &#125; else &#123; if (rk &lt;= sum[ls[rid]] - sum[ls[lid]]) return Query(ls[lid], ls[rid], rk); else return Query(rs[lid], rs[rid], rk - (sum[ls[rid]] - sum[ls[lid]])); &#125;&#125;int n, m;signed main() &#123; read(n, m); for (int i = 1, a; i &lt;= n; ++i) &#123; read(a); ++cntroot; if (i == 1) NewAdd(root[cntroot] = ++cntnd, -MAXa, MAXa, a, 1); else VerAdd(root[cntroot] = ++cntnd, root[cntroot - 1], a, 1); &#125; for (int i = 1, L, R, rk; i &lt;= m; ++i) &#123; read(L, R, rk); // printf(&quot;%d\\n&quot;, Query(L, R, rk)); printf(&quot;%d\\n&quot;, Query(root[L - 1], root[R], rk)); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二分","slug":"TemLib/二分","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二分/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%88%86/","excerpt":"","text":"重点： midmidmid 取 l+rl+rl+r 还是 l+r+1l+r+1l+r+1。 &quot; === &quot; 的话应该算那种情况。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, x, arr[MAXn + 10];int a() &#123; //大于等于中最小的(lower_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int b() &#123; //大于中最小的(upper_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int c() &#123; //小于中最大的 int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int d() &#123; //小于等于中最大的 int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int main() &#123; read(n), read(x); for (re int i = 1; i &lt;= n; ++i) &#123; read(arr[i]); &#125; printf(&quot;%d %d %d %d\\n&quot;, a(), b(), c(), d()); // printf(&quot;%d %d\\n&quot;, int(lower_bound(arr + 1, arr + 1 + n, x) - arr), int(upper_bound(arr + 1, arr + 1 + n, x) - arr));&#125; 结果：","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二分图","slug":"TemLib/二分图","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/二分图/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"","text":"Luogu P3386 【模板】二分图最大匹配 Luogu P1350 车的放置 Luogu P6062 USACO05JAN Muddy Fields G Luogu P3355 骑士共存问题 12345678910111213141516171819202122232425262728293031323334353637bool vis[MAXnd + 10];int match[MAXnd + 10];bool Dfs(int cur) &#123; if (vis[cur]) return 0; // vis[cur] = 1; // 如果只是求最大匹配，不求最小点覆盖和最大独立集可以不用给左部点打标记，可以不加这两行。 for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; vis[to[i]] = 1; if (!match[to[i]] || Dfs(match[to[i]])) &#123; match[to[i]] = cur; return 1; &#125; &#125; return 0;&#125;int ans1, ans2, mincover[MAXnd + 10];signed main() &#123; // ...... for (int i = 1; i &lt;= cntleft; ++i) &#123; memset(vis, 0, sizeof(vis)); if (Dfs(i)) ++ans1; &#125; for (int i = cntleft + 1, top = cntleft + cntright; i &lt;= top; ++i) &#123; if (match[i]) match[match[i]] = 1; &#125; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= cntleft; ++i) &#123; if (!match[i]) Dfs(i); &#125; for (int i = 1; i &lt;= cntleft; ++i) &#123; if (!vis[i]) mincover[++ans2] = i; &#125; for (int i = cntleft + 1, top = cntleft + cntright; i &lt;= top; ++i) &#123; if (vis[i]) mincover[++ans2] = i; &#125; // ans1 == ans2&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"二叉堆","slug":"TemLib/二叉堆","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二叉堆/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%8F%89%E5%A0%86/","excerpt":"","text":"P3378 【模板】堆 大根堆 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; int opt; n = read(); while (n--) &#123; opt = read(); switch (opt) &#123; case 1: Insert(read()); break; case 2: printf(&quot;%d\\n&quot;, GetRoot()); break; case 3: PopRoot(); break; &#125; &#125;&#125; 小根堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &gt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &lt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &gt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; Insert(1); Insert(3); Insert(1); Insert(7); Insert(11); Insert(25); cout &lt;&lt; GetRoot() &lt;&lt; endl; PopRoot(); cout &lt;&lt; GetRoot() &lt;&lt; endl;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二叉搜索树","slug":"TemLib/二叉搜索树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二叉搜索树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"P5076 【深基16.例7】普通二叉树（简化版） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;const int INF = 2147483647;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());register bool f = c == &#x27;-&#x27;;register T s = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -s : s;&#125;struct Node &#123; int l, r, siz, cnt, val;&#125;;Node nd[MAXn + 10];int cnt;void Insert(int id, int val) &#123; ++nd[id].siz; if (nd[id].val == val) &#123; ++nd[id].cnt; &#125; else if (nd[id].val &lt; val) &#123; if (!nd[id].r) &#123; nd[++cnt].val = val; nd[id].r = cnt; &#125; Insert(nd[id].r, val); &#125; else &#123; if (!nd[id].l) &#123; nd[++cnt].val = val; nd[id].l = cnt; &#125; Insert(nd[id].l, val); &#125;&#125; int ValtoRank(int id, int val) &#123; if (!id) &#123; return 1; &#125; if (nd[id].val == val) &#123; return nd[nd[id].l].siz + 1; &#125; else if (nd[id].val &lt; val) &#123; return nd[nd[id].l].siz + nd[id].cnt + ValtoRank(nd[id].r, val); &#125; else &#123; return ValtoRank(nd[id].l, val); &#125;&#125;int RanktoVal(int id, int rank) &#123; if (!id) &#123; return -123456789; &#125; if (rank &lt;= nd[nd[id].l].siz) &#123; return RanktoVal(nd[id].l, rank); &#125; else if (rank &gt; nd[nd[id].l].siz + nd[id].cnt) &#123; return RanktoVal(nd[id].r, rank - nd[nd[id].l].siz - nd[id].cnt); &#125; else &#123; return nd[id].val; &#125;&#125;int EvaPreVal(int id, int val) &#123; if (!id) &#123; return -INF; &#125; if (nd[id].val &gt;= val) &#123; return EvaPreVal(nd[id].l, val); &#125; else &#123; return max(nd[id].val, EvaPreVal(nd[id].r, val)); &#125;&#125;int EvaNexVal(int id, int val) &#123; if (!id) &#123; return INF; &#125; if (nd[id].val &lt;= val) &#123; return EvaNexVal(nd[id].r, val); &#125; else &#123; return min(nd[id].val, EvaNexVal(nd[id].l, val)); &#125;&#125;int root = 1, n, opt, x;int main() &#123; read(n); nd[1].cnt = 1; nd[1].l = 2; nd[1].siz = 2; nd[1].val = INF; nd[2].cnt = 1; nd[2].siz = 1; nd[2].val = -INF; cnt += 2; for (re int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: printf(&quot;%d\\n&quot;, ValtoRank(root, x) - 1); break; case 2: printf(&quot;%d\\n&quot;, RanktoVal(root, x + 1)); break; case 3: printf(&quot;%d\\n&quot;, EvaPreVal(root, x)); break; case 4: printf(&quot;%d\\n&quot;, EvaNexVal(root, x)); break; case 5: Insert(root, x); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二维凸包","slug":"TemLib/二维凸包","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/二维凸包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/","excerpt":"","text":"P2742 USACO5.1 圈奶牛Fencing the Cows /【模板】二维凸包 省略号部分见 二维计算几何模板。 x-y 排序法 12345678910111213141516171819202122232425262728struct Point &#123; // ... inline bool operator&lt;(const Point sec) const &#123; if (cmp(x, sec.x)) &#123; return x &lt; sec.x; &#125; return y &lt; sec.y; &#125;&#125;;int top, bottom, stk[MAXn * 2 + 10]; bool instk[MAXn + 10];void EvaConv(Point p[], int n) &#123; sort(p + 1, p + 1 + n); bottom = 1; top = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (top &gt; bottom &amp;&amp; (p[stk[top]] - p[stk[top - 1]]) % (p[i] - p[stk[top]]) &lt;= 0) instk[stk[top--]] = 0; stk[++top] = i; instk[i] = 1; &#125; bottom = top; for (int i = n; i; --i) &#123; if (instk[i]) continue; while (top &gt; bottom &amp;&amp; (p[stk[top]] - p[stk[top - 1]]) % (p[i] - p[stk[top]]) &lt;= 0) instk[stk[top--]] = 0; stk[++top] = i; instk[i] = 1; &#125; while (top &gt; bottom &amp;&amp; (p[stk[top]] - p[stk[top - 1]]) % (p[1] - p[stk[top]]) &lt;= 0) instk[stk[top--]] = 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"二维树状数组","slug":"TemLib/二维树状数组","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/二维树状数组/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"1234567891011121314151617181920212223int t[MAXn + 10][MAXn + 10];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline void Add(int x, int y, int k, int topx, int topy) &#123; for (int i = x; i &lt;= topx; i += lowbit(i)) &#123; for (int j = y; j &lt;= topy; j += lowbit(j)) &#123; t[i][j] += k; &#125; &#125;&#125;inline int Sum(int x, int y) &#123; int ans = 0; for (int i = x; i; i -= lowbit(i)) &#123; for (int j = y; j; j -= lowbit(j)) &#123; ans += t[i][j]; &#125; &#125; return ans;&#125;inline int Sec(int x1, int y1, int x2, int y2) &#123; return Sum(x2, y2) - Sum(x1 - 1, y2) - Sum(x2, y1 - 1) + Sum(x1 - 1, y1 - 1);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二维计算几何","slug":"TemLib/二维计算几何","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/二维计算几何/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697const double EPS = 1e-10;const double INF = 1e15;const double PI = acos(-1);const double SQRT2 = sqrt(2);inline int sig(double a) &#123; if (a &gt; EPS) return 1; else if (a &lt; -EPS) return -1; else return 0;&#125;inline int cmp(double a, double b) &#123; if (a - b &gt; EPS) return 1; else if (a - b &lt; -EPS) return -1; else return 0;&#125;struct Point &#123; double x, y; inline Point(): x(0.0), y(0.0)&#123;&#125; inline Point(double _x, double _y): x(_x), y(_y)&#123;&#125; inline Point operator+(Point sec) &#123;return Point&#123;x: x + sec.x, y: y + sec.y&#125;;&#125; inline Point operator-(Point sec) &#123;return Point&#123;x: x - sec.x, y: y - sec.y&#125;;&#125; inline Point operator&gt;&gt;(Point sec) &#123;return Point&#123;x: sec.x - x, y: sec.y - y&#125;;&#125; inline Point operator*(double a) &#123;return Point&#123;x: x * a, y: y * a&#125;;&#125; inline double operator*(Point sec) &#123;return x * sec.x + y * sec.y;&#125; inline double operator%(Point sec) &#123;return x * sec.y - sec.x * y;&#125; inline bool operator==(Point sec) &#123;return x == sec.x &amp;&amp; y == sec.y;&#125; inline bool operator&lt;(const Point sec) const &#123; if (cmp(x, sec.x) == 0) &#123; return y &lt; sec.y; &#125; return x &lt; sec.x; &#125;&#125;;inline double length(Point a) &#123; return sqrt(a * a);&#125;inline double area(Point a, Point b, Point c) &#123; return (a &gt;&gt; b) % (a &gt;&gt; c);&#125;inline double proj(Point a, Point b, Point c) &#123; return ((a &gt;&gt; b) * (a &gt;&gt; c)) / length(a &gt;&gt; b);&#125;inline double angle(Point a) &#123; return atan2(a.y, a.x);&#125;inline double angle(Point a, Point b) &#123; return acos((a * b) / length(a) / length(b));&#125;inline Point rotate(Point a, double angle) &#123; double cs = cos(angle), sn = sin(angle); return Point&#123;x: cs * a.x - sn * a.y, y: sn * a.x + cs * a.y&#125;;&#125;inline bool poi_on_str(Point a, Point b, Point c) &#123; return sig((a &gt;&gt; c) % (b &gt;&gt; c)) == 0;&#125;inline double poi_dist_str(Point a, Point b, Point c) &#123; return fabs((a &gt;&gt; b) % (a &gt;&gt; c)) / length(a &gt;&gt; b);&#125;inline double poi_dist_seg(Point a, Point b, Point c) &#123; if (a == b) return length(a &gt;&gt; c); if ((a &gt;&gt; b) * (a &gt;&gt; c) &lt;= 0) return length(a &gt;&gt; c); if ((b &gt;&gt; a) * (b &gt;&gt; c) &lt;= 0) return length(b &gt;&gt; c); return poi_dist_str(a, b, c);&#125;inline bool poi_on_seg(Point a, Point b, Point c) &#123; return sig(poi_dist_seg(a, b, c)) == 0;&#125;inline Point poi_proj_str(Point a, Point b, Point c) &#123; return a + (a &gt;&gt; b) * (((a &gt;&gt; b) * (a &gt;&gt; c)) / ((a &gt;&gt; b) * (a &gt;&gt; b)));&#125;inline bool seg_on_seg(Point a, Point b, Point c, Point d) &#123; if (poi_on_seg(c, d, a) || poi_on_seg(c, d, b) || poi_on_seg(a, b, c) || poi_on_seg(a, b, d)) return 1; return sig((a &gt;&gt; b) % (a &gt;&gt; c)) * sig((a &gt;&gt; b) % (a &gt;&gt; d)) &lt; 0 &amp;&amp; sig((c &gt;&gt; d) % (c &gt;&gt; a)) * sig((c &gt;&gt; d) % (c &gt;&gt; b)) &lt; 0;&#125;inline Point str_int_str(Point a, Point b, Point c, Point d) &#123; return a + ((a &gt;&gt; b) * (((c &gt;&gt; d) % (c &gt;&gt; a)) / ((a &gt;&gt; b) % (c &gt;&gt; d))));&#125;inline double pol_area(Point point[], int n) &#123; double ans = 0; Point zero(0, 0); for (int i = 1; i &lt; n; ++i) &#123; ans += (zero &gt;&gt; point[i]) % (zero &gt;&gt; point[i + 1]); &#125; ans += (zero &gt;&gt; point[n]) % (zero &gt;&gt; point[1]); return ans / 2;&#125;inline int poi_on_pol(Point a, Point b[], int n) &#123; int cnt = 0; Point far(PI * 1e6, SQRT2 * 1e6); for (int i = 1; i &lt; n; ++i) &#123; if (poi_on_seg(b[i], b[i + 1], a)) return 1; if (seg_on_seg(b[i], b[i + 1], a, far)) ++cnt; &#125; if (poi_on_seg(b[n], b[1], a)) return 1; if (seg_on_seg(b[n], b[1], a, far)) ++cnt; if (cnt &amp; 1) return 2; else return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"二维费用背包","slug":"TemLib/二维费用背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二维费用背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1855 榨取kkksc03 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW1 = 200;const int MAXW2 = 200;const int INF = 0x3f3f3f3f;int n, W1, W2;int d[MAXW1 + 10][MAXW2 + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;int eva_maxV(int W1, int W2) &#123; int ans = -INF; for (int i = 0; i &lt;= W1; i++) &#123; for (int j = 0; j &lt;= W2; j++) ans = max(ans, d[i][j]); &#125; return ans;&#125;int main() &#123; n = read(); W1 = read(); W2 = read(); int v, w1, w2; for (int i = 1; i &lt;= n; i++) &#123; v = 1; w1 = read(); w2 = read(); for (int j = W1; j &gt;= w1; j--) &#123; for (int k = W2; k &gt;= w2; k--) d[j][k] = max(d[j][k], d[j - w1][k - w2] + v); &#125; &#125; cout &lt;&lt; eva_maxV(W1, W2);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"分块","slug":"TemLib/分块","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/分块/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E5%9D%97/","excerpt":"","text":"P2357 守墓人 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register#define int long longconst int MAXn = 2e6;const int MAXsqrtn = 500;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m;int a[MAXn + 10], inpart[MAXn + 10], length;int cntpart, sum[MAXsqrtn + 10], add[MAXsqrtn + 10], le[MAXsqrtn + 10], ri[MAXsqrtn + 10];void BuildUseArray(int *a) &#123; length = cntpart = sqrt(n); for (re int i = 1, l = 1, r = cntpart; i &lt;= cntpart; ++i) &#123; le[i] = l; ri[i] = r; for (re int j = l; j &lt;= r; ++j) &#123; sum[i] += a[j]; inpart[j] = i; &#125; l = r + 1; r += length; &#125; if (ri[cntpart] &lt; n) &#123; ++cntpart; le[cntpart] = ri[cntpart - 1] + 1; ri[cntpart] = n; for (re int i = le[cntpart]; i &lt;= ri[cntpart]; ++i) &#123; sum[cntpart] += a[i]; inpart[i] = cntpart; &#125; &#125;&#125;void Add(int l, int r, int k) &#123; if (inpart[l] == inpart[r]) &#123; for (re int i = l; i &lt;= r; ++i) &#123; a[i] += k; &#125; sum[inpart[l]] += k * (r - l + 1); &#125; else &#123; for (re int i = l; i &lt;= ri[inpart[l]]; ++i) &#123; a[i] += k; &#125; sum[inpart[l]] += k * (ri[inpart[l]] - l + 1); for (re int i = le[inpart[r]]; i &lt;= r; ++i) &#123; a[i] += k; &#125; sum[inpart[r]] += k * (r - le[inpart[r]] + 1); for (re int i = inpart[l] + 1; i &lt; inpart[r]; ++i) &#123; add[i] += k; &#125; &#125;&#125;int EvaSum(int l, int r) &#123; int ans = 0; if (inpart[l] == inpart[r]) &#123; for (re int i = l; i &lt;= r; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[l]] * (r - l + 1); &#125; else &#123; for (re int i = l; i &lt;= ri[inpart[l]]; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[l]] * (ri[inpart[l]] - l + 1); for (re int i = le[inpart[r]]; i &lt;= r; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[r]] * (r - le[inpart[r]] + 1); for (re int i = inpart[l] + 1; i &lt; inpart[r]; ++i) &#123; ans += sum[i] + add[i] * length; &#125; &#125; return ans;&#125;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArray(a); for (re int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(z); Add(x, y, z); break; case 2: read(x); a[1] += x; sum[1] += x; break; case 3: read(x); a[1] -= x; sum[1] -= x; break; case 4: read(x), read(y); printf(&quot;%lld\\n&quot;, EvaSum(x, y)); break; case 5: printf(&quot;%lld\\n&quot;, a[1] + add[1]); break; &#125; &#125;&#125; 本来我是用线段树的板题来测我的分块的，但是后来又用这道题测了一下，发现始终过不了，调了很久才发现 “EvaSum -&gt; if (inpart[l] == inpart[r]) -&gt; ans += add[inpart[l]] * (r - l + 1);” 这句没有写。但是线段树的板题竟然过了，就离谱，这就是我不推荐用线段树板题测分块的原因。（不是为了水题）。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"分组背包","slug":"TemLib/分组背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/分组背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1757 通天之分组背包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 1000;const int MAXW = 1000;int n, W;int v[MAXn + 10];int w[MAXn + 10];int team[MAXn + 10][MAXn + 10];int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void put_in() &#123; W = read(); n = read(); int teamid; for (int i = 1; i &lt;= n; i++) &#123; w[i] = read(); v[i] = read(); teamid = read(); team[teamid][++team[teamid][0]] = i; &#125;&#125;void rec(int v[], int w[], int W)&#123; for (int i = 1; i &lt;= MAXn; i++) &#123; if (team[i][0]) &#123; for (int j = W; j &gt;= 0; j--) &#123; for (int k = 1; k &lt;= team[i][0]; k++) &#123; if (j &gt;= w[team[i][k]]) d[j] = max(d[j], d[j - w[team[i][k]]] + v[team[i][k]]); &#125; &#125; &#125; &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v, w, W); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"前缀积法求逆元","slug":"TemLib/前缀积法求逆元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/前缀积法求逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%8D%E7%BC%80%E7%A7%AF%E6%B3%95%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P5431 【模板】乘法逆元 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e6;#define int long longtemplate &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ans * x % mod; &#125; x = x * x % mod; y &gt;&gt;= 1; &#125; return ans;&#125;int inv(int n, int mod) &#123; int inv = power(n, mod - 2, mod); return (inv % mod + mod) % mod;&#125;int n, p, k, a[MAXn + 10], pi[MAXn + 10], mi[MAXn + 10], invv, ans;signed main() &#123; read(n), read(p), read(k); pi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); pi[i] = (pi[i - 1] * a[i]) % p; &#125; mi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mi[i] = (mi[i - 1] * k) % p; &#125; invv = inv(pi[n], p); for (re int i = n; i; --i) &#123; ans = (ans + mi[i] * (invv * pi[i - 1] % p)) % p; invv = (invv * a[i]) % p; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"割点 & 点双连通分量","slug":"TemLib/割点 & 点双连通分量","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/割点 & 点双连通分量/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%B2%E7%82%B9%20&%20%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"P3388 【模板】割点（割顶） 123456789101112131415161718192021222324252627282930313233int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXnd + 10&gt; iscut;void Tarjan(int cur, int root) &#123; dfs[cur] = low[cur] = ++cntdfs; int times = 0; bool havcnt = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], root); low[cur] = min(low[cur], low[to[i]]); if (!havcnt) &#123; if (low[to[i]] &gt;= dfs[cur]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; havcnt = 1; ++cntcut; iscut[cur] = 1; &#125; &#125; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, i); &#125; &#125;&#125; T103492 【模板】点双连通分量 12345678910111213141516171819202122232425262728293031323334353637int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntdcc; vector&lt;int&gt; dcc[MAXnd + 10];int top, stk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; dcc[++cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt;= dfs[cur]) &#123; ++cntdcc; int x; do &#123; x = stk[top--]; dcc[cntdcc].push_back(x); &#125; while (x != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"割边 & 边双连通分量","slug":"TemLib/割边 & 边双连通分量","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/割边 & 边双连通分量/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%B2%E8%BE%B9%20&%20%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"T103481 【模板】割边 123456789101112131415161718192021222324252627int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125;&#125; T103489 【模板】边双连通分量 1234567891011121314151617181920212223242526272829303132333435363738394041int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;int cntdcc, indcc[MAXnd + 10];void EvaDcc(int cur) &#123; indcc[cur] = cntdcc; for (int i = head[cur]; i; i = nex[i]) &#123; if (indcc[to[i]] || iscut[i]) continue; EvaDcc(to[i]); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!indcc[i]) &#123; ++cntdcc; EvaDcc(i); &#125; &#125;&#125; 如果只让输出边双的个数，桥数+不连通的图数也是正确答案。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"动态dp","slug":"TemLib/动态dp","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/动态dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81dp/","excerpt":"","text":"Luogu P4719 【模板】“动态 DP”&amp;动态树分治 1234567891011121314151617Mat g[MAXn + 10];void Update(int x, int v) &#123; g[x].a[1][0] -= val[x]; g[x].a[1][0] += v; while (fa[top[x]]) &#123; Mat last = query(1, nddfs[top[x]], ed[x]); modifyRepPoint(1, nddfs[x], g[x]); Mat now = query(1, nddfs[top[x]], ed[x]); x = fa[top[x]]; g[x].a[0][0] -= max(last.a[0][0], last.a[1][0]); g[x].a[0][0] += max(now.a[0][0], now.a[1][0]); g[x].a[0][1] = g[x].a[0][0]; g[x].a[1][0] -= last.a[0][0]; g[x].a[1][0] += now.a[0][0]; &#125; modifyRepPoint(1, nddfs[x], g[x]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"动态二维凸包","slug":"TemLib/动态二维凸包","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/动态二维凸包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/","excerpt":"","text":"CF70D Professor’s task 省略号部分见 二维计算几何模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct Point &#123; double x, y, ang; // ... inline bool operator&lt;(const Point sec) const &#123; return ang &lt; sec.ang; &#125;&#125;;// ...typedef set&lt;Point&gt;::iterator it;set&lt;Point&gt; s;inline it Prec(it x) &#123; return x == begin(s) ? --end(s) : --x;&#125;inline it Nex(it x) &#123; return (++x) == end(s) ? begin(s) : x;&#125;void Solve(Point p) &#123; pair&lt;it, bool&gt; pr = s.insert(p); if (pr.second == 0) return; if (s.size() &lt;= 3) return; it cur = pr.first; it prec = Prec(cur), nex = Nex(cur); if (sig((*cur - *prec) % (*nex - *cur)) &lt;= 0) &#123; s.erase(cur); return; &#125; it i = Prec(cur), j = Prec(i); while (s.size() &gt; 3 &amp;&amp; sig((*i - *j) % (*cur - *i)) &lt;= 0) &#123; s.erase(i); i = j; j = Prec(j); &#125; i = Nex(cur), j = Nex(i); while (s.size() &gt; 3 &amp;&amp; sig((*i - *cur) % (*j - *i)) &lt;= 0) &#123; s.erase(i); i = j; j = Nex(j); &#125;&#125;bool Query(Point p) &#123; it nex = s.lower_bound(p); if (nex == end(s)) nex = begin(s); it prec = Prec(nex); return sig((p - *prec) % (*nex - p)) &lt;= 0;&#125;int n;signed main() &#123; read(n); Point o&#123;x: PI / 100.0, y: SQRT2 / 100.0, ang: 0.0&#125;, ori[4]; for (int i = 1, opt, x, y; i &lt;= 3; ++i) &#123; read(opt, x, y); o.x += x; o.y += y; ori[i].x = x * 3; ori[i].y = y * 3; &#125; for (int i = 1; i &lt;= 3; ++i) &#123; ori[i].ang = angle(o, ori[i]); Solve(ori[i]); &#125; Point p; for (int i = 4, opt, x, y; i &lt;= n; ++i) &#123; read(opt, x, y); p.x = x * 3; p.y = y * 3; p.ang = angle(o, p); if (opt == 1) &#123; Solve(p); &#125; else &#123; puts(Query(p) ? &quot;YES&quot; : &quot;NO&quot;); &#125; &#125; return 0;&#125; Point o&#123;x: PI / 100.0, y: SQRT2 / 100.0, ang: 0.0&#125; 这里使用了原点偏移法，给了原点一个无理数增量，这是为了避免极角相等的点的情况，如果不加这句可能会 W ⁣A{\\color{red}\\mathrm{W\\!A}}WA，还有一种不建议使用的避免 W ⁣A{\\color{red}\\mathrm{W\\!A}}WA 的方法是增加排序关键字法，将代码第四行的函数改为： 123456inline bool operator&lt;(const Point sec) const &#123; if (!cmp(ang, sec.ang)) &#123; return x &lt; sec.x; &#125; return ang &lt; sec.ang;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"动态开点线段树","slug":"TemLib/动态开点线段树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/动态开点线段树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"P5459 [BJOI2016]回转寿司 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define int long longusing std::map;using std::sort;using std::unique;const int MAXn = 1e5;const int MAXa = 1e5;const int MAXsuma = MAXn * MAXa;const int MAXlogsuma = 34;const int MAXnd = MAXn * MAXlogsuma * 4;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], le[MAXnd + 10], ri[MAXnd + 10], sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int AddNew(int l, int r, int p, int k) &#123; int id = ++cntnd; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = k; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; ls[id] = AddNew(l, mid, p, k); &#125; else &#123; rs[id] = AddNew(mid + 1, r, p, k); &#125; pushup(id); &#125; return id;&#125;void AddOld(int id, int p, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] += k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) &#123; if (ls[id]) &#123; AddOld(ls[id], p, k); &#125; else &#123; ls[id] = AddNew(le[id], mid, p, k); &#125; &#125; else &#123; if (rs[id]) &#123; AddOld(rs[id], p, k); &#125; else &#123; rs[id] = AddNew(mid + 1, ri[id], p, k); &#125; &#125; pushup(id); &#125;&#125;int Sec(int id, int l, int r) &#123; if (!id) return 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += Sec(ls[id], l, r); if (r &gt; mid) ans += Sec(rs[id], l, r); return ans; &#125;&#125;int n1, n2, L, R, a[MAXn + 10], suma[MAXn + 10], ans;signed main() &#123; read(n1, L, R); for (int i = 1; i &lt;= n1; ++i) &#123; read(a[i]); suma[i] = suma[i - 1] + a[i]; &#125; ++cntnd; le[cntnd] = -MAXsuma; ri[cntnd] = MAXsuma; sum[cntnd] = 0; AddOld(1, 0, 1); for (int i = 1; i &lt;= n1; ++i) &#123; ans += Sec(1, suma[i] - R, suma[i] - L); AddOld(1, suma[i], 1); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"动态树(lct)","slug":"TemLib/动态树(lct)","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/动态树(lct)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E6%A0%91(lct)/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int fa[MAXn + 10], son[MAXn + 10][2], val[MAXn + 10], xsum[MAXn + 10], rev[MAXn + 10];inline bool side(int id) &#123; return id == son[fa[id]][1];&#125;inline bool isroot(int id) &#123; return son[fa[id]][0] != id &amp;&amp; son[fa[id]][1] != id;&#125;inline void pushup(int id) &#123; xsum[id] = xsum[son[id][0]] ^ val[id] ^ xsum[son[id][1]];&#125;inline void putrev(int id) &#123; swap(son[id][0], son[id][1]); rev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (rev[id]) &#123; putrev(son[id][0]), putrev(son[id][1]); rev[id] = 0; &#125;&#125;inline void rotate(int id) &#123; int y = fa[id], z = fa[y], sideid = side(id), s = son[id][sideid ^ 1]; if (!isroot(y)) &#123;son[z][side(y)] = id;&#125; fa[id] = z; son[y][sideid] = s; if (s) &#123;fa[s] = y;&#125; son[id][sideid ^ 1] = y; fa[y] = id; pushup(y), pushup(id);&#125;int top, stk[MAXn + 10];inline void splay(int id) &#123; int anc = id; while (true) &#123; stk[++top] = anc; if (!isroot(anc)) anc = fa[anc]; else break; &#125; while (top) pushdown(stk[top--]); int y; while (!isroot(id)) &#123; y = fa[id]; if (!isroot(y)) &#123; if (side(id) == side(y)) rotate(y); else rotate(id); &#125; rotate(id); &#125;&#125;inline void access(int x) &#123; int backupx = x; for (int sn = 0; x; sn = x, x = fa[x]) &#123; splay(x); son[x][1] = sn; pushup(x); &#125; splay(backupx);&#125;inline void makeroot(int x) &#123; access(x); putrev(x);&#125;inline int findroot(int x) &#123; access(x); int rt = x; while (true) &#123; pushdown(rt); if (son[rt][0]) rt = son[rt][0]; else break; &#125; splay(rt); return rt;&#125;inline void Split(int x, int y) &#123; makeroot(x); access(y);&#125;inline void Link(int x, int y) &#123; makeroot(x); if (findroot(y) != x) fa[x] = y;&#125;inline void Cut(int x, int y) &#123; makeroot(x); if (findroot(y) == x &amp;&amp; fa[y] == x &amp;&amp; !son[y][0]) &#123; son[x][1] = fa[y] = 0; pushup(x); &#125;&#125;int n, m;signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(val[i]); &#125; for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt, x, y); if (opt == 0) &#123; Split(x, y); printf(&quot;%d\\n&quot;, xsum[y]); &#125; else if (opt == 1) &#123; Link(x, y); &#125; else if (opt == 2) &#123; Cut(x, y); &#125; else if (opt == 3) &#123; splay(x); val[x] = y; pushup(x); &#125; &#125; return 0;&#125; 其中 putrev 和 pushdown 这两个函数有两个版本，先 swap 版（就是上面代码用的的版本）： 12345678910inline void putrev(int id) &#123; swap(son[id][0], son[id][1]); rev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (rev[id]) &#123; putrev(son[id][0]), putrev(son[id][1]); rev[id] = 0; &#125;&#125; 后 swap 版： 12345678910inline void putrev(int id) &#123; rev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (rev[id]) &#123; swap(son[id][0], son[id][1]); putrev(son[id][0]), putrev(son[id][1]); rev[id] = 0; &#125;&#125; 如果使用第二个版本，那么需要保证在 splay 中从上往下操作时所有对儿子节点的操作和询问都应该在 pushdown 之后进行。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"卢卡斯定理","slug":"TemLib/卢卡斯定理","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/卢卡斯定理/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/","excerpt":"","text":"P3807 【模板】卢卡斯定理/Lucas 定理 C⁡nmmod⁡p=C⁡n/pm/p×C⁡nmod⁡pmmod⁡pmod⁡p\\operatorname{C}^m_n\\operatorname{mod}p=\\operatorname{C}^{m/p}_{n/p}\\times \\operatorname{C}^{m\\operatorname{mod}p}_{n \\operatorname{mod}p}\\operatorname{mod}pCnm​modp=Cn/pm/p​×Cnmodpmmodp​modp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#define re registertypedef long long ll;const int MAXC = 1e5 + 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int x, int p) &#123; int ans, k; exgcd(x, p, ans, k); return (ans % p + p) % p;&#125;int fac[MAXC + 10];void EvaFac(int top, int p) &#123; fac[0] = 1; for (re int i = 1; i &lt;= top; ++i) &#123; fac[i] = ((ll)fac[i - 1] * i) % p; &#125;&#125;int C(int n, int m, int p) &#123; if (n &lt; m) return 0; return (ll)fac[n] * inv(fac[m], p) % p * inv(fac[n - m], p) % p;&#125;int Lucas(int n, int m, int p) &#123; if (!m) return 1; return (ll)Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;&#125;int T, n, m, p;int main() &#123; read(T); while (T--) &#123; read(n), read(m), read(p); EvaFac(MAXC, p); n += m; m = n - m; printf(&quot;%d\\n&quot;, Lucas(n, m, p)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"可重集全排列","slug":"TemLib/可重集全排列","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/可重集全排列/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8F%AF%E9%87%8D%E9%9B%86%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"P2518 [HAOI2010]计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans;signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"同余最短路","slug":"TemLib/同余最短路","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/同余最短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P3403 跳楼机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXnd = 5e5;const int MAXn = 12;const int MAXeg = MAXnd * MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10], wei[MAXeg + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;bool vis[MAXnd + 10]; int dis[MAXnd + 10];priority_queue&lt;pair&lt;int, int&gt;&gt; q;void Dijkstra(int root, int rootdis) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = rootdis; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int n, l, r, a[MAXn + 10], ans;signed main() &#123; read(n, l, r); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; sort(a + 1, a + 1 + n); for (int i = 0; i &lt; a[1]; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; Insert(i, (i + a[j]) % a[1], a[j]); &#125; &#125; Dijkstra(0, 0); for (int i = 0; i &lt; a[1]; ++i) &#123; if (dis[i] &gt; r) continue; ans += (r - dis[i]) / a[1] + 1; if (dis[i] &gt; l - 1) continue; ans -= (l - 1 - dis[i]) / a[1] + 1; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"后缀数组 & Height数组","slug":"TemLib/后缀数组 & Height数组","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/后缀数组 & Height数组/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%20&%20Height%E6%95%B0%E7%BB%84/","excerpt":"","text":"Acwing 2715. 后缀数组 1234567891011121314151617181920212223242526272829303132333435363738int sa[MAXn + 10], rk[MAXn + 10], x[MAXn * 2 + 10], y[MAXn * 2 + 10], buc[MAXn + 10];void EvaSaRk(int n, int m, char *str) &#123; for (int i = 1; i &lt;= n; ++i) ++buc[x[i] = str[i] - &#x27;0&#x27; + 1]; for (int i = 2; i &lt;= m; ++i) buc[i] += buc[i - 1]; for (int i = n; i; --i) sa[buc[x[i]]--] = i; for (int half = 1; ; half &lt;&lt;= 1) &#123; int cnty = 0; for (int i = n - half + 1; i &lt;= n; ++i) y[++cnty] = i; for (int i = 1; i &lt;= n; ++i) if (sa[i] &gt; half) y[++cnty] = sa[i] - half; memset(buc, 0, sizeof(buc)); for (int i = 1; i &lt;= n; ++i) ++buc[x[i]]; for (int i = 2; i &lt;= m; ++i) buc[i] += buc[i - 1]; for (int i = n; i; --i) sa[buc[x[y[i]]]--] = y[i]; swap(x, y); m = 0; for (int i = 1; i &lt;= n; ++i) &#123; x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + half] == y[sa[i - 1] + half]) ? m : ++m; &#125; if (m == n) break; &#125; for (int i = 1; i &lt;= n; ++i) &#123; rk[sa[i]] = i; &#125;&#125;int ht[MAXn + 10];void EvaHt(int n, char *str) &#123; for (int i = 1, k = 0, j; i &lt;= n; ++i) &#123; if (rk[i] == 1) continue; if (k) --k; j = sa[rk[i] - 1]; while (str[i + k] == str[j + k]) ++k; ht[rk[i]] = k; &#125;&#125;EvaSaRk(n, &#x27;z&#x27; - &#x27;0&#x27; + 1, str);EvaHt(n, str);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"后缀自动机(SAM)","slug":"TemLib/后缀自动机(SAM)","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/后缀自动机(SAM)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA(SAM)/","excerpt":"","text":"Luogu P3804 【模板】后缀自动机 (SAM) 1234567891011121314151617181920212223242526int cntnd, last, link[MAXnd + 10], son[MAXnd + 10][26], cntep[MAXnd + 10], mxlen[MAXnd + 10];void Init() &#123; cntnd = last = 1;&#125;void Extend(int ch) &#123; int a, b, c; a = c = last, b = last = ++cntnd; cntep[b] = 1; mxlen[b] = mxlen[a] + 1; for (; c &amp;&amp; !son[c][ch]; c = link[c]) son[c][ch] = b; if (!c) &#123; link[b] = 1; &#125; else &#123; int d = son[c][ch]; if (mxlen[d] == mxlen[c] + 1) &#123; link[b] = d; &#125; else &#123; int e = ++cntnd; link[e] = link[d]; memcpy(son[e], son[d], sizeof(son[e])); mxlen[e] = mxlen[c] + 1; link[d] = link[b] = e; for (; c &amp;&amp; son[c][ch] == d; c = link[c]) son[c][ch] = e; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"哈希","slug":"TemLib/哈希","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/哈希/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%93%88%E5%B8%8C/","excerpt":"","text":"123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 2333;int ans = 0, num, mo;vector&lt;int&gt; hash[MOD + 10];void insert(int a) &#123; mo = a % MOD; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == a) return; ans++; hash[mo].push_back(a);&#125;int main() &#123; int n; int a; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a), insert(a); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"圆方树解仙人掌","slug":"TemLib/圆方树解仙人掌","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/圆方树解仙人掌/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9C%86%E6%96%B9%E6%A0%91%E8%A7%A3%E4%BB%99%E4%BA%BA%E6%8E%8C/","excerpt":"","text":"Luogu P5236 【模板】静态仙人掌 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int cntdfs1, dfs[MAXnd + 10], low[MAXnd + 10];int back[MAXnd + 10], throwback[MAXnd + 10], bottom[MAXnd + 10];int cntdcc; vector&lt;pair&lt;int, int&gt;&gt; dcc[MAXnd + 10];int topstk, stk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs1; if (!head1[cur]) &#123; dcc[++cntdcc].push_back(make_pair(cur, 0)); return; &#125; stk[++topstk] = cur; for (int i = head1[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; if (low[cur] &gt; dfs[to[i]]) &#123; low[cur] = dfs[to[i]]; throwback[cur] = wei[i]; &#125; &#125; else &#123; back[to[i]] = wei[i]; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt;= dfs[cur]) &#123; ++cntdcc; int x; x = stk[topstk--]; dcc[cntdcc].push_back(make_pair(cur, throwback[x])); dcc[cntdcc].push_back(make_pair(x, back[x])); while (x != to[i]) &#123; x = stk[topstk--]; dcc[cntdcc].push_back(make_pair(x, back[x])); &#125; &#125; &#125; &#125; bottom[cur] = cntdfs1;&#125;int tresum[MAXnd + 10];int fa[MAXnd + 10], dep[MAXnd + 10], siz[MAXnd + 10], hson[MAXnd + 10];void Dfs1(int cur, int f, int tsum) &#123; fa[cur] = f; tresum[cur] = tsum; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mxsonsiz = 0; for (int i = head2[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; Dfs1(to[i], cur, tresum[cur] + wei[i]); siz[cur] += siz[to[i]]; if (mxsonsiz &lt; siz[to[i]]) &#123; mxsonsiz = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs2, nddfs[MAXnd + 10], idxdfs[MAXnd + 10], top[MAXnd + 10];void Dfs2(int cur, int tp) &#123; nddfs[cur] = ++cntdfs2; idxdfs[cntdfs2] = cur; top[cur] = tp; if (hson[cur]) &#123; Dfs2(hson[cur], tp); &#125; for (int i = head2[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; Dfs2(to[i], to[i]); &#125;&#125;void Lca(int x, int y, int &amp;lca, int &amp;xnear, int &amp;ynear) &#123; lca = xnear = ynear = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; xnear = top[x]; x = fa[top[x]]; &#125; else &#123; ynear = top[y]; y = fa[top[y]]; &#125; &#125; if (dep[x] &gt; dep[y]) &#123; lca = y; xnear = idxdfs[nddfs[lca] + 1]; &#125; else if (dep[x] &lt; dep[y]) &#123; lca = x; ynear = idxdfs[nddfs[lca] + 1]; &#125; else &#123; lca = x; &#125;&#125;int cirsum[MAXnd + 10];int n, m, q;int N;signed main() &#123; read(n, m, q); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); Insert(head1, u, v, w); Insert(head1, v, u, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125; N = n; for (int i = 1, dccsiz; i &lt;= cntdcc; ++i) &#123; dccsiz = dcc[i].size(); if (dccsiz == 1) &#123; ; &#125; else if (dccsiz == 2) &#123; Insert(head2, dcc[i][0].first, dcc[i][1].first, dcc[i][0].second); &#125; else &#123; ++N; cirsum[dcc[i][dccsiz - 1].first] = dcc[i][dccsiz - 1].second; for (int j = dccsiz - 2; j; --j) &#123; cirsum[dcc[i][j].first] = cirsum[dcc[i][j + 1].first] + dcc[i][j].second; &#125; cirsum[N] = cirsum[dcc[i][1].first] + dcc[i][0].second; Insert(head2, dcc[i][0].first, N, 0); for (int j = 1; j &lt; dccsiz; ++j) &#123; Insert(head2, N, dcc[i][j].first, min(cirsum[dcc[i][j].first], cirsum[N] - cirsum[dcc[i][j].first])); &#125; &#125; &#125; Dfs1(1, 0, 0); Dfs2(1, 1); for (int i = 1, x, y, lca, xnear, ynear; i &lt;= q; ++i) &#123; read(x, y); Lca(x, y, lca, xnear, ynear); if (lca &lt;= n) &#123; printf(&quot;%d\\n&quot;, tresum[x] + tresum[y] - 2 * tresum[lca]); &#125; else &#123; int tmp = abs(cirsum[xnear] - cirsum[ynear]); printf(&quot;%d\\n&quot;, tresum[x] - tresum[xnear] + tresum[y] - tresum[ynear] + min(tmp, cirsum[lca] - tmp)); &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"块状链表","slug":"TemLib/块状链表","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/块状链表/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Poj 2887 BigString 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXtxtlen = 1e6;const int MAXsqrttxtlen = 1e3;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, sqrtn;struct Node &#123; int len; Node *pre, *nex; char txt[MAXsqrttxtlen * 2 + 10]; Node() &#123;len = 0, pre = nullptr, nex = nullptr, memset(txt, 0, sizeof(txt));&#125; inline void split(int p) &#123; Node *nw = new Node; nw-&gt;nex = nex; nex = nw; nw-&gt;pre = this; if (nw-&gt;nex != nullptr) nw-&gt;nex-&gt;pre = nw; copy(txt + p + 1, txt + len + 1, nw-&gt;txt + 1); nw-&gt;len = len - p; len = p; &#125; inline void insert(int p, char ch) &#123; for (int i = len; i &gt; p; --i) &#123; txt[i + 1] = txt[i]; &#125; txt[p + 1] = ch; ++len; if (len &gt; sqrtn) &#123; split(len &gt;&gt; 1); &#125; &#125;&#125;;Node *head;inline void Init(char *str) &#123; Node *last = nullptr; for (int l = 1, r = sqrtn; ; l += sqrtn, r += sqrtn) &#123; Node *nw = new Node; if (last != nullptr) &#123; nw-&gt;pre = last; last-&gt;nex = nw; &#125; else &#123; head = nw; &#125; nw-&gt;len = min(r, n) - l + 1; copy(str + l, str + l + nw-&gt;len, nw-&gt;txt + 1); last = nw; if (r &gt;= n) break; &#125;&#125;inline char Query(int p) &#123; --p; Node *cur = head; while (p &gt;= cur-&gt;len) &#123; p -= cur-&gt;len; cur = cur-&gt;nex; &#125; return cur-&gt;txt[1 + p];&#125;inline void Insert(int p, char ch) &#123; --p; Node *cur = head; if (p == -1) &#123; cur-&gt;insert(0, ch); return; &#125; while (p &gt;= cur-&gt;len) &#123; p -= cur-&gt;len; cur = cur-&gt;nex; &#125; cur-&gt;insert(1 + p, ch);&#125;int m;char str[MAXtxtlen + 10];signed main() &#123; scanf(&quot;%s&quot;, str + 1); n = strlen(str + 1); sqrtn = sqrt(n); Init(str); read(m); char opt, ch; for (int i = 1, p; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, &amp;opt); if (opt == &#x27;Q&#x27;) &#123; read(p); printf(&quot;%c\\n&quot;, Query(p)); &#125; else if (opt == &#x27;I&#x27;) &#123; scanf(&quot;%s&quot;, &amp;ch); read(p); Insert(p - 1, ch); &#125; else &#123; puts(&quot;Error!&quot;); exit(1); &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"基环树","slug":"TemLib/基环树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/基环树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9F%BA%E7%8E%AF%E6%A0%91/","excerpt":"","text":"P1453 城市环路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;double k;int n, a[MAXn + 10], deg[MAXn + 10];queue&lt;int&gt; q;bool vis[MAXn + 10];int cntring, ring[MAXn + 10];void EvaRing() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 1) &#123; q.push(i); &#125; &#125; int cur; while (!q.empty()) &#123; cur = q.front(); q.pop(); vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!vis[to[i]]) &#123; --deg[to[i]]; if (deg[to[i]] == 1) &#123; q.push(to[i]); &#125; &#125; &#125; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 2) &#123; vis[i] = 1; ring[++cntring] = i; break; &#125; &#125; bool ok = 1; while (ok) &#123; ok = 0; for (re int i = head[ring[cntring]]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 1) continue; vis[to[i]] = 1; ring[++cntring] = to[i]; ok = 1; break; &#125; &#125;&#125;int d[MAXn + 10][2];void dp(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 2) continue; dp(to[i]); d[cur][0] += max(d[to[i]][1], d[to[i]][0]); d[cur][1] += d[to[i]][0]; &#125; d[cur][1] += a[cur];&#125;void Dp() &#123; memset(vis, 0, sizeof(vis)); for (re int i = 1; i &lt;= cntring; ++i) &#123; dp(ring[i]); &#125;&#125;int f[MAXn + 10][2][2];int Dp2() &#123; f[1][0][0] = d[ring[1]][0]; f[1][1][1] = d[ring[1]][1]; f[1][0][1] = f[1][1][0] = -INF; for (re int i = 2; i &lt;= cntring; ++i) &#123; f[i][0][0] = max(f[i - 1][0][0], f[i - 1][0][1]) + d[ring[i]][0]; f[i][0][1] = f[i - 1][0][0] + d[ring[i]][1]; f[i][1][0] = max(f[i - 1][1][0], f[i - 1][1][1]) + d[ring[i]][0]; f[i][1][1] = f[i - 1][1][0] + d[ring[i]][1]; &#125; return max(max(f[cntring][0][0], f[cntring][0][1]), f[cntring][1][0]);&#125;int main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (re int i = 1, u, v; i &lt;= n; ++i) &#123; read(u), read(v); ++u; ++v; ++deg[u]; ++deg[v]; Insert(u, v); Insert(v, u); &#125; scanf(&quot;%lf&quot;, &amp;k); EvaRing(); Dp(); printf(&quot;%.1lf\\n&quot;, (double)Dp2() * k);&#125; 基环树求环长度和环上每个节点前的边的长度： 123456789101112int cntinring, ring[MAXnd + 10], ringdis;int ndwei[MAXnd + 10];void EvaRing(int cur, int fromedge, int begin) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (iscut[i] || i == (fromedge ^ 1)) continue; ring[++cntinring] = to[i]; ringdis += wei[i]; ndwei[to[i]] = wei[i]; if (to[i] != begin) EvaRing(to[i], i, begin); if (cur == begin) break; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"埃氏筛","slug":"TemLib/埃氏筛","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/埃氏筛/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9F%83%E6%B0%8F%E7%AD%9B/","excerpt":"","text":"P3383 【模板】线性筛素数 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#define re register const int MAXn = 1e8;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, cntp, p[MAXn / 10 + 100];bool notp[MAXn + 10];void ES(int up) &#123; notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; if ((long long)i * i &lt;= up) for (re int j = i * i; j &lt;= up; j += i) notp[j] = 1; &#125; &#125;&#125;int main() &#123; read(n), read(m); ES(n); for (re int i = 1, q; i &lt;= m; ++i) &#123; read(q); printf(&quot;%d\\n&quot;, p[q]); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"堆排序","slug":"TemLib/堆排序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/堆排序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 【模板】快速排序 可以用快排的板测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int heap[MAXn+10];int heapn;int n;void up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void insert(int x) &#123; heap[++heapn] = x; up(heapn);&#125;void pop(int p) &#123; heap[p] = heap[heapn--]; up(p); down(p);&#125;void pop_root() &#123; heap[1] = heap[heapn--]; down(1);&#125;int get_root() &#123; return heap[1];&#125;int main()&#123; n = read(); for(int i = 0; i &lt; n; i++) &#123; insert(read()); &#125; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, get_root()); pop_root(); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"多重背包","slug":"TemLib/多重背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/多重背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1776 宝物筛选 1. 单调队列优化版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW = 4e4;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int le, ri; pair&lt;int, int&gt; q[MAXW + 10];inline void Init() &#123; le = 1; ri = 0;&#125;inline void Push_back(int x, int idx) &#123; while (le &lt;= ri &amp;&amp; q[ri].first &lt;= x) &#123; --ri; &#125; q[++ri] = make_pair(x, idx);&#125;inline int Front(int idx) &#123; while (le &lt;= ri &amp;&amp; q[le].second &lt; idx) &#123; ++le; &#125; return q[le].first;&#125;int n, W, d[MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, v, w, m; i &lt;= n; ++i) &#123; read(v, w, m); for (int j = 0; j &lt; w; ++j) &#123; Init(); for (int k = 0, l = j; l &lt;= W; ++k, l += w) &#123; Push_back(d[l] - k * v, k); d[l] = Front(k - m) + k * v; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, d[W]);&#125; 2. 二进制拆分版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 100;const int MAXW = 40000;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; &#125;&#125;void rec(int v[], int w[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; n = read(); W = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; v = read(); w = read(); num = read(); bin_divide(v, w, num, v_new, w_new, num_new); &#125; rec(v_new, w_new, W, num_new); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"字符串dp","slug":"TemLib/字符串dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2dp/","excerpt":"","text":"P3082 [USACO13MAR]Necklace G 1. Kmp上Dp（会T） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::ios;using std::cin;using std::cout;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int INF = 0x3f3f3f3f;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10];int d[MAXltxt + 10][MAXlwrd + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; while (k &amp;&amp; (wrd[k + 1] != txt[i + 1] || k == lwrd)) k = fail[k]; if (wrd[k + 1] == txt[i + 1]) ++k; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; 2. Ac自动机上Dp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using std::ios;using std::cin;using std::cout;using std::queue;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int MAXnd = 1e3;const int INF = 0x3f3f3f3f;int cntnd, son[MAXnd + 10][26], fail[MAXnd + 10];int Insert(char *str) &#123; int len = strlen(str + 1); int cur = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (!son[cur][str[i] - &#x27;a&#x27;]) &#123; son[cur][str[i] - &#x27;a&#x27;] = ++cntnd; &#125; cur = son[cur][str[i] - &#x27;a&#x27;]; &#125; return cur;&#125;queue&lt;int&gt; q;void EvaFail() &#123; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int j = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) &#123; if (son[j][i]) &#123; fail[son[j][i]] = son[fail[j]][i]; q.push(son[j][i]); &#125; else &#123; son[j][i] = son[fail[j]][i]; &#125; &#125; &#125;&#125;char wrd[MAXlwrd + 10], txt[MAXltxt + 10];int n, lwrd, ltxt, d[MAXltxt + 10][MAXlwrd + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); Insert(wrd); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; k = son[k][txt[i + 1] - &#x27;a&#x27;]; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"字符串哈希","slug":"TemLib/字符串哈希","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串哈希/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"P3370 【模板】字符串哈希 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1510;const int base = 261;const int MOD = 23333;int n, ans = 0;char s[MAXn];vector&lt;string&gt; hash[MOD + 2];inline void insert() &#123; int mo = 1; for (int i = 0; s[i]; i++) mo = (mo * 1ll * base + s[i]) % MOD; string s2 = s; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == s2) return; hash[mo].push_back(s2); ans++;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, &amp;s), insert(); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"字符串哈希解最小循环节","slug":"TemLib/字符串哈希解最小循环节","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/字符串哈希解最小循环节/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E8%A7%A3%E6%9C%80%E5%B0%8F%E5%BE%AA%E7%8E%AF%E8%8A%82/","excerpt":"","text":"P3538 POI2012\\OKR-A Horrible Poem 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e5;const int BASE = 107;const int MOD = 1e9 + 7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, cntp, p[MAXn + 10], minpf[MAXn + 10];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; minpf[i] = i; &#125; int up2 = up / i; for (int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; minpf[i * p[j]] = p[j]; if (!(i % p[j])) &#123; break; &#125; &#125; &#125;&#125;int hashpre[MAXn + 10], poww[MAXn + 10];inline int hash(int l, int r) &#123; return ((hashpre[r] - hashpre[l - 1] * poww[r - l + 1]) % MOD + MOD) % MOD;&#125;char str[MAXn + 10];signed main() &#123; read(n); LS(n); scanf(&quot;%s&quot;, str + 1); for (int i = 1; i &lt;= n; ++i) &#123; hashpre[i] = (hashpre[i - 1] * BASE + str[i] - &#x27;a&#x27;) % MOD; &#125; poww[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; poww[i] = (poww[i - 1] * BASE) % MOD; &#125; read(m); for (re int i = 1; i &lt;= m; ++i) &#123; int l, r, len, ans; read(l), read(r); ans = len = r - l + 1; if (hash(l + 1, r) == hash(l, r - 1)) &#123; printf(&quot;1\\n&quot;); &#125; else &#123; while (len &gt; 1) &#123; if (hash(l + ans / minpf[len], r) == hash(l, r - ans / minpf[len])) &#123; ans /= minpf[len]; //ans: 循环节长度 &#125; //minpf: 最小质因数，循环次数 len /= minpf[len]; //len: 无实际意义，用于提取所有质因数 &#125; printf(&quot;%lld\\n&quot;, ans); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"字符串最小表示法","slug":"TemLib/字符串最小表示法","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串最小表示法/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"P1368 【模板】最小表示法 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::min;const int MAXn = 3e5;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, a[MAXn * 2 + 10], begin;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); a[i + n] = a[i]; &#125; int i = 1, j = 2, k = 0; while (true) &#123; if (i &gt; n || j &gt; n) &#123; begin = min(i, j); break; &#125; k = 0; while (a[i + k] == a[j + k] &amp;&amp; k &lt; n) ++k; if (k == n) &#123; begin = i; break; &#125; if (a[i + k] &gt; a[j + k]) &#123; i = i + k + 1; if (i == j) ++i; &#125; else &#123; j = j + k + 1; if (i == j) ++j; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d &quot;, a[begin + i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"完全背包","slug":"TemLib/完全背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/完全背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1616 疯狂的采药 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;LL n, W;LL d[MAXW + 10];int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = w; i &lt;= W; i++) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"实用小高精","slug":"TemLib/实用小高精","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/实用小高精/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%9E%E7%94%A8%E5%B0%8F%E9%AB%98%E7%B2%BE/","excerpt":"","text":"不实用的高精 推荐一个实用小高精： 1234567891011121314151617181920212223struct BigInt &#123; const static long long base = 1e13; long long s[2]; friend BigInt operator + (BigInt a, const BigInt b) &#123; a.s[0] += b.s[0]; a.s[1] += b.s[1]; if (a.s[0] &gt;= base) ++a.s[1], a.s[0] -= base; return a; &#125; friend int operator % (BigInt a, int b) &#123; return ((a.s[1] % b) * base + a.s[0]) % b; &#125; friend BigInt operator / (BigInt a, int b) &#123; BigInt c; c.s[1] = a.s[1] / b; c.s[0] = ((a.s[1] % b) * base + a.s[0]) / b; return c; &#125; void print() &#123; if (s[1]) printf(&quot;%lld%13lld&quot;, s[1], s[0]); else printf(&quot;%lld&quot;, s[0]); &#125;&#125;; 乘法不用考虑，用 s[1] * s[1] 就炸了。减法还要考虑负数（如果需要的话）。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"对顶栈","slug":"TemLib/对顶栈","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/对顶栈/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AF%B9%E9%A1%B6%E6%A0%88/","excerpt":"","text":"P2201 数列编辑器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;struct Ele &#123; int val, sum, maxsum; Ele()&#123;&#125; Ele(int val_):val(val_)&#123;&#125;&#125;;struct Stack &#123; int top; Ele stk[MAXn + 10]; inline void Push(int x) &#123; stk[++top] = Ele(x); &#125; inline int Pop() &#123; return stk[top--].val; &#125;&#125;fro, beh;int n;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; char opt; for (re int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; opt; switch (opt) &#123; case &#x27;I&#x27;: cin &gt;&gt; x; fro.Push(x); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;D&#x27;: fro.Pop(); break; case &#x27;L&#x27;: beh.Push(fro.Pop()); break; case &#x27;R&#x27;: fro.Push(beh.Pop()); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;Q&#x27;: cin &gt;&gt; x; cout &lt;&lt; fro.stk[x].maxsum &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"容斥原理","slug":"TemLib/容斥原理","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/容斥原理/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"","text":"P1450 HAOI2008 硬币购物 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 4;const int MAXn2 = 16;const int MAXW = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int T, n = 4, W, w[MAXn + 10], cnt[MAXn + 10], d[MAXW + 10];signed main() &#123; read(w[1]), read(w[2]), read(w[3]), read(w[4]), read(T); d[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = w[i]; j &lt;= MAXW; ++j) &#123; d[j] += d[j - w[i]]; &#125; &#125; while (T--) &#123; read(cnt[1]), read(cnt[2]), read(cnt[3]), read(cnt[4]), read(W); int ans = 0; for (re int i = 0; i &lt; MAXn2; ++i) &#123; int p = W; for (re int j = 1; j &lt;= n; ++j) &#123; if ((i &gt;&gt; (j - 1)) &amp; 1) &#123; p -= w[j] * (cnt[j] + 1); &#125; &#125; if (p &lt; 0) &#123; continue; &#125; ans += __builtin_popcount(i) &amp; 1 ? -d[p] : d[p]; &#125; printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"左偏堆","slug":"TemLib/左偏堆","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/左偏堆/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B7%A6%E5%81%8F%E5%A0%86/","excerpt":"","text":"Luogu P3377 【模板】左偏树（可并堆） 123456789101112131415161718int ls[MAXn + 10], rs[MAXn + 10];int val[MAXn + 10], hig[MAXn + 10]; bool isdel[MAXn + 10];void Init() &#123; val[0] = INF; hig[0] = -1;&#125;int Merge(int x, int y) &#123; if (!x || !y) return x + y; if (val[x] &gt; val[y]) swap(x, y); rs[x] = Merge(rs[x], y); if (hig[ls[x]] &lt; hig[rs[x]]) swap(ls[x], rs[x]); hig[x] = hig[rs[x]] + 1; return x;&#125;int Pop(int x) &#123; isdel[x] = 1; return Merge(ls[x], rs[x]);&#125; main 函数里的函数调用： 12345678910111213141516171819202122Init();u.Init(n);// ...read(opt);if (opt == 1) &#123; read(x, y); if (isdel[x] || isdel[y]) continue; int ancx = u.anc(x), ancy = u.anc(y); if (ancx == ancy) continue; int nwroot = Merge(ancx, ancy); nwroot == ancx ? u.Merge(ancy, ancx) : u.Merge(ancx, ancy);&#125; else if (opt == 2) &#123; read(x); if (isdel[x]) &#123; puts(&quot;-1&quot;); continue; &#125; int ancx = u.anc(x); int nwroot = Pop(ancx); u.ChangeRoot(ancx, nwroot); printf(&quot;%d\\n&quot;, val[ancx]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"带权并查集","slug":"TemLib/带权并查集","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/带权并查集/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"带权并查集的适用前提：维护的关系具有可传递性 带权并查集操作需保证的条件：执行了 Find 函数或 Merge 函数的节点的所有信息一定会被更新 P2024 NOI2001 食物链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;const int MAXm = 1e5;int fa[MAXn + 10], dis[MAXn + 10];void Init(int top) &#123; for (int i = 0; i &lt;= top; ++i) &#123; fa[i] = i; &#125; memset(dis, 0, sizeof(dis));&#125;int Find(int x) &#123; if (fa[x] == x) &#123; return x; &#125; else &#123; int lastfa = fa[x]; fa[x] = Find(fa[x]); dis[x] = dis[x] + dis[lastfa]; return fa[x]; &#125;&#125;void Merge(int x, int y, int dist) &#123; int ancx = Find(x), ancy = Find(y); fa[ancx] = ancy; dis[ancx] = -dis[x] + dist + dis[y];&#125;int Query(int x, int y) &#123; int ancx = Find(x), ancy = Find(y); if (ancx != ancy) &#123; return -1; &#125; else &#123; return ((dis[x] - dis[y]) % 3 + 3) % 3; &#125;&#125;int n, m, cntfalse;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; Init(n); for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (x &gt; n || y &gt; n) &#123; ++cntfalse; continue; &#125; if (opt == 1) &#123; int qu = Query(x, y); if (qu == -1) &#123; Merge(x, y, 0); &#125; else if (qu != 0) &#123; ++cntfalse; &#125; &#125; else &#123; int qu = Query(x, y); if (qu == -1) &#123; Merge(x, y, 1); &#125; else if (qu != 1) &#123; ++cntfalse; &#125; &#125; &#125; cout &lt;&lt; cntfalse &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"并查集","slug":"TemLib/并查集","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/并查集/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"P3367 【模板】并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 1e4;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;int n, m;int main() &#123; read(n), read(m); Init(n); for (re int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y); Merge(x, y); break; case 2: read(x), read(y); SameAnc(x, y) ? printf(&quot;Y\\n&quot;) : printf(&quot;N\\n&quot;); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"康托展开 & 逆康托展开","slug":"TemLib/康托展开 & 逆康托展开","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/康托展开 & 逆康托展开/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%20&%20%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","excerpt":"","text":"P3014 [USACO11FEB]Cow Line S 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 20;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : c ^ &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int t[MAXn + 10];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline void BuildUseSum(int *sum, int top) &#123; for (int i = 1; i &lt;= top; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;inline void Add(int p, int x, int top) &#123; while (p &lt;= top) &#123; t[p] += x; p += lowbit(p); &#125;&#125;inline int Sum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;inline int Div(int l, int r, int x) &#123; int mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (Sum(mid) &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int fac[MAXn + 10];void EvaFac(int top) &#123; fac[0] = 1; for (int i = 1; i &lt;= top; ++i) &#123; fac[i] = fac[i - 1] * i; &#125;&#125;int sum[MAXn + 10];void EvaSum(int top) &#123; for (int i = 1; i &lt;= top; ++i) &#123; sum[i] = i; &#125;&#125;int n, q;int x, a[MAXn + 10];int cnt[MAXn + 10], ans[MAXn + 10];void InvCantor() &#123; BuildUseSum(sum, n); int tmpx = x - 1; for (int i = n; i; --i) &#123; cnt[i] = tmpx / fac[i - 1]; tmpx %= fac[i - 1]; &#125; for (int i = n; i; --i) &#123; ans[i] = Div(1, n, cnt[i] + 1); Add(ans[i], -1, n); &#125;&#125;int Cantor() &#123; BuildUseSum(sum, n); int ans = 1; for (int i = n; i; --i) &#123; Add(a[i], -1, n); ans += fac[i - 1] * Sum(a[i]); &#125; return ans;&#125;signed main() &#123; read(n, q); EvaFac(n); EvaSum(n); char opt; for (int i = 1; i &lt;= q; ++i) &#123; cin &gt;&gt; opt; if (opt == &#x27;P&#x27;) &#123; read(x); InvCantor(); for (int i = n; i; --i) &#123; printf(&quot;%lld &quot;, ans[i]); &#125; puts(&quot;&quot;); &#125; else &#123; for (int i = n; i; --i) &#123; read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Cantor()); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"异或高斯消元","slug":"TemLib/异或高斯消元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/异或高斯消元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BC%82%E6%88%96%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"P2447 SDOI2010 外星千足虫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 2e3; // 本代码中n和m和题面中的是反的，代码中n代表矩阵的行数，m代表列数const int MAXm = 1e3;int n, m, ans;bitset&lt;MAXm + 10&gt; a[MAXn + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; m &gt;&gt; n; char tmp; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m + 1; ++j) &#123; cin &gt;&gt; tmp; a[i][j] = tmp - &#x27;0&#x27;; &#125; &#125; int row = 1; for (int col = 1; col &lt;= m; ++col) &#123; int maxer = row; for (int i = row + 1; i &lt;= n; ++i) &#123; if (a[maxer][col] &lt; a[i][col]) &#123; maxer = i; &#125; &#125; if (!a[maxer][col]) &#123; cout &lt;&lt; &quot;Cannot Determine\\n&quot;; return 0; &#125; ans = max(ans, maxer); swap(a[row], a[maxer]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (a[i][col]) &#123; a[i] = a[i] ^ a[row]; &#125; &#125; ++row; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt;= m; ++i) &#123; if (a[i][m + 1]) &#123; cout &lt;&lt; &quot;?y7M#\\n&quot;; &#125; else &#123; cout &lt;&lt; &quot;Earth\\n&quot;; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"强连通分量","slug":"TemLib/强连通分量","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/强连通分量/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"B3609 [图论与代数结构 701] 强连通分量 1234567891011121314151617181920212223242526272829303132int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntscc; vector&lt;int&gt; scc[MAXnd + 10];int top, stk[MAXnd + 10]; bool instk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]] &amp;&amp; instk[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; scc[cntscc].push_back(x); &#125; while (x != cur); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125; 缩点： 12345for (int i = 1; i &lt;= m; ++i) &#123; if (inscc[from1[i]] != inscc[to1[i]]) &#123; Insert2(inscc[from1[i]], inscc[to1[i]]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"归并排序","slug":"TemLib/归并排序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/归并排序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 【模板】快速排序 可以用快排的板测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x=x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];int tmp[MAXn + 10];void merge(int l, int r) &#123; if (r - l &lt;= 1) &#123; return; &#125; int mid = l + (r - l &gt;&gt; 1); merge(l, mid); merge(mid, r); int p = l, q = mid, s = l; while (s &lt; r) &#123; if (p &gt;= mid || (q &lt; r &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = l; i &lt; r; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"归并法求逆序对数","slug":"TemLib/归并法求逆序对数","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/归并法求逆序对数/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BD%92%E5%B9%B6%E6%B3%95%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/","excerpt":"","text":"P1908 逆序对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Inverted Sequence Numbers//different from only Merge Sort:&quot;//Diff&quot; #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn=500000;inline int read()&#123; register char c; while(c=getchar(),c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;); register int x(c-&#x27;0&#x27;); while(c=getchar(),c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123; x=x*10+c-&#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn+10];int tmp[MAXn+10];long long ans;//Diffvoid merge(int ll, int rr) &#123; if (rr - ll &lt;= 1) &#123; return; &#125; int mid = ll + (rr - ll &gt;&gt; 1); merge(ll, mid); merge(mid, rr); int p = ll, q = mid, s = ll; while (s &lt; rr) &#123; if (p &gt;= mid || (q &lt; rr &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; ans += mid - p;//Diff &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = ll; i &lt; rr; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); printf(&quot;%lld&quot;, ans);//Diff&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快读","slug":"TemLib/快读","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/快读/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E8%AF%BB/","excerpt":"","text":"12345678template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快速乘","slug":"TemLib/快速乘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/快速乘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E4%B9%98/","excerpt":"","text":"龟速乘 12345678910111213template&lt;class T&gt;inline T mul(T x, T y, T mod) &#123; x %= mod; y %= mod; T ans = 0; while (y) &#123; if (y &amp; 1) &#123; ans = (ans + x) % mod; &#125; x = (x + x) % mod; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快速幂","slug":"TemLib/快速幂","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/快速幂/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"P1226 【模板】快速幂||取余运算 12345678910111213typedef long long LL;const int MOD = 1e7 + 7;inline int power(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ((LL)ans * x) % MOD; &#125; x = ((LL)x * x) % MOD; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快速排序","slug":"TemLib/快速排序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/快速排序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 【模板】快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];void _QuickSort_(int* a, int l, int r) &#123; int i = l, j = r, f = a[(l + r) / 2]; do &#123; while (a[i] &lt; f) &#123; i++; &#125; while (a[j] &gt; f) &#123; j--; &#125; if (i &lt;= j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125; while (i &lt;= j); if (l &lt; j) &#123; _QuickSort_(a, l, j); &#125; if (i &lt; r) &#123; _QuickSort_(a, i, r); &#125;&#125;void QuickSort(int* a, int l, int r) &#123; _QuickSort_(a, l, r - 1);&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; QuickSort(a, 0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"扩展欧几里得定理(exgcd)","slug":"TemLib/扩展欧几里得定理(exgcd)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/扩展欧几里得定理(exgcd)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86(exgcd)/","excerpt":"","text":"P1082 [NOIP2012 提高组] 同余方程 P5656 【模板】二元一次不定方程 (exgcd) 123456789101112131415161718192021#include&lt;cstdio&gt;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int a, b, d, x, y;int main() &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); d = exgcd(a, b, x, y); x *= d; x = (x % b + b) % b; printf(&quot;%d\\n&quot;, x);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"折半搜索","slug":"TemLib/折半搜索","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/折半搜索/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/","excerpt":"","text":"P4799 [CEOI2015 Day2]世界冰球锦标赛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 40;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;map&lt;int, int&gt; map1, map2;int n, midn, W, w[MAXn + 10];signed main() &#123; read(n, W); midn = n &gt;&gt; 1; for (int i = 1; i &lt;= n; ++i) &#123; read(w[i]); &#125; map1[0] = map2[0] = 1; for (int i = 1; i &lt;= midn; ++i) &#123; auto j = end(map1), bottomj = begin(map1); for (--j; ; --j) &#123; map1[(*j).first + w[i]] += map1[(*j).first]; if (j == bottomj) break; &#125; &#125; for (int i = midn + 1; i &lt;= n; ++i) &#123; auto j = end(map2), bottomj = begin(map2); for (--j; ; --j) &#123; map2[(*j).first + w[i]] += map2[(*j).first]; if (j == bottomj) break; &#125; &#125; int sum = 0, ans = 0; auto j = begin(map2), topj = end(map2); auto i = end(map1), bottomi = begin(map1); for (--i; ; --i) &#123; int topmapj = W - (*i).first; while (j != topj &amp;&amp; (*j).first &lt;= topmapj) &#123; sum += (*j).second; ++j; &#125; ans += (*i).second * sum; if (i == bottomi) break; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"搜索","slug":"搜索","permalink":"http://rsdbkhusky.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"插头dp","slug":"TemLib/插头dp","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/插头dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%8F%92%E5%A4%B4dp/","excerpt":"","text":"Luogu P5056【模板】插头dp 其实我觉得叫插头 dp，不如叫拼图 dp 更形象。 可以将代码中注释起来的有 exit(1) 的行取消注释，如果代码没有漏洞，则不会触发 exit(1)，反之则可能触发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 12;const int MAXm = 12;const int MAXcntsta = 5e4;const int MOD = 1009;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;vector&lt;pair&lt;int, int&gt;&gt; hx[2][MOD + 10];inline void Clear(int idx) &#123; for (int i = 0; i &lt; MOD; ++i) &#123; hx[idx][i].clear(); &#125;&#125;inline void Add(int idx, int k, int v) &#123; int hxk = k % MOD; for (auto i = begin(hx[idx][hxk]), topi = end(hx[idx][hxk]); i != topi; ++i) &#123; if ((*i).first == k) &#123; (*i).second += v; return; &#125; &#125; hx[idx][hxk].push_back(make_pair(k, v));&#125;inline int deg(int num, int deg) &#123; return (num &gt;&gt; (deg &lt;&lt; 1)) &amp; 3;&#125;inline int assdeg(int num, int deg, int val) &#123; return (num &amp; ~(3 &lt;&lt; (deg &lt;&lt; 1))) | (val &lt;&lt; (deg &lt;&lt; 1));&#125;int n, m, ans; char a[MAXn + 10][MAXm + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, a[i] + 1); &#125; int begini, beginj, endi, endj; bool ok = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (a[i][j] == &#x27;.&#x27;) &#123; begini = i, beginj = j; ok = 1; break; &#125; &#125; if (ok) break; &#125; ok = 0; for (int i = n; i; --i) &#123; for (int j = m; j; --j) &#123; if (a[i][j] == &#x27;.&#x27;) &#123; endi = i, endj = j; ok = 1; break; &#125; &#125; if (ok) break; &#125; for (int i = begini; i &lt;= n; ++i) &#123; for (int j = (i == begini) ? beginj : 1; j &lt;= m; ++j) &#123; int now = ((i - 1) * m + j) &amp; 1, last = now ^ 1; int x = j - 1, y = j; if (i == begini &amp;&amp; j == beginj) Add(last, 0, 1); Clear(now); for (int k = 0; k &lt; MOD; ++k) &#123; if (hx[last][k].empty()) continue; for (auto l = begin(hx[last][k]), topl = end(hx[last][k]); l != topl; ++l) &#123; int sta = (*l).first, val = (*l).second; if (!val) continue; int degx = deg(sta, x), degy = deg(sta, y); if (a[i][j] == &#x27;*&#x27;) &#123; if (degx == 0 &amp;&amp; degy == 0) Add(now, sta, val); &#125; else &#123; if (degx == 0 &amp;&amp; degy == 0) &#123; if (i != n &amp;&amp; j != m) Add(now, assdeg(assdeg(sta, x, 1), y, 2), val); &#125; else if (degx &amp;&amp; degy == 0) &#123; if (i != n) Add(now, sta, val); if (j != m) Add(now, assdeg(assdeg(sta, x, 0), y, degx), val); &#125; else if (degx == 0 &amp;&amp; degy) &#123; if (i != n) Add(now, assdeg(assdeg(sta, x, degy), y, 0), val); if (j != m) Add(now, sta, val); &#125; else if (degx == 1 &amp;&amp; degy == 1) &#123; int tmpsta = sta; tmpsta = assdeg(assdeg(tmpsta, x, 0), y, 0); for (int o = y + 1, cnt = 1; ; ++o) &#123; int dego = deg(tmpsta, o); if (dego == 1) ++cnt; else if (dego == 2) --cnt; if (!cnt) &#123; tmpsta = assdeg(tmpsta, o, 1); break; &#125; &#125; Add(now, tmpsta, val); &#125; else if (degx == 2 &amp;&amp; degy == 2) &#123; // if (i == n) exit(1); int tmpsta = sta; tmpsta = assdeg(assdeg(tmpsta, x, 0), y, 0); for (int o = x - 1, cnt = 1; ; --o) &#123; int dego = deg(tmpsta, o); if (dego == 1) --cnt; else if (dego == 2) ++cnt; if (!cnt) &#123; tmpsta = assdeg(tmpsta, o, 2); break; &#125; &#125; Add(now, tmpsta, val); &#125; else if (degx == 2 &amp;&amp; degy == 1) &#123; // if (i == n) exit(1); Add(now, assdeg(assdeg(sta, x, 0), y, 0), val); &#125; else if (i == endi &amp;&amp; j == endj) &#123; if (!assdeg(assdeg(sta, x, 0), y, 0)) ans += val; &#125; &#125; &#125; &#125; if (j == m) &#123; for (int k = 0; k &lt; MOD; ++k) &#123; if (hx[now][k].empty()) continue; for (auto l = begin(hx[now][k]), topl = end(hx[now][k]); l != topl; ++l) &#123; // if (deg((*l).first, m)) exit(1); (*l).first &lt;&lt;= 2; &#125; &#125; &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"整体二分解静态区间第k小","slug":"TemLib/整体二分解静态区间第k小","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/整体二分解静态区间第k小/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E8%A7%A3%E9%9D%99%E6%80%81%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/","excerpt":"","text":"P3834【模板】可持久化线段树 2（主席树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#define re registerconst int MAXn = 2e5;const int MAXm = 2e5;const int MAXai = 1e9;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int top, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x)))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= top) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int n, m, cnt, ans[MAXm + 10];struct Ele &#123; int idx, v, l, r, opt; Ele(): idx(0), v(0), l(0), r(0), opt(0) &#123;&#125; Ele(int idx_, int v_, int l_, int r_, int opt_): idx(idx_), v(v_), l(l_), r(r_), opt(opt_) &#123;&#125;&#125;a[MAXn + MAXm + 10], a1[MAXn + MAXm + 10], a2[MAXn + MAXm + 10];void Div(int L, int R, int l, int r) &#123; if (l &gt; r) return; if (L == R) &#123; for (re int i = l; i &lt;= r; ++i) &#123; if (a[i].opt) &#123; ans[a[i].idx] = L; &#125; &#125; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; int cnt1 = 0; int cnt2 = 0; for (re int i = l; i &lt;= r; ++i) &#123; if (!a[i].opt) &#123; if (a[i].v &lt;= mid) &#123; a1[++cnt1] = a[i]; Add(a[i].idx, 1); &#125; else &#123; a2[++cnt2] = a[i]; &#125; &#125; else &#123; int x = EvaSum(a[i].r) - EvaSum(a[i].l - 1); if (a[i].v &lt;= x) &#123; a1[++cnt1] = a[i]; &#125; else &#123; a[i].v -= x; a2[++cnt2] = a[i]; &#125; &#125; &#125; for (re int i = 1; i &lt;= cnt1; ++i) &#123; if (!a1[i].opt) &#123; Add(a1[i].idx, -1); &#125; &#125; for (re int i = 1; i &lt;= cnt1; ++i) &#123; a[l + i - 1] = a1[i]; &#125; for (re int i = 1; i &lt;= cnt2; ++i) &#123; a[l + cnt1 + i - 1] = a2[i]; &#125; Div(L, mid, l, l + cnt1 - 1); Div(mid + 1, R, l + cnt1, r); &#125;&#125;int main() &#123; read(n), read(m); top = n; for (re int i = 1, v; i &lt;= n; ++i) &#123; read(v); a[++cnt] = Ele(i, v, 0, 0, 0); &#125; for (re int i = 1, l, r, k; i &lt;= m; ++i) &#123; read(l), read(r), read(k); a[++cnt] = Ele(i, k, l, r, 1); &#125; Div(-MAXai, MAXai, 1, cnt); for (re int i = 1; i &lt;= m; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"斜率优化dp & Luogu P3195 [HNOI2008]玩具装箱","slug":"TemLib/斜率优化dp & Luogu P3195 [HNOI2008]玩具装箱","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/斜率优化dp & Luogu P3195 [HNOI2008]玩具装箱/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P3195%20[HNOI2008]%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1/","excerpt":"","text":"题目传送门 本题状转方程： di=min⁡j&lt;i{dj+(sumi−sumj+i−j−1−L)2}=min⁡j&lt;i{dj+((−1−L+sumi+i)−(j+sumj))2}设Ai=−1−L+sumi+i,Bi=i+sumi=min⁡j&lt;i{dj+(Ai−Bj)2}=min⁡j&lt;i{dj+Bj2−2×Ai×Bj}+Ai2\\begin{aligned} d_i&amp;=\\min_{j&lt;i}\\{d_j+(sum_i-sum_j+i-j-1-L)^2\\}\\\\ &amp;=\\min_{j&lt;i}\\{d_j+((-1-L+sum_i+i)-(j+sum_j))^2\\}\\\\ &amp;设A_i=-1-L+sum_i+i,B_i=i+sum_i\\\\ &amp;=\\min_{j&lt;i}\\{d_j+(A_i-B_j)^2\\}\\\\ &amp;=\\min_{j&lt;i}\\{d_j+B_j^2-2\\times A_i \\times B_j\\}+A_i^2 \\end{aligned} di​​=j&lt;imin​{dj​+(sumi​−sumj​+i−j−1−L)2}=j&lt;imin​{dj​+((−1−L+sumi​+i)−(j+sumj​))2}设Ai​=−1−L+sumi​+i,Bi​=i+sumi​=j&lt;imin​{dj​+(Ai​−Bj​)2}=j&lt;imin​{dj​+Bj2​−2×Ai​×Bj​}+Ai2​​ 推式子的方向是将只含 jjj（决策）的，既含 jjj（决策）又含 iii（状态）的和不含 jjj 的分别放在一起。 于是只含 jjj 的 dj+Bj2d_j+B_j^2dj​+Bj2​、既含 jjj 又含 iii（斜率优化要求含 iii 与 jjj 这一部分中这两者的关系是相乘）的 2×Ai×Bj2\\times A_i \\times B_j2×Ai​×Bj​、和什么都不含的 Ai2A_i^2Ai2​。 只含 jjj 的部分就是决策点的 yyy 坐标，既含 jjj 又含 iii 的部分比较复杂：将这一部分分为只含 iii 的 part1part1part1 和只含 jjj 的 part2part2part2（系数归谁无所谓），part2part2part2 就是决策点的 xxx 坐标，而 part1part1part1 的相反数是状态线的斜率。本题 xi=Bix_i=B_ixi​=Bi​，yi=di+Bi2y_i=d_i+B_i^2yi​=di​+Bi2​，ki=−(−(2×Ai))=2×Aik_i=-(-(2\\times A_i))=2\\times A_iki​=−(−(2×Ai​))=2×Ai​。 注意：决策点 xxx 坐标必须满足随状态的下标（iii）增加而单增。 上（下）凸壳维护即可，二分查询。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 5e4;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;struct Point &#123; double x, y; int idx; inline bool operator&lt;(const Point sec) const &#123; if (x == sec.x) &#123; return y &lt; sec.y; &#125; return x &lt; sec.x; &#125;&#125;;inline double k(Point a, Point b) &#123; return (b.y - a.y) / (b.x - a.x);&#125;inline double cp(Point a1, Point a2, Point b1, Point b2) &#123; return (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);&#125;int n, L, sum[MAXn + 10], d[MAXn + 10];int top; Point stk[MAXn + 10];int Div(int l, int r, double x) &#123; if (l &gt; r) return r; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (k(stk[mid], stk[mid + 1]) &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;signed main() &#123; read(n, L); for (int i = 1, a; i &lt;= n; ++i) &#123; read(a); sum[i] = sum[i - 1] + a; &#125; stk[++top] = Point&#123;x: 0, y: 0, idx: 0&#125;; for (int i = 1; i &lt;= n; ++i) &#123; int Ai = (-1 - L + sum[i] + i), Bi = i + sum[i]; int j = Div(1, top - 1, 2 * Ai); if (j == 0 || (j == top - 1 &amp;&amp; k(stk[top - 1], stk[top]) &lt; 2 * Ai)) &#123; j = top; &#125; j = stk[j].idx; int Bj = j + sum[j]; d[i] = d[j] + (Ai - Bj) * (Ai - Bj); Point nowpoint = Point&#123;x: (double)Bi, y: (double)d[i] + Bi * Bi, idx: i&#125;; while (top &gt; 1 &amp;&amp; cp(stk[top - 1], stk[top], stk[top], nowpoint) &lt;= 0) &#123; --top; &#125; stk[++top] = nowpoint; &#125; printf(&quot;%lld\\n&quot;, d[n]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"旋转卡壳 & 最小矩形覆盖","slug":"TemLib/旋转卡壳 & 最小矩形覆盖","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/旋转卡壳 & 最小矩形覆盖/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%20&%20%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/","excerpt":"","text":"旋转卡壳 Luogu P1452 USACO03FALL Beauty Contest G /【模板】旋转卡壳 注意 stk 数组要开二倍。 123456789101112131415// ...void EvaConv(Point p[], int n) &#123;/* ... */&#125;double Rotate(Point p[], int n) &#123; EvaConv(p, n); if (top &lt;= 2) &#123; return dist(p[stk[1]], p[stk[top]]); &#125; double ans = 0; copy(stk + 1, stk + top + 1, stk + top + 1); for (int i = 1, j = 3; i &lt;= top; ++i) &#123; while (j &lt; top * 2 &amp;&amp; area(p[stk[i]], p[stk[i + 1]], p[stk[j]]) &lt;= area(p[stk[i]], p[stk[i + 1]], p[stk[j + 1]])) ++j; ans = max(ans, max(dist(p[stk[i]], p[stk[j]]), dist(p[stk[i + 1]], p[stk[j]]))); &#125; return ans;&#125; 最小矩形覆盖 Luogu P3187 HNOI2007 最小矩形覆盖 12345678910111213141516171819202122232425// ...void EvaConv(Point p[], int n) &#123;/* ... */&#125;void Rotate(Point p[], int n) &#123; EvaConv(p, n); if (top &lt;= 2) &#123; puts(&quot;Error!&quot;); exit(1); &#125; copy(stk + 1, stk + top + 1, stk + top + 1); for (int i = 1, j = 3, k = 2, l, topidx = top * 2; i &lt;= top; ++i) &#123; while (j &lt; topidx &amp;&amp; area(p[stk[i]], p[stk[i + 1]], p[stk[j]]) &lt;= area(p[stk[i]], p[stk[i + 1]], p[stk[j + 1]])) ++j; while (k &lt; topidx &amp;&amp; proj(p[stk[i]], p[stk[i + 1]], p[stk[k]]) &lt;= proj(p[stk[i]], p[stk[i + 1]], p[stk[k + 1]])) ++k; if (i == 1) l = j; while (l &lt; topidx &amp;&amp; proj(p[stk[i]], p[stk[i + 1]], p[stk[l]]) &gt;= proj(p[stk[i]], p[stk[i + 1]], p[stk[l + 1]])) ++l; double h = poi_dist_str(p[stk[i]], p[stk[i + 1]], p[stk[j]]); Point kproji = poi_proj_str(p[stk[i]], p[stk[i + 1]], p[stk[k]]), lproji = poi_proj_str(p[stk[i]], p[stk[i + 1]], p[stk[l]]); double w = length(kproji - lproji); if (ans &gt; h * w) &#123; Point jprojk = poi_proj_str(kproji + rotate(lproji - kproji, -PI / 2), kproji, p[stk[j]]), jprojl = poi_proj_str(lproji + rotate(kproji - lproji, PI / 2), lproji, p[stk[j]]); ans = h * w; ansp[0] = lproji; ansp[1] = kproji; ansp[2] = jprojk; ansp[3] = jprojl; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"最大流","slug":"TemLib/最大流","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/最大流/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"","text":"P3376 【模板】网络最大流 1. Ek 算法 123456789101112131415161718192021222324252627282930313233int l, r, que[MAXn + 10];bool vis[MAXn + 10]; int lim[MAXn + 10], fromeg[MAXn + 10];bool bfs(int s, int t) &#123; l = 1, r = 0; memset(vis, 0, sizeof(vis)); que[++r] = s; vis[s] = 1; lim[s] = INF; fromeg[s] = 0; int cur; while (l &lt;= r) &#123; cur = que[l++]; for (int i = head[cur]; i; i = nex[i]) &#123; if (!c[i] || vis[to[i]]) continue; que[++r] = to[i]; vis[to[i]] = 1; lim[to[i]] = min(lim[cur], c[i]); fromeg[to[i]] = i; if (to[i] == t) return 1; &#125; &#125; return 0;&#125;int fmx;void Ek(int s, int t) &#123; while (bfs(s, t)) &#123; fmx += lim[t]; for (int eg = fromeg[t]; eg; eg = fromeg[to[eg ^ 1]]) &#123; c[eg] -= lim[t]; c[eg ^ 1] += lim[t]; &#125; &#125;&#125; 2. Dinic 算法 12345678910111213141516171819202122232425262728293031323334353637int lay[MAXn + 10], arc[MAXn + 10];int l, r, que[MAXn + 10];bool bfs(int s, int t) &#123; memset(lay, -1, sizeof(lay)); l = 1, r = 0; que[++r] = s; lay[s] = 0; arc[s] = head[s]; while (l &lt;= r) &#123; int cur = que[l++]; for (int i = head[cur]; i; i = nex[i]) &#123; if (~lay[to[i]] || !cap[i]) continue; lay[to[i]] = lay[cur] + 1; arc[to[i]] = head[to[i]]; if (to[i] == t) return 1; que[++r] = to[i]; &#125; &#125; return 0;&#125;int dfs(int cur, int t, int lim) &#123; if (cur == t) return lim; int ans = 0; for (int i = arc[cur]; i &amp;&amp; ans &lt; lim; i = nex[i]) &#123; arc[cur] = i; if (lay[to[i]] != lay[cur] + 1 || !cap[i]) continue; int flow = dfs(to[i], t, min(lim - ans, cap[i])); if (!flow) lay[to[i]] = -1; cap[i] -= flow; cap[i ^ 1] += flow; ans += flow; &#125; return ans;&#125;int Dinic(int s, int t) &#123; int ans = 0; while (bfs(s, t)) ans += dfs(s, t, INF); return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最小树形图","slug":"TemLib/最小树形图","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/最小树形图/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/","excerpt":"","text":"P4716 【模板】最小树形图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e2;const int MAXm = 1e4;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, eg[MAXn + 10][MAXn + 10], tmpeg[MAXn + 10][MAXn + 10];int pre[MAXn + 10];bool vis[MAXn + 10];int CheckCon(int cur) &#123; vis[cur] = 1; int ans = 1; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (eg[cur][i] == INF || vis[i]) continue; ans += CheckCon(i); &#125; return ans;&#125;int cntdfs, dfs[MAXn + 10], low[MAXn + 10];int cntscc, inscc[MAXn + 10];int top, stk[MAXn + 10]; bool instk[MAXn + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; if (pre[cur]) &#123; if (!dfs[pre[cur]]) &#123; Tarjan(pre[cur]); low[cur] = min(low[cur], low[pre[cur]]); &#125; else if (instk[pre[cur]]) &#123; low[cur] = min(low[cur], dfs[pre[cur]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; inscc[x] = cntscc; &#125; while (x != cur); &#125;&#125;int n, m, root, ans;signed main() &#123; read(n, m, root); cntnd = n; memset(eg, 0x3f, sizeof(eg)); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); if (u == v) continue; eg[u][v] = min(eg[u][v], w); &#125; if (CheckCon(root) != cntnd) &#123; puts(&quot;-1&quot;); return 0; &#125; while (true) &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; pre[i] = i; if (i == root) continue; for (int j = 1; j &lt;= cntnd; ++j) &#123; if (eg[j][i] &lt; eg[pre[i]][i]) &#123; pre[i] = j; &#125; &#125; &#125; memset(dfs, 0, sizeof(dfs)); cntdfs = cntscc = 0; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (!dfs[i]) Tarjan(i); &#125; if (cntscc == cntnd) &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; ans += eg[pre[i]][i]; &#125; break; &#125; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; if (inscc[pre[i]] == inscc[i]) ans += eg[pre[i]][i]; &#125; memset(tmpeg, 0x3f, sizeof(tmpeg)); for (int i = 1, x = inscc[i]; i &lt;= cntnd; ++i, x = inscc[i]) &#123; for (int j = 1, y = inscc[j]; j &lt;= cntnd; ++j, y = inscc[j]) &#123; if (eg[i][j] == INF || eg[pre[j]][j] == INF || x == y) continue; if (inscc[pre[j]] != y) &#123; tmpeg[x][y] = min(tmpeg[x][y], eg[i][j]); &#125; else &#123; tmpeg[x][y] = min(tmpeg[x][y], eg[i][j] - eg[pre[j]][j]); &#125; &#125; &#125; memcpy(eg, tmpeg, sizeof(eg)); cntnd = cntscc; root = inscc[root]; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最小生成树","slug":"TemLib/最小生成树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最小生成树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P3366 【模板】最小生成树 Kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e3;const int MAXm = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); &#125; &#125; return ans;&#125;int ans;signed main() &#123; read(n), read(m); for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); edge[i] = Edge(u, v, w); &#125; ans = Kruskal(); for (re int i = 1; i &lt; n; ++i) &#123; if (!SameAnc(i, i + 1)) &#123; printf(&quot;orz\\n&quot;); return 0; &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最小费用最大流","slug":"TemLib/最小费用最大流","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/最小费用最大流/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"","text":"1. 无负环最小费用最大流 P3381 【模板】最小费用最大流 1234567891011121314151617181920212223242526272829303132333435int inque[MAXnd + 10], dis[MAXnd + 10], lim[MAXnd + 10], pre[MAXnd + 10];queue&lt;int&gt; que;void Spfa(int s) &#123; memset(inque, 0, sizeof(inque)); memset(dis, 0x3f, sizeof(dis)); memset(lim, 0x3f, sizeof(lim)); memset(pre, 0, sizeof(pre)); dis[s] = 0; que.push(s); inque[s] = 1; while (!que.empty()) &#123; int cur = que.front(); que.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (!cap[i]) continue; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; lim[to[i]] = min(lim[cur], cap[i]); pre[to[i]] = i; if (!inque[to[i]]) &#123; que.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;void Ek(int s, int t, int &amp;ansf, int &amp;anscos) &#123; ansf = 0, anscos = 0; while (Spfa(s), dis[t] != INF) &#123; ansf += lim[t]; anscos += lim[t] * dis[t]; for (int eg = pre[t]; eg; eg = pre[to[eg ^ 1]]) &#123; cap[eg] -= lim[t]; cap[eg ^ 1] += lim[t]; &#125; &#125;&#125; 2. 有负环最小费用最大流 P7173 【模板】有负圈的费用流 123456789101112131415161718192021222324252627282930313233int n, m, s1, t1, s2, t2, ans1, ans2;int startf[MAXnd + 10];int ansf, anscos;signed main() &#123; cntnex = 1; read(n, m, s1, t1); s2 = n + 1, t2 = n + 2; for (int i = 1, u, v, c, w; i &lt;= m; ++i) &#123; read(u, v, c, w); if (w &gt;= 0) &#123; Insert(u, v, c, w); Insert(v, u, 0, -w); &#125; else if (w &lt; 0) &#123; startf[u] -= c, startf[v] += c; ans2 += w * c; Insert(u, v, 0, w); Insert(v, u, c, -w); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (startf[i] &gt; 0) &#123; Insert(s2, i, startf[i], 0); Insert(i, s2, 0, 0); &#125; else if (startf[i] &lt; 0) &#123; Insert(i, t2, -startf[i], 0); Insert(t2, i, 0, 0); &#125; &#125; Insert(t1, s1, INF, 0); Insert(s1, t1, 0, 0); Ek(s2, t2, ansf, anscos); ans1 += cap[cntnex]; ans2 += anscos; head[s1] = nex[head[s1]]; head[t1] = nex[head[t1]]; cntnex -= 2; Ek(s1, t1, ansf, anscos); ans1 += ansf; ans2 += anscos; printf(&quot;%d %d\\n&quot;, ans1, ans2); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最短路","slug":"TemLib/最短路","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P3371 【模板】单源最短路径（弱化版） P4779 【模板】单源最短路径（标准版） 1. Dijkstra 1234567891011121314151617181920bool vis[MAXn + 10]; int dis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;Dijkstra(root); 2. SPFA 1234567891011121314151617181920bool inque[MAXn + 10]; int dis[MAXn + 10];queue&lt;int&gt; q;void SPFA(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(root); inque[root] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;SPFA(root); 3. Floyd 12345678for (re int k = 1; k &lt;= n; ++k) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); //传递闭包：con[i][j] |= con[i][k] &amp; con[k][j]; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最近公共祖先(lca)","slug":"TemLib/最近公共祖先(lca)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最近公共祖先(lca)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(lca)/","excerpt":"","text":"P3379 【模板】最近公共祖先（LCA） 1. 倍增 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 500000;const int MAXlogdep = 19;const int MAXm = MAXn - 1;int anc[MAXn + 10][MAXlogdep + 10], dep[MAXn + 10], n, q, s;int head[MAXn + 10], next[MAXm * 2 + 10], toid[MAXm * 2 + 10], nown;int lg2[MAXn + 10];void Insert(int from, int to) &#123; next[++nown] = head[from]; head[from] = nown; toid[nown] = to;&#125;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;; &#125; return x;&#125;void Dfs(int nodeid, int fa) &#123; anc[nodeid][0] = fa; for (int i = 1; i &lt;= MAXlogdep; ++i) &#123; anc[nodeid][i] = anc[anc[nodeid][i - 1]][i - 1]; &#125; dep[nodeid] = dep[fa] + 1; for (int i = head[nodeid]; i; i = next[i]) &#123; if (toid[i] != fa) &#123; Dfs(toid[i], nodeid); &#125; &#125;&#125;void Init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; lg2[i] = lg2[i - 1] + (1 &lt;&lt; lg2[i - 1] == i); &#125; for (int i = 0; i &lt;= n; ++i) &#123; lg2[i]--; &#125;&#125;int Lca(int x, int y) &#123; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; while (dep[x] &lt; dep[y]) &#123; y = anc[y][lg2[dep[y] - dep[x]]]; &#125; if (x == y) &#123; return y; &#125; for (int i = lg2[dep[y]]; i &gt;= 0; --i) &#123; if (anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main() &#123; n = read(); q = read(); s = read(); Init(); int x, y; for (int i = 1; i &lt; n; ++i) &#123; x = read(); y = read(); Insert(x, y); Insert(y, x); &#125; Dfs(s, 0); for (int i = 0; i &lt; q; ++i) &#123; x = read(); y = read(); printf(&quot;%d\\n&quot;, Lca(x, y)); &#125; return 0;&#125; 2. 树剖 12345678910int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; x = fa[top[x]]; &#125; else &#123; y = fa[top[y]]; &#125; &#125; return dep[x] &gt; dep[y] ? y : x;&#125; 3. 离线Tarjan 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e5;const int MAXm = MAXn;const int MAXq = 5e5;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int headq[MAXn + 10], cntnexq, nexq[MAXq + 10], q[MAXq + 10];void Insertq(int u, int v) &#123; nexq[++cntnexq] = headq[u]; headq[u] = cntnexq; q[cntnexq] = v;&#125;int fa[MAXn + 10]; bool vis[MAXn + 10];void Dfs1(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; fa[to[i]] = cur; Dfs1(to[i]); &#125;&#125;int times[MAXn + 10], ans[MAXq + 10];void Dfs2(int cur) &#123; ++times[cur]; for (re int i = headq[cur]; i; i = nexq[i]) &#123; int id = q[i]; while (times[id] != 1) &#123; id = fa[id]; &#125; ans[i] = id; &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (times[to[i]]) continue; Dfs2(to[i]); &#125; ++times[cur];&#125;int n, Q, root, qid_nexq[MAXq + 10];int main() &#123; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;Q, &amp;root); for (re int i = 1, u, v; i &lt; n; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); for (re int i = 1, u, v; i &lt;= Q; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insertq(u, v); qid_nexq[i] = cntnexq; &#125; Dfs2(root); for (re int i = 1; i &lt;= Q; ++i) &#123; printf(&quot;%d\\n&quot;, ans[qid_nexq[i]]); &#125;&#125; 4. 欧拉序 请见 一位dalao的博客。（我懒得写了）","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最长上升子序列(lis)","slug":"TemLib/最长上升子序列(lis)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最长上升子序列(lis)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(lis)/","excerpt":"","text":"本解法时间复杂度O(nlogn)O(nlogn)O(nlogn)，还有一种 DP 的 O(n2)O(n^2)O(n2) 的求法，感兴趣的可以上网了解一下 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, s[MAXn + 10], cnt;int main() &#123; read(n); for (re int i = 1, a; i &lt;= n; ++i) &#123; read(a); if (a &gt; s[cnt]) &#123; s[++cnt] = a; &#125; else &#123; *lower_bound(s + 1, s + 1 + cnt, a) = a; &#125; &#125; printf(&quot;%d\\n&quot;, cnt);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"最长公共子序列(lcs)","slug":"TemLib/最长公共子序列(lcs)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最长公共子序列(lcs)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(lcs)/","excerpt":"","text":"P1439 【模板】最长公共子序列 本解法时间复杂度O(nlogn)O(nlogn)O(nlogn)，还有一种 DP 的 O(n2)O(n^2)O(n2) 的求法，感兴趣的可以上网了解一下 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;const int INF = 0x3f3f3f3f;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;int id[MAXn + 10];int mapping[MAXn + 10];int d[MAXn + 10];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) id[read()] = i; for (int i = 1; i &lt;= n; i++) mapping[i] = id[read()]; memset(d, 0x3f, sizeof(d)); int len = 0; d[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int l = 0, r = len, mid; if (mapping[i] &gt; d[len]) d[++len] = mapping[i]; else &#123; while (l &lt; r) &#123; mid = (l + r) / 2; if (d[mid] &gt; mapping[i]) r = mid; else l = mid + 1; &#125; d[l] = min(mapping[i], d[l]); &#125; &#125; cout &lt;&lt; len; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"有理数取余","slug":"TemLib/有理数取余","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/有理数取余/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%89%E7%90%86%E6%95%B0%E5%8F%96%E4%BD%99/","excerpt":"","text":"P2613 【模板】有理数取余 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#define re register#define int long longconst int MOD = 19260817;inline void read(int &amp;a) &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x * 10 + c - &#x27;0&#x27;) % MOD; &#125; a = x;&#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int inv, k; exgcd(n, mod, inv, k); return (inv % mod + mod) % mod;&#125;int frac(int a, int b, int mod) &#123; return (a * inv(b, mod)) % mod;&#125;int a, b;signed main() &#123; read(a), read(b); if (!(b % MOD)) &#123; printf(&quot;Angry!\\n&quot;); return 0; &#125; printf(&quot;%lld\\n&quot;, frac(a, b, MOD));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树上关键点","slug":"TemLib/树上关键点","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树上关键点/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E4%B8%8A%E5%85%B3%E9%94%AE%E7%82%B9/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template&lt;class T&gt;inline void read(T &amp;a) &#123; re char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());re bool f = c == &#x27;-&#x27;;re T x = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n, k, ans, root = 1;bool vis[MAXn + 10];pair&lt;int, bool&gt; Dfs(int cur) &#123; // 0: hav, 1: ned vis[cur] = 1; int ned = -INF, hav = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; pair&lt;int, bool&gt; tmp = Dfs(to[i]); if (tmp.second) &#123; ned = max(ned, tmp.first); &#125; else &#123; hav = max(hav, tmp.first); &#125; &#125; if (cur == root) &#123; if (ned == -INF &amp;&amp; hav == -INF) &#123; ++ans; &#125; else if (ned == -INF) &#123; ; &#125; else if (hav == -INF) &#123; ++ans; &#125; else &#123; if (ned &gt; hav) &#123; ++ans; &#125; else &#123; ; &#125; &#125; return make_pair(-1, -1); &#125; if (ned == -INF &amp;&amp; hav == -INF) &#123; return make_pair(1, 1); &#125; else if (ned == -INF) &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; else if (hav == -INF) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (ned &gt; hav) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; &#125;&#125;int main() &#123; read(n); read(k); if (k == 0) &#123; printf(&quot;%d\\n&quot;, n); return 0; &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs(root); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树上启发式合并","slug":"TemLib/树上启发式合并","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树上启发式合并/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","excerpt":"","text":"U41492 树上数颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int fa[MAXn + 10], hson[MAXn + 10], siz[MAXn + 10];void Dfs1(int cur, int f) &#123; fa[cur] = f; siz[cur] = 1; int mx = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; Dfs1(to[i], cur); siz[cur] += siz[to[i]]; if (mx &lt; siz[to[i]]) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int color[MAXn + 10], ans[MAXn + 10];int cntbuc, buc[MAXn + 10];void Dfs3(int cur, int hson) &#123; if (!buc[color[cur]]) ++cntbuc; ++buc[color[cur]]; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson) continue; Dfs3(to[i], hson); &#125;&#125;void Dfs2(int cur) &#123; if (!hson[cur]) &#123; ans[cur] = 1; buc[color[cur]] = 1; cntbuc = 1; &#125; else &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; Dfs2(to[i]); memset(buc, 0, sizeof(buc)); cntbuc = 0; &#125; Dfs2(hson[cur]); Dfs3(cur, hson[cur]); ans[cur] = cntbuc; &#125;&#125;int n, q;signed main() &#123; read(n); for (int i = 1, u, v; i &lt; n; ++i) &#123; read(u, v); Insert(u, v); Insert(v, u); &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(color[i]); &#125; Dfs1(1, 0); Dfs2(1); read(q); for (int i = 1, cur; i &lt;= q; ++i) &#123; read(cur); printf(&quot;%d\\n&quot;, ans[cur]); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树形dp","slug":"TemLib/树形dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树形dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%BD%A2dp/","excerpt":"","text":"P1352 没有上司的舞会 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 6000;const int NEGINF = 0xc0c0c0c0;int n;int d[MAXn + 10][2];int v[MAXn + 10];int edgenum;int head[MAXn + 10];int next[MAXn + 10];int to[MAXn + 10];inline int read()&#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void first()&#123; memset(d, 0xc0c0, sizeof(d));&#125;void insert_edge(int from, int too)&#123; next[++edgenum] = head[from]; head[from] = edgenum; to[edgenum] = too;&#125;void put_in()&#123; n = read(); for (int i = 1; i &lt;= n; i++) v[i] = read(); for (int i = 1; i &lt; n; i++)&#123; int to = read(); int from = read(); insert_edge(from, to); &#125;&#125;int dp(int nodeid, bool have_root)&#123; if (d[nodeid][have_root] != NEGINF) return d[nodeid][have_root]; int&amp; ans = d[nodeid][have_root] = 0; if (!have_root) for (int i = head[nodeid]; i; i = next[i]) ans += max(dp(to[i], 0), dp(to[i], 1)); else&#123; ans += v[nodeid]; for (int i = head[nodeid]; i; i = next[i]) ans += dp(to[i], 0); &#125; return ans;&#125;int find_root()&#123; bool have_in_deg[MAXn + 10] = &#123; 0 &#125;; for (int i = 1; i &lt;= edgenum; i++) have_in_deg[to[i]] = 1; for (int i = 1; i &lt;= n; i++) if (!have_in_deg[i]) return i;&#125;int main()&#123; first(); put_in(); int rootid = find_root(); cout &lt;&lt; max(dp(rootid, 0), dp(rootid, 1)) &lt;&lt; endl;&#125; P2015 二叉苹果树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100;const int MAXq = 100;const int INF = 0x3f3f3f3f;int n, q;int d[MAXn + 10][MAXq + 10];int to[MAXn + 10][2];//ÏÂ±ê1ÎªfromµÄidint edgew[MAXn + 10][2];//ÏÂ±ê1ÎªfromµÄidinline int read()&#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;void Init()&#123; memset(d, -1, sizeof(d));&#125;void insert_edge(int nodeid1, int nodeid2, int edge_w)&#123; if (!to[nodeid1][0])&#123; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; &#125;else&#123; to[nodeid1][1] = nodeid2; edgew[nodeid1][1] = edge_w; &#125;&#125;int dp(int nodeid, int keepnum)&#123; if (d[nodeid][keepnum] != -1) return d[nodeid][keepnum]; int&amp; ans = d[nodeid][keepnum] = 0; if (!keepnum) return ans = 0; if (!to[nodeid][0]) return ans = -INF; for (int knuml = 0; knuml &lt;= keepnum; knuml++)&#123; int knumr = keepnum - knuml; int tmp_ans = 0; if (knuml) tmp_ans += edgew[nodeid][0] + dp(to[nodeid][0], knuml - 1); if (knumr) tmp_ans += edgew[nodeid][1] + dp(to[nodeid][1], knumr - 1); ans = max(ans, tmp_ans); &#125; return ans;&#125;int main()&#123; Init(); n = read(); q = read(); for (int i = 1; i &lt; n; i++)&#123; int nodeid1 = read(); int nodeid2 = read(); int edgew = read(); insert_edge(nodeid1, nodeid2, edgew); &#125; cout &lt;&lt; dp(1, q);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树形背包","slug":"TemLib/树形背包","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/树形背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/","excerpt":"","text":"1. size优化解树形背包 注意：该方法无法解决带权树形背包。 P3177 HAOI2015 树上染色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e3;const int MAXm = MAXn;const int MAXk = 2e3;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXm + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, fa[MAXn + 10], siz[MAXn + 10], d[MAXn + 10][MAXk + 10];void Dfs(int cur) &#123; siz[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs(to[i]); siz[cur] += siz[to[i]]; &#125;&#125;void DfsDp(int cur) &#123; d[cur][0] = d[cur][1] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; DfsDp(to[i]); for (int j = min(m, siz[cur]); ~j; --j) &#123; for (int k = 0; k &lt;= min(j, siz[to[i]]); ++k) &#123; d[cur][j] = max(d[cur][j], d[cur][j - k] + d[to[i]][k] + wei[i] * (k * (m - k) + (siz[to[i]] - k) * (n - siz[to[i]] - (m - k)))); &#125; &#125; &#125;&#125;signed main() &#123; memset(d, 0xc0, sizeof(d)); read(n, m); if (n &lt; m * 2) &#123; m = n - m; &#125; for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1); DfsDp(1); printf(&quot;%lld\\n&quot;, d[1][m]);&#125; 2. dfs序优化解树形背包 U189430 带权树形背包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e3;const int MAXW = 1e4;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm + 10], from[MAXm + 10], to[MAXm + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; from[cntnex] = u; to[cntnex] = v;&#125;int n, W, ndw[MAXn + 10], ndv[MAXn + 10];int cntdfs, idxdfs[MAXn + 10], bottom[MAXn + 10];void Dfs(int cur) &#123; idxdfs[++cntdfs] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; Dfs(to[i]); &#125; bottom[cur] = cntdfs;&#125;int d[MAXn * 2 + 10][MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, f; i &lt;= n; ++i) &#123; read(ndw[i], f, ndv[i]); if (f == i) &#123; Insert(n + 1, i); &#125; else &#123; Insert(f, i); &#125; &#125; Dfs(n + 1); // 主干部分 for (int i = cntdfs; i; --i) &#123; int cur = idxdfs[i]; for (int j = W; j &gt;= ndw[cur]; --j) &#123; d[i][j] = max(d[bottom[cur] + 1][j], d[i + 1][j - ndw[cur]] + ndv[cur]); &#125; for (int j = ndw[cur] - 1; ~j; --j) &#123; d[i][j] = d[bottom[cur] + 1][j]; &#125; &#125; // 主干部分 int ans = 0; for (int j = 0; j &lt;= W; ++j) &#123; ans = max(ans, d[1][j]); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树状数组","slug":"TemLib/树状数组","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树状数组/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 5e5;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int n, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= n) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int a[MAXn + 10], m;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseSum(a); for (re int i = 1, opt, x, y, k; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(k); Add(x, k); Add(y + 1, -k); break; case 2: read(x); printf(&quot;%lld\\n&quot;, EvaSum(x)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树的直径","slug":"TemLib/树的直径","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树的直径/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","excerpt":"","text":"U81904 【模板】树的直径 1. 两次Dfs 注意：该方法无法解决负权树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerusing namespace std;const int MAXn = 5e5;const int MAXm = MAXn;const int FINF = 0xc0c0c0c0;int n;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10];void Dfs(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; dis[to[i]] = dis[cur] + wei[i]; Dfs(to[i]); &#125;&#125;int EvaFar(int root) &#123; memset(dis, 0xc0, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[root] = 0; Dfs(root); int mx = FINF, maxer = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mx &lt; dis[i]) &#123; mx = dis[i]; maxer = i; &#125; &#125; return maxer;&#125;int side1, side2;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1, u, v, w; i &lt; n; ++i) &#123; scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); Insert(u, v, w); Insert(v, u, w); &#125; side1 = EvaFar(1); side2 = EvaFar(side1); printf(&quot;%d %d\\n&quot;, side1, side2); printf(&quot;%d\\n&quot;, dis[side2]);&#125; 2. 树形Dp 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e5;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int ans, d[MAXn + 10];void Dfs(int cur, int fath) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fath) continue; Dfs(to[i], cur); ans = max(ans, d[cur] + d[to[i]] + wei[i]); d[cur] = max(d[cur], d[to[i]] + wei[i]); &#125;&#125;int n;signed main() &#123; read(n); for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1, 0); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树的重心","slug":"TemLib/树的重心","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树的重心/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/","excerpt":"","text":"P1395 会议 1234567891011121314151617181920212223242526int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n;bool vis[MAXn + 10]; int siz[MAXn + 10], w[MAXn + 10], cen[2];void EvaCen(int cur) &#123; vis[cur] = 1; siz[cur] = 1; w[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; EvaCen(to[i]); siz[cur] += siz[to[i]]; w[cur] = max(w[cur], siz[to[i]]); &#125; w[cur] = max(w[cur], n - siz[cur]); if (w[cur] &lt;= n / 2) &#123; cen[cen[0] != 0] = cur; &#125;&#125;EvaCen(1);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树链剖分","slug":"TemLib/树链剖分","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树链剖分/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","excerpt":"","text":"P3384 【模板】轻重链剖分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, k, root, mod;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10], add[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[id &lt;&lt; 1] + sum[(id &lt;&lt; 1) + 1];&#125;inline void pushdown(int id) &#123; sum[id &lt;&lt; 1] += add[id] * (ri[id &lt;&lt; 1] - le[id &lt;&lt; 1] + 1); sum[(id &lt;&lt; 1) + 1] += add[id] * (ri[(id &lt;&lt; 1) + 1] - le[(id &lt;&lt; 1) + 1] + 1); add[id &lt;&lt; 1] += add[id]; add[(id &lt;&lt; 1) + 1] += add[id]; add[id] = 0;&#125;void BuildUseArray(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArray(id &lt;&lt; 1, l, mid, a); BuildUseArray((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int w) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] += w * (ri[id] - le[id] + 1); add[id] += w; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(id &lt;&lt; 1, l, r, w); if (r &gt; mid) Add((id &lt;&lt; 1) + 1, l, r, w); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; int ans = 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; ans += sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) ans += Eva(id &lt;&lt; 1, l, r); if (r &gt; mid) ans += Eva((id &lt;&lt; 1) + 1, l, r); &#125; return ans;&#125;int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125; bottom[cur] = idxdfs[cntdfs];&#125;void TreePathAdd(int x, int y, int w) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; Add(1, nddfs[top[y]], nddfs[y], w); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; Add(1, nddfs[x], nddfs[y], w);&#125;int TreePathEva(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; ans += Eva(1, nddfs[top[y]], nddfs[y]); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; ans += Eva(1, nddfs[x], nddfs[y]); return ans;&#125;void SonTreeAdd(int x, int w) &#123; Add(1, nddfs[x], nddfs[bottom[x]], w);&#125;int SonTreeEva(int x) &#123; return Eva(1, nddfs[x], nddfs[bottom[x]]);&#125;int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; y = fa[top[y]]; &#125; return dep[x] &gt; dep[y] ? y : x;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];signed main() &#123; read(n), read(k), read(root), read(mod); for (re int i = 1; i &lt;= n; ++i) &#123; read(ndwei[i]); &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArray(1, 1, n, idxwei); for (re int i = 1, opt, x, y, w; i &lt;= k; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(w); TreePathAdd(x, y, w); break; case 2: read(x), read(y); printf(&quot;%lld\\n&quot;, TreePathEva(x, y) % mod); break; case 3: read(x), read(w); SonTreeAdd(x, w); break; case 4: read(x); printf(&quot;%lld\\n&quot;, SonTreeEva(x) % mod); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"根号分治","slug":"TemLib/根号分治","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/根号分治/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/","excerpt":"","text":"P3396 哈希冲突 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5 + 5e4;const int MAXsqrtn = 387;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, sqrtn, m, a[MAXn + 10];int small[MAXsqrtn + 10][MAXsqrtn + 10];signed main() &#123; read(n, m); sqrtn = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); for (int j = 1; j &lt;= sqrtn; ++j) &#123; small[j][i % j] += a[i]; &#125; &#125; char opt; for (int i = 1; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, &amp;opt); if (opt == &#x27;A&#x27;) &#123; int mod, yu; read(mod, yu); if (mod &lt;= sqrtn) &#123; printf(&quot;%d\\n&quot;, small[mod][yu]); &#125; else &#123; int ans = 0; for (int i = (yu ? yu : mod); i &lt;= n; i += mod) &#123; ans += a[i]; &#125; printf(&quot;%d\\n&quot;, ans); &#125; &#125; else &#123; int idx, val; read(idx, val); for (int i = 1; i &lt;= sqrtn; ++i) &#123; small[i][idx % i] += -a[idx] + val; &#125; a[idx] = val; &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"混合背包","slug":"TemLib/混合背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/混合背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1833 樱花 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 10000;const int MAXW = 1000;const int INF = 0x3f3f3f3f;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];bool is_limit[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new, bool is_limit[]) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; is_limit[num_new] = 1; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; is_limit[num_new] = 1; &#125;&#125;void put_in() &#123; W = read(); n = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; w = read(); v = read(); num = read(); if (num) bin_divide(v, w, num, v_new, w_new, num_new, is_limit); else &#123; v_new[++num_new] = v; w_new[num_new] = w; is_limit[num_new] = 0; &#125; &#125;&#125;void rec(int v[], int w[], bool is_limit[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; if (is_limit[i]) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; else &#123; for (int j = w[i]; j &lt;= W; j++) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; &#125;&#125;int eva_maxV(int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v_new, w_new, is_limit, W, num_new); cout &lt;&lt; eva_maxV(W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"次短路","slug":"TemLib/次短路","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/次短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%AC%A1%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P2865 [USACO06NOV]Roadblocks G 1. Dijkstra 123456789101112131415161718192021222324252627int dis[MAXn + 10], secdis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); memset(secdis, 0x3f, sizeof(secdis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second, d = -q.top().first; q.pop(); if (secdis[cur] &lt; d) continue; for (re int i = head[cur]; i; i = nex[i]) &#123; int dist = d + wei[i]; if (dis[to[i]] &gt; dist) &#123; swap(dis[to[i]], dist); q.push(make_pair(-dis[to[i]], to[i])); &#125; if (secdis[to[i]] &gt; dist) &#123; secdis[tod[i]] = dist; q.push(make_pair(-secdis[to[i]], to[i])); &#125; &#125; &#125;&#125;// main函数中Dijkstra(root);printf(&quot;%d\\n&quot;, secdis[cur]); 2. Spfa 1234567891011121314151617181920212223242526272829303132333435int secdis[MAXn + 10], dis[MAXn + 10];bool inque[MAXn + 10];queue&lt;int&gt; q;int tmp[4];bool update(int &amp;dis1, int &amp;secdis1, int dis2, int secdis2) &#123; tmp[0] = dis1, tmp[1] = secdis1, tmp[2] = dis2, tmp[3] = secdis2; sort(tmp, tmp + 4); unique(tmp, tmp + 4); if (dis1 != tmp[0] || secdis1 != tmp[1]) &#123; dis1 = tmp[0], secdis1 = tmp[1]; return 1; &#125; else &#123; return 0; &#125;&#125;void Spfa(int sour) &#123; memset(secdis, 0x3f, sizeof(secdis)); memset(dis, 0x3f, sizeof(dis)); dis[sour] = 0; q.push(sour); inque[sour] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (update(dis[to[i]], secdis[to[i]], dis[cur] + wei[i], secdis[cur] + wei[i])) &#123; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;// main函数中Spfa(root);printf(&quot;%d\\n&quot;, secdis[cur]);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"欧拉路径","slug":"TemLib/欧拉路径","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/欧拉路径/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. 无向图欧拉路径 P2731 [USACO3.3]骑马修栅栏 Riding the Fences 之所以要用邻接矩阵是因为一条边只能走一次，走过一条边这条边的另一个方向也不能走了，邻接矩阵便于删除走过的边的另一个方向。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e2;const int MAXm = 1024;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, m, source = 1, edge[MAXn + 10][MAXn + 10], deg[MAXn + 10];int top, stk[MAXm * 2 + 10];void Dfs(int cur) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (edge[cur][i]) &#123; --edge[cur][i]; --edge[i][cur]; Dfs(i); &#125; &#125; stk[++top] = cur;&#125;signed main() &#123; read(m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); ++edge[u][v]; ++edge[v][u]; ++deg[u]; ++deg[v]; n = max(n, max(u, v)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (deg[i] &amp; 1) &#123; source = i; break; &#125; &#125; Dfs(source); for (int i = top; i; --i) &#123; printf(&quot;%d\\n&quot;, stk[i]); &#125;&#125; 空间开不下 O(n2)O(n^2)O(n2) 怎么办，听别人说要用什么当前弧优化，留坑待补…… 2. 有向图欧拉路径 P7771 【模板】欧拉路径 有向图求欧拉路径，因为边没有另一个方向，所以不用删另一个方向。直接用邻接表即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = 2e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : c ^ &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;inline bool cmp(int a, int b) &#123; return a &gt; b;&#125;vector&lt;int&gt; edge[MAXn + 10];int top, stk[MAXm + 10];void Dfs(int cur) &#123; while (!edge[cur].empty()) &#123; int to = edge[cur].back(); edge[cur].pop_back(); Dfs(to); &#125; stk[++top] = cur;&#125; int n, m;int indeg[MAXn + 10], outdeg[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); edge[u].push_back(v); ++outdeg[u]; ++indeg[v]; &#125; int cnt1 = 0, cnt2 = 0, bg = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (indeg[i] == outdeg[i] + 1) &#123; ++cnt1; &#125; else if (indeg[i] == outdeg[i] - 1) &#123; ++cnt2; bg = i; &#125; else if (indeg[i] != outdeg[i]) &#123; puts(&quot;No&quot;); return 0; &#125; &#125; if (!((cnt1 == 1 &amp;&amp; cnt2 == 1) || (cnt1 == 0 &amp;&amp; cnt2 == 0))) &#123; puts(&quot;No&quot;); return 0; &#125; if (bg == 0) &#123; bg = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; sort(begin(edge[i]), end(edge[i]), cmp); &#125; Dfs(bg); for (int i = top; i; --i) &#123; printf(&quot;%d &quot;, stk[i]); &#125; puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"点分治","slug":"TemLib/点分治","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/点分治/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%82%B9%E5%88%86%E6%B2%BB/","excerpt":"","text":"Luogu P4178 Tree 不建议使用 Luogu 3806 作为模板，该题情形过于特殊，只需找到一组解即可判断为 true，导致只遍历树的一部分也可通过此题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445bool vis[MAXn + 10];int cen, siz[MAXn + 10];void EvaCen(int cur, int f, int totsiz) &#123;/* ... */&#125;int cntd, d[MAXn + 10];void Dfs(int cur, int f, int dis, int tar) &#123; if (dis &gt; tar) return; d[++cntd] = dis; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == f || vis[to[i]]) continue; Dfs(to[i], cur, dis + wei[i], tar); &#125;&#125;int ans;int top, stk[MAXn + 10];void Div(int bg, int totsiz, int tar) &#123; EvaCen(bg, 0, totsiz); int c = cen; vis[c] = 1; while (top) Add(stk[top--], -1, tar); for (int i = head[c]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; cntd = 0; Dfs(to[i], c, wei[i], tar); for (int i = 1; i &lt;= cntd; ++i) &#123; ans += Sum(tar - d[i]); &#125; for (int i = 1; i &lt;= cntd; ++i) &#123; Add(d[i], 1, tar); stk[++top] = d[i]; &#125; &#125; for (int i = head[c]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; if (siz[to[i]] &lt; siz[c]) Div(to[i], siz[to[i]], tar); else Div(to[i], siz[to[i]] - siz[c], tar); &#125;&#125;signed main() &#123; // ... Add(0, 1, tar); Div(1, n, tar);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"矩阵运算","slug":"TemLib/矩阵运算","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/矩阵运算/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/","excerpt":"","text":"P3390 【模板】矩阵快速幂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Mat &#123; int mat[MAXmat][MAXmat]; Mat() &#123; memset(mat, 0, sizeof(mat)); &#125; Mat(int a[MAXmat][MAXmat]) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = a[i][j]; &#125; &#125; &#125; inline void operator=(Mat x) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = x.mat[i][j]; &#125; &#125; &#125; inline Mat operator+(Mat x) &#123; Mat ans; for (int i = 0; i &lt; MAXmat; ++i) &#123; for (int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (mat[i][j] + x.mat[i][j]) % MOD; &#125; &#125; return ans; &#125; inline Mat operator*(Mat x) &#123; Mat ans; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int k = 0; k &lt; MAXmat; ++k) &#123; int a = mat[i][k]; for (re int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (a * x.mat[k][j] + ans.mat[i][j]) % MOD; &#125; &#125; &#125; return ans; &#125; inline Mat operator^(int x) &#123; Mat ans, base; for (re int i = 0; i &lt; MAXmat; ++i) &#123; ans.mat[i][i] = 1; &#125; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; base.mat[i][j] = mat[i][j]; &#125; &#125; while (x) &#123; if (x &amp; 1) &#123; ans = ans * base; &#125; base = base * base; x &gt;&gt;= 1; &#125; return ans; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"矩阵求逆","slug":"TemLib/矩阵求逆","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/矩阵求逆/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/","excerpt":"","text":"Luogu P4783 【模板】矩阵求逆 1234567891011121314151617181920212223242526272829303132333435int n, n2; // n2 = n * 2int a[MAXn + 10][MAXn * 2 + 10];bool EvaInv() &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i][i + n] = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int chose = 0; for (int j = i; j &lt;= n; ++j) &#123; if (a[j][i]) &#123; chose = j; break; &#125; &#125; if (chose == 0) return 0; if (chose != i) &#123; for (int j = 1; j &lt;= n2; ++j) &#123; swap(a[i][j], a[chose][j]); &#125; &#125; int invaii = inv(a[i][i]); for (int j = i; j &lt;= n2; ++j) &#123; a[i][j] = a[i][j] * invaii % MOD; &#125; for (int j = 1; j &lt;= n; ++j) &#123; if (j == i) continue; int mul = a[j][i]; for (int k = i; k &lt;= n2; ++k) &#123; a[j][k] -= a[i][k] * mul % MOD; redmod(a[j][k]); &#125; &#125; &#125; return 1;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性求区间欧拉函数","slug":"TemLib/线性求区间欧拉函数","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/线性求区间欧拉函数/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"1234567891011121314151617int cntp, p[MAXn + 10]; bool notp[MAXn + 10];int ola[MAXn + 10];void Ls(int top) &#123; notp[1] = 1; ola[1] = 1; for (int i = 2; i &lt;= top; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; ola[i] = i - 1; &#125; for (int j = 1, toppj = top / i; j &lt;= cntp &amp;&amp; p[j] &lt;= toppj; ++j) &#123; notp[i * p[j]] = 1; ola[i * p[j]] = ola[i] * (i % p[j] ? p[j] - 1 : p[j]); if (!(i % p[j])) break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性基","slug":"TemLib/线性基","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/线性基/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E5%9F%BA/","excerpt":"","text":"Acwing 3164. 线性基 这里推荐 Acwing 上的线性基模板。luogu 上的模板数据范围太小了。 这里的求线性基是求一种特殊的线性基：把每个数在二进制下的每一位看做一个 0/10/10/1 分向量，每个数表示一个向量，一个数组就是一个向量组。求这个向量组的线性基。 1. 高消法 生成的线性基拥有的性质： 是原向量组的线性基废话 线性基内所有数在二进制下会构成上三角结构（重要性质） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXm = 64;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline bool deg(int num, int deg) &#123; return num &amp; (1ll &lt;&lt; deg);&#125;int n;int a[MAXn + 10];signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; int row = 1; for (int col = MAXm - 1; ~col &amp;&amp; row &lt;= n; --col) &#123; for (int i = row; i &lt;= n; ++i) &#123; if (deg(a[i], col)) &#123; swap(a[row], a[i]); break; &#125; &#125; if (!deg(a[row], col)) continue; for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (deg(a[i], col)) &#123; a[i] ^= a[row]; &#125; &#125; ++row; &#125; int ans = 0; for (int i = 1; i &lt; row; ++i) &#123; ans ^= a[i]; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 提供一组样例： 1210681519689123291 153992348230057 352917520953222 379410980430607 333284887124912 596782649548897 1004880543767517 258503666829624 353486948696275 244563245470691 二进制表示： 1234567891010011010111101011010101010111110100100010111011011001000110000001110001000110011011011100001101010010101000000111110100000001101111000101011111000011001010110010001001010000000101101100110001100001111010010111100011110111011110100111001011011101100001000011110110001010100100111010101101000000110000111100100011110111011111011110110100101101111011101001110101100011011100100110011110000001001001110000101000001011111101001100000000010100000001101001100110111100110110111010001010111110001001111100011 生成的线性基： 1234567891010000001000011001001000110110011001011000111101101010000000000111010000111011110111011000111000100000010000100010110101100000011010000011010101111100100010000000110010110100001010011001111111101100001000010010001101111100111011001000111001010111101010000010000001110001111101101010010011010001000110000000010000101010011100011111001101000101101010000000000001000111110101010000111011101100101101001110000000001001000010010010010100000101110001010001000000000001010010110111111110110101001011111110111 可以看到确实是上三角结构。 2. 贪心法 生成的线性基不具有性质 2。 所以这种方法生成的线性基不能处理一些问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXm = 64;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline int degll(int num, int deg) &#123; return num &amp; (1ll &lt;&lt; deg);&#125;inline int maxdegll(int num) &#123; return 63 - __builtin_clzl(num);&#125;int n;int num[MAXm + 10];signed main() &#123; read(n); for (int i = 1, a, mxdeg; i &lt;= n; ++i) &#123; read(a); while (a) &#123; mxdeg = maxdegll(a); if (num[mxdeg]) &#123; a ^= num[mxdeg]; &#125; else &#123; num[mxdeg] = a; break; &#125; &#125; &#125; int ans = 0; for (int i = MAXm - 1; ~i; --i) &#123; if (!degll(ans, i)) &#123; ans ^= num[i]; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 生成的线性基： 1234567891010011010111101011010101010111110100100010111011011010100000011111010000000110111100010101111100001100010001100000011100010001100110110111000011010100100011011111110010011101100001101101111010000110110000011011011001100011100010110111001010000001010010000011001111010001000001111001110110011001000100100000010001111000101011100001111000001110010100111000000001100011111100011001101011111011101000001010000000001100001001001101101111010001011110101010100000000001010010110111111110110101001011111110111 而且注意这种方法生成的线性基存在 num 数组里的时候不是连续的，如果删去 41 行 if (!degll(ans, i)) 的话输出的是： 12345678910111001101011110101101010101011111010010001011101101101010000001111101000000011011110001010111110000110001000110000001110001000110011011011100001101010010001101111111001001110110000110110111101000011011000001101101100110001110001011011100101000000101001000001100111101000100000111100111011001100100010010000001000111100010101110000111100000111001010011100000000000000000000000000000000000000000000000000000000001100011111100011001101011111011101000001010000000001100001001001101101111010001011110101010100000000001010010110111111110110101001011111110111","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"笛卡尔树","slug":"TemLib/笛卡尔树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/笛卡尔树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/","excerpt":"","text":"P5854 【模板】笛卡尔树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 1e7;struct Node &#123; LL p; LL ls; LL rs;&#125;;Node node[MAXn + 10];LL n;LL nowid;LL stk[MAXn + 10];LL top;inline LL read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register LL s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void insert(LL p) &#123; nowid++; node[nowid].p = p; LL newtop = top; while (newtop &amp;&amp; node[stk[newtop]].p &gt; node[nowid].p) newtop--; if (newtop) node[stk[newtop]].rs = nowid; if (newtop &lt; top) node[nowid].ls = stk[newtop + 1]; stk[++newtop] = nowid; top = newtop;&#125;int main() &#123; n = read(); LL p; for (LL i = 0; i &lt; n; i++) &#123; p = read(); insert(p);/*这里 insert 的数字的值(p)没有单调的要求， 但数字的标号(id)要求单增，若不单增要先排序*/ &#125; for (LL i = 1; i &lt;= n; i++) &#123; printf(&quot;%lld %lld %lld\\n&quot;, node[i].p, node[i].ls, node[i].rs); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性求区间逆元","slug":"TemLib/线性求区间逆元","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/线性求区间逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 【模板】乘法逆元 invi=(p−⌊pi⌋)×invpmod⁡imod⁡pinv_i=(p-\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor)\\times inv_{p\\operatorname{mod}i}\\operatorname{mod}pinvi​=(p−⌊ip​⌋)×invpmodi​modp 123456void EvaSectionInvLine(int n, int mod, int inv[]) &#123; inv[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; inv[i] = (long long) (mod - mod / i) * inv[mod % i] % mod; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性求区间莫比乌斯函数","slug":"TemLib/线性求区间莫比乌斯函数","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/线性求区间莫比乌斯函数/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/","excerpt":"","text":"123456789101112131415161718192021int mob[MAXn + 10];int cntp, p[MAXn + 10]; bool notp[MAXn + 10];void Ls(int top) &#123; notp[1] = 1; mob[1] = 1; for (int i = 2; i &lt;= top; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; mob[i] = -1; &#125; for (int j = 1, toppj = top / i; j &lt;= cntp &amp;&amp; p[j] &lt;= toppj; ++j) &#123; notp[i * p[j]] = 1; if (i % p[j]) &#123; mob[i * p[j]] = -mob[i]; &#125; else &#123; mob[i * p[j]] = 0; break; &#125; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性筛","slug":"TemLib/线性筛","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/线性筛/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E7%AD%9B/","excerpt":"","text":"P3383 【模板】线性筛素数 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define re register const int MAXn = 1e8;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, cntp, p[MAXn / 10 + 100];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) p[++cntp] = i; int up2 = up / i; for (re int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; if (!(i % p[j])) break; &#125; &#125;&#125; int main() &#123; read(n), read(m); LS(n); for (re int i = 1, q; i &lt;= m; ++i) &#123; read(q); printf(&quot;%d\\n&quot;, p[q]); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线段树","slug":"TemLib/线段树","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/线段树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"P3372 【模板】线段树 1 1. 无懒标记 Update 2022-01-06: 草，今天来翻看我的老文章，突然发现我还写过一个无懒标记的线段树。就不删了，留个纪念。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] = sum[id] + k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125; 2. 有懒标记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], add[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;inline void pushdown(int id) &#123; sum[ls] = sum[ls] + add[id] * (ri[ls] - le[ls] + 1); sum[rs] = sum[rs] + add[id] * (ri[rs] - le[rs] + 1); add[ls] = add[ls] + add[id]; add[rs] = add[rs] + add[id]; add[id] = 0;&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] = sum[id] + k * (ri[id] - le[id] + 1); add[id] = add[id] + k; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线段树优化建图","slug":"TemLib/线段树优化建图","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/线段树优化建图/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define re registerconst int MAXn = 5e5;const int MAXm = 1e5;const int MAXedge = 3e7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn * 11 + 10], cntnex, nex[MAXedge + 10], to[MAXedge + 10]; bool wei[MAXedge + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, root;struct Node&#123; int l, r, idx;&#125;out[MAXn * 4 + 10], in[MAXn * 4 + 10];int cntnd;void BuildOut(int id, int l, int r) &#123; out[id].idx = ++cntnd; out[id].l = l; out[id].r = r; if (l == r) &#123; Insert(l, out[id].idx, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildOut(id &lt;&lt; 1, l, mid); BuildOut((id &lt;&lt; 1) + 1, mid + 1, r); Insert(out[id &lt;&lt; 1].idx, out[id].idx, 0); Insert(out[(id &lt;&lt; 1) + 1].idx, out[id].idx, 0);&#125;void BuildIn(int id, int l, int r) &#123; in[id].idx = ++cntnd; in[id].l = l; in[id].r = r; if (l == r) &#123; Insert(in[id].idx, 10 * n + l, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildIn(id &lt;&lt; 1, l, mid); BuildIn((id &lt;&lt; 1) + 1, mid + 1, r); Insert(in[id].idx, in[id &lt;&lt; 1].idx, 0); Insert(in[id].idx, in[(id &lt;&lt; 1) + 1].idx, 0);&#125;int cntqin, qin[MAXn + 10], cntqout, qout[MAXn + 10];void GetSecIn(int id, int l, int r) &#123; if (in[id].l &gt;= l &amp;&amp; in[id].r &lt;= r) &#123; qin[++cntqin] = in[id].idx; return; &#125; int mid = (in[id].l + in[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecIn(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecIn((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void GetSecOut(int id, int l, int r) &#123; if (out[id].l &gt;= l &amp;&amp; out[id].r &lt;= r) &#123; qout[++cntqout] = out[id].idx; return; &#125; int mid = (out[id].l + out[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecOut(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecOut((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void InsertSec(int l1, int r1, int l2, int r2) &#123; cntqin = cntqout = 0; GetSecOut(1, l2, r2); GetSecIn(1, l1, r1); for (re int i = 1; i &lt;= cntqout; ++i) &#123; for (re int j = 1; j &lt;= cntqin; ++j) &#123; Insert(qout[i], qin[j], 1); &#125; &#125;&#125;bool vis[MAXn * 11 + 10]; int dis[MAXn * 11 + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int main() &#123; read(n), read(m), read(root); cntnd = n; BuildOut(1, 1, n); BuildIn(1, 1, n); for (re int i = 1, l1, r1, l2, r2; i &lt;= m; ++i) &#123; read(l1), read(r1), read(l2), read(r2); InsertSec(l1, r1, l2, r2); InsertSec(l2, r2, l1, r1); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; Insert(i, 10 * n + i, 0); Insert(10 * n + i, i, 0); &#125; Dijkstra(root); for (re int i = 10 * n + 1; i &lt;= 11 * n; ++i) &#123; printf(&quot;%d\\n&quot;, dis[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"线段树分裂","slug":"TemLib/线段树分裂","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/线段树分裂/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82/","excerpt":"","text":"省略号部分请见线段树合并。 Luogu P5494 【模板】线段树分裂 1234567891011121314151617181920212223242526272829303132333435363738394041// ...int Split(int id, int p) &#123; int nwid = ++cntnd; le[nwid] = le[id]; ri[nwid] = ri[id]; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt; mid) &#123; if (ls[id]) ls[nwid] = Split(ls[id], p); &#125; else if (p == mid) &#123; ls[nwid] = ls[id]; ls[id] = 0; &#125; else &#123; ls[nwid] = ls[id]; ls[id] = 0; if (rs[id]) rs[nwid] = Split(rs[id], p); &#125; pushup(id); pushup(nwid); return nwid;&#125;int Split2(int rtid, int p) &#123; if (p == 0) &#123; ++cntnd; le[cntnd] = 1; ri[cntnd] = n; return cntnd; &#125; else if (p == n) &#123; ++cntnd; le[cntnd] = 1; ri[cntnd] = n; int tmp = root[rtid]; root[rtid] = cntnd; return tmp; &#125; else &#123; return Split(root[rtid], p); &#125;&#125;signed main() &#123; // ... read(rtid, l, r); root[++cntrt] = Split2(rtid, r); // root[rtid] = Mergeto(root[rtid], Split2(cntrt, l - 1)); // 将下标为rtid的权值线段树值域[l,r]分裂出来&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线段树合并","slug":"TemLib/线段树合并","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/线段树合并/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","excerpt":"","text":"其中 le 和 ri 两个数组并非必要，如果空间吃紧可以用传参代替。 Luogu P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], le[MAXnd + 10], ri[MAXnd + 10];int mxval[MAXnd + 10], maxer[MAXnd + 10];inline void Init(int n) &#123; mxval[0] = -INF; for (int i = 1; i &lt;= n; ++i) &#123; le[i] = 1; ri[i] = MAXa; &#125; cntnd = n;&#125;inline void pushup(int id) &#123; if (mxval[ls[id]] &gt;= mxval[rs[id]]) &#123; mxval[id] = mxval[ls[id]]; maxer[id] = maxer[ls[id]]; &#125; else &#123; mxval[id] = mxval[rs[id]]; maxer[id] = maxer[rs[id]]; &#125;&#125;int modifyAddNew(int l, int r, int p, int v) &#123; int id = ++cntnd; le[id] = l; ri[id] = r; if (le[id] == ri[id]) &#123; mxval[id] = v; maxer[id] = le[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) ls[id] = modifyAddNew(le[id], mid, p, v); else rs[id] = modifyAddNew(mid + 1, ri[id], p, v); pushup(id); &#125; return id;&#125;void modifyAddOld(int id, int p, int v) &#123; if (le[id] == ri[id]) &#123; mxval[id] += v; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) &#123; if (ls[id]) modifyAddOld(ls[id], p, v); else ls[id] = modifyAddNew(le[id], mid, p, v); &#125; else &#123; if (rs[id]) modifyAddOld(rs[id], p, v); else rs[id] = modifyAddNew(mid + 1, ri[id], p, v); &#125; pushup(id); &#125;&#125;int Mergeto(int id1, int id2) &#123; if (id1 == 0 || id2 == 0) &#123; return id1 + id2; &#125; else &#123; if (le[id1] == ri[id1]) &#123; mxval[id1] += mxval[id2]; &#125; else &#123; ls[id1] = Mergeto(ls[id1], ls[id2]); rs[id1] = Mergeto(rs[id1], rs[id2]); pushup(id1); &#125; return id1; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线段树套平衡树","slug":"TemLib/线段树套平衡树","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/线段树套平衡树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E5%B9%B3%E8%A1%A1%E6%A0%91/","excerpt":"","text":"P3380 【模板】二逼平衡树（树套树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;const int MAXm = 5e4;const int MAXlogn = 16;const int MAXnd1 = MAXn * 4;const int MAXnd2 = MAXnd1 * 3 + MAXn * MAXlogn + MAXm * MAXlogn;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int idxinf, idxninf;int cntnd, son[MAXnd2 + 10][2], fa[MAXnd2 + 10], siz[MAXnd2 + 10], cnt[MAXnd2 + 10], val[MAXnd2 + 10];inline void pushup(int cur) &#123; siz[cur] = cnt[cur] + siz[son[cur][0]] + siz[son[cur][1]];&#125;inline int side(int cur) &#123; return cur == son[fa[cur]][1];&#125;inline void rotate(int cur) &#123; int y = fa[cur], z = fa[y], sidecur = side(cur), s = son[cur][sidecur ^ 1]; if (z) &#123;son[z][side(y)] = cur;&#125; fa[cur] = z; son[y][sidecur] = s; if (s) &#123;fa[s] = y;&#125; son[cur][sidecur ^ 1] = y; fa[y] = cur; pushup(y); pushup(cur);&#125;inline void splay(int &amp;root, int cur, int goal = 0) &#123; int y, z; while (fa[cur] != goal) &#123; y = fa[cur], z = fa[y]; if (z != goal) &#123; if (side(cur) == side(y)) rotate(y); else rotate(cur); &#125; rotate(cur); &#125; if (!goal) root = cur;&#125;inline int V2R(int &amp;root, int v) &#123; int ans = 0, cur = root; while (true) &#123; if (val[cur] &lt; v) &#123; ans += siz[son[cur][0]] + cnt[cur]; if (son[cur][1]) cur = son[cur][1]; else break; &#125; else if (val[cur] == v) &#123; ans += siz[son[cur][0]]; break; &#125; else &#123; if (son[cur][0]) cur = son[cur][0]; else break; &#125; &#125; splay(root, cur); return ans - 1;&#125;inline int PI(int &amp;root, int v) &#123; int ans = idxninf, cur = root; while (true) &#123; if (val[cur] &gt;= v) &#123; if (son[cur][0]) cur = son[cur][0]; else break; &#125; else &#123; ans = val[ans] &gt; val[cur] ? ans : cur; if (son[cur][1]) cur = son[cur][1]; else break; &#125; &#125; splay(root, cur); return ans;&#125;inline int NI(int &amp;root, int v) &#123; int ans = idxinf, cur = root; while (true) &#123; if (val[cur] &lt;= v) &#123; if (son[cur][1]) cur = son[cur][1]; else break; &#125; else &#123; ans = val[ans] &lt; val[cur] ? ans : cur; if (son[cur][0]) cur = son[cur][0]; else break; &#125; &#125; splay(root, cur); return ans;&#125;inline void I(int &amp;root, int v) &#123; int cur = root, f = 0; while (cur &amp;&amp; v != val[cur]) &#123; f = cur; cur = son[cur][v &gt; val[cur]]; &#125; if (cur) &#123; ++cnt[cur]; &#125; else &#123; cur = ++cntnd; cnt[cur] = 1; val[cur] = v; fa[cur] = f; if (f) son[f][v &gt; val[f]] = cur; &#125; splay(root, cur);&#125;inline void D(int &amp;root, int v) &#123; int pre = PI(root, v), nex = NI(root, v); splay(root, pre); splay(root, nex, pre); int del = son[nex][0]; if (del) &#123; --cnt[del]; if (cnt[del]) &#123; splay(root, del); &#125; else &#123; son[nex][0] = 0; &#125; &#125;&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd1 + 10], ri[MAXnd1 + 10], root[MAXnd1 + 10];void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; I(root[id], INF); I(root[id], -INF); for (int i = l; i &lt;= r; ++i) I(root[id], a[i]); if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); &#125;&#125;void Insert(int id, int p, int a) &#123; I(root[id], a); if (le[id] == ri[id]) &#123; ; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) Insert(ls, p, a); else Insert(rs, p, a); &#125;&#125;void Delete(int id, int p, int a) &#123; D(root[id], a); if (le[id] == ri[id]) &#123; ; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) Delete(ls, p, a); else Delete(rs, p, a); &#125;&#125;int ValtoRank(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return V2R(root[id], v); &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += ValtoRank(ls, l, r, v); if (r &gt; mid) ans += ValtoRank(rs, l, r, v); return ans; &#125;&#125;int RanktoVal(int l, int r, int rk) &#123; --rk; int L = -INF + 1, R = INF - 1, M; while (L &lt; R) &#123; M = (L + R + 1) &gt;&gt; 1; if (ValtoRank(1, l, r, M) &lt;= rk) &#123; L = M; &#125; else &#123; R = M - 1; &#125; &#125; return L;&#125;int Pre(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return val[PI(root[id], v)]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = -INF; if (l &lt;= mid) ans = max(ans, Pre(ls, l, r, v)); if (r &gt; mid) ans = max(ans, Pre(rs, l, r, v)); return ans; &#125;&#125;int Nex(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return val[NI(root[id], v)]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = INF; if (l &lt;= mid) ans = min(ans, Nex(ls, l, r, v)); if (r &gt; mid) ans = min(ans, Nex(rs, l, r, v)); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; val[idxinf = ++cntnd] = INF; val[idxninf = ++cntnd] = -INF; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, l, r, p, k, tmp; i &lt;= m; ++i) &#123; read(opt); if (opt == 1) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, ValtoRank(1, l, r, k) + 1); &#125; else if (opt == 2) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, RanktoVal(l, r, k)); &#125; else if (opt == 3) &#123; read(p, k); Delete(1, p, a[p]); a[p] = k; Insert(1, p, k); &#125; else if (opt == 4) &#123; read(l, r, k); tmp = Pre(1, l, r, k); if (tmp == -INF) puts(&quot;-2147483647&quot;); else printf(&quot;%d\\n&quot;, tmp); &#125; else if (opt == 5) &#123; read(l, r, k); tmp = Nex(1, l, r, k); if (tmp == INF) puts(&quot;2147483647&quot;); else printf(&quot;%d\\n&quot;, tmp); &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"莫队","slug":"TemLib/莫队","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/莫队/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%8E%AB%E9%98%9F/","excerpt":"","text":"复杂度分析 aaa：块长，nnn：数组长度，mmm：询问个数，ttt：修改个数。 普通莫队 Luogu P1494 [国家集训队]小Z的袜子 各指针复杂度（从上往下依次代表左端点，右端点，时间点的移动次数） am+n n×naam+n\\\\ ~~~~~~~~~~~~~~~~~~~n\\times\\dfrac{n}{a}\\\\ am+n n×an​ 最优块长（nnn，mmm，ttt 同阶情况下） nm\\dfrac{n}{\\sqrt{m}}\\\\ m​n​ 带修莫队 Luogu P1903 [国家集训队]数颜色 / 维护队列 各指针复杂度 am+n am+n×na t×(na)2am+n\\\\ ~~~~~~~~~am+n\\times\\dfrac{n}{a}\\\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~t\\times\\left(\\dfrac{n}{a}\\right)^2 am+n am+n×an​ t×(an​)2 最优块长 n23n^{\\frac{2}{3}}\\\\ n32​ 回滚莫队 AT1219 歴史の研究 各指针复杂度 am n×naam\\\\ ~~~~~~~~~~~~~~~~~~~~~n\\times\\dfrac{n}{a}\\\\ am n×an​ 最优块长 nm\\dfrac{n}{\\sqrt{m}}\\\\ m​n​ 树上莫队 SP10707 COT2 - Count on a tree II 复杂度与相当于普通莫队。 二次离线莫队 Luogu P4887 【模板】莫队二次离线（第十四分块(前体)） 复杂度与相当于普通莫队的复杂度加上二次离线的复杂度。 代码 普通莫队 12345678910111213141516171819202122232425262728293031int lenpart, inpart[MAXn + 10];void EvaInpart(int n, int m) &#123; lenpart = ceil((double)n / sqrt(ceil((double)m))); for (int i = 1; i &lt;= n; ++i) &#123; inpart[i] = i / lenpart; &#125;&#125;struct Query &#123; int l, r, id; inline bool operator&lt;(const Query sec) const &#123; if (inpart[l] == inpart[sec.l]) &#123; return inpart[l] &amp; 1 ? r &lt; sec.r : sec.r &lt; r; &#125; return l &lt; sec.l; &#125;&#125; que[MAXm + 10];int n, m, a[MAXn + 10];int sum, buc[MAXc + 10], ans[MAXm + 10];inline void add(int v) &#123;/* ... */&#125;inline void del(int v) &#123;/* ... */&#125;void Mocap() &#123; for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; while (l &gt; que[i].l) add(a[--l]); while (r &lt; que[i].r) add(a[++r]); while (l &lt; que[i].l) del(a[l++]); while (r &gt; que[i].r) del(a[r--]); // 记录答案 &#125;&#125; 带修莫队 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int lenpart, inpart[MAXn + 10];void EvaInpart(int n) &#123; lenpart = ceil((double)cbrt((double)n) * cbrt((double)n)); for (int i = 1; i &lt;= n; ++i) &#123; inpart[i] = i / lenpart; &#125;&#125;struct Query &#123; int l, r, t, idx; inline bool operator&lt;(const Query sec) const &#123; if (inpart[l] == inpart[sec.l]) &#123; if (inpart[r] == inpart[sec.r]) &#123; return t &lt; sec.t; &#125; return inpart[l] &amp; 1 ? r &lt; sec.r : sec.r &lt; r; &#125; return l &lt; sec.l; &#125;&#125; que[MAXquery + 10]; int cntque;struct Change &#123; int p, v;&#125; cha[MAXchange + 10]; int cntcha;int n, m, a[MAXn + 10];int buc[MAXcolor + 10], res;int ans[MAXn + 10];inline void add(int v) &#123;/* ... */&#125;inline void del(int v) &#123;/* ... */&#125;void Mocap() &#123; for (int i = 1, l = 1, r = 0, t = 0; i &lt;= cntque; ++i) &#123; while (que[i].l &lt; l) add(a[--l]); while (que[i].r &gt; r) add(a[++r]); while (que[i].l &gt; l) del(a[l++]); while (que[i].r &lt; r) del(a[r--]); while (que[i].t &gt; t) &#123; if (cha[t + 1].p &gt;= l &amp;&amp; cha[t + 1].p &lt;= r) &#123; del(a[cha[t + 1].p]); add(cha[t + 1].v); &#125; swap(a[cha[t + 1].p], cha[t + 1].v); ++t; &#125; while (que[i].t &lt; t) &#123; if (cha[t].p &gt;= l &amp;&amp; cha[t].p &lt;= r) &#123; del(a[cha[t].p]); add(cha[t].v); &#125; swap(a[cha[t].p], cha[t].v); --t; &#125; ans[que[i].idx] = res; &#125;&#125; 回滚莫队 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int lenpart, inpart[MAXn + 10];void EvaInpart(int n, int m) &#123; lenpart = ceil((double)n / sqrt((double)m)); for (int i = 1; i &lt;= n; ++i) &#123; inpart[i] = i / lenpart; &#125;&#125;int n, m, a[MAXn + 10];int cntmap, mapup[MAXn + 10]; map&lt;int, int&gt; mapdown;struct Query &#123; int l, r, idx; inline bool operator&lt;(const Query sec) const &#123; if (inpart[l] == inpart[sec.l]) &#123; return r &lt; sec.r; &#125; return l &lt; sec.l; &#125;&#125; que[MAXm + 10];int buc[MAXn + 10], res, ans[MAXm + 10];inline void add(int v) &#123;/* ... */&#125;void Mocap() &#123; for (int i = 1, j = 1; i &lt;= m; i = j) &#123; while (j &lt;= m &amp;&amp; inpart[que[i].l] == inpart[que[j].l]) ++j; int k = i; for (; k &lt; j; ++k) &#123; if (inpart[que[k].l] == inpart[que[k].r]) &#123; for (int p = que[k].l; p &lt;= que[k].r; ++p) add(a[p]); ans[que[k].idx] = res; for (int p = que[k].l; p &lt;= que[k].r; ++p) --buc[a[p]]; res = 0; &#125; else break; &#125; for (int r = inpart[que[i].l] * lenpart + lenpart - 1; k &lt; j; ++k) &#123; if (inpart[que[k].l] != inpart[que[k].r]) &#123; while (r &lt; que[k].r) add(a[++r]); int backup = res; for (int l = inpart[que[i].l] * lenpart + lenpart - 1; l &gt;= que[k].l; --l) add(a[l]); ans[que[k].idx] = res; for (int l = inpart[que[i].l] * lenpart + lenpart - 1; l &gt;= que[k].l; --l) --buc[a[l]]; res = backup; &#125; &#125; memset(buc, 0, sizeof(buc)); res = 0; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"费马小定理求逆元","slug":"TemLib/费马小定理求逆元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/费马小定理求逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 【模板】乘法逆元 此题不是求单个逆元的模板题，但可以用这道模板题检验这种求逆方法的正确性（没有WA） 123456789101112131415inline int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = (1LL * ans * x) % mod; &#125; y &gt;&gt;= 1; x = (1LL * x * x) % mod; &#125; return ans;&#125;int inv(int n, int mod) &#123; return power(n, mod - 2, mod);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"邻接表","slug":"TemLib/邻接表","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/邻接表/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%82%BB%E6%8E%A5%E8%A1%A8/","excerpt":"","text":"12345678910#include&lt;cstdio&gt;const int MAXn = 1e4;const int MAXm = 1e4 * 2;//无向图MAXM应开边数二倍int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"错排问题","slug":"TemLib/错排问题","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/错排问题/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"P1595 信封问题 1234567891011121314#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 20;int n, a[MAXn + 10];signed main() &#123; a[1] = 0; a[2] = 1; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 3; i &lt;= n; ++i) &#123; a[i] = (i - 1) * (a[i - 2] + a[i - 1]); &#125; printf(&quot;%lld\\n&quot;, a[n]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"高精运算","slug":"TemLib/高精运算","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/高精运算/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E7%B2%BE%E8%BF%90%E7%AE%97/","excerpt":"","text":"实用小高精（推荐） P1601 A+B Problem（高精） P1303 A*B Problem P1480 A/B Problem (转载的) 支持负数，压位，重载运算符 不过赛场上应该没人写一遍这个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 10000;const int BIT = 4;const int MOD = 1e4;struct bign &#123; int num[maxn], len; bool flag; friend bign abs(const bign &amp;x) &#123; bign k = x; k.flag = true; return k; &#125; friend void remove(bign &amp;x) &#123; while (x.num[x.len] == 0 &amp;&amp; x.len &gt; 1)x.len--; &#125; bign() &#123; memset(num, 0, sizeof(num)); flag = true; len = 1; &#125; bign(const int &amp;x) &#123; *this = bign(); if (x) &#123; int k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const ll &amp;x) &#123; *this = bign(); if (x) &#123; ll k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const char *x) &#123; int l = strlen(x), s, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == 4) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign(const string x) &#123; int l = x.length(), s = 0, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == BIT) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign operator=(const int &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const ll &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const char *x) &#123; return *this = bign(x); &#125; bign operator=(const string &amp;x) &#123; return *this = bign(x); &#125; bool operator&lt;(const bign &amp;x) const &#123; if (flag != x.flag)return flag &lt; x.flag; if (len != x.len)return (len &lt; x.len) ^ flag ^ 1; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return (num[i] &lt; x.num[i]) ^ flag ^ 1; &#125; &#125; return false; &#125; bool operator&lt;(const int &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&lt;(const ll &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&gt;(const bign &amp;x) const &#123; return x &lt; *this; &#125; bool operator&gt;(const int &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&gt;(const ll &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&lt;=(const bign &amp;x) const &#123; return !(*this &gt; x); &#125; bool operator&lt;=(const int &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&lt;=(const ll &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&gt;=(const bign &amp;x) const &#123; return !(*this &lt; x); &#125; bool operator&gt;=(const int &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator&gt;=(const ll &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator==(const bign &amp;x) const &#123; if (flag != x.flag)return false; if (len != x.len)return false; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return false; &#125; &#125; return true; &#125; bool operator==(const int &amp;x) const &#123; return *this == bign(x); &#125; bool operator==(const ll &amp;x) const &#123; return *this == bign(x); &#125; bool operator!=(const bign &amp;x) const &#123; return !(*this == x); &#125; bool operator!=(const int &amp;x) const &#123; return *this != bign(x); &#125; bool operator!=(const ll &amp;x) const &#123; return *this != bign(x); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;x) &#123; string s; in &gt;&gt; s; x = s; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const bign &amp;x) &#123; if (x.flag == false &amp;&amp; x != 0)out &lt;&lt; &quot;-&quot;; out &lt;&lt; x.num[x.len]; for (int i = x.len - 1; i &gt;= 1; i--)printf(&quot;%0*d&quot;, BIT, x.num[i]); return out; &#125; bign operator-() const &#123; bign k = *this; k.flag ^= 1; return k; &#125; bign operator+(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len || i &lt;= x.len; i++) &#123; int p = num[i] + x.num[i] + g; k.num[++k.len] = p % MOD; g = p / MOD; &#125; return k; &#125; if (flag &amp;&amp; !x.flag)return *this - (-x); if (!flag &amp;&amp; x.flag)return x - (-*this); return -((-x) + (-*this)); &#125; bign operator+(const int &amp;x) const &#123; return *this + bign(x); &#125; bign operator+=(const bign &amp;x) &#123; return *this = *this + x; &#125; bign operator+=(const int &amp;x) &#123; return *this += bign(x); &#125; bign operator+=(const ll &amp;x) &#123; return *this += bign(x); &#125; bign operator++() &#123; return *this += 1; &#125; bign operator++(int) &#123; bign k = *this; *this += 1; return k; &#125; bign operator-(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag &amp;&amp; *this &gt;= x) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len; i++) &#123; int p = num[i] - x.num[i] + g; if (p &lt; 0)g = -1; else g = 0; k.num[++k.len] = (p % MOD + MOD) % MOD; &#125; remove(k); return k; &#125; if (flag &amp;&amp; x.flag)return -(x - *this); if (flag &amp;&amp; !x.flag)return *this + (-x); if (!flag &amp;&amp; x.flag)return -((-*this) + x); return (-x) - (-*this); &#125; bign operator-=(const bign &amp;x) &#123; *this = *this - x; return *this; &#125; bign operator-=(const int &amp;x) &#123; return *this -= bign(x); &#125; bign operator-=(const ll &amp;x) &#123; return *this -= bign(x); &#125; bign operator--() &#123; return *this -= 1; &#125; bign operator--(int) &#123; bign k = *this; *this -= 1; return k; &#125; bign operator*(const bign &amp;x) const &#123; bign k; k.flag = (flag == x.flag); k.len = len + x.len + 1; for (int i = 1; i &lt;= len; i++) &#123; for (int j = 1; j &lt;= x.len; j++) &#123; k.num[i + j - 1] += num[i] * x.num[j]; k.num[i + j] += k.num[i + j - 1] / MOD; k.num[i + j - 1] %= MOD; &#125; &#125; remove(k); return k; &#125; bign operator*(const int &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*(const ll &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*=(const bign &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const int &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const ll &amp;x) &#123; return *this = *this * x; &#125; bign operator/(const bign &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(), a = bign(); k.flag = (flag == x.flag); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x)) &#123; a -= abs(x); k.num[i]++; &#125; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/(const int &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/(const ll &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/=(const bign &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const int &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const ll &amp;x) &#123; return *this = *this / x; &#125; bign operator%(const bign &amp;x) const &#123; if (x == 0)return bign(); bign a = bign(); for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x))a -= abs(x); &#125;// if (a == 0)return a;// if (flag &amp;&amp; x.flag)return a;// if (flag &amp;&amp; !x.flag)return a + x;// if (!flag &amp;&amp; x.flag)return x - a;// return -a;//È¡Ä£ if (flag)return a; return -a; &#125; bign operator%(const int &amp;x) const &#123; return *this % bign(x); &#125; bign operator%(const ll &amp;x) const &#123; return *this % bign(x); &#125; bign operator%=(const bign &amp;x) &#123; return *this = *this % x; &#125; bign operator%=(const int &amp;x) &#123; return *this %= bign(x); &#125; bign operator%=(const ll &amp;x) &#123; return *this %= bign(x); &#125; friend bign pow(const bign &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const int &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const bign &amp;x, const int &amp;y) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans *= cnt; cnt *= cnt; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign max(const bign &amp;x, const bign &amp;y) &#123; return x &gt; y ? x : y; &#125; friend bign min(const bign &amp;x, const bign &amp;y) &#123; return x &lt; y ? x : y; &#125;&#125;;int main() &#123; bign a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; a - b &lt;&lt; endl; cout &lt;&lt; a * b &lt;&lt; endl; cout &lt;&lt; a / b &lt;&lt; endl; cout &lt;&lt; a % b &lt;&lt; endl; return 0;&#125; 你竟然看完了！","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"高斯消元解有后效性的dp","slug":"TemLib/高斯消元解有后效性的dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/高斯消元解有后效性的dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E6%9C%89%E5%90%8E%E6%95%88%E6%80%A7%E7%9A%84dp/","excerpt":"","text":"CF24D Broken robot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e3;const int MAXm = 1e3;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, x, y;double mat[MAXm + 10][MAXm + 10], d[MAXn + 10][MAXm + 10];signed main() &#123; read(n), read(m); read(x), read(y); if (m == 1) &#123; printf(&quot;%d\\n&quot;, 2 * (n - x)); return 0; &#125; for (re int i = n - 1; i &gt;= x; --i) &#123; memset(mat, 0, sizeof(mat)); mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = d[i + 1][1] + 3; for (re int j = 2; j &lt; m; ++j) &#123; mat[j][j - 1] = mat[j][j + 1] = -1; mat[j][j] = 3; mat[j][m + 1] = d[i + 1][j] + 4; &#125; mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = d[i + 1][m] + 3; // ------- 高斯消元 begin ------- for (re int i = 1; i &lt; m; ++i) &#123; double solve = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] -= mat[i][i] * solve; if (i != m) &#123; mat[i + 1][i + 1] -= mat[i][i + 1] * solve; &#125; mat[i + 1][m + 1] -= mat[i][m + 1] * solve; &#125; for (re int i = m; i &gt; 1; --i) &#123; double solve = mat[i - 1][i] / mat[i][i]; mat[i - 1][i] -= mat[i][i] * solve; mat[i - 1][m + 1] -= mat[i][m + 1] * solve; &#125; // ------- 高斯消元 end ------- for (re int j = 1; j &lt;= m; ++j) &#123; d[i][j] = mat[j][m + 1] / mat[j][j]; &#125; &#125; printf(&quot;%.4f\\n&quot;, d[x][y]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"高斯消元","slug":"TemLib/高斯消元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/高斯消元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"P2455 [SDOI2006]线性方程组 高斯消元的模板我推荐这一道，而不是 Luogu P3389。原因是 P3389 数据确实太水了。我在 P3389 上 AC 的代码在 P2455 只有 20pts。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 50;int n;double a[MAXn + 10][MAXn + 1 + 10];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n + 1; ++j) &#123; scanf(&quot;%lf&quot;, &amp;a[i][j]); &#125; &#125; int row = 1; for (re int col = 1; col &lt;= n; ++col) &#123; int maxer = row; for (re int i = row + 1; i &lt;= n; ++i) &#123; if (abs(a[maxer][col]) &lt; abs(a[i][col])) &#123; maxer = i; &#125; &#125; if (!a[maxer][col]) continue; for (re int j = 1; j &lt;= n + 1; ++j) &#123; swap(a[row][j], a[maxer][j]); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; double solve = a[i][col] / a[row][col]; for (re int j = col; j &lt;= n + 1; ++j) &#123; a[i][j] -= a[row][j] * solve; &#125; &#125; ++row; &#125; if (row &lt;= n) &#123; for (re int i = row; i &lt;= n; ++i) &#123; if (a[i][n + 1]) &#123; printf(&quot;-1\\n&quot;); return 0; &#125; &#125; printf(&quot;0\\n&quot;); &#125; else &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (int(a[i][n + 1] / a[i][i] * 100) == 0) &#123; printf(&quot;x%d=0\\n&quot;, i); &#125; else &#123; printf(&quot;x%d=%.2lf\\n&quot;, i, a[i][n + 1] / a[i][i]); &#125; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"非质数模数逆元运算","slug":"TemLib/非质数模数逆元运算","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/非质数模数逆元运算/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%9D%9E%E8%B4%A8%E6%95%B0%E6%A8%A1%E6%95%B0%E9%80%86%E5%85%83%E8%BF%90%E7%AE%97/","excerpt":"","text":"原理：将模数 mod \\bmodmod 分解质因数 p1c1p2c2p3c3⋯p_1^{c_1}p_2^{c_2}p_3^{c_3}\\cdotsp1c1​​p2c2​​p3c3​​⋯，再将所有参与运算的数按照 mod \\bmodmod 的质因数分解为 v×p1c1′p2c2′p3c3′v\\times p_1^{c&#x27;_1}p_2^{c&#x27;_2}p_3^{c&#x27;_3}v×p1c1′​​p2c2′​​p3c3′​​，其中 vvv 为不属于 mod \\bmodmod 质因数的部分，可以直接用 exgcd 求逆元，其余部分在进行乘除运算时直接指数相加减，最后乘在一起就是结果，如果运算完有指数为负则没有逆元，一般使用下（比如求组合数）是不会出现指数为负的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int mod = 15;// ...int cntp, p[MAXcntp * 2 + 10];void Dis(int x) &#123; cntp = 0; for (int i = 2, topi = sqrt(x); i &lt;= topi; ++i) &#123; if (!(x % i)) &#123; p[++cntp] = i; while (!(x % i)) &#123; x /= i; &#125; &#125; &#125; if (x &gt; 1) p[++cntp] = x;&#125;struct Number &#123; int v, c[MAXcntp * 2 + 10]; inline Number()&#123;&#125; inline Number(int x) &#123; for (int i = 1; i &lt;= cntp; ++i) &#123; c[i] = 0; if (!x) continue; while (!(x % p[i])) &#123; ++c[i]; x /= p[i]; &#125; &#125; v = x; &#125; inline void operator=(int x) &#123; memset(c, 0, sizeof(c)); for (int i = 1; i &lt;= cntp; ++i) &#123; c[i] = 0; if (!x) continue; while (!(x % p[i])) &#123; ++c[i]; x /= p[i]; &#125; &#125; v = x; &#125; inline Number operator*(Number sec) &#123; Number ans; ans.v = v * sec.v % mod; for (int i = 1; i &lt;= cntp; ++i) &#123; ans.c[i] = c[i] + sec.c[i]; &#125; return ans; &#125; inline Number operator/(Number sec) &#123; Number ans; ans.v = v * inv(sec.v) % mod; for (int i = 1; i &lt;= cntp; ++i) &#123; ans.c[i] = c[i] - sec.c[i]; &#125; return ans; &#125; inline int real() &#123; int ans = v; for (int i = 1; i &lt;= cntp; ++i) &#123; ans *= power(p[i], c[i]); ans %= mod; &#125; return ans; &#125;&#125;;signed main() &#123; Dis(mod); Number a(36), b(14); Number c = a / b; printf(&quot;%lld\\n&quot;, c.real());&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"吉老师线段树","slug":"TemLib/吉老师线段树","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/吉老师线段树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%89%E8%80%81%E5%B8%88%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"核心思想 设当前操作为将区间内值与 vvv 取 min⁡\\minmin，如果当前节点完全被操作区间包含（既满足普通线段树停止递归的条件），分类讨论： max⁡≤v\\max\\le vmax≤v secmax&lt;v&lt;max⁡\\mathrm{secmax}&lt;v&lt;\\maxsecmax&lt;v&lt;max v≤secmaxv\\le\\mathrm{secmax}v≤secmax 对于有多种懒标记的情况，要么钦定他们的顺序，要么将他们转化成几种没有顺序关系（或者说是顺序上不冲突）的懒标记（比如几种加减标记）。 对于维护历史最值的要求，考虑标记的生命周期。 DarkBzoj #4695. 最假女选手 解法一用的是钦定懒标记顺序的方法，解法二用的是转化成没有顺序关系的懒标记的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10];int mx[MAXnd + 10], cntmx[MAXnd + 10], secmx[MAXnd + 10], mn[MAXnd + 10], cntmn[MAXnd + 10], secmn[MAXnd + 10];int sum[MAXnd + 10];int lzadd[MAXnd + 10], lzmx[MAXnd + 10], lzmn[MAXnd + 10];/*钦定顺序: lzadd &gt; lzmx = lzmn*/inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs]; if (mx[ls] &gt; mx[rs]) &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls]; secmx[id] = max(secmx[ls], mx[rs]); &#125; else if (mx[ls] &lt; mx[rs]) &#123; mx[id] = mx[rs]; cntmx[id] = cntmx[rs]; secmx[id] = max(mx[ls], secmx[rs]); &#125; else &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls] + cntmx[rs]; secmx[id] = max(secmx[ls], secmx[rs]); &#125; if (mn[ls] &lt; mn[rs]) &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls]; secmn[id] = min(secmn[ls], mn[rs]); &#125; else if (mn[ls] &gt; mn[rs]) &#123; mn[id] = mn[rs]; cntmn[id] = cntmn[rs]; secmn[id] = min(mn[ls], secmn[rs]); &#125; else &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls] + cntmn[rs]; secmn[id] = min(secmn[ls], secmn[rs]); &#125;&#125;inline void putadd(int id, int padd) &#123; sum[id] += padd * (ri[id] - le[id] + 1); mx[id] += padd; mn[id] += padd; if (secmx[id] != -INF) secmx[id] += padd; if (secmn[id] != INF) secmn[id] += padd; if (lzmx[id] != -INF) lzmx[id] += padd; if (lzmn[id] != INF) lzmn[id] += padd; lzadd[id] += padd;&#125;inline void putmx(int id, int pmx) &#123; if (mn[id] &gt;= pmx) return; sum[id] += (pmx - mn[id]) * cntmn[id]; if (secmx[id] == mn[id]) secmx[id] = pmx; if (mx[id] == mn[id]) mx[id] = pmx; if (lzmn[id] &lt; pmx) lzmn[id] = pmx; mn[id] = lzmx[id] = pmx;&#125;inline void putmn(int id, int pmn) &#123; if (mx[id] &lt;= pmn) return; sum[id] -= (mx[id] - pmn) * cntmx[id]; if (secmn[id] == mx[id]) secmn[id] = pmn; if (mn[id] == mx[id]) mn[id] = pmn; if (lzmx[id] &gt; pmn) lzmx[id] = pmn; mx[id] = lzmn[id] = pmn;&#125;inline void pushdown(int id) &#123; if (lzadd[id]) &#123; // 注意顺序lzadd与其他懒标记的顺序 putadd(ls, lzadd[id]); putadd(rs, lzadd[id]); lzadd[id] = 0; &#125; if (lzmx[id] != -INF) &#123; putmx(ls, lzmx[id]); putmx(rs, lzmx[id]); lzmx[id] = -INF; &#125; if (lzmn[id] != INF) &#123; putmn(ls, lzmn[id]); putmn(rs, lzmn[id]); lzmn[id] = INF; &#125;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; lzmx[id] = -INF; lzmn[id] = INF; if (l == r) &#123; mx[id] = mn[id] = sum[id] = a[l]; cntmx[id] = cntmn[id] = 1; secmx[id] = -INF; secmn[id] = INF; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putadd(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyMax(int id, int l, int r, int v) &#123; if (mn[id] &gt;= v) return; if (secmn[id] &gt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putmx(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMax(ls, l, r, v); if (r &gt; mid[id]) modifyMax(rs, l, r, v); pushup(id); &#125;&#125;void modifyMin(int id, int l, int r, int v) &#123; if (mx[id] &lt;= v) return; if (secmx[id] &lt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putmn(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMin(ls, l, r, v); if (r &gt; mid[id]) modifyMin(rs, l, r, v); pushup(id); &#125;&#125;int querySum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += querySum(ls, l, r); if (r &gt; mid[id]) ans += querySum(rs, l, r); return ans; &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;int queryMin(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mn[id]; &#125; else &#123; pushdown(id); int ans = INF; if (l &lt;= mid[id]) ans = min(ans, queryMin(ls, l, r)); if (r &gt; mid[id]) ans = min(ans, queryMin(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int mx[MAXnd + 10], cntmx[MAXnd + 10], secmx[MAXnd + 10], mn[MAXnd + 10], cntmn[MAXnd + 10], secmn[MAXnd + 10];int sum[MAXnd + 10];int lz1[MAXnd + 10], lz2[MAXnd + 10], lz3[MAXnd + 10];/*lz1: 最大值的增减值lz2: 最小值的增减值lz3: 非最小最大值的增减值*/inline void pushup(int id) &#123; if (mx[ls] &gt; mx[rs]) &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls]; secmx[id] = max(secmx[ls], mx[rs]); &#125; else if (mx[ls] &lt; mx[rs]) &#123; mx[id] = mx[rs]; cntmx[id] = cntmx[rs]; secmx[id] = max(mx[ls], secmx[rs]); &#125; else &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls] + cntmx[rs]; secmx[id] = max(secmx[ls], secmx[rs]); &#125; if (mn[ls] &lt; mn[rs]) &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls]; secmn[id] = min(secmn[ls], mn[rs]); &#125; else if (mn[ls] &gt; mn[rs]) &#123; mn[id] = mn[rs]; cntmn[id] = cntmn[rs]; secmn[id] = min(mn[ls], secmn[rs]); &#125; else &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls] + cntmn[rs]; secmn[id] = min(secmn[ls], secmn[rs]); &#125; sum[id] = sum[ls] + sum[rs];&#125;inline void update(int id, int v1, int v2, int v3) &#123; if (mx[id] == secmn[id]) &#123; sum[id] += v1 * cntmx[id] + v2 * cntmn[id]; mx[id] += v1; mn[id] += v2; secmx[id] += v2; secmn[id] += v1; lz1[id] += v1; lz2[id] += v2; &#125; else if (mx[id] == mn[id]) &#123; if (v1) &#123; sum[id] += v1 * cntmx[id]; mx[id] += v1; mn[id] += v1; lz1[id] += v1; lz2[id] += v1; &#125; else if (v2) &#123; sum[id] += v2 * cntmx[id]; mx[id] += v2; mn[id] += v2; lz1[id] += v2; lz2[id] += v2; &#125; else &#123; sum[id] += v3 * cntmx[id]; mx[id] += v3; mn[id] += v3; lz1[id] += v3; lz2[id] += v3; &#125; &#125; else &#123; sum[id] += v1 * cntmx[id] + v2 * cntmn[id] + v3 * (len[id] - cntmx[id] - cntmn[id]); mx[id] += v1; mn[id] += v2; secmx[id] += v3; secmn[id] += v3; lz1[id] += v1; lz2[id] += v2; lz3[id] += v3; &#125;&#125;inline void pushdown(int id) &#123; int maxx = max(mx[ls], mx[rs]), minn = min(mn[ls], mn[rs]); if (mx[ls] == mn[ls]) update(ls, mx[ls] == maxx ? lz1[id] : 0, mn[ls] == minn ? lz2[id] : 0, lz3[id]); else update(ls, mx[ls] == maxx ? lz1[id] : lz3[id], mn[ls] == minn ? lz2[id] : lz3[id], lz3[id]); if (mx[rs] == mn[rs]) update(rs, mx[rs] == maxx ? lz1[id] : 0, mn[rs] == minn ? lz2[id] : 0, lz3[id]); else update(rs, mx[rs] == maxx ? lz1[id] : lz3[id], mn[rs] == minn ? lz2[id] : lz3[id], lz3[id]); lz1[id] = lz2[id] = lz3[id] = 0;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; if (l == r) &#123; mn[id] = mx[id] = sum[id] = a[l]; cntmn[id] = cntmx[id] = 1; secmn[id] = INF; secmx[id] = -INF; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v, v, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyMin(int id, int l, int r, int v) &#123; if (mx[id] &lt;= v) return; if (secmx[id] &lt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v - mx[id], 0, 0); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMin(ls, l, r, v); if (r &gt; mid[id]) modifyMin(rs, l, r, v); pushup(id); &#125;&#125;void modifyMax(int id, int l, int r, int v) &#123; if (mn[id] &gt;= v) return; if (secmn[id] &gt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, 0, v - mn[id], 0); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMax(ls, l, r, v); if (r &gt; mid[id]) modifyMax(rs, l, r, v); pushup(id); &#125;&#125;int querySum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += querySum(ls, l, r); if (r &gt; mid[id]) ans += querySum(rs, l, r); return ans; &#125;&#125;int queryMin(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mn[id]; &#125; else &#123; pushdown(id); int ans = INF; if (l &lt;= mid[id]) ans = min(ans, queryMin(ls, l, r)); if (r &gt; mid[id]) ans = min(ans, queryMin(rs, l, r)); return ans; &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs Luogu P6242 【模板】线段树 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int sum[MAXnd + 10];int mx[MAXnd + 10], cntmx[MAXnd + 10], secmx[MAXnd + 10], hismx[MAXnd + 10];int lz1[MAXnd + 10], lz2[MAXnd + 10], lz3[MAXnd + 10], lz4[MAXnd + 10];/*lz1: 最大值的增减值lz2: 最大值的增减值生命周期中的最大值lz3: 非最大值的增减值lz4: 非最大值历史的增减值生命周期中的最大值*/inline void pushup(int id) &#123; if (mx[ls] &gt; mx[rs]) &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls]; secmx[id] = max(secmx[ls], mx[rs]); &#125; else if (mx[ls] &lt; mx[rs]) &#123; mx[id] = mx[rs]; cntmx[id] = cntmx[rs]; secmx[id] = max(mx[ls], secmx[rs]); &#125; else &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls] + cntmx[rs]; secmx[id] = max(secmx[ls], secmx[rs]); &#125; hismx[id] = max(hismx[ls], hismx[rs]); sum[id] = sum[ls] + sum[rs];&#125;inline void update(int id, int v1, int v2, int v3, int v4) &#123; sum[id] += v1 * cntmx[id] + v3 * (len[id] - cntmx[id]); hismx[id] = max(hismx[id], mx[id] + v2); lz2[id] = max(lz2[id], lz1[id] + v2); lz4[id] = max(lz4[id], lz3[id] + v4); mx[id] += v1; // 注意顺序! if (secmx[id] != -INF) secmx[id] += v3; lz1[id] += v1; lz3[id] += v3;&#125;inline void pushdown(int id) &#123; int maxx = max(mx[ls], mx[rs]); if (maxx == mx[ls]) update(ls, lz1[id], lz2[id], lz3[id], lz4[id]); else update(ls, lz3[id], lz4[id], lz3[id], lz4[id]); if (maxx == mx[rs]) update(rs, lz1[id], lz2[id], lz3[id], lz4[id]); else update(rs, lz3[id], lz4[id], lz3[id], lz4[id]); lz1[id] = lz2[id] = lz3[id] = lz4[id] = 0;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; if (l == r) &#123; sum[id] = mx[id] = hismx[id] = a[l]; cntmx[id] = 1; secmx[id] = -INF; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v, v, v, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyMin(int id, int l, int r, int v) &#123; if (mx[id] &lt;= v) return; if (secmx[id] &lt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v - mx[id], v - mx[id], 0, 0); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMin(ls, l, r, v); if (r &gt; mid[id]) modifyMin(rs, l, r, v); pushup(id); &#125;&#125;int querySum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += querySum(ls, l, r); if (r &gt; mid[id]) ans += querySum(rs, l, r); return ans; &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;int queryHisMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return hismx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryHisMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryHisMax(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs Luogu P4314 CPU 监控 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int mx[MAXnd + 10], hismx[MAXnd + 10];int lz1[MAXnd + 10], lz2[MAXnd + 10], lz3[MAXnd + 10], lz4[MAXnd + 10], lz5[MAXnd + 10];/*lz1: 末段增减值lz2: 末段增减值的历史最大值lz3: 首段增减值的历史最大值lz4: (如果有)末端覆盖值lz5: (如果有)中间段的最大值*/inline void pushup(int id) &#123; mx[id] = max(mx[ls], mx[rs]); hismx[id] = max(hismx[ls], hismx[rs]);&#125;inline void update(int id, int v1, int v2, int v3, int v4, int v5) &#123; if (v4 == INF) &#123; if (lz4[id] == INF) &#123; hismx[id] = max(hismx[id], mx[id] + v3); mx[id] = mx[id] + v1; lz2[id] = lz3[id] = max(lz2[id], lz1[id] + v3); lz1[id] = lz1[id] + v1; &#125; else &#123; hismx[id] = max(hismx[id], mx[id] + v3); mx[id] = mx[id] + v1; lz2[id] = max(lz2[id], lz1[id] + v3); lz1[id] = lz1[id] + v1; &#125; &#125; else &#123; if (lz4[id] == INF) &#123; hismx[id] = max(max(max(hismx[id], mx[id] + v3), v5), v4 + v2); mx[id] = v4 + v1; lz3[id] = max(lz3[id], lz1[id] + v3); lz1[id] = v1; lz2[id] = v2; lz4[id] = v4; lz5[id] = v5; &#125; else &#123; hismx[id] = max(max(max(hismx[id], mx[id] + v3), v5), v4 + v2); mx[id] = v4 + v1; lz5[id] = max(max(max(lz5[id], v5), lz4[id] + lz2[id]), lz4[id] + lz1[id] + v3); lz1[id] = v1; lz2[id] = v2; lz4[id] = v4; &#125; &#125;&#125;inline void pushdown(int id) &#123; update(ls, lz1[id], lz2[id], lz3[id], lz4[id], lz5[id]); update(rs, lz1[id], lz2[id], lz3[id], lz4[id], lz5[id]); lz1[id] = lz2[id] = lz3[id] = 0; lz4[id] = INF; lz5[id] = -INF;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; lz4[id] = INF; lz5[id] = -INF; if (l == r) &#123; mx[id] = hismx[id] = a[l]; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v, v, v, INF, -INF); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyRep(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; mx[id] = v; hismx[id] = max(hismx[id], v); if (lz4[id] != INF) lz5[id] = max(lz5[id], lz4[id] + lz2[id]); lz1[id] = lz2[id] = 0; lz4[id] = v; &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyRep(ls, l, r, v); if (r &gt; mid[id]) modifyRep(rs, l, r, v); pushup(id); &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;int queryHisMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return hismx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryHisMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryHisMax(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"杂谈","slug":"杂谈","permalink":"http://rsdbkhusky.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"软件","slug":"软件","permalink":"http://rsdbkhusky.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"搜索","slug":"搜索","permalink":"http://rsdbkhusky.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]}