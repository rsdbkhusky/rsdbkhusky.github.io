{"meta":{"title":"燃烧的冰块_husky's blog","subtitle":"Thank for your visiting","description":"这是一个个人博客","author":"rsdbk_husky","url":"http://rsdbkhusky.github.io","root":"/"},"pages":[{"title":"分类","date":"un55fin55","updated":"un55fin55","comments":true,"path":"categories/index.html","permalink":"http://rsdbkhusky.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"un55fin55","updated":"un55fin55","comments":true,"path":"link/index.html","permalink":"http://rsdbkhusky.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"un55fin55","updated":"un55fin55","comments":true,"path":"tags/index.html","permalink":"http://rsdbkhusky.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2021/12/10/hello-world/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/10/hello-world/","excerpt":"","text":"LaTeX\\LaTeXLATE​X ∑i=1i≤nai\\sum\\limits_{i=1}^{i\\le n}a_i i=1∑i≤n​ai​ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"二维凸包","slug":"二维凸包/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/10/07/二维凸包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/07/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/index/","excerpt":"","text":"P2742 USACO5.1 圈奶牛Fencing the Cows /【模板】二维凸包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;struct Point &#123; double x, y; inline bool operator&lt;(const Point sec) const &#123; if (x == sec.x) &#123; return y &lt; sec.y; &#125; return x &lt; sec.x; &#125;&#125;;inline double cp(Point a1, Point a2, Point b1, Point b2) &#123; return (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);&#125;inline double dist(Point a, Point b) &#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int n; Point point[MAXn + 10];int top, stk[MAXn + 10]; bitset&lt;MAXn + 10&gt; instk;double ans;signed main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y); &#125; sort(point + 1, point + 1 + n); stk[++top] = 1; instk[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; while (top &gt; 1 &amp;&amp; cp(point[stk[top - 1]], point[stk[top]], point[stk[top]], point[i]) &lt;= 0) &#123; instk[stk[top--]] = 0; &#125; stk[++top] = i; instk[i] = 1; &#125; int tmptop = top - 1; for (int i = n - 1; i; --i) &#123; if (!instk[i]) &#123; while (top - tmptop &gt; 1 &amp;&amp; cp(point[stk[top - 1]], point[stk[top]], point[stk[top]], point[i]) &lt;= 0) &#123; instk[stk[top--]] = 0; &#125; stk[++top] = i; instk[i] = 1; &#125; &#125; while (top - tmptop &gt; 1 &amp;&amp; cp(point[stk[top - 1]], point[stk[top]], point[stk[top]], point[1]) &lt;= 0) &#123; instk[stk[top--]] = 0; &#125; for (int i = 1; i &lt; top; ++i) &#123; ans += dist(point[stk[i]], point[stk[i + 1]]); &#125; ans += dist(point[stk[top]], point[stk[1]]); printf(&quot;%.2lf\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"欧拉路径","slug":"欧拉路径/index","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2021/10/06/欧拉路径/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/06/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/index/","excerpt":"","text":"1. 无向图欧拉路径 P2731 [USACO3.3]骑马修栅栏 Riding the Fences 之所以要用邻接矩阵是因为一条边只能走一次，走过一条边这条边的另一个方向也不能走了，邻接矩阵便于删除走过的边的另一个方向。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e2;const int MAXm = 1024;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, m, source = 1, edge[MAXn + 10][MAXn + 10], deg[MAXn + 10];int top, stk[MAXm * 2 + 10];void Dfs(int cur) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (edge[cur][i]) &#123; --edge[cur][i]; --edge[i][cur]; Dfs(i); &#125; &#125; stk[++top] = cur;&#125;signed main() &#123; read(m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); ++edge[u][v]; ++edge[v][u]; ++deg[u]; ++deg[v]; n = max(n, max(u, v)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (deg[i] &amp; 1) &#123; source = i; break; &#125; &#125; Dfs(source); for (int i = top; i; --i) &#123; printf(&quot;%d\\n&quot;, stk[i]); &#125;&#125; 复杂度要求在 O(n2)O(n^2)O(n2) 以内怎么办，听别人说要用什么当前弧优化，留坑待补…… 2. 有向图欧拉路径 P7771 【模板】欧拉路径 有向图因为不需要删除边的另一个方向就用邻接表就行了，代码就不放了。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"01分数规划","slug":"01分数规划/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/09/30/01分数规划/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/index/","excerpt":"","text":"P4377 USACO18OPEN Talent Show G 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 250;const int MAXW = 1e3;const double MAXfrac = 1e6;const double EPS = 1e-8;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, W, w[MAXn + 10], t[MAXn + 10]; double v[MAXn + 10];double d[MAXW + 10];double calc(double x) &#123; for (int i = 1; i &lt;= n; ++i) &#123; v[i] = (double)t[i] - (double)w[i] * x; &#125; memset(d, 0xc2, sizeof(d)); d[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = W; ~j; --j) &#123; int k = min(j + w[i], W); d[k] = max(d[k], d[j] + v[i]); &#125; &#125; return d[W];&#125;signed main() &#123; read(n, W); for (int i = 1; i &lt;= n; ++i) &#123; read(w[i], t[i]); &#125; double L = 0, R = MAXfrac; while (R - L &gt; EPS) &#123; double mid = (L + R) / 2; if (calc(mid) &gt; 0) &#123; L = mid; &#125; else &#123; R = mid; &#125; &#125; printf(&quot;%d\\n&quot;, int(L * 1000));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"容斥原理","slug":"容斥原理/index","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2021/09/30/容斥原理/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/index/","excerpt":"","text":"P1450 HAOI2008 硬币购物 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 4;const int MAXn2 = 16;const int MAXW = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int T, n = 4, W, w[MAXn + 10], cnt[MAXn + 10], d[MAXW + 10];signed main() &#123; read(w[1]), read(w[2]), read(w[3]), read(w[4]), read(T); d[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = w[i]; j &lt;= MAXW; ++j) &#123; d[j] += d[j - w[i]]; &#125; &#125; while (T--) &#123; read(cnt[1]), read(cnt[2]), read(cnt[3]), read(cnt[4]), read(W); int ans = 0; for (re int i = 0; i &lt; MAXn2; ++i) &#123; int p = W; for (re int j = 1; j &lt;= n; ++j) &#123; if ((i &gt;&gt; (j - 1)) &amp; 1) &#123; p -= w[j] * (cnt[j] + 1); &#125; &#125; if (p &lt; 0) &#123; continue; &#125; ans += __builtin_popcount(i) &amp; 1 ? -d[p] : d[p]; &#125; printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"字符串最小表示法","slug":"字符串最小表示法/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/09/30/字符串最小表示法/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/index/","excerpt":"","text":"P1368 【模板】最小表示法 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::min;const int MAXn = 3e5;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, a[MAXn * 2 + 10], begin;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); a[i + n] = a[i]; &#125; int i = 1, j = 2, k = 0; while (true) &#123; if (i &gt; n || j &gt; n) &#123; begin = min(i, j); break; &#125; k = 0; while (a[i + k] == a[j + k] &amp;&amp; k &lt; n) ++k; if (k == n) &#123; begin = i; break; &#125; if (a[i + k] &gt; a[j + k]) &#123; i = i + k + 1; if (i == j) ++i; &#125; else &#123; j = j + k + 1; if (i == j) ++j; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d &quot;, a[begin + i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"异或高斯消元","slug":"异或高斯消元/index","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2021/09/30/异或高斯消元/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E5%BC%82%E6%88%96%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/index/","excerpt":"","text":"P2447 SDOI2010 外星千足虫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 2e3; // 本代码中n和m和题面中的是反的，代码中n代表矩阵的行数，m代表列数const int MAXm = 1e3;int n, m, ans;bitset&lt;MAXm + 10&gt; a[MAXn + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; m &gt;&gt; n; char tmp; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m + 1; ++j) &#123; cin &gt;&gt; tmp; a[i][j] = tmp - &#x27;0&#x27;; &#125; &#125; int row = 1; for (int col = 1; col &lt;= m; ++col) &#123; int maxer = row; for (int i = row + 1; i &lt;= n; ++i) &#123; if (a[maxer][col] &lt; a[i][col]) &#123; maxer = i; &#125; &#125; if (!a[maxer][col]) &#123; cout &lt;&lt; &quot;Cannot Determine\\n&quot;; return 0; &#125; ans = max(ans, maxer); swap(a[row], a[maxer]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (a[i][col]) &#123; a[i] = a[i] ^ a[row]; &#125; &#125; ++row; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt;= m; ++i) &#123; if (a[i][m + 1]) &#123; cout &lt;&lt; &quot;?y7M#\\n&quot;; &#125; else &#123; cout &lt;&lt; &quot;Earth\\n&quot;; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"同余最短路","slug":"同余最短路/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/09/30/同余最短路/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF/index/","excerpt":"","text":"P3403 跳楼机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXnd = 5e5;const int MAXn = 12;const int MAXeg = MAXnd * MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10], wei[MAXeg + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;bool vis[MAXnd + 10]; int dis[MAXnd + 10];priority_queue&lt;pair&lt;int, int&gt;&gt; q;void Dijkstra(int root, int rootdis) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = rootdis; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int n, l, r, a[MAXn + 10], ans;signed main() &#123; read(n, l, r); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; sort(a + 1, a + 1 + n); for (int i = 0; i &lt; a[1]; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; Insert(i, (i + a[j]) % a[1], a[j]); &#125; &#125; Dijkstra(0, 0); for (int i = 0; i &lt; a[1]; ++i) &#123; if (dis[i] &gt; r) continue; ans += (r - dis[i]) / a[1] + 1; if (dis[i] &gt; l - 1) continue; ans -= (l - 1 - dis[i]) / a[1] + 1; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树形背包","slug":"树形背包/index","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2021/09/30/树形背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P3177 HAOI2015 树上染色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e3;const int MAXm = MAXn;const int MAXk = 2e3;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXm + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, fa[MAXn + 10], siz[MAXn + 10], d[MAXn + 10][MAXk + 10];void Dfs(int cur) &#123; siz[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs(to[i]); siz[cur] += siz[to[i]]; &#125;&#125;void DfsDp(int cur) &#123; d[cur][0] = d[cur][1] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; DfsDp(to[i]); for (int j = min(m, siz[cur]); ~j; --j) &#123; for (int k = 0; k &lt;= min(j, siz[to[i]]); ++k) &#123; d[cur][j] = max(d[cur][j], d[cur][j - k] + d[to[i]][k] + wei[i] * (k * (m - k) + (siz[to[i]] - k) * (n - siz[to[i]] - (m - k)))); &#125; &#125; &#125;&#125;signed main() &#123; memset(d, 0xc0, sizeof(d)); read(n, m); if (n &lt; m * 2) &#123; m = n - m; &#125; for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1); DfsDp(1); printf(&quot;%lld\\n&quot;, d[1][m]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"带权并查集","slug":"带权并查集/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/09/30/带权并查集/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/index/","excerpt":"","text":"带权并查集的适用前提：维护的关系具有可传递性 带权并查集操作需保证的条件：执行了 Find 函数或 Merge 函数的节点的所有信息一定会被更新 P2024 NOI2001 食物链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;const int MAXm = 1e5;int fa[MAXn + 10], dis[MAXn + 10];void Init(int top) &#123; for (int i = 0; i &lt;= top; ++i) &#123; fa[i] = i; &#125; memset(dis, 0, sizeof(dis));&#125;int Find(int x) &#123; if (fa[x] == x) &#123; return x; &#125; else &#123; int lastfa = fa[x]; fa[x] = Find(fa[x]); dis[x] = dis[x] + dis[lastfa]; return fa[x]; &#125;&#125;void Merge(int x, int y, int dist) &#123; int ancx = Find(x), ancy = Find(y); fa[ancx] = ancy; dis[ancx] = -dis[x] + dist + dis[y];&#125;int Query(int x, int y) &#123; int ancx = Find(x), ancy = Find(y); if (ancx != ancy) &#123; return -1; &#125; else &#123; return ((dis[x] - dis[y]) % 3 + 3) % 3; &#125;&#125;int n, m, cntfalse;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; Init(n); for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (x &gt; n || y &gt; n) &#123; ++cntfalse; continue; &#125; if (opt == 1) &#123; int qu = Query(x, y); if (qu == -1) &#123; Merge(x, y, 0); &#125; else if (qu != 0) &#123; ++cntfalse; &#125; &#125; else &#123; int qu = Query(x, y); if (qu == -1) &#123; Merge(x, y, 1); &#125; else if (qu != 1) &#123; ++cntfalse; &#125; &#125; &#125; cout &lt;&lt; cntfalse &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Floyd解最小环","slug":"Floyd解最小环/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/09/30/Floyd解最小环/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/Floyd%E8%A7%A3%E6%9C%80%E5%B0%8F%E7%8E%AF/index/","excerpt":"","text":"P6175 无向图的最小环问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e2;const int INF = 0x20202020;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, m, ans = INF;int wei[MAXn + 10][MAXn + 10], dis[MAXn + 10][MAXn + 10];signed main() &#123; read(n, m); memset(wei, 0x20, sizeof(wei)); memset(dis, 0x20, sizeof(dis)); for (int i = 1; i &lt;= n; ++i) &#123; wei[i][i] = dis[i][i] = 0; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); wei[u][v] = wei[v][u] = dis[u][v] = dis[v][u] = min(dis[u][v], w); &#125; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j || j == k || k == i) continue; ans = min(ans, wei[i][k] + wei[k][j] + dis[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125; if (ans == INF) &#123; printf(&quot;No solution.\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, ans); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"字符串dp","slug":"字符串dp/index","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2021/09/30/字符串dp/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/30/%E5%AD%97%E7%AC%A6%E4%B8%B2dp/index/","excerpt":"","text":"P3082 [USACO13MAR]Necklace G 1. Kmp上Dp（会T） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::ios;using std::cin;using std::cout;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int INF = 0x3f3f3f3f;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10];int d[MAXltxt + 10][MAXlwrd + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; while (k &amp;&amp; (wrd[k + 1] != txt[i + 1] || k == lwrd)) k = fail[k]; if (wrd[k + 1] == txt[i + 1]) ++k; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; 2. Ac自动机上Dp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using std::ios;using std::cin;using std::cout;using std::queue;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int MAXnd = 1e3;const int INF = 0x3f3f3f3f;int cntnd, son[MAXnd + 10][26], fail[MAXnd + 10];int Insert(char *str) &#123; int len = strlen(str + 1); int cur = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (!son[cur][str[i] - &#x27;a&#x27;]) &#123; son[cur][str[i] - &#x27;a&#x27;] = ++cntnd; &#125; cur = son[cur][str[i] - &#x27;a&#x27;]; &#125; return cur;&#125;queue&lt;int&gt; q;void EvaFail() &#123; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int j = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) &#123; if (son[j][i]) &#123; fail[son[j][i]] = son[fail[j]][i]; q.push(son[j][i]); &#125; else &#123; son[j][i] = son[fail[j]][i]; &#125; &#125; &#125;&#125;char wrd[MAXlwrd + 10], txt[MAXltxt + 10];int n, lwrd, ltxt, d[MAXltxt + 10][MAXlwrd + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); Insert(wrd); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; k = son[k][txt[i + 1] - &#x27;a&#x27;]; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"莫队","slug":"莫队/index","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2021/09/16/莫队/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/16/%E8%8E%AB%E9%98%9F/index/","excerpt":"","text":"P1494 [国家集训队]小Z的袜子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using std::sort;#define int long longconst int MAXn = 5e4;const int MAXm = 5e4;const int MAXc = 5e4;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int b, cntblock, inblock[MAXn + 10];struct Query &#123; int l, r, id; inline bool operator&lt;(const Query &amp;y) const &#123; if (l / b == y.l / b) &#123; return (l / b) &amp; 1 ? r &lt; y.r : y.r &lt; r; &#125; return l &lt; y.l; &#125;&#125;q[MAXm + 10];int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int n, m, a[MAXn + 10];int sum, cnt[MAXc + 10], ans1[MAXm + 10], ans2[MAXm + 10];inline void add(int x) &#123; sum += cnt[x]; ++cnt[x];&#125;inline void del(int x) &#123; --cnt[x]; sum -= cnt[x];&#125;void Mocap() &#123; int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (q[i].l &gt;= q[i].r) &#123; ans1[q[i].id] = 0; ans2[q[i].id] = 1; continue; &#125; while (l &gt; q[i].l) add(a[--l]); while (r &lt; q[i].r) add(a[++r]); while (l &lt; q[i].l) del(a[l++]); while (r &gt; q[i].r) del(a[r--]); ans1[q[i].id] = sum; ans2[q[i].id] = (r - l + 1) * (r - l) / 2; &#125;&#125;signed main() &#123; read(n, m); b = ceil((double)n / sqrt(ceil((double)m))); // b = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (int i = 1; i &lt;= m; ++i) &#123; read(q[i].l, q[i].r); q[i].id = i; &#125; sort(q + 1, q + 1 + m); Mocap(); for (int i = 1; i &lt;= m; ++i) &#123; if (ans1[i] != 0) &#123; int g = gcd(ans1[i], ans2[i]); ans1[i] /= g, ans2[i] /= g; &#125; else &#123; ans2[i] = 1; &#125; printf(&quot;%lld/%lld\\n&quot;, ans1[i], ans2[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"高斯消元解有后效性的dp","slug":"高斯消元解有后效性的dp/index","date":"un33fin33","updated":"un55fin55","comments":true,"path":"2021/09/15/高斯消元解有后效性的dp/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/15/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E6%9C%89%E5%90%8E%E6%95%88%E6%80%A7%E7%9A%84dp/index/","excerpt":"","text":"CF24D Broken robot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e3;const int MAXm = 1e3;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, x, y;double mat[MAXm + 10][MAXm + 10], d[MAXn + 10][MAXm + 10];signed main() &#123; read(n), read(m); read(x), read(y); if (m == 1) &#123; printf(&quot;%d\\n&quot;, 2 * (n - x)); return 0; &#125; for (re int i = n - 1; i &gt;= x; --i) &#123; memset(mat, 0, sizeof(mat)); mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = d[i + 1][1] + 3; for (re int j = 2; j &lt; m; ++j) &#123; mat[j][j - 1] = mat[j][j + 1] = -1; mat[j][j] = 3; mat[j][m + 1] = d[i + 1][j] + 4; &#125; mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = d[i + 1][m] + 3; // ------- 高斯消元 begin ------- for (re int i = 1; i &lt; m; ++i) &#123; double solve = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] -= mat[i][i] * solve; if (i != m) &#123; mat[i + 1][i + 1] -= mat[i][i + 1] * solve; &#125; mat[i + 1][m + 1] -= mat[i][m + 1] * solve; &#125; for (re int i = m; i &gt; 1; --i) &#123; double solve = mat[i - 1][i] / mat[i][i]; mat[i - 1][i] -= mat[i][i] * solve; mat[i - 1][m + 1] -= mat[i][m + 1] * solve; &#125; // ------- 高斯消元 end ------- for (re int j = 1; j &lt;= m; ++j) &#123; d[i][j] = mat[j][m + 1] / mat[j][j]; &#125; &#125; printf(&quot;%.4f\\n&quot;, d[x][y]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"动态开点线段树","slug":"动态开点线段树/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/09/15/动态开点线段树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/15/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/index/","excerpt":"","text":"P5459 [BJOI2016]回转寿司 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define int long longusing std::map;using std::sort;using std::unique;const int MAXn = 1e5;const int MAXa = 1e5;const int MAXsuma = MAXn * MAXa;const int MAXlogsuma = 34;const int MAXnd = MAXn * MAXlogsuma * 4;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], le[MAXnd + 10], ri[MAXnd + 10], sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int AddNew(int l, int r, int p, int k) &#123; int id = ++cntnd; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = k; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; ls[id] = AddNew(l, mid, p, k); &#125; else &#123; rs[id] = AddNew(mid + 1, r, p, k); &#125; pushup(id); &#125; return id;&#125;void AddOld(int id, int p, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] += k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) &#123; if (ls[id]) &#123; AddOld(ls[id], p, k); &#125; else &#123; ls[id] = AddNew(le[id], mid, p, k); &#125; &#125; else &#123; if (rs[id]) &#123; AddOld(rs[id], p, k); &#125; else &#123; rs[id] = AddNew(mid + 1, ri[id], p, k); &#125; &#125; pushup(id); &#125;&#125;int Sec(int id, int l, int r) &#123; if (!id) return 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += Sec(ls[id], l, r); if (r &gt; mid) ans += Sec(rs[id], l, r); return ans; &#125;&#125;int n1, n2, L, R, a[MAXn + 10], suma[MAXn + 10], ans;signed main() &#123; read(n1, L, R); for (int i = 1; i &lt;= n1; ++i) &#123; read(a[i]); suma[i] = suma[i - 1] + a[i]; &#125; ++cntnd; le[cntnd] = -MAXsuma; ri[cntnd] = MAXsuma; sum[cntnd] = 0; AddOld(1, 0, 1); for (int i = 1; i &lt;= n1; ++i) &#123; ans += Sec(1, suma[i] - R, suma[i] - L); AddOld(1, suma[i], 1); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"主席树","slug":"主席树/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/09/15/主席树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/index/","excerpt":"","text":"P3834【模板】可持久化线段树 2（主席树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using std::map;using std::sort;using std::unique;const int MAXn = 2e5;const int MAXlogn = 20;const int MAXm = 2e5;const int MAXnd = MAXn * 4 + MAXm * MAXlogn;const int MAXroot = MAXm;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], sum[MAXnd + 10];int cntroot, root[MAXroot + 10];int end[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int Build0(int l, int r) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; ls[id] = Build0(l, mid); rs[id] = Build0(mid + 1, r); &#125; return id;&#125;int BuildUseArr(int l, int r, int *a) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; ls[id] = BuildUseArr(l, mid, a); rs[id] = BuildUseArr(mid + 1, r, a); pushup(id); &#125; return id;&#125;int Insert(int verid, int l, int r, int p, int k) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; sum[id] = sum[verid] + k; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; ls[id] = Insert(ls[verid], l, mid, p, k); rs[id] = rs[verid]; &#125; else &#123; ls[id] = ls[verid]; rs[id] = Insert(rs[verid], mid + 1, r, p, k); &#125; pushup(id); &#125; return id;&#125;map&lt;int, int&gt; mapdown; int cntmap, mapup[MAXn + 10];int n1, n2, m, a[MAXn + 10];int Query(int lid, int rid, int k) &#123; if (end[lid]) &#123; return mapup[end[lid]]; &#125; else &#123; if (k &lt;= sum[ls[rid]] - sum[ls[lid]]) &#123; return Query(ls[lid], ls[rid], k); &#125; else &#123; return Query(rs[lid], rs[rid], k - (sum[ls[rid]] - sum[ls[lid]])); &#125; &#125;&#125;signed main() &#123; read(n1, m); for (int i = 1; i &lt;= n1; ++i) &#123; read(a[i]); mapup[i] = a[i]; &#125; sort(mapup + 1, mapup + 1 + n1); n2 = unique(mapup + 1, mapup + 1 + n1) - mapup - 1; for (int i = 1; i &lt;= n2; ++i) &#123; mapdown[mapup[i]] = i; &#125; cntroot = -1; root[++cntroot] = Build0(1, n2); for (int i = 1; i &lt;= n1; ++i) &#123; ++cntroot; root[cntroot] = Insert(root[cntroot - 1], 1, n2, mapdown[a[i]], 1); &#125; for (int i = 1, l, r, k; i &lt;= m; ++i) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, Query(root[l - 1], root[r], k)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"前缀积法求逆元","slug":"前缀积法求逆元/index","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2021/09/08/前缀积法求逆元/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/08/%E5%89%8D%E7%BC%80%E7%A7%AF%E6%B3%95%E6%B1%82%E9%80%86%E5%85%83/index/","excerpt":"","text":"P5431 【模板】乘法逆元 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e6;#define int long longtemplate &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ans * x % mod; &#125; x = x * x % mod; y &gt;&gt;= 1; &#125; return ans;&#125;int inv(int n, int mod) &#123; int inv = power(n, mod - 2, mod); return (inv % mod + mod) % mod;&#125;int n, p, k, a[MAXn + 10], pi[MAXn + 10], mi[MAXn + 10], invv, ans;signed main() &#123; read(n), read(p), read(k); pi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); pi[i] = (pi[i - 1] * a[i]) % p; &#125; mi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mi[i] = (mi[i - 1] * k) % p; &#125; invv = inv(pi[n], p); for (re int i = n; i; --i) &#123; ans = (ans + mi[i] * (invv * pi[i - 1] % p)) % p; invv = (invv * a[i]) % p; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"有理数取余","slug":"有理数取余/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/09/06/有理数取余/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/06/%E6%9C%89%E7%90%86%E6%95%B0%E5%8F%96%E4%BD%99/index/","excerpt":"","text":"P2613 【模板】有理数取余 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#define re register#define int long longconst int MOD = 19260817;inline void read(int &amp;a) &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x * 10 + c - &#x27;0&#x27;) % MOD; &#125; a = x;&#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int inv, k; exgcd(n, mod, inv, k); return (inv % mod + mod) % mod;&#125;int frac(int a, int b, int mod) &#123; return (a * inv(b, mod)) % mod;&#125;int a, b;signed main() &#123; read(a), read(b); if (!(b % MOD)) &#123; printf(&quot;Angry!\\n&quot;); return 0; &#125; printf(&quot;%lld\\n&quot;, frac(a, b, MOD));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"快速乘","slug":"快速乘/index","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2021/09/05/快速乘/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/05/%E5%BF%AB%E9%80%9F%E4%B9%98/index/","excerpt":"","text":"龟速乘 12345678910111213template&lt;class T&gt;inline T mul(T x, T y, T mod) &#123; x %= mod; y %= mod; T ans = 0; while (y) &#123; if (y &amp; 1) &#123; ans = (ans + x) % mod; &#125; x = (x + x) % mod; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"可重集全排列","slug":"可重集全排列/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/09/01/可重集全排列/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/01/%E5%8F%AF%E9%87%8D%E9%9B%86%E5%85%A8%E6%8E%92%E5%88%97/index/","excerpt":"","text":"P2518 [HAOI2010]计数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans;signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"次短路","slug":"次短路/index","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2021/09/01/次短路/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/01/%E6%AC%A1%E7%9F%AD%E8%B7%AF/index/","excerpt":"","text":"P2865 [USACO06NOV]Roadblocks G 1. Dijkstra 12345678910111213141516171819202122232425262728bool vis[MAXn + 10];int dis[MAXn + 10], secdis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); memset(secdis, 0x3f, sizeof(secdis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second, d = -q.top().first; q.pop(); if (secdis[cur] &lt; d) continue; for (re int i = head[cur]; i; i = nex[i]) &#123; int dist = d + wei[i]; if (dis[to[i]] &gt; dist) &#123; swap(dis[to[i]], dist); q.push(make_pair(-dis[to[i]], to[i])); &#125; if (secdis[to[i]] &gt; dist) &#123; secdis[tod[i]] = dist; q.push(make_pair(-secdis[to[i]], to[i])); &#125; &#125; &#125;&#125;// main函数中Dijkstra(root);printf(&quot;%d\\n&quot;, secdis[cur]); 2. Spfa 12345678910111213141516171819202122232425262728293031323334353637bool inque[MAXn + 10];int dis[MAXn + 10], secdis[MAXn + 10];queue&lt;int&gt; q;void Spfa(int root) &#123; memset(dis, 0x3f, sizeof(dis)); memset(secdis, 0x3f, sizeof(secdis)); dis[root] = 0; q.push(root); inque[root] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; bool trans = 0; int dist = dis[cur] + wei[i], secdist = secdis[cur] + wei[i]; if (dis[to[i]] &gt; dist) &#123; secdis[to[i]] = dis[to[i]]; dis[to[i]] = dist; trans = 1; &#125; else if (dis[to[i]] &lt; dist &amp;&amp; secdis[to[i]] &gt; dist) &#123; secdis[to[i]] = dist; trans = 1; &#125; if (secdis[to[i]] &gt; secdist) &#123; secdis[to[i]] = secdist; trans = 1; &#125; if (trans) &#123; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;// main函数中Spfa(root);printf(&quot;%d\\n&quot;, secdis[cur]);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"严格次小生成树","slug":"严格次小生成树/index","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2021/08/31/严格次小生成树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/31/%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/index/","excerpt":"","text":"P4180 [BJWC2010]严格次小生成树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = 3e5;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m, root = 1;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int fat[MAXn + 10];int anc(int x) &#123; return fat[x] = fat[x] == x ? x : anc(fat[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fat[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fat[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];bool intree[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); intree[i] = 1; &#125; &#125; return ans;&#125;void mergemax(int &amp;ansmax, int &amp;anscmx, int max1, int cmx1, int max2, int cmx2) &#123; if (max1 &gt; max2) &#123; ansmax = max1; anscmx = max(max2, cmx1); &#125; else if (max1 &lt; max2) &#123; ansmax = max2; anscmx = max(max1, cmx2); &#125; else &#123; ansmax = max1; anscmx = max(cmx1, cmx2); &#125;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], maxx[MAXn * 4 + 10], cmax[MAXn * 4 + 10];void pushup(int id) &#123; mergemax(maxx[id], cmax[id], maxx[id &lt;&lt; 1], cmax[id &lt;&lt; 1], maxx[(id &lt;&lt; 1) + 1], cmax[(id &lt;&lt; 1) + 1]);&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; maxx[id] = a[l]; cmax[id] = -INF; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(id &lt;&lt; 1, l, mid, a); BuildUseArr((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;pair&lt;int, int&gt; Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return make_pair(maxx[id], cmax[id]); &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid &amp;&amp; r &gt; mid) &#123; int ansmax, anscmx; pair&lt;int, int&gt; left, right; left = Eva(id &lt;&lt; 1, l, r); right = Eva((id &lt;&lt; 1) + 1, l, r); mergemax(ansmax, anscmx, left.first, left.second, right.first, right.second); return make_pair(ansmax, anscmx); &#125; else if (l &lt;= mid) &#123; return Eva(id &lt;&lt; 1, l, r); &#125; else &#123; return Eva((id &lt;&lt; 1) + 1, l, r); &#125; &#125;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; ndwei[to[i]] = wei[i]; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125;&#125;pair&lt;int, int&gt; TreePathEva(int x, int y) &#123; int ansmax = -INF, anscmx = -INF; int tmpansmax, tmpanscmx; pair&lt;int, int&gt; tmp; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; tmp = Eva(1, nddfs[top[y]], nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; if (x == y) &#123; return make_pair(ansmax, anscmx); &#125; else &#123; tmp = Eva(1, nddfs[x] + 1, nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; return make_pair(ansmax, anscmx); &#125;&#125;int ans, diff = INF;signed main() &#123; cntnex = 1; read(n), read(m); int tmp = 0; for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); if (u == v) &#123; ++tmp; continue; &#125; edge[i - tmp] = Edge(u, v, w); &#125; m -= tmp; ans = Kruskal(); for (re int i = 1; i &lt;= m; ++i) &#123; Insert(edge[i].u, edge[i].v, edge[i].w); Insert(edge[i].v, edge[i].u, edge[i].w); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArr(1, 1, n, idxwei); for (re int i = 1; i &lt;= m; ++i) &#123; if (!intree[i]) &#123; pair&lt;int, int&gt; tmp = TreePathEva(edge[i].u, edge[i].v); if (tmp.first == edge[i].w) &#123; diff = min(diff, edge[i].w - tmp.second); &#125; else &#123; diff = min(diff, edge[i].w - tmp.first); &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans + diff);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最小生成树","slug":"最小生成树/index","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2021/08/31/最小生成树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/31/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/index/","excerpt":"","text":"P3366 【模板】最小生成树 Kruskal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e3;const int MAXm = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); &#125; &#125; return ans;&#125;int ans;signed main() &#123; read(n), read(m); for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); edge[i] = Edge(u, v, w); &#125; ans = Kruskal(); for (re int i = 1; i &lt; n; ++i) &#123; if (!SameAnc(i, i + 1)) &#123; printf(&quot;orz\\n&quot;); return 0; &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树上关键点","slug":"树上关键点/index","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2021/08/30/树上关键点/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/30/%E6%A0%91%E4%B8%8A%E5%85%B3%E9%94%AE%E7%82%B9/index/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template&lt;class T&gt;inline void read(T &amp;a) &#123; re char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());re bool f = c == &#x27;-&#x27;;re T x = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n, k, ans, root = 1;bool vis[MAXn + 10];pair&lt;int, bool&gt; Dfs(int cur) &#123; // 0: hav, 1: ned vis[cur] = 1; int ned = -INF, hav = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; pair&lt;int, bool&gt; tmp = Dfs(to[i]); if (tmp.second) &#123; ned = max(ned, tmp.first); &#125; else &#123; hav = max(hav, tmp.first); &#125; &#125; if (cur == root) &#123; if (ned == -INF &amp;&amp; hav == -INF) &#123; ++ans; &#125; else if (ned == -INF) &#123; ; &#125; else if (hav == -INF) &#123; ++ans; &#125; else &#123; if (ned &gt; hav) &#123; ++ans; &#125; else &#123; ; &#125; &#125; return make_pair(-1, -1); &#125; if (ned == -INF &amp;&amp; hav == -INF) &#123; return make_pair(1, 1); &#125; else if (ned == -INF) &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; else if (hav == -INF) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (ned &gt; hav) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; &#125;&#125;int main() &#123; read(n); read(k); if (k == 0) &#123; printf(&quot;%d\\n&quot;, n); return 0; &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs(root); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"分块","slug":"分块/index","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2021/08/29/分块/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/29/%E5%88%86%E5%9D%97/index/","excerpt":"","text":"P2357 守墓人 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register#define int long longconst int MAXn = 2e6;const int MAXsqrtn = 500;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m;int a[MAXn + 10], inpart[MAXn + 10], length;int cntpart, sum[MAXsqrtn + 10], add[MAXsqrtn + 10], le[MAXsqrtn + 10], ri[MAXsqrtn + 10];void BuildUseArray(int *a) &#123; length = cntpart = sqrt(n); for (re int i = 1, l = 1, r = cntpart; i &lt;= cntpart; ++i) &#123; le[i] = l; ri[i] = r; for (re int j = l; j &lt;= r; ++j) &#123; sum[i] += a[j]; inpart[j] = i; &#125; l = r + 1; r += length; &#125; if (ri[cntpart] &lt; n) &#123; ++cntpart; le[cntpart] = ri[cntpart - 1] + 1; ri[cntpart] = n; for (re int i = le[cntpart]; i &lt;= ri[cntpart]; ++i) &#123; sum[cntpart] += a[i]; inpart[i] = cntpart; &#125; &#125;&#125;void Add(int l, int r, int k) &#123; if (inpart[l] == inpart[r]) &#123; for (re int i = l; i &lt;= r; ++i) &#123; a[i] += k; &#125; sum[inpart[l]] += k * (r - l + 1); &#125; else &#123; for (re int i = l; i &lt;= ri[inpart[l]]; ++i) &#123; a[i] += k; &#125; sum[inpart[l]] += k * (ri[inpart[l]] - l + 1); for (re int i = le[inpart[r]]; i &lt;= r; ++i) &#123; a[i] += k; &#125; sum[inpart[r]] += k * (r - le[inpart[r]] + 1); for (re int i = inpart[l] + 1; i &lt; inpart[r]; ++i) &#123; add[i] += k; &#125; &#125;&#125;int EvaSum(int l, int r) &#123; int ans = 0; if (inpart[l] == inpart[r]) &#123; for (re int i = l; i &lt;= r; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[l]] * (r - l + 1); &#125; else &#123; for (re int i = l; i &lt;= ri[inpart[l]]; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[l]] * (ri[inpart[l]] - l + 1); for (re int i = le[inpart[r]]; i &lt;= r; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[r]] * (r - le[inpart[r]] + 1); for (re int i = inpart[l] + 1; i &lt; inpart[r]; ++i) &#123; ans += sum[i] + add[i] * length; &#125; &#125; return ans;&#125;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArray(a); for (re int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(z); Add(x, y, z); break; case 2: read(x); a[1] += x; sum[1] += x; break; case 3: read(x); a[1] -= x; sum[1] -= x; break; case 4: read(x), read(y); printf(&quot;%lld\\n&quot;, EvaSum(x, y)); break; case 5: printf(&quot;%lld\\n&quot;, a[1] + add[1]); break; &#125; &#125;&#125; 本来我是用线段树的板题来测我的分块的，但是后来又用这道题测了一下，发现始终过不了，调了很久才发现 “EvaSum -&gt; if (inpart[l] == inpart[r]) -&gt; ans += add[inpart[l]] * (r - l + 1);” 这句没有写。但是线段树的板题竟然过了，就离谱，这就是我不推荐用线段树板题测分块的原因。（不是为了水题）。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"逆康托展开","slug":"逆康托展开/index","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/08/25/逆康托展开/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/25/%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/index/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 18;const int MAXk = 1e16;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, k;int trector[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x)))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; trector[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int k) &#123; while (p &lt;= n) &#123; trector[p] += k; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int sum = 0; while (p &gt; 0) &#123; sum += trector[p]; p -= lowbit(p); &#125; return sum;&#125;int fac[MAXn + 10];void Evafac() &#123; fac[1] = 1; for (re int i = 2; i &lt; n; ++i) &#123; fac[i] = fac[i - 1] * i; &#125;&#125;int sum[MAXn + 10];void Initsum() &#123; for (re int i = 2; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + 1; &#125;&#125;int Div(int l, int r, int x) &#123; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (EvaSum(mid) &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int cantor[MAXn + 10], ans[MAXn + 10];signed main() &#123; read(n), read(k); --k; Evafac(); for (re int i = n; i &gt; 1; --i) &#123; cantor[i] = k / fac[i - 1]; k %= fac[i - 1]; &#125; Initsum(); BuildUseSum(sum); for (re int i = 1; i &lt;= n; ++i) &#123; ans[i] = Div(1, n, cantor[n - i + 1]); Add(ans[i], -1); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%lld &quot;, ans[i]); &#125; printf(&quot;\\n&quot;);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"对顶栈","slug":"对顶栈/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/08/23/对顶栈/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/23/%E5%AF%B9%E9%A1%B6%E6%A0%88/index/","excerpt":"","text":"P2201 数列编辑器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;struct Ele &#123; int val, sum, maxsum; Ele()&#123;&#125; Ele(int val_):val(val_)&#123;&#125;&#125;;struct Stack &#123; int top; Ele stk[MAXn + 10]; inline void Push(int x) &#123; stk[++top] = Ele(x); &#125; inline int Pop() &#123; return stk[top--].val; &#125;&#125;fro, beh;int n;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; char opt; for (re int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; opt; switch (opt) &#123; case &#x27;I&#x27;: cin &gt;&gt; x; fro.Push(x); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;D&#x27;: fro.Pop(); break; case &#x27;L&#x27;: beh.Push(fro.Pop()); break; case &#x27;R&#x27;: fro.Push(beh.Pop()); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;Q&#x27;: cin &gt;&gt; x; cout &lt;&lt; fro.stk[x].maxsum &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"实用小高精","slug":"实用小高精/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/08/18/实用小高精/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/18/%E5%AE%9E%E7%94%A8%E5%B0%8F%E9%AB%98%E7%B2%BE/index/","excerpt":"","text":"不实用的高精 推荐一个实用小高精： 1234567891011121314151617181920212223struct BigInt &#123; const static long long base = 1e13; long long s[2]; friend BigInt operator + (BigInt a, const BigInt b) &#123; a.s[0] += b.s[0]; a.s[1] += b.s[1]; if (a.s[0] &gt;= base) ++a.s[1], a.s[0] -= base; return a; &#125; friend int operator % (BigInt a, int b) &#123; return ((a.s[1] % b) * base + a.s[0]) % b; &#125; friend BigInt operator / (BigInt a, int b) &#123; BigInt c; c.s[1] = a.s[1] / b; c.s[0] = ((a.s[1] % b) * base + a.s[0]) / b; return c; &#125; void print() &#123; if (s[1]) printf(&quot;%lld%13lld&quot;, s[1], s[0]); else printf(&quot;%lld&quot;, s[0]); &#125;&#125;; 乘法不用考虑，用 s[1] * s[1] 就炸了。减法还要考虑负数（如果需要的话）。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"线段树优化建图","slug":"线段树优化建图/index","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2021/08/13/线段树优化建图/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/13/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/index/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define re registerconst int MAXn = 5e5;const int MAXm = 1e5;const int MAXedge = 3e7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn * 11 + 10], cntnex, nex[MAXedge + 10], to[MAXedge + 10]; bool wei[MAXedge + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, root;struct Node&#123; int l, r, idx;&#125;out[MAXn * 4 + 10], in[MAXn * 4 + 10];int cntnd;void BuildOut(int id, int l, int r) &#123; out[id].idx = ++cntnd; out[id].l = l; out[id].r = r; if (l == r) &#123; Insert(l, out[id].idx, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildOut(id &lt;&lt; 1, l, mid); BuildOut((id &lt;&lt; 1) + 1, mid + 1, r); Insert(out[id &lt;&lt; 1].idx, out[id].idx, 0); Insert(out[(id &lt;&lt; 1) + 1].idx, out[id].idx, 0);&#125;void BuildIn(int id, int l, int r) &#123; in[id].idx = ++cntnd; in[id].l = l; in[id].r = r; if (l == r) &#123; Insert(in[id].idx, 10 * n + l, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildIn(id &lt;&lt; 1, l, mid); BuildIn((id &lt;&lt; 1) + 1, mid + 1, r); Insert(in[id].idx, in[id &lt;&lt; 1].idx, 0); Insert(in[id].idx, in[(id &lt;&lt; 1) + 1].idx, 0);&#125;int cntqin, qin[MAXn + 10], cntqout, qout[MAXn + 10];void GetSecIn(int id, int l, int r) &#123; if (in[id].l &gt;= l &amp;&amp; in[id].r &lt;= r) &#123; qin[++cntqin] = in[id].idx; return; &#125; int mid = (in[id].l + in[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecIn(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecIn((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void GetSecOut(int id, int l, int r) &#123; if (out[id].l &gt;= l &amp;&amp; out[id].r &lt;= r) &#123; qout[++cntqout] = out[id].idx; return; &#125; int mid = (out[id].l + out[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecOut(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecOut((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void InsertSec(int l1, int r1, int l2, int r2) &#123; cntqin = cntqout = 0; GetSecOut(1, l2, r2); GetSecIn(1, l1, r1); for (re int i = 1; i &lt;= cntqout; ++i) &#123; for (re int j = 1; j &lt;= cntqin; ++j) &#123; Insert(qout[i], qin[j], 1); &#125; &#125;&#125;bool vis[MAXn * 11 + 10]; int dis[MAXn * 11 + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int main() &#123; read(n), read(m), read(root); cntnd = n; BuildOut(1, 1, n); BuildIn(1, 1, n); for (re int i = 1, l1, r1, l2, r2; i &lt;= m; ++i) &#123; read(l1), read(r1), read(l2), read(r2); InsertSec(l1, r1, l2, r2); InsertSec(l2, r2, l1, r1); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; Insert(i, 10 * n + i, 0); Insert(10 * n + i, i, 0); &#125; Dijkstra(root); for (re int i = 10 * n + 1; i &lt;= 11 * n; ++i) &#123; printf(&quot;%d\\n&quot;, dis[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"基环树","slug":"基环树/index","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2021/08/12/基环树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/12/%E5%9F%BA%E7%8E%AF%E6%A0%91/index/","excerpt":"","text":"P1453 城市环路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;double k;int n, a[MAXn + 10], deg[MAXn + 10];queue&lt;int&gt; q;bool vis[MAXn + 10];int cntring, ring[MAXn + 10];void EvaRing() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 1) &#123; q.push(i); &#125; &#125; int cur; while (!q.empty()) &#123; cur = q.front(); q.pop(); vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!vis[to[i]]) &#123; --deg[to[i]]; if (deg[to[i]] == 1) &#123; q.push(to[i]); &#125; &#125; &#125; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 2) &#123; vis[i] = 1; ring[++cntring] = i; break; &#125; &#125; bool ok = 1; while (ok) &#123; ok = 0; for (re int i = head[ring[cntring]]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 1) continue; vis[to[i]] = 1; ring[++cntring] = to[i]; ok = 1; break; &#125; &#125;&#125;int d[MAXn + 10][2];void dp(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 2) continue; dp(to[i]); d[cur][0] += max(d[to[i]][1], d[to[i]][0]); d[cur][1] += d[to[i]][0]; &#125; d[cur][1] += a[cur];&#125;void Dp() &#123; memset(vis, 0, sizeof(vis)); for (re int i = 1; i &lt;= cntring; ++i) &#123; dp(ring[i]); &#125;&#125;int f[MAXn + 10][2][2];int Dp2() &#123; f[1][0][0] = d[ring[1]][0]; f[1][1][1] = d[ring[1]][1]; f[1][0][1] = f[1][1][0] = -INF; for (re int i = 2; i &lt;= cntring; ++i) &#123; f[i][0][0] = max(f[i - 1][0][0], f[i - 1][0][1]) + d[ring[i]][0]; f[i][0][1] = f[i - 1][0][0] + d[ring[i]][1]; f[i][1][0] = max(f[i - 1][1][0], f[i - 1][1][1]) + d[ring[i]][0]; f[i][1][1] = f[i - 1][1][0] + d[ring[i]][1]; &#125; return max(max(f[cntring][0][0], f[cntring][0][1]), f[cntring][1][0]);&#125;int main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (re int i = 1, u, v; i &lt;= n; ++i) &#123; read(u), read(v); ++u; ++v; ++deg[u]; ++deg[v]; Insert(u, v); Insert(v, u); &#125; scanf(&quot;%lf&quot;, &amp;k); EvaRing(); Dp(); printf(&quot;%.1lf\\n&quot;, (double)Dp2() * k);&#125; 基环树求环长度和环上每个节点前的边的长度： 123456789101112int cntinring, ring[MAXnd + 10], ringdis;int ndwei[MAXnd + 10];void EvaRing(int cur, int fromedge, int begin) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (iscut[i] || i == (fromedge ^ 1)) continue; ring[++cntinring] = to[i]; ringdis += wei[i]; ndwei[to[i]] = wei[i]; if (to[i] != begin) EvaRing(to[i], i, begin); if (cur == begin) break; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Cdq解三维偏序","slug":"Cdq解三维偏序/index","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2021/08/10/Cdq解三维偏序/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/Cdq%E8%A7%A3%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F/index/","excerpt":"","text":"P3810 【模板】三维偏序（陌上花开） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXk = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int top, t[MAXk + 10];#define lowbit(x) (x &amp; (-x))void Add(int p, int v) &#123; while (p &lt;= top) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int n, k;struct Ele &#123; int a, b, c, cnt, ans;&#125;eletmp[MAXn + 10], ele[MAXn + 10];inline bool cmpc(Ele x, Ele y) &#123; if (x.c == y.c) &#123; if (x.b == y.b) &#123; return x.a &lt; y.a; &#125; return x.b &lt; y.b; &#125; return x.c &lt; y.c;&#125;inline bool cmpb(Ele x, Ele y) &#123; if (x.b == y.b) &#123; return x.a &lt; y.a; &#125; return x.b &lt; y.b;&#125;void cdq(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int j = l; for (int i = mid + 1; i &lt;= r; ++i) &#123; while (j &lt;= mid &amp;&amp; ele[i].b &gt;= ele[j].b) &#123; Add(ele[j].a, ele[j].cnt); ++j; &#125; ele[i].ans += EvaSum(ele[i].a); &#125; for (int i = l; i &lt; j; ++i) &#123; Add(ele[i].a, -ele[i].cnt); &#125; inplace_merge(ele + l, ele + 1 + mid, ele + 1 + r, cmpb);&#125;int ans[MAXn + 10], m;int main() &#123; read(n), read(k); top = k; for (int i = 1; i &lt;= n; ++i) &#123; read(eletmp[i].a), read(eletmp[i].b), read(eletmp[i].c); &#125; sort(eletmp + 1, eletmp + 1 + n, cmpc); for (int i = 1, j = 0; i &lt;= n; ++i) &#123; ++j; if (eletmp[i].a != eletmp[i + 1].a || eletmp[i].b != eletmp[i + 1].b || eletmp[i].c != eletmp[i + 1].c) &#123; ++m; ele[m].a = eletmp[i].a; ele[m].b = eletmp[i].b; ele[m].c = eletmp[i].c; ele[m].cnt = j; j = 0; &#125; &#125; cdq(1, m); for (int i = 1; i &lt;= m; ++i) &#123; ans[ele[i].ans + ele[i].cnt - 1] += ele[i].cnt; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"三分","slug":"三分/index","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2021/08/10/三分/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/%E4%B8%89%E5%88%86/index/","excerpt":"","text":"P3382 【模板】三分法 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define re registerconst int MAXn = 13 + 1;const double EPS = 1e-6;int n;double l, r, a[MAXn + 10];double f(double x) &#123; double ans = 0; for (re int i = n; ~i; --i) &#123; ans = ans * x + a[i]; &#125; return ans;&#125;void ThreeDiv() &#123; if (r - l &lt; EPS) return; double mid = (l + r) / 2; if (f(mid - EPS) &gt; f(mid + EPS)) &#123; r = mid; &#125; else &#123; l = mid; &#125; ThreeDiv();&#125;int main() &#123; scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;l, &amp;r); for (re int i = n; ~i; --i) &#123; scanf(&quot;%lf&quot;, &amp;a[i]); &#125; ThreeDiv(); printf(&quot;%.5lf\\n&quot;, l);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二分","slug":"二分/index","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2021/08/10/二分/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/%E4%BA%8C%E5%88%86/index/","excerpt":"","text":"重点： midmidmid 取 l+rl+rl+r 还是 l+r+1l+r+1l+r+1。 &quot; === &quot; 的话应该算那种情况。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, x, arr[MAXn + 10];int a() &#123; //大于等于中最小的(lower_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int b() &#123; //大于中最小的(upper_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int c() &#123; //小于中最大的 int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int d() &#123; //小于等于中最大的 int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int main() &#123; read(n), read(x); for (re int i = 1; i &lt;= n; ++i) &#123; read(arr[i]); &#125; printf(&quot;%d %d %d %d\\n&quot;, a(), b(), c(), d()); // printf(&quot;%d %d\\n&quot;, int(lower_bound(arr + 1, arr + 1 + n, x) - arr), int(upper_bound(arr + 1, arr + 1 + n, x) - arr));&#125; 结果：","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"字符串哈希解最小循环节","slug":"字符串哈希解最小循环节/index","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2021/08/10/字符串哈希解最小循环节/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E8%A7%A3%E6%9C%80%E5%B0%8F%E5%BE%AA%E7%8E%AF%E8%8A%82/index/","excerpt":"","text":"P3538 POI2012\\OKR-A Horrible Poem 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e5;const int BASE = 107;const int MOD = 1e9 + 7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, cntp, p[MAXn + 10], minpf[MAXn + 10];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; minpf[i] = i; &#125; int up2 = up / i; for (int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; minpf[i * p[j]] = p[j]; if (!(i % p[j])) &#123; break; &#125; &#125; &#125;&#125;int hashpre[MAXn + 10], poww[MAXn + 10];inline int hash(int l, int r) &#123; return ((hashpre[r] - hashpre[l - 1] * poww[r - l + 1]) % MOD + MOD) % MOD;&#125;char str[MAXn + 10];signed main() &#123; read(n); LS(n); scanf(&quot;%s&quot;, str + 1); for (int i = 1; i &lt;= n; ++i) &#123; hashpre[i] = (hashpre[i - 1] * BASE + str[i] - &#x27;a&#x27;) % MOD; &#125; poww[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; poww[i] = (poww[i - 1] * BASE) % MOD; &#125; read(m); for (re int i = 1; i &lt;= m; ++i) &#123; int l, r, len, ans; read(l), read(r); ans = len = r - l + 1; if (hash(l + 1, r) == hash(l, r - 1)) &#123; printf(&quot;1\\n&quot;); &#125; else &#123; while (len &gt; 1) &#123; if (hash(l + ans / minpf[len], r) == hash(l, r - ans / minpf[len])) &#123; ans /= minpf[len]; //ans: 循环节长度 &#125; //minpf: 最小质因数，循环次数 len /= minpf[len]; //len: 无实际意义，用于提取所有质因数 &#125; printf(&quot;%lld\\n&quot;, ans); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"整体二分解静态区间第k小","slug":"整体二分解静态区间第k小/index","date":"un22fin22","updated":"un33fin33","comments":true,"path":"2021/08/10/整体二分解静态区间第k小/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E8%A7%A3%E9%9D%99%E6%80%81%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/index/","excerpt":"","text":"P3834【模板】可持久化线段树 2（主席树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#define re registerconst int MAXn = 2e5;const int MAXm = 2e5;const int MAXai = 1e9;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int top, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x)))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= top) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int n, m, cnt, ans[MAXm + 10];struct Ele &#123; int idx, v, l, r, opt; Ele(): idx(0), v(0), l(0), r(0), opt(0) &#123;&#125; Ele(int idx_, int v_, int l_, int r_, int opt_): idx(idx_), v(v_), l(l_), r(r_), opt(opt_) &#123;&#125;&#125;a[MAXn + MAXm + 10], a1[MAXn + MAXm + 10], a2[MAXn + MAXm + 10];void Div(int L, int R, int l, int r) &#123; if (l &gt; r) return; if (L == R) &#123; for (re int i = l; i &lt;= r; ++i) &#123; if (a[i].opt) &#123; ans[a[i].idx] = L; &#125; &#125; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; int cnt1 = 0; int cnt2 = 0; for (re int i = l; i &lt;= r; ++i) &#123; if (!a[i].opt) &#123; if (a[i].v &lt;= mid) &#123; a1[++cnt1] = a[i]; Add(a[i].idx, 1); &#125; else &#123; a2[++cnt2] = a[i]; &#125; &#125; else &#123; int x = EvaSum(a[i].r) - EvaSum(a[i].l - 1); if (a[i].v &lt;= x) &#123; a1[++cnt1] = a[i]; &#125; else &#123; a[i].v -= x; a2[++cnt2] = a[i]; &#125; &#125; &#125; for (re int i = 1; i &lt;= cnt1; ++i) &#123; if (!a1[i].opt) &#123; Add(a1[i].idx, -1); &#125; &#125; for (re int i = 1; i &lt;= cnt1; ++i) &#123; a[l + i - 1] = a1[i]; &#125; for (re int i = 1; i &lt;= cnt2; ++i) &#123; a[l + cnt1 + i - 1] = a2[i]; &#125; Div(L, mid, l, l + cnt1 - 1); Div(mid + 1, R, l + cnt1, r); &#125;&#125;int main() &#123; read(n), read(m); top = n; for (re int i = 1, v; i &lt;= n; ++i) &#123; read(v); a[++cnt] = Ele(i, v, 0, 0, 0); &#125; for (re int i = 1, l, r, k; i &lt;= m; ++i) &#123; read(l), read(r), read(k); a[++cnt] = Ele(i, k, l, r, 1); &#125; Div(-MAXai, MAXai, 1, cnt); for (re int i = 1; i &lt;= m; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最长上升子序列(lis)","slug":"最长上升子序列(lis)/index","date":"un22fin22","updated":"un11fin11","comments":true,"path":"2021/08/10/最长上升子序列(lis)/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(lis)/index/","excerpt":"","text":"本解法时间复杂度O(nlogn)O(nlogn)O(nlogn)，还有一种 DP 的 O(n2)O(n^2)O(n2) 的求法，感兴趣的可以上网了解一下 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, s[MAXn + 10], cnt;int main() &#123; read(n); for (re int i = 1, a; i &lt;= n; ++i) &#123; read(a); if (a &gt; s[cnt]) &#123; s[++cnt] = a; &#125; else &#123; *lower_bound(s + 1, s + 1 + cnt, a) = a; &#125; &#125; printf(&quot;%d\\n&quot;, cnt);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"错排问题","slug":"错排问题/index","date":"un22fin22","updated":"un33fin33","comments":true,"path":"2021/08/10/错排问题/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/10/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/index/","excerpt":"","text":"P1595 信封问题 1234567891011121314#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 20;int n, a[MAXn + 10];signed main() &#123; a[1] = 0; a[2] = 1; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 3; i &lt;= n; ++i) &#123; a[i] = (i - 1) * (a[i - 2] + a[i - 1]); &#125; printf(&quot;%lld\\n&quot;, a[n]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Ac自动机","slug":"Ac自动机/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/Ac自动机/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Ac%E8%87%AA%E5%8A%A8%E6%9C%BA/index/","excerpt":"","text":"P3808 【模板】AC自动机（简单版） P3796 【模板】AC自动机（加强版） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXtxtlen = 1e6;const int MAXwrdlen = 70;const int MAXwrdcnt = 150;const int MAXnd = 1e6;int cntnd, son[MAXnd + 10][26], mat[MAXnd + 10];char txt[MAXtxtlen + 10], wrd[MAXwrdcnt + 10][MAXwrdlen + 10];int ltxt, lwrd;int fail[MAXnd + 10], ndidx[MAXwrdcnt + 10];int n;queue&lt;int&gt; q;void clear(queue&lt;int&gt; &amp;q) &#123; queue&lt;int&gt; empty; swap(q, empty);&#125;void Init() &#123; cntnd = ltxt = lwrd = n = 0; memset(son, 0, sizeof(son)); memset(mat, 0, sizeof(mat)); memset(txt, 0, sizeof(txt)); memset(wrd, 0, sizeof(wrd)); memset(fail, 0, sizeof(fail)); memset(ndidx, 0, sizeof(ndidx)); memset(mat, 0, sizeof(mat)); clear(q);&#125;void Insert(char *wrd, int wrdidx) &#123; int cur = 0; for (re int i = 1; i &lt;= lwrd; ++i) &#123; if (son[cur][wrd[i] - 97]) &#123; cur = son[cur][wrd[i] - 97]; &#125; else &#123; cur = son[cur][wrd[i] - 97] = ++cntnd; &#125; &#125; ndidx[wrdidx] = cur;&#125;void GetFail() &#123; for (re int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int cur = q.front(); q.pop(); for (re int i = 0; i &lt; 26; ++i) &#123; if (son[cur][i]) &#123; fail[son[cur][i]] = son[fail[cur]][i]; q.push(son[cur][i]); &#125; else &#123; son[cur][i] = son[fail[cur]][i]; &#125; &#125; &#125;&#125;void Work() &#123; int cur = 0; for (re int i = 1; i &lt;= ltxt; ++i) &#123; cur = son[cur][txt[i] - 97]; int x = cur; while (x) &#123; ++mat[x]; x = fail[x]; &#125; &#125;&#125;int main() &#123; while (true) &#123; Init(); scanf(&quot;%d&quot;, &amp;n); if (!n) break; for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, wrd[i] + 1); lwrd = strlen(wrd[i] + 1); Insert(wrd[i], i); &#125; GetFail(); scanf(&quot;%s&quot;, txt + 1); ltxt = strlen(txt + 1); Work(); int mx = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mat[ndidx[i]] &gt; mx) &#123; mx = mat[ndidx[i]]; &#125; &#125; printf(&quot;%d\\n&quot;, mx); for (re int i = 1; i &lt;= n; ++i) &#123; if (mat[ndidx[i]] == mx) &#123; printf(&quot;%s\\n&quot;, wrd[i] + 1); &#125; &#125; &#125; &#125; 每个字符串只算一次的 Work 函数。 12345678910111213int Work() &#123; int j = 0, ans = 0; for (re int i = 1; i &lt;= ltxt; ++i) &#123; j = son[j][txt[i] - 97]; int k = j; while (cnt[k] &amp;&amp; k) &#123; ans += cnt[k]; cnt[k] = 0; k = fail[k]; &#125; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Luogu CF727C Guess the Array","slug":"Guess the Array/index","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2021/07/21/Guess the Array/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Guess%20the%20Array/index/","excerpt":"","text":"CF727C Guess the Array 注：本文含交互题 endl 与 fflush 不同种类的配合使用效果的 测试（见 “四”） 一. 审题： 1. 前提条件： 一个数 nnn 代表数组中数的个数。 2. 询问 &amp; 输入： 询问： 输出两个数 xxx，yyy 。代表询问 axa_xax​ 和 aya_yay​ 的和。 格式：? x y 输入： 读入一个数代表这两个数的和。 3. 输出： 数组中所有数的值。格式：! a[1] a[2] a[3] ... a[n] 二. 思路 1. 思考解法 我们可以不一口气把 nnn 次都询问完（当然最后肯定是都要询问完的），既然 nnn 个数询问 nnn 次一定有解，那么我们可以先询问 a1+a2a_1+a_2a1​+a2​ ， a2+a3a_2+a_3a2​+a3​ 以及 a3+a1a_3+a_1a3​+a1​ 。这样就能先计算出 a1a_1a1​，a2a_2a2​ 以及 a3a_3a3​。 只要有了一个数的具体值，我们每询问一次就可以算出一个数的具体值，这样一气呵成，避免了一口气询问完后堆积过多条件无从下手的情况。 2. 具体实现 前三个数： 解法有很多，如 {x+y=ay+z=bz+x=c\\ \\ \\ \\ \\begin{cases}x+y=a\\\\y+z=b\\\\z+x=c\\end{cases} ⎩⎨⎧​x+y=ay+z=bz+x=c​ ⟹2x+2y+2z=a+b+c\\Longrightarrow 2x+2y+2z=a+b+c ⟹2x+2y+2z=a+b+c ⟹x+y+z=a+b+c2\\Longrightarrow x+y+z=\\dfrac{a+b+c}{2} ⟹x+y+z=2a+b+c​ ⟹x=a+b+c2−b\\Longrightarrow x=\\dfrac{a+b+c}{2}-b ⟹x=2a+b+c​−b yyy，zzz 同理。 剩下的数： 接下来询问a1+a4a_1+a_4a1​+a4​，a1+a5a_1+a_5a1​+a5​ . . . a1+ana_1+a_na1​+an​。 三. 代码 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5000;int n;int add12,add13,add23; //addxy:第x个和第y个数的和int add[MAXn + 10]; //add[x]:第1个和第x个数的和int first; //第一个数的值int main() &#123; scanf(&quot;%d&quot;, &amp;n); cout &lt;&lt; &quot;? 1 2&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add12); cout &lt;&lt; &quot;? 2 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add23); cout &lt;&lt; &quot;? 1 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add13);//这里用了endl就不需要fflush(stdout)了 first = (add13 - add23 + add12) &gt;&gt; 1;//读入前三个数间两两值得和，并计算第一个数 for (int i = 4 ; i &lt;= n; ++i) &#123; cout &lt;&lt; &quot;? 1 &quot; &lt;&lt; i &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add[i]); &#125;//读入第1个数和第4-n个数间两两的值 cout &lt;&lt; &quot;! &quot; &lt;&lt; first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add12 - first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add23 - add12 + first; fflush(stdout); for(int i = 4; i &lt;= n; ++i) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; add[i] - first; &#125;&#125; 四. endl 与 fflush 对交互题来说，弄清楚 endl 和 fflush 怎么用格外重要。不多废话了，直接摆上测试结果： 结论：endl 后面 不用跟 fflush，但如果没有 endl （或是用 printf）要加上 fflush(stdout)。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Manacher","slug":"Manacher/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/Manacher/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Manacher/index/","excerpt":"","text":"P3805 【模板】manacher 算法 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e7 + 1e6;char str[MAXn * 2 + 10];int n, cntch;int rad[MAXn * 2 + 10];void Evarad() &#123; for (re int i = 0, l = 0, r = -1; i &lt;= cntch; ++i) &#123; rad[i] = (i &gt; r) ? 0 : min(rad[l + r - i], r - i); while (i - rad[i] &gt; 0 &amp;&amp; i + rad[i] &lt; cntch &amp;&amp; str[i - rad[i] - 1] == str[i + rad[i] + 1]) &#123; ++rad[i]; &#125; if (i + rad[i] &gt; r) &#123; r = i + rad[i]; l = i - rad[i]; &#125; &#125;&#125;int main() &#123; str[0] = &#x27;#&#x27;; char ch; while (true) &#123; ch = getchar(); if (ch &lt; &#x27;a&#x27; || ch &gt; &#x27;z&#x27;) break; str[++cntch] = ch; str[++cntch] = &#x27;#&#x27;; &#125; Evarad(); int ans = 0; for (re int i = 0; i &lt;= cntch; ++i) &#123; if (i % 2) &#123; ans = max(ans, 2 * (rad[i] / 2) + 1); &#125; else &#123; ans = max(ans, 2 * (rad[i] / 2)); &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Splay","slug":"Splay/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/07/21/Splay/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Splay/index/","excerpt":"","text":"P3369 【模板】普通平衡树 P3391 【模板】文艺平衡树 函数汇总： check(id)check(id)check(id) pushup(id)pushup(id)pushup(id) rotate(id)rotate(id)rotate(id) splay(id,goal)splay(id, goal)splay(id,goal) find(v)find(v)find(v) EvaPre(v)EvaPre(v)EvaPre(v) EvaNex(v)EvaNex(v)EvaNex(v) Insert(v)Insert(v)Insert(v) Delete(v)Delete(v)Delete(v) ValtoRank(v)ValtoRank(v)ValtoRank(v) RanktoVal(rank)RanktoVal(rank)RanktoVal(rank) 文艺平衡树独有的： pushdown(id)pushdown(id)pushdown(id) 带 pushdownpushdownpushdown 的 RanktoVal(rank)RanktoVal(rank)RanktoVal(rank) Reverser(rank,rank)Reverser(rank, rank)Reverser(rank,rank) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;cstdio&gt;#define re registerconst int MAXn = 1e5;const int INF = 0x3f3f3f3f;template&lt;class T&gt;inline void read(T &amp;a) &#123; register char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());register bool f = c == &#x27;-&#x27;;register T s = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -s : s;&#125;int root, cntnd;int son[MAXn + 10][2], fa[MAXn + 10], cnt[MAXn + 10], siz[MAXn + 10], val[MAXn + 10];bool check(int id) &#123; return id == son[fa[id]][1];&#125;void pushup(int id) &#123; siz[id] = siz[son[id][0]] + siz[son[id][1]] + cnt[id];&#125;void rotate(int id) &#123; int x = id, y = fa[x], z = fa[y]; bool b = check(x); int s = son[x][b ^ 1]; son[y][b] = s; fa[s] = y; son[z][check(y)] = x; fa[x] = z; son[x][b ^ 1] = y; fa[y] = x; pushup(y); pushup(x); &#125;void splay(int id, int goal = 0) &#123; while (fa[id] != goal) &#123; int y = fa[id]; if (fa[y] != goal) &#123; if (check(id) == check(y)) &#123; rotate(y); &#125; else &#123; rotate(id); &#125; &#125; rotate(id); &#125; if (!goal) &#123; root = id; &#125;&#125;void find(int v) &#123; int id = root; while (son[id][val[id] &lt; v] &amp;&amp; val[id] != v) &#123; id = son[id][val[id] &lt; v]; &#125; splay(id);&#125;int EvaPre(int v) &#123; find(v); if (val[root] &lt; v) &#123; return root; &#125; int id = son[root][0]; while (son[id][1]) &#123; id = son[id][1]; &#125; return id;&#125;int EvaNex(int v) &#123; find(v); if (val[root] &gt; v) &#123; return root; &#125; int id = son[root][1]; while (son[id][0]) &#123; id = son[id][0]; &#125; return id;&#125;void Insert(int v) &#123; int id = root, f = 0; while (val[id] != v &amp;&amp; id) &#123; f = id; id = son[id][val[id] &lt; v]; &#125; if (id) &#123; ++cnt[id]; &#125; else &#123; id = ++cntnd; if (f) &#123; son[f][v &gt; val[f]] = id; &#125; fa[id] = f; son[id][0] = son[id][1] = 0; cnt[id] = siz[id] = 1; val[id] = v; &#125; splay(id);&#125;void Delete(int v) &#123; int pre = EvaPre(v), nex = EvaNex(v); splay(pre); splay(nex, pre); int del = son[nex][0]; if (cnt[del] &gt; 1) &#123; --cnt[del]; splay(del); &#125; else &#123; son[nex][0] = 0; &#125;&#125;int ValtoRank(int v) &#123; find(v); if (val[root] &gt;= v) &#123; return siz[son[root][0]] + 1; &#125; else &#123; return siz[son[root][0]] + cnt[root] + 1; &#125;&#125;int RanktoId(int rank) &#123; int id = root; while (true) &#123; if (son[id][0] &amp;&amp; rank &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rank &gt; siz[son[id][0]] + cnt[id]) &#123; rank -= siz[son[id][0]] + cnt[id]; //两者位置不能反 id = son[id][1]; &#125; else &#123; return id; &#125; &#125;&#125;int n, opt, x;int main() &#123; read(n); Insert(INF); Insert(-INF); for (re int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: Insert(x); break; case 2: Delete(x); break; case 3: printf(&quot;%d\\n&quot;, ValtoRank(x) - 1); break; case 4: printf(&quot;%d\\n&quot;, val[RanktoId(x + 1)]); break; case 5: printf(&quot;%d\\n&quot;, val[EvaPre(x)]); break; case 6: printf(&quot;%d\\n&quot;, val[EvaNex(x)]); break; &#125; &#125;&#125; 文艺平衡树独有的： 12345678910111213141516171819202122232425262728bool rev[MAXn + 10];void pushdown(int id) &#123; if (rev[id]) &#123; swap(son[id][0], son[id][1]); rev[son[id][0]] ^= 1; rev[son[id][1]] ^= 1; rev[id] = 0; &#125;&#125;int RanktoId(int rank) &#123; int id = root; while (true) &#123; pushdown(id); //add if (son[id][0] &amp;&amp; rank &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rank &gt; siz[son[id][0]] + cnt[id]) &#123; rank -= siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; else &#123; return id; &#125; &#125;&#125;void Reverse(int l, int r) &#123; int pre = RanktoId(l - 1), nex = RanktoId(r + 1); splay(pre); splay(nex, pre); rev[son[nex][0]] ^= 1;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Treap","slug":"Treap/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/Treap/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Treap/index/","excerpt":"","text":"P3369 【模板】普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int INF = 2147483647;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());register bool f = c == &#x27;-&#x27;;register T s = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -s : s;&#125;int cntnd, val[MAXn + 10], cnt[MAXn + 10], siz[MAXn + 10], son[MAXn + 10][2], rd[MAXn + 10];void pushup(int id) &#123; siz[id] = siz[son[id][0]] + siz[son[id][1]] + cnt[id];&#125;void rotate(int &amp;id, bool b) &#123; int s = son[id][b ^ 1]; son[id][b ^ 1] = son[s][b]; son[s][b] = id; pushup(id); pushup(s); id = s;&#125;void Insert(int &amp;id, int v) &#123; if (!id) &#123; id = ++cntnd; val[cntnd] = v; cnt[cntnd] = 1; siz[cntnd] = 1; rd[cntnd] = rand(); return; &#125; if (val[id] == v) &#123; ++cnt[id]; ++siz[id]; &#125; else &#123; bool bol = val[id] &lt; v; Insert(son[id][bol], v); if (rd[son[id][bol]] &gt; rd[id]) &#123; rotate(id, bol ^ 1); &#125; pushup(id); &#125; &#125;void Delete(int &amp;id, int v) &#123; if (!id) &#123; return; &#125; if (val[id] == v) &#123; if (!son[id][0] &amp;&amp; !son[id][1]) &#123; --cnt[id]; --siz[id]; if (!siz[id]) &#123; id = 0; &#125; &#125; else if (!son[id][0] &amp;&amp; son[id][1]) &#123; rotate(id, 0); Delete(son[id][0], v); &#125; else if (son[id][0] &amp;&amp; !son[id][1]) &#123; rotate(id, 1); Delete(son[id][1], v); &#125; else &#123; bool bol = rd[son[id][0]] &gt;= rd[son[id][1]]; rotate(id, bol); Delete(son[id][bol], v); &#125; &#125; else if (val[id] &lt; v) &#123; Delete(son[id][1], v); &#125; else &#123; Delete(son[id][0], v); &#125; pushup(id);&#125;int ValtoRank(int id, int v) &#123; if (!id) &#123; return 1; &#125; if (val[id] == v) &#123; return siz[son[id][0]] + 1; &#125; else if (val[id] &lt; v) &#123; return siz[son[id][0]] + cnt[id] + ValtoRank(son[id][1], v); &#125; else &#123; return ValtoRank(son[id][0], v); &#125;&#125;int RanktoVal(int id, int rank) &#123; if (!id) &#123; return -123456789; &#125; if (rank &lt;= siz[son[id][0]]) &#123; return RanktoVal(son[id][0], rank); &#125; else if (rank &gt; siz[son[id][0]] + cnt[id]) &#123; return RanktoVal(son[id][1], rank - siz[son[id][0]] - cnt[id]); &#125; else &#123; return val[id]; &#125;&#125;int EvaPre(int id, int v) &#123; if (!id) &#123; return -INF; &#125; if (val[id] &gt;= v) &#123; return EvaPre(son[id][0], v); &#125; else &#123; return max(val[id], EvaPre(son[id][1], v)); &#125;&#125; int EvaNex(int id, int v) &#123; if (!id) &#123; return INF; &#125; if (val[id] &lt;= v) &#123; return EvaNex(son[id][1], v); &#125; else &#123; return min(val[id], EvaNex(son[id][0], v)); &#125; &#125;int root, n, opt, x;int main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: Insert(root, x); break; case 2: Delete(root, x); break; case 3: printf(&quot;%d\\n&quot;, ValtoRank(root, x)); break; case 4: printf(&quot;%d\\n&quot;, RanktoVal(root, x)); break; case 5: printf(&quot;%d\\n&quot;, EvaPre(root, x)); break; case 6: printf(&quot;%d\\n&quot;, EvaNex(root, x)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二叉搜索树","slug":"二叉搜索树/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/二叉搜索树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/index/","excerpt":"","text":"P5076 【深基16.例7】普通二叉树（简化版） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;const int INF = 2147483647;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());register bool f = c == &#x27;-&#x27;;register T s = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -s : s;&#125;struct Node &#123; int l, r, siz, cnt, val;&#125;;Node nd[MAXn + 10];int cnt;void Insert(int id, int val) &#123; ++nd[id].siz; if (nd[id].val == val) &#123; ++nd[id].cnt; &#125; else if (nd[id].val &lt; val) &#123; if (!nd[id].r) &#123; nd[++cnt].val = val; nd[id].r = cnt; &#125; Insert(nd[id].r, val); &#125; else &#123; if (!nd[id].l) &#123; nd[++cnt].val = val; nd[id].l = cnt; &#125; Insert(nd[id].l, val); &#125;&#125; int ValtoRank(int id, int val) &#123; if (!id) &#123; return 1; &#125; if (nd[id].val == val) &#123; return nd[nd[id].l].siz + 1; &#125; else if (nd[id].val &lt; val) &#123; return nd[nd[id].l].siz + nd[id].cnt + ValtoRank(nd[id].r, val); &#125; else &#123; return ValtoRank(nd[id].l, val); &#125;&#125;int RanktoVal(int id, int rank) &#123; if (!id) &#123; return -123456789; &#125; if (rank &lt;= nd[nd[id].l].siz) &#123; return RanktoVal(nd[id].l, rank); &#125; else if (rank &gt; nd[nd[id].l].siz + nd[id].cnt) &#123; return RanktoVal(nd[id].r, rank - nd[nd[id].l].siz - nd[id].cnt); &#125; else &#123; return nd[id].val; &#125;&#125;int EvaPreVal(int id, int val) &#123; if (!id) &#123; return -INF; &#125; if (nd[id].val &gt;= val) &#123; return EvaPreVal(nd[id].l, val); &#125; else &#123; return max(nd[id].val, EvaPreVal(nd[id].r, val)); &#125;&#125;int EvaNexVal(int id, int val) &#123; if (!id) &#123; return INF; &#125; if (nd[id].val &lt;= val) &#123; return EvaNexVal(nd[id].r, val); &#125; else &#123; return min(nd[id].val, EvaNexVal(nd[id].l, val)); &#125;&#125;int root = 1, n, opt, x;int main() &#123; read(n); nd[1].cnt = 1; nd[1].l = 2; nd[1].siz = 2; nd[1].val = INF; nd[2].cnt = 1; nd[2].siz = 1; nd[2].val = -INF; cnt += 2; for (re int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: printf(&quot;%d\\n&quot;, ValtoRank(root, x) - 1); break; case 2: printf(&quot;%d\\n&quot;, RanktoVal(root, x + 1)); break; case 3: printf(&quot;%d\\n&quot;, EvaPreVal(root, x)); break; case 4: printf(&quot;%d\\n&quot;, EvaNexVal(root, x)); break; case 5: Insert(root, x); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"割点 & 点双连通分量","slug":"割点 & 点双连通分量/index","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2021/07/21/割点 & 点双连通分量/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%89%B2%E7%82%B9%20&%20%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/index/","excerpt":"","text":"P3388 【模板】割点（割顶） 123456789101112131415161718192021222324252627282930313233int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXnd + 10&gt; iscut;void Tarjan(int cur, int root) &#123; dfs[cur] = low[cur] = ++cntdfs; int times = 0; bool havcnt = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], root); low[cur] = min(low[cur], low[to[i]]); if (!havcnt) &#123; if (low[to[i]] &gt;= dfs[cur]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; havcnt = 1; ++cntcut; iscut[cur] = 1; &#125; &#125; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, i); &#125; &#125;&#125; T103492 【模板】点双连通分量 12345678910111213141516171819202122232425262728293031323334353637int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntdcc; vector&lt;int&gt; dcc[MAXnd + 10];int top, stk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; dcc[++cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt;= dfs[cur]) &#123; ++cntdcc; int x; do &#123; x = stk[top--]; dcc[cntdcc].push_back(x); &#125; while (x != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"割边 & 边双连通分量","slug":"割边 & 边双连通分量/index","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2021/07/21/割边 & 边双连通分量/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%89%B2%E8%BE%B9%20&%20%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/index/","excerpt":"","text":"T103481 【模板】割边 123456789101112131415161718192021222324252627int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125;&#125; T103489 【模板】边双连通分量 1234567891011121314151617181920212223242526272829303132333435363738394041int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;int cntdcc, indcc[MAXnd + 10];void EvaDcc(int cur) &#123; indcc[cur] = cntdcc; for (int i = head[cur]; i; i = nex[i]) &#123; if (indcc[to[i]] || iscut[i]) continue; EvaDcc(to[i]); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!indcc[i]) &#123; ++cntdcc; EvaDcc(i); &#125; &#125;&#125; 如果只让输出边双的个数，桥数+不连通的图数也是正确答案。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"卢卡斯定理","slug":"卢卡斯定理/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/07/21/卢卡斯定理/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/index/","excerpt":"","text":"P3807 【模板】卢卡斯定理/Lucas 定理 C⁡nmmod⁡p=C⁡n/pm/p×C⁡nmod⁡pmmod⁡pmod⁡p\\operatorname{C}^m_n\\operatorname{mod}p=\\operatorname{C}^{m/p}_{n/p}\\times \\operatorname{C}^{m\\operatorname{mod}p}_{n \\operatorname{mod}p}\\operatorname{mod}pCnm​modp=Cn/pm/p​×Cnmodpmmodp​modp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#define re registertypedef long long ll;const int MAXC = 1e5 + 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int x, int p) &#123; int ans, k; exgcd(x, p, ans, k); return (ans % p + p) % p;&#125;int fac[MAXC + 10];void EvaFac(int top, int p) &#123; fac[0] = 1; for (re int i = 1; i &lt;= top; ++i) &#123; fac[i] = ((ll)fac[i - 1] * i) % p; &#125;&#125;int C(int n, int m, int p) &#123; if (n &lt; m) return 0; return (ll)fac[n] * inv(fac[m], p) % p * inv(fac[n - m], p) % p;&#125;int Lucas(int n, int m, int p) &#123; if (!m) return 1; return (ll)Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;&#125;int T, n, m, p;int main() &#123; read(T); while (T--) &#123; read(n), read(m), read(p); EvaFac(MAXC, p); n += m; m = n - m; printf(&quot;%d\\n&quot;, Lucas(n, m, p)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"康托展开","slug":"康托展开/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/康托展开/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/index/","excerpt":"","text":"P5367 【模板】康托展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt; #define re register#define int long longconst int MAXn = 1e6;const int MOD = 998244353;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, trector[MAXn + 10], sum[MAXn + 10];#define lowbit(x) (x&amp;(-x))void Build() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; trector[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int k) &#123; while (p &lt;= n) &#123; trector[p] += k; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int sum = 0; while (p &gt; 0) &#123; sum += trector[p]; p -= lowbit(p); &#125; return sum;&#125;int fac[MAXn + 10];void Evafac() &#123; fac[1] = 1; for (re int i = 2; i &lt;= n; ++i) &#123; fac[i] = fac[i - 1] * i; fac[i] %= MOD; &#125;&#125;int arr[MAXn + 10];int Cantor() &#123; int ans = 0; for (re int i = n, sum; i; --i) &#123; sum = EvaSum(arr[i] - 1); ans += sum * fac[i - 1]; ans %= MOD; Add(arr[i], -1); &#125; return ans % MOD;&#125;signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; sum[i] = sum[i - 1] + 1; &#125; Build(); Evafac(); for (re int i = 1; i &lt;= n; ++i) &#123; read(arr[n - i + 1]); &#125; printf(&quot;%lld\\n&quot;, Cantor() + 1);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"强连通分量","slug":"强连通分量/index","date":"un33fin33","updated":"un55fin55","comments":true,"path":"2021/07/21/强连通分量/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/index/","excerpt":"","text":"B3609 [图论与代数结构 701] 强连通分量 1234567891011121314151617181920212223242526272829303132int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntscc; vector&lt;int&gt; scc[MAXnd + 10];int top, stk[MAXnd + 10]; bool instk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]] &amp;&amp; instk[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; scc[cntscc].push_back(x); &#125; while (x != cur); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125; 缩点： 12345for (int i = 1; i &lt;= m; ++i) &#123; if (inscc[from1[i]] != inscc[to1[i]]) &#123; Insert2(inscc[from1[i]], inscc[to1[i]]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"快读","slug":"快读/index","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/07/21/快读/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%BF%AB%E8%AF%BB/index/","excerpt":"","text":"上面的只能读非负数，下面的能读负数 12345678template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125; 12345678template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"最近公共祖先(lca)","slug":"最近公共祖先(lca)/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/最近公共祖先(lca)/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(lca)/index/","excerpt":"","text":"P3379 【模板】最近公共祖先（LCA） 1. 倍增 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 500000;const int MAXlogdep = 19;const int MAXm = MAXn - 1;int anc[MAXn + 10][MAXlogdep + 10], dep[MAXn + 10], n, q, s;int head[MAXn + 10], next[MAXm * 2 + 10], toid[MAXm * 2 + 10], nown;int lg2[MAXn + 10];void Insert(int from, int to) &#123; next[++nown] = head[from]; head[from] = nown; toid[nown] = to;&#125;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;; &#125; return x;&#125;void Dfs(int nodeid, int fa) &#123; anc[nodeid][0] = fa; for (int i = 1; i &lt;= MAXlogdep; ++i) &#123; anc[nodeid][i] = anc[anc[nodeid][i - 1]][i - 1]; &#125; dep[nodeid] = dep[fa] + 1; for (int i = head[nodeid]; i; i = next[i]) &#123; if (toid[i] != fa) &#123; Dfs(toid[i], nodeid); &#125; &#125;&#125;void Init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; lg2[i] = lg2[i - 1] + (1 &lt;&lt; lg2[i - 1] == i); &#125; for (int i = 0; i &lt;= n; ++i) &#123; lg2[i]--; &#125;&#125;int Lca(int x, int y) &#123; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; while (dep[x] &lt; dep[y]) &#123; y = anc[y][lg2[dep[y] - dep[x]]]; &#125; if (x == y) &#123; return y; &#125; for (int i = lg2[dep[y]]; i &gt;= 0; --i) &#123; if (anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main() &#123; n = read(); q = read(); s = read(); Init(); int x, y; for (int i = 1; i &lt; n; ++i) &#123; x = read(); y = read(); Insert(x, y); Insert(y, x); &#125; Dfs(s, 0); for (int i = 0; i &lt; q; ++i) &#123; x = read(); y = read(); printf(&quot;%d\\n&quot;, Lca(x, y)); &#125; return 0;&#125; 2. 树剖 12345678910int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; x = fa[top[x]]; &#125; else &#123; y = fa[top[y]]; &#125; &#125; return dep[x] &gt; dep[y] ? y : x;&#125; 3. 离线Tarjan 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e5;const int MAXm = MAXn;const int MAXq = 5e5;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int headq[MAXn + 10], cntnexq, nexq[MAXq + 10], q[MAXq + 10];void Insertq(int u, int v) &#123; nexq[++cntnexq] = headq[u]; headq[u] = cntnexq; q[cntnexq] = v;&#125;int fa[MAXn + 10]; bool vis[MAXn + 10];void Dfs1(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; fa[to[i]] = cur; Dfs1(to[i]); &#125;&#125;int times[MAXn + 10], ans[MAXq + 10];void Dfs2(int cur) &#123; ++times[cur]; for (re int i = headq[cur]; i; i = nexq[i]) &#123; int id = q[i]; while (times[id] != 1) &#123; id = fa[id]; &#125; ans[i] = id; &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (times[to[i]]) continue; Dfs2(to[i]); &#125; ++times[cur];&#125;int n, Q, root, qid_nexq[MAXq + 10];int main() &#123; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;Q, &amp;root); for (re int i = 1, u, v; i &lt; n; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); for (re int i = 1, u, v; i &lt;= Q; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insertq(u, v); qid_nexq[i] = cntnexq; &#125; Dfs2(root); for (re int i = 1; i &lt;= Q; ++i) &#123; printf(&quot;%d\\n&quot;, ans[qid_nexq[i]]); &#125;&#125; 4. 欧拉序 请见 一位dalao的博客。（我懒得写了）","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树的直径","slug":"树的直径/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/树的直径/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/index/","excerpt":"","text":"U81904 【模板】树的直径 1. 两次Dfs 注意：该方法无法解决负权树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerusing namespace std;const int MAXn = 5e5;const int MAXm = MAXn;const int FINF = 0xc0c0c0c0;int n;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10];void Dfs(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; dis[to[i]] = dis[cur] + wei[i]; Dfs(to[i]); &#125;&#125;int EvaFar(int root) &#123; memset(dis, 0xc0, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[root] = 0; Dfs(root); int mx = FINF, maxer = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mx &lt; dis[i]) &#123; mx = dis[i]; maxer = i; &#125; &#125; return maxer;&#125;int side1, side2;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1, u, v, w; i &lt; n; ++i) &#123; scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); Insert(u, v, w); Insert(v, u, w); &#125; side1 = EvaFar(1); side2 = EvaFar(side1); printf(&quot;%d %d\\n&quot;, side1, side2); printf(&quot;%d\\n&quot;, dis[side2]);&#125; 2. 树形Dp 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 5e5;const int MAXm = MAXn;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;bool vis[MAXn + 10]; int d[MAXn + 10], n, ans;// d[i]: 节点d到所有节点最长路径长度路径void Dfs(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; Dfs(to[i]); ans = max(ans, d[cur] + d[to[i]] + wei[i]); // 虽然d[i]为最长路径长度，但这里的d[i]还没有更新好，只是更新到了的中的最长。 d[cur] = max(d[cur], d[to[i]] + wei[i]); &#125;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1, u, v, w; i &lt; n; ++i) &#123; scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树状数组","slug":"树状数组/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/树状数组/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/index/","excerpt":"","text":"P3374 【模板】树状数组 1 P3368 【模板】树状数组 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 5e5;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int n, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= n) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int a[MAXn + 10], m;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseSum(a); for (re int i = 1, opt, x, y, k; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(k); Add(x, k); Add(y + 1, -k); break; case 2: read(x); printf(&quot;%lld\\n&quot;, EvaSum(x)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树的重心","slug":"树的重心/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/07/21/树的重心/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/index/","excerpt":"","text":"1234567891011121314151617181920212223242526int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n;bool vis[MAXn + 10]; int siz[MAXn + 10], w[MAXn + 10], cen[2];void GetCen(int cur) &#123; vis[cur] = 1; siz[cur] = 1; w[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; GetCen(to[i]); siz[cur] += siz[to[i]]; w[cur] = max(w[cur], siz[to[i]]); &#125; w[cur] = max(w[cur], n - siz[cur]); if (w[cur] &lt;= n / 2) &#123; cen[cen[0] != 0] = cur; &#125;&#125;GetCen(1);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"树链剖分","slug":"树链剖分/index","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2021/07/21/树链剖分/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/index/","excerpt":"","text":"P3384 【模板】轻重链剖分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, k, root, mod;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10], add[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[id &lt;&lt; 1] + sum[(id &lt;&lt; 1) + 1];&#125;inline void pushdown(int id) &#123; sum[id &lt;&lt; 1] += add[id] * (ri[id &lt;&lt; 1] - le[id &lt;&lt; 1] + 1); sum[(id &lt;&lt; 1) + 1] += add[id] * (ri[(id &lt;&lt; 1) + 1] - le[(id &lt;&lt; 1) + 1] + 1); add[id &lt;&lt; 1] += add[id]; add[(id &lt;&lt; 1) + 1] += add[id]; add[id] = 0;&#125;void BuildUseArray(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArray(id &lt;&lt; 1, l, mid, a); BuildUseArray((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int w) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] += w * (ri[id] - le[id] + 1); add[id] += w; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(id &lt;&lt; 1, l, r, w); if (r &gt; mid) Add((id &lt;&lt; 1) + 1, l, r, w); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; int ans = 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; ans += sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) ans += Eva(id &lt;&lt; 1, l, r); if (r &gt; mid) ans += Eva((id &lt;&lt; 1) + 1, l, r); &#125; return ans;&#125;int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125; bottom[cur] = idxdfs[cntdfs];&#125;void TreePathAdd(int x, int y, int w) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; Add(1, nddfs[top[y]], nddfs[y], w); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; Add(1, nddfs[x], nddfs[y], w);&#125;int TreePathEva(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; ans += Eva(1, nddfs[top[y]], nddfs[y]); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; ans += Eva(1, nddfs[x], nddfs[y]); return ans;&#125;void SonTreeAdd(int x, int w) &#123; Add(1, nddfs[x], nddfs[bottom[x]], w);&#125;int SonTreeEva(int x) &#123; return Eva(1, nddfs[x], nddfs[bottom[x]]);&#125;int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; y = fa[top[y]]; &#125; return dep[x] &gt; dep[y] ? y : x;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];signed main() &#123; read(n), read(k), read(root), read(mod); for (re int i = 1; i &lt;= n; ++i) &#123; read(ndwei[i]); &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArray(1, 1, n, idxwei); for (re int i = 1, opt, x, y, w; i &lt;= k; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(w); TreePathAdd(x, y, w); break; case 2: read(x), read(y); printf(&quot;%lld\\n&quot;, TreePathEva(x, y) % mod); break; case 3: read(x), read(w); SonTreeAdd(x, w); break; case 4: read(x); printf(&quot;%lld\\n&quot;, SonTreeEva(x) % mod); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"点分治","slug":"点分治/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/点分治/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%82%B9%E5%88%86%E6%B2%BB/index/","excerpt":"","text":"P3806 【模板】点分治1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;#define re registertypedef long long LL;const int MAXn = 2e5;const int MAXm = 2e5;const int MAXpathlen = 1e8;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;inline int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int cntnext, head[MAXn + 10], next[MAXm + 10], to[MAXm + 10], wei[MAXm + 10];inline void Insert(int from, int too, int w) &#123; next[++cntnext] = head[from]; head[from] = cntnext; to[cntnext] = too; wei[cntnext] = w;&#125;int root, nsontree, size[MAXn + 10], weight[MAXn + 10];bool vis[MAXn + 10]; //vis代表的是在Solve中是否访问过 void GetCore(int u, int fa) &#123; size[u] = 1; weight[u] = 0; for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(v == fa || vis[v]) &#123; continue; &#125; GetCore(v, u); size[u] += size[v]; weight[u] = max(weight[u], size[v]); &#125; weight[u] = max(weight[u], nsontree - size[u]); if(weight[u] &lt; weight[root]) &#123; root = u; &#125;&#125;int dis[MAXn + 10], cntrem, rem[MAXn + 10];void GetDis(int u, int fa) &#123; rem[++cntrem] = dis[u]; for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(v == fa || vis[v]) continue; dis[v] = dis[u] + wei[i]; GetDis(v, u); &#125; &#125;int nque;int test[MAXn + 10], q[MAXn + 10], query[MAXn + 10];bool judge[MAXpathlen + 10];void Calc(int u) &#123; int cnt = 0; for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(vis[v]) continue; cntrem = 0; dis[v] = wei[i]; GetDis(v, u); for(re int j = cntrem; j &gt; 0; --j) &#123; for(re int k = 1; k &lt;= nque; ++k)&#123; if(query[k] &gt;= rem[j])test[k] |= judge[query[k] - rem[j]]; &#125; &#125; for(re int j = cntrem; j &gt; 0; --j) &#123; judge[rem[j]] = true; q[++cnt] = rem[j]; &#125; &#125; for(re int i = 1; i &lt;= cnt; ++i) &#123; judge[q[i]] = false; &#125;&#125;void DivRule(int u) &#123; vis[u] = true; judge[0] = true; Calc(u); for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(vis[v]) continue; nsontree = size[v]; weight[root = 0] = INF; GetCore(v, 0); DivRule(root); &#125;&#125;int n;int main() &#123; read(n); read(nque); for(re int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u); read(v); read(w); Insert(u, v, w); Insert(v, u, w); &#125; for(re int i = 1; i &lt;= nque; ++i) &#123; read(query[i]); &#125; weight[root] = INF; nsontree = n; GetCore(1, 0); DivRule(root); for(re int i = 1; i &lt;= nque; ++i) &#123; if(test[i]) &#123; printf(&quot;AYE\\n&quot;); &#125; else &#123; printf(&quot;NAY\\n&quot;); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"线段树","slug":"线段树/index","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/07/21/线段树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%BA%BF%E6%AE%B5%E6%A0%91/index/","excerpt":"","text":"P3372 【模板】线段树 1 1. 无懒标记 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] = sum[id] + k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125; 2. 有懒标记 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], add[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;inline void pushdown(int id) &#123; sum[ls] = sum[ls] + add[id] * (ri[ls] - le[ls] + 1); sum[rs] = sum[rs] + add[id] * (ri[rs] - le[rs] + 1); add[ls] = add[ls] + add[id]; add[rs] = add[rs] + add[id]; add[id] = 0;&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] = sum[id] + k * (ri[id] - le[id] + 1); add[id] = add[id] + k; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"邻接表","slug":"邻接表/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/邻接表/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%82%BB%E6%8E%A5%E8%A1%A8/index/","excerpt":"","text":"12345678910#include&lt;cstdio&gt;const int MAXn = 1e4;const int MAXm = 1e4 * 2;//无向图MAXM应开边数二倍int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"锁机","slug":"锁机/index","date":"un33fin33","updated":"un11fin11","comments":true,"path":"2021/07/21/锁机/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%94%81%E6%9C%BA/index/","excerpt":"","text":"作为一名 OIerOIerOIer，我们时时刻刻都有被 jcjcjc 的风险。这事我们需要一款简单的锁机程序来锁死保护我们的电脑： 12345678910#include&lt;windows.h&gt; #include&lt;winable.h&gt; #include&lt;time.h&gt;int main() &#123; FreeConsole(); while(1) &#123; if (clock() &gt; 10000) break; BlockInput(1); &#125; &#125; 比如这就是一个 101010 秒钟的锁机 ，clock() 函数的单位是 msmsms。 如果无效试试用管理员身份运行。 小心别多数了个 000。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"Exgcd求逆元","slug":"Exgcd求逆元/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/Exgcd求逆元/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/Exgcd%E6%B1%82%E9%80%86%E5%85%83/index/","excerpt":"","text":"P3811 【模板】乘法逆元 此题不是求单个逆元的模板题，但可以用这道模板题检验这种求逆方法的正确性（没有WA） 123456789101112131415int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"01背包","slug":"01背包/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/01背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/01%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P1048 [NOIP2005 普及组] 采药 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;LL n, W;LL d[MAXW + 10];inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = W; i &gt;= w; i--) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Gcd Lcm","slug":"Gcd Lcm/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/Gcd Lcm/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/Gcd%20Lcm/index/","excerpt":"","text":"P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题 1. 最大公约数(gcd) 辗转相除法 123int gcd(int a, int b) return b ? gcd(b, a % b) : a;&#125; 更相减损术 带取模的 123456789101112131415int gcd(int a, int b) &#123; int twice = 1; while (a % 2 == 0 &amp;&amp; b % 2 == 0) &#123; a /= 2, b /= 2; twice *= 2; &#125; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return twice * a;&#125; 不带取模的 12345678910int gcd(int a, int b) &#123; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return a;&#125; 2. 最小公倍数 123int lcm(int a, int b) &#123; return a / gcd(a, b) * b; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"中国剩余定理(crt)","slug":"中国剩余定理(crt)/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/中国剩余定理(crt)/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86(crt)/index/","excerpt":"","text":"P1495 【模板】中国剩余定理(CRT)/曹冲养猪 x=∑i=1nai×Mi×Mi−1(mod⁡ mi) mod⁡mx=\\sum\\limits_{i=1}^{n}a_i\\times M_i\\times M^{-1}_i(\\operatorname{mod}~m_i)~\\operatorname{mod}mx=i=1∑n​ai​×Mi​×Mi−1​(mod mi​) modm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 10;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;int n, a[MAXn + 10], m[MAXn + 10];int Crt() &#123; int ans = 0, mulm = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mulm = mulm * m[i]; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; int M = mulm / m[i]; ans = (ans + ((a[i] * M) % mulm * inv(M, m[i])) % mulm) % mulm; &#125; return ans;&#125;signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(m[i]), read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Crt());&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"二叉堆","slug":"二叉堆/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/二叉堆/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E4%BA%8C%E5%8F%89%E5%A0%86/index/","excerpt":"","text":"P3378 【模板】堆 大根堆 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; int opt; n = read(); while (n--) &#123; opt = read(); switch (opt) &#123; case 1: Insert(read()); break; case 2: printf(&quot;%d\\n&quot;, GetRoot()); break; case 3: PopRoot(); break; &#125; &#125;&#125; 小根堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &gt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &lt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &gt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; Insert(1); Insert(3); Insert(1); Insert(7); Insert(11); Insert(25); cout &lt;&lt; GetRoot() &lt;&lt; endl; PopRoot(); cout &lt;&lt; GetRoot() &lt;&lt; endl;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二维费用背包","slug":"二维费用背包/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/二维费用背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P1855 榨取kkksc03 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW1 = 200;const int MAXW2 = 200;const int INF = 0x3f3f3f3f;int n, W1, W2;int d[MAXW1 + 10][MAXW2 + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;int eva_maxV(int W1, int W2) &#123; int ans = -INF; for (int i = 0; i &lt;= W1; i++) &#123; for (int j = 0; j &lt;= W2; j++) ans = max(ans, d[i][j]); &#125; return ans;&#125;int main() &#123; n = read(); W1 = read(); W2 = read(); int v, w1, w2; for (int i = 1; i &lt;= n; i++) &#123; v = 1; w1 = read(); w2 = read(); for (int j = W1; j &gt;= w1; j--) &#123; for (int k = W2; k &gt;= w2; k--) d[j][k] = max(d[j][k], d[j - w1][k - w2] + v); &#125; &#125; cout &lt;&lt; eva_maxV(W1, W2);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"分组背包","slug":"分组背包/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/分组背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P1757 通天之分组背包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 1000;const int MAXW = 1000;int n, W;int v[MAXn + 10];int w[MAXn + 10];int team[MAXn + 10][MAXn + 10];int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void put_in() &#123; W = read(); n = read(); int teamid; for (int i = 1; i &lt;= n; i++) &#123; w[i] = read(); v[i] = read(); teamid = read(); team[teamid][++team[teamid][0]] = i; &#125;&#125;void rec(int v[], int w[], int W)&#123; for (int i = 1; i &lt;= MAXn; i++) &#123; if (team[i][0]) &#123; for (int j = W; j &gt;= 0; j--) &#123; for (int k = 1; k &lt;= team[i][0]; k++) &#123; if (j &gt;= w[team[i][k]]) d[j] = max(d[j], d[j - w[team[i][k]]] + v[team[i][k]]); &#125; &#125; &#125; &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v, w, W); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"哈希","slug":"哈希/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/哈希/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%93%88%E5%B8%8C/index/","excerpt":"","text":"123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 2333;int ans = 0, num, mo;vector&lt;int&gt; hash[MOD + 10];void insert(int a) &#123; mo = a % MOD; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == a) return; ans++; hash[mo].push_back(a);&#125;int main() &#123; int n; int a; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a), insert(a); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"埃氏筛","slug":"埃氏筛/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/埃氏筛/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%9F%83%E6%B0%8F%E7%AD%9B/index/","excerpt":"","text":"P3383 【模板】线性筛素数 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#define re register const int MAXn = 1e8;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, cntp, p[MAXn / 10 + 100];bool notp[MAXn + 10];void ES(int up) &#123; notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; if ((long long)i * i &lt;= up) for (re int j = i * i; j &lt;= up; j += i) notp[j] = 1; &#125; &#125;&#125;int main() &#123; read(n), read(m); ES(n); for (re int i = 1, q; i &lt;= m; ++i) &#123; read(q); printf(&quot;%d\\n&quot;, p[q]); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"多重背包","slug":"多重背包/index","date":"un11fin11","updated":"un44fin44","comments":true,"path":"2021/06/07/多重背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P1776 宝物筛选 1. 单调队列优化版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW = 4e4;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int le, ri; pair&lt;int, int&gt; q[MAXW + 10];inline void Init() &#123; le = 1; ri = 0;&#125;inline void Push_back(int x, int idx) &#123; while (le &lt;= ri &amp;&amp; q[ri].first &lt;= x) &#123; --ri; &#125; q[++ri] = make_pair(x, idx);&#125;inline int Front(int idx) &#123; while (le &lt;= ri &amp;&amp; q[le].second &lt; idx) &#123; ++le; &#125; return q[le].first;&#125;int n, W, d[MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, v, w, m; i &lt;= n; ++i) &#123; read(v, w, m); for (int j = 0; j &lt; w; ++j) &#123; Init(); for (int k = 0, l = j; l &lt;= W; ++k, l += w) &#123; Push_back(d[l] - k * v, k); d[l] = Front(k - m) + k * v; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, d[W]);&#125; 2. 二进制拆分版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 100;const int MAXW = 40000;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; &#125;&#125;void rec(int v[], int w[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; n = read(); W = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; v = read(); w = read(); num = read(); bin_divide(v, w, num, v_new, w_new, num_new); &#125; rec(v_new, w_new, W, num_new); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"字符串哈希","slug":"字符串哈希/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/字符串哈希/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/index/","excerpt":"","text":"P3370 【模板】字符串哈希 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1510;const int base = 261;const int MOD = 23333;int n, ans = 0;char s[MAXn];vector&lt;string&gt; hash[MOD + 2];inline void insert() &#123; int mo = 1; for (int i = 0; s[i]; i++) mo = (mo * 1ll * base + s[i]) % MOD; string s2 = s; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == s2) return; hash[mo].push_back(s2); ans++;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, &amp;s), insert(); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"完全背包","slug":"完全背包/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/完全背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P1616 疯狂的采药 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;LL n, W;LL d[MAXW + 10];int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = w; i &lt;= W; i++) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"并查集","slug":"并查集/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/并查集/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%B9%B6%E6%9F%A5%E9%9B%86/index/","excerpt":"","text":"P3367 【模板】并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 1e4;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;int n, m;int main() &#123; read(n), read(m); Init(n); for (re int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y); Merge(x, y); break; case 2: read(x), read(y); SameAnc(x, y) ? printf(&quot;Y\\n&quot;) : printf(&quot;N\\n&quot;); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"快速排序","slug":"快速排序/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/快速排序/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/index/","excerpt":"","text":"P1177 【模板】快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];void _QuickSort_(int* a, int l, int r) &#123; int i = l, j = r, f = a[(l + r) / 2]; do &#123; while (a[i] &lt; f) &#123; i++; &#125; while (a[j] &gt; f) &#123; j--; &#125; if (i &lt;= j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125; while (i &lt;= j); if (l &lt; j) &#123; _QuickSort_(a, l, j); &#125; if (i &lt; r) &#123; _QuickSort_(a, i, r); &#125;&#125;void QuickSort(int* a, int l, int r) &#123; _QuickSort_(a, l, r - 1);&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; QuickSort(a, 0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"快速幂","slug":"快速幂/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/快速幂/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E5%BF%AB%E9%80%9F%E5%B9%82/index/","excerpt":"","text":"P1226 【模板】快速幂||取余运算 12345678910111213typedef long long LL;const int MOD = 1e7 + 7;inline int power(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ((LL)ans * x) % MOD; &#125; x = ((LL)x * x) % MOD; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"扩展欧几里得定理(exgcd)","slug":"扩展欧几里得定理(exgcd)/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/扩展欧几里得定理(exgcd)/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86(exgcd)/index/","excerpt":"","text":"P1082 [NOIP2012 提高组] 同余方程 P5656 【模板】二元一次不定方程 (exgcd) 123456789101112131415161718192021#include&lt;cstdio&gt;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int a, b, d, x, y;int main() &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); d = exgcd(a, b, x, y); x *= d; x = (x % b + b) % b; printf(&quot;%d\\n&quot;, x);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"最长公共子序列(lcs)","slug":"最长公共子序列(lcs)/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/最长公共子序列(lcs)/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(lcs)/index/","excerpt":"","text":"P1439 【模板】最长公共子序列 本解法时间复杂度O(nlogn)O(nlogn)O(nlogn)，还有一种 DP 的 O(n2)O(n^2)O(n2) 的求法，感兴趣的可以上网了解一下 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;const int INF = 0x3f3f3f3f;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;int id[MAXn + 10];int mapping[MAXn + 10];int d[MAXn + 10];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) id[read()] = i; for (int i = 1; i &lt;= n; i++) mapping[i] = id[read()]; memset(d, 0x3f, sizeof(d)); int len = 0; d[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int l = 0, r = len, mid; if (mapping[i] &gt; d[len]) d[++len] = mapping[i]; else &#123; while (l &lt; r) &#123; mid = (l + r) / 2; if (d[mid] &gt; mapping[i]) r = mid; else l = mid + 1; &#125; d[l] = min(mapping[i], d[l]); &#125; &#125; cout &lt;&lt; len; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"混合背包","slug":"混合背包/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/混合背包/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85/index/","excerpt":"","text":"P1833 樱花 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 10000;const int MAXW = 1000;const int INF = 0x3f3f3f3f;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];bool is_limit[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new, bool is_limit[]) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; is_limit[num_new] = 1; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; is_limit[num_new] = 1; &#125;&#125;void put_in() &#123; W = read(); n = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; w = read(); v = read(); num = read(); if (num) bin_divide(v, w, num, v_new, w_new, num_new, is_limit); else &#123; v_new[++num_new] = v; w_new[num_new] = w; is_limit[num_new] = 0; &#125; &#125;&#125;void rec(int v[], int w[], bool is_limit[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; if (is_limit[i]) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; else &#123; for (int j = w[i]; j &lt;= W; j++) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; &#125;&#125;int eva_maxV(int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v_new, w_new, is_limit, W, num_new); cout &lt;&lt; eva_maxV(W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"笛卡尔树","slug":"笛卡尔树/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/笛卡尔树/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/index/","excerpt":"","text":"P5854 【模板】笛卡尔树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 1e7;struct Node &#123; LL p; LL ls; LL rs;&#125;;Node node[MAXn + 10];LL n;LL nowid;LL stk[MAXn + 10];LL top;inline LL read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register LL s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void insert(LL p) &#123; nowid++; node[nowid].p = p; LL newtop = top; while (newtop &amp;&amp; node[stk[newtop]].p &gt; node[nowid].p) newtop--; if (newtop) node[stk[newtop]].rs = nowid; if (newtop &lt; top) node[nowid].ls = stk[newtop + 1]; stk[++newtop] = nowid; top = newtop;&#125;int main() &#123; n = read(); LL p; for (LL i = 0; i &lt; n; i++) &#123; p = read(); insert(p);/*这里 insert 的数字的值(p)没有单调的要求， 但数字的标号(id)要求单增，若不单增要先排序*/ &#125; for (LL i = 1; i &lt;= n; i++) &#123; printf(&quot;%lld %lld %lld\\n&quot;, node[i].p, node[i].ls, node[i].rs); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线性求区间欧拉函数","slug":"线性求区间欧拉函数/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/线性求区间欧拉函数/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/index/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#define re register#define DEBUGconst int MAXn = 1e3;int minpf[MAXn + 10], cntp, prime[MAXn / 5 + 100], phi[MAXn + 10];void EvaEuler(int up) &#123; phi[1] = 1; minpf[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!minpf[i]) &#123; minpf[i] = i; prime[++cntp] = i; phi[i] = i - 1; &#125; for (re int j = 1; j &lt;= cntp &amp;&amp; i * prime[j] &lt;= up &amp;&amp; minpf[i] &gt;= prime[j]; ++j) &#123; minpf[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - 1 : prime[j]); &#125; &#125;&#125;int main() &#123; int up = 10; EvaEuler(up);#ifdef DEBUG for (re int i = 1; i &lt;= up; ++i) &#123; printf(&quot;%4d&quot;, i); &#125; printf(&quot;\\n&quot;); for (re int i = 1; i &lt;= up; ++i) &#123; printf(&quot;%4d&quot;, minpf[i]); &#125; printf(&quot;\\n&quot;); for (re int i = 1; i &lt;= up; ++i) &#123; printf(&quot;%4d&quot;, phi[i]); &#125; printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); for (re int i = 1; i &lt;= cntp; ++i) &#123; printf(&quot;%4d&quot;, prime[i]); &#125;#endif&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性求区间逆元","slug":"线性求区间逆元/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/线性求区间逆元/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E9%80%86%E5%85%83/index/","excerpt":"","text":"P3811 【模板】乘法逆元 invi=(p−⌊pi⌋)×invpmod⁡imod⁡pinv_i=(p-\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor)\\times inv_{p\\operatorname{mod}i}\\operatorname{mod}pinvi​=(p−⌊ip​⌋)×invpmodi​modp 123456void EvaSectionInvLine(int n, int mod, int inv[]) &#123; inv[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; inv[i] = (long long) (mod - mod / i) * inv[mod % i] % mod; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性筛","slug":"线性筛/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/线性筛/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E7%BA%BF%E6%80%A7%E7%AD%9B/index/","excerpt":"","text":"P3383 【模板】线性筛素数 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define re register const int MAXn = 1e8;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, cntp, p[MAXn / 10 + 100];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) p[++cntp] = i; int up2 = up / i; for (re int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; if (!(i % p[j])) break; &#125; &#125;&#125; int main() &#123; read(n), read(m); LS(n); for (re int i = 1, q; i &lt;= m; ++i) &#123; read(q); printf(&quot;%d\\n&quot;, p[q]); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"费马小定理求逆元","slug":"费马小定理求逆元/index","date":"un11fin11","updated":"un33fin33","comments":true,"path":"2021/06/07/费马小定理求逆元/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83/index/","excerpt":"","text":"P3811 【模板】乘法逆元 此题不是求单个逆元的模板题，但可以用这道模板题检验这种求逆方法的正确性（没有WA） 123456789101112131415inline int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = (1LL * ans * x) % mod; &#125; y &gt;&gt;= 1; x = (1LL * x * x) % mod; &#125; return ans;&#125;int inv(int n, int mod) &#123; return power(n, mod - 2, mod);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"高精运算","slug":"高精运算/index","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2021/06/07/高精运算/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/07/%E9%AB%98%E7%B2%BE%E8%BF%90%E7%AE%97/index/","excerpt":"","text":"实用小高精（推荐） P1601 A+B Problem（高精） P1303 A*B Problem P1480 A/B Problem (转载的) 支持负数，压位，重载运算符 不过赛场上应该没人写一遍这个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 10000;const int BIT = 4;const int MOD = 1e4;struct bign &#123; int num[maxn], len; bool flag; friend bign abs(const bign &amp;x) &#123; bign k = x; k.flag = true; return k; &#125; friend void remove(bign &amp;x) &#123; while (x.num[x.len] == 0 &amp;&amp; x.len &gt; 1)x.len--; &#125; bign() &#123; memset(num, 0, sizeof(num)); flag = true; len = 1; &#125; bign(const int &amp;x) &#123; *this = bign(); if (x) &#123; int k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const ll &amp;x) &#123; *this = bign(); if (x) &#123; ll k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const char *x) &#123; int l = strlen(x), s, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == 4) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign(const string x) &#123; int l = x.length(), s = 0, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == BIT) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign operator=(const int &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const ll &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const char *x) &#123; return *this = bign(x); &#125; bign operator=(const string &amp;x) &#123; return *this = bign(x); &#125; bool operator&lt;(const bign &amp;x) const &#123; if (flag != x.flag)return flag &lt; x.flag; if (len != x.len)return (len &lt; x.len) ^ flag ^ 1; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return (num[i] &lt; x.num[i]) ^ flag ^ 1; &#125; &#125; return false; &#125; bool operator&lt;(const int &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&lt;(const ll &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&gt;(const bign &amp;x) const &#123; return x &lt; *this; &#125; bool operator&gt;(const int &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&gt;(const ll &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&lt;=(const bign &amp;x) const &#123; return !(*this &gt; x); &#125; bool operator&lt;=(const int &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&lt;=(const ll &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&gt;=(const bign &amp;x) const &#123; return !(*this &lt; x); &#125; bool operator&gt;=(const int &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator&gt;=(const ll &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator==(const bign &amp;x) const &#123; if (flag != x.flag)return false; if (len != x.len)return false; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return false; &#125; &#125; return true; &#125; bool operator==(const int &amp;x) const &#123; return *this == bign(x); &#125; bool operator==(const ll &amp;x) const &#123; return *this == bign(x); &#125; bool operator!=(const bign &amp;x) const &#123; return !(*this == x); &#125; bool operator!=(const int &amp;x) const &#123; return *this != bign(x); &#125; bool operator!=(const ll &amp;x) const &#123; return *this != bign(x); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;x) &#123; string s; in &gt;&gt; s; x = s; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const bign &amp;x) &#123; if (x.flag == false &amp;&amp; x != 0)out &lt;&lt; &quot;-&quot;; out &lt;&lt; x.num[x.len]; for (int i = x.len - 1; i &gt;= 1; i--)printf(&quot;%0*d&quot;, BIT, x.num[i]); return out; &#125; bign operator-() const &#123; bign k = *this; k.flag ^= 1; return k; &#125; bign operator+(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len || i &lt;= x.len; i++) &#123; int p = num[i] + x.num[i] + g; k.num[++k.len] = p % MOD; g = p / MOD; &#125; return k; &#125; if (flag &amp;&amp; !x.flag)return *this - (-x); if (!flag &amp;&amp; x.flag)return x - (-*this); return -((-x) + (-*this)); &#125; bign operator+(const int &amp;x) const &#123; return *this + bign(x); &#125; bign operator+=(const bign &amp;x) &#123; return *this = *this + x; &#125; bign operator+=(const int &amp;x) &#123; return *this += bign(x); &#125; bign operator+=(const ll &amp;x) &#123; return *this += bign(x); &#125; bign operator++() &#123; return *this += 1; &#125; bign operator++(int) &#123; bign k = *this; *this += 1; return k; &#125; bign operator-(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag &amp;&amp; *this &gt;= x) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len; i++) &#123; int p = num[i] - x.num[i] + g; if (p &lt; 0)g = -1; else g = 0; k.num[++k.len] = (p % MOD + MOD) % MOD; &#125; remove(k); return k; &#125; if (flag &amp;&amp; x.flag)return -(x - *this); if (flag &amp;&amp; !x.flag)return *this + (-x); if (!flag &amp;&amp; x.flag)return -((-*this) + x); return (-x) - (-*this); &#125; bign operator-=(const bign &amp;x) &#123; *this = *this - x; return *this; &#125; bign operator-=(const int &amp;x) &#123; return *this -= bign(x); &#125; bign operator-=(const ll &amp;x) &#123; return *this -= bign(x); &#125; bign operator--() &#123; return *this -= 1; &#125; bign operator--(int) &#123; bign k = *this; *this -= 1; return k; &#125; bign operator*(const bign &amp;x) const &#123; bign k; k.flag = (flag == x.flag); k.len = len + x.len + 1; for (int i = 1; i &lt;= len; i++) &#123; for (int j = 1; j &lt;= x.len; j++) &#123; k.num[i + j - 1] += num[i] * x.num[j]; k.num[i + j] += k.num[i + j - 1] / MOD; k.num[i + j - 1] %= MOD; &#125; &#125; remove(k); return k; &#125; bign operator*(const int &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*(const ll &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*=(const bign &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const int &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const ll &amp;x) &#123; return *this = *this * x; &#125; bign operator/(const bign &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(), a = bign(); k.flag = (flag == x.flag); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x)) &#123; a -= abs(x); k.num[i]++; &#125; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/(const int &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/(const ll &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/=(const bign &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const int &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const ll &amp;x) &#123; return *this = *this / x; &#125; bign operator%(const bign &amp;x) const &#123; if (x == 0)return bign(); bign a = bign(); for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x))a -= abs(x); &#125;// if (a == 0)return a;// if (flag &amp;&amp; x.flag)return a;// if (flag &amp;&amp; !x.flag)return a + x;// if (!flag &amp;&amp; x.flag)return x - a;// return -a;//È¡Ä£ if (flag)return a; return -a; &#125; bign operator%(const int &amp;x) const &#123; return *this % bign(x); &#125; bign operator%(const ll &amp;x) const &#123; return *this % bign(x); &#125; bign operator%=(const bign &amp;x) &#123; return *this = *this % x; &#125; bign operator%=(const int &amp;x) &#123; return *this %= bign(x); &#125; bign operator%=(const ll &amp;x) &#123; return *this %= bign(x); &#125; friend bign pow(const bign &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const int &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const bign &amp;x, const int &amp;y) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans *= cnt; cnt *= cnt; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign max(const bign &amp;x, const bign &amp;y) &#123; return x &gt; y ? x : y; &#125; friend bign min(const bign &amp;x, const bign &amp;y) &#123; return x &lt; y ? x : y; &#125;&#125;;int main() &#123; bign a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; a - b &lt;&lt; endl; cout &lt;&lt; a * b &lt;&lt; endl; cout &lt;&lt; a / b &lt;&lt; endl; cout &lt;&lt; a % b &lt;&lt; endl; return 0;&#125; 你竟然看完了！","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"Kmp","slug":"Kmp/index","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2021/06/06/Kmp/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/Kmp/index/","excerpt":"","text":"P3375 【模板】KMP字符串匹配 wrd$$：$$txt$$：从 $$1$$ 开始。 $$lwrd$$：$$ltxt$$：闭区间，$$[1, l]$$。 $$sec_i$$：以 $$i$$ 为左端点的子串是单词串。 $$fail_j = k$$： 文本串 $$[1, k]$$ 的的后缀和整个文本串前缀最长公共部分的长度。 如果单词串上遍历到 $$j + 1$$ 时（还未确定单词串位置 $$j + 1$$ 是否能匹配成功），$$fail_j = k$$ 代表保证单词串 $$[1, k]$$。 一定是已匹配成功的。 也就是说应该判断 $$word_{j + 1}$$ 与 $$txt_i$$ 是否相等，而非 $$word_j$$，因为$$word_j$$ 之前已经匹配成功了。 ![](Kmp.png) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;using std::ios;using std::cin;using std::cout;const int MAXlwrd = 1e6;const int MAXltxt = 1e6;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10]; bool isbegin[MAXltxt + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;void Solve() &#123; int j = 0; for (int i = 1; i &lt;= ltxt; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != txt[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == txt[i]) ++j; if (j == lwrd) isbegin[i - lwrd + 1] = 1; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); Solve(); for (int i = 1; i &lt;= ltxt; ++i) &#123; if (isbegin[i]) &#123; cout &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; for (int i = 1; i &lt;= lwrd; ++i) &#123; cout &lt;&lt; fail[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"St表","slug":"St表/index","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2021/06/06/St表/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/St%E8%A1%A8/index/","excerpt":"","text":"P3865 【模板】ST 表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXlog2n = 17;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, a[MAXn + 10], power[MAXlog2n + 10], st[MAXn + 10][MAXlog2n + 10];double ln2;void BuildSt() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; st[i][0] = a[i]; &#125; int maxidx = log(n) / ln2; for (re int idx = 1; idx &lt;= maxidx; ++idx) &#123; for (re int l = n - power[idx] + 1; l; --l) &#123; st[l][idx] = max(st[l][idx - 1], st[l + power[idx - 1]][idx - 1]); &#125; &#125;&#125;int EvaMax(int l, int r) &#123; int idx = log(r - l + 1) / ln2; return max(st[l][idx], st[r - power[idx] + 1][idx]);&#125;int m;int main() &#123; ln2 = log(2); power[0] = 1; for (re int i = 1; i &lt;= MAXlog2n; ++i) &#123; power[i] = power[i - 1] &lt;&lt; 1; &#125; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildSt(); for (re int i = 1, l, r; i &lt;= m; ++i) &#123; read(l), read(r); printf(&quot;%d\\n&quot;, EvaMax(l, r)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"堆排序","slug":"堆排序/index","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2021/06/06/堆排序/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/%E5%A0%86%E6%8E%92%E5%BA%8F/index/","excerpt":"","text":"P1177 【模板】快速排序 可以用快排的板测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int heap[MAXn+10];int heapn;int n;void up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void insert(int x) &#123; heap[++heapn] = x; up(heapn);&#125;void pop(int p) &#123; heap[p] = heap[heapn--]; up(p); down(p);&#125;void pop_root() &#123; heap[1] = heap[heapn--]; down(1);&#125;int get_root() &#123; return heap[1];&#125;int main()&#123; n = read(); for(int i = 0; i &lt; n; i++) &#123; insert(read()); &#125; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, get_root()); pop_root(); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"归并排序","slug":"归并排序/index","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2021/06/06/归并排序/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index/","excerpt":"","text":"P1177 【模板】快速排序 可以用快排的板测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x=x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];int tmp[MAXn + 10];void merge(int l, int r) &#123; if (r - l &lt;= 1) &#123; return; &#125; int mid = l + (r - l &gt;&gt; 1); merge(l, mid); merge(mid, r); int p = l, q = mid, s = l; while (s &lt; r) &#123; if (p &gt;= mid || (q &lt; r &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = l; i &lt; r; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"归并法求逆序对数","slug":"归并法求逆序对数/index","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2021/06/06/归并法求逆序对数/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/%E5%BD%92%E5%B9%B6%E6%B3%95%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/index/","excerpt":"","text":"P1908 逆序对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Inverted Sequence Numbers//different from only Merge Sort:&quot;//Diff&quot; #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn=500000;inline int read()&#123; register char c; while(c=getchar(),c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;); register int x(c-&#x27;0&#x27;); while(c=getchar(),c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123; x=x*10+c-&#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn+10];int tmp[MAXn+10];long long ans;//Diffvoid merge(int ll, int rr) &#123; if (rr - ll &lt;= 1) &#123; return; &#125; int mid = ll + (rr - ll &gt;&gt; 1); merge(ll, mid); merge(mid, rr); int p = ll, q = mid, s = ll; while (s &lt; rr) &#123; if (p &gt;= mid || (q &lt; rr &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; ans += mid - p;//Diff &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = ll; i &lt; rr; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); printf(&quot;%lld&quot;, ans);//Diff&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"树形dp","slug":"树形dp/index","date":"un00fin00","updated":"un11fin11","comments":true,"path":"2021/06/06/树形dp/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/%E6%A0%91%E5%BD%A2dp/index/","excerpt":"","text":"P1352 没有上司的舞会 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 6000;const int NEGINF = 0xc0c0c0c0;int n;int d[MAXn + 10][2];int v[MAXn + 10];int edgenum;int head[MAXn + 10];int next[MAXn + 10];int to[MAXn + 10];inline int read()&#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void first()&#123; memset(d, 0xc0c0, sizeof(d));&#125;void insert_edge(int from, int too)&#123; next[++edgenum] = head[from]; head[from] = edgenum; to[edgenum] = too;&#125;void put_in()&#123; n = read(); for (int i = 1; i &lt;= n; i++) v[i] = read(); for (int i = 1; i &lt; n; i++)&#123; int to = read(); int from = read(); insert_edge(from, to); &#125;&#125;int dp(int nodeid, bool have_root)&#123; if (d[nodeid][have_root] != NEGINF) return d[nodeid][have_root]; int&amp; ans = d[nodeid][have_root] = 0; if (!have_root) for (int i = head[nodeid]; i; i = next[i]) ans += max(dp(to[i], 0), dp(to[i], 1)); else&#123; ans += v[nodeid]; for (int i = head[nodeid]; i; i = next[i]) ans += dp(to[i], 0); &#125; return ans;&#125;int find_root()&#123; bool have_in_deg[MAXn + 10] = &#123; 0 &#125;; for (int i = 1; i &lt;= edgenum; i++) have_in_deg[to[i]] = 1; for (int i = 1; i &lt;= n; i++) if (!have_in_deg[i]) return i;&#125;int main()&#123; first(); put_in(); int rootid = find_root(); cout &lt;&lt; max(dp(rootid, 0), dp(rootid, 1)) &lt;&lt; endl;&#125; P2015 二叉苹果树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100;const int MAXq = 100;const int INF = 0x3f3f3f3f;int n, q;int d[MAXn + 10][MAXq + 10];int to[MAXn + 10][2];//ÏÂ±ê1ÎªfromµÄidint edgew[MAXn + 10][2];//ÏÂ±ê1ÎªfromµÄidinline int read()&#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;void Init()&#123; memset(d, -1, sizeof(d));&#125;void insert_edge(int nodeid1, int nodeid2, int edge_w)&#123; if (!to[nodeid1][0])&#123; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; &#125;else&#123; to[nodeid1][1] = nodeid2; edgew[nodeid1][1] = edge_w; &#125;&#125;int dp(int nodeid, int keepnum)&#123; if (d[nodeid][keepnum] != -1) return d[nodeid][keepnum]; int&amp; ans = d[nodeid][keepnum] = 0; if (!keepnum) return ans = 0; if (!to[nodeid][0]) return ans = -INF; for (int knuml = 0; knuml &lt;= keepnum; knuml++)&#123; int knumr = keepnum - knuml; int tmp_ans = 0; if (knuml) tmp_ans += edgew[nodeid][0] + dp(to[nodeid][0], knuml - 1); if (knumr) tmp_ans += edgew[nodeid][1] + dp(to[nodeid][1], knumr - 1); ans = max(ans, tmp_ans); &#125; return ans;&#125;int main()&#123; Init(); n = read(); q = read(); for (int i = 1; i &lt; n; i++)&#123; int nodeid1 = read(); int nodeid2 = read(); int edgew = read(); insert_edge(nodeid1, nodeid2, edgew); &#125; cout &lt;&lt; dp(1, q);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"高斯消元","slug":"高斯消元/index","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2021/06/06/高斯消元/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/06/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/index/","excerpt":"","text":"P2455 [SDOI2006]线性方程组 高斯消元的模板我推荐这一道，而不是 Luogu P3389。原因是 P3389 数据确实太水了。我在 P3389 上 AC 的代码在 P2455 只有 20pts。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 50;int n;double a[MAXn + 10][MAXn + 1 + 10];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n + 1; ++j) &#123; scanf(&quot;%lf&quot;, &amp;a[i][j]); &#125; &#125; int row = 1; for (re int col = 1; col &lt;= n; ++col) &#123; int maxer = row; for (re int i = row + 1; i &lt;= n; ++i) &#123; if (abs(a[maxer][col]) &lt; abs(a[i][col])) &#123; maxer = i; &#125; &#125; if (!a[maxer][col]) continue; for (re int j = 1; j &lt;= n + 1; ++j) &#123; swap(a[row][j], a[maxer][j]); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; double solve = a[i][col] / a[row][col]; for (re int j = col; j &lt;= n + 1; ++j) &#123; a[i][j] -= a[row][j] * solve; &#125; &#125; ++row; &#125; if (row &lt;= n) &#123; for (re int i = row; i &lt;= n; ++i) &#123; if (a[i][n + 1]) &#123; printf(&quot;-1\\n&quot;); return 0; &#125; &#125; printf(&quot;0\\n&quot;); &#125; else &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (int(a[i][n + 1] / a[i][i] * 100) == 0) &#123; printf(&quot;x%d=0\\n&quot;, i); &#125; else &#123; printf(&quot;x%d=%.2lf\\n&quot;, i, a[i][n + 1] / a[i][i]); &#125; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"最短路","slug":"最短路/index","date":"un66fin66","updated":"un11fin11","comments":true,"path":"2021/06/05/最短路/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/05/%E6%9C%80%E7%9F%AD%E8%B7%AF/index/","excerpt":"","text":"P3371 【模板】单源最短路径（弱化版） P4779 【模板】单源最短路径（标准版） 1. Dijkstra 1234567891011121314151617181920bool vis[MAXn + 10]; int dis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;Dijkstra(root); 2. SPFA 1234567891011121314151617181920bool inque[MAXn + 10]; int dis[MAXn + 10];queue&lt;int&gt; q;void SPFA(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(root); inque[root] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;SPFA(root); 3. Floyd 12345678for (re int k = 1; k &lt;= n; ++k) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); //传递闭包：con[i][j] |= con[i][k] &amp; con[k][j]; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"矩阵运算","slug":"矩阵运算/index","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2021/06/03/矩阵运算/index/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/03/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/index/","excerpt":"","text":"P3390 【模板】矩阵快速幂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Mat &#123; int mat[MAXmat][MAXmat]; Mat() &#123; memset(mat, 0, sizeof(mat)); &#125; Mat(int a[MAXmat][MAXmat]) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = a[i][j]; &#125; &#125; &#125; inline void operator=(Mat x) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = x.mat[i][j]; &#125; &#125; &#125; inline Mat operator+(Mat x) &#123; Mat ans; for (int i = 0; i &lt; MAXmat; ++i) &#123; for (int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (mat[i][j] + x.mat[i][j]) % MOD; &#125; &#125; return ans; &#125; inline Mat operator*(Mat x) &#123; Mat ans; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int k = 0; k &lt; MAXmat; ++k) &#123; int a = mat[i][k]; for (re int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (a * x.mat[k][j] + ans.mat[i][j]) % MOD; &#125; &#125; &#125; return ans; &#125; inline Mat operator^(int x) &#123; Mat ans, base; for (re int i = 0; i &lt; MAXmat; ++i) &#123; ans.mat[i][i] = 1; &#125; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; base.mat[i][j] = mat[i][j]; &#125; &#125; while (x) &#123; if (x &amp; 1) &#123; ans = ans * base; &#125; base = base * base; x &gt;&gt;= 1; &#125; return ans; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]}