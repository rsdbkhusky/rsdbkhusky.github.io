{"meta":{"title":"ç‡ƒçƒ§çš„å†°å—_husky's blog","subtitle":"using namespace determination","description":"using namespace determination","author":"rsdbk_husky","url":"http://rsdbkhusky.github.io","root":"/"},"pages":[{"title":"cs","date":"un55fin55","updated":"un55fin55","comments":true,"path":"cs.html","permalink":"http://rsdbkhusky.github.io/cs.html","excerpt":"","text":"FirstSecondThirdForthFifthSixth A a b B Hello World! $He\\text{ll}\\phi~\\LaTeX$ 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int a, b;signed main() &#123; cin &gt;&gt; a &gt;&gt; b; printf(&quot;%d\\n&quot;, a + b); return 0;&#125; 1console.log(&#x27;hello world&#x27;) 123pay attention:- make sb to do sth+ make sb do sth"},{"title":"æ ‡ç­¾","date":"un55fin55","updated":"un55fin55","comments":true,"path":"tags/index.html","permalink":"http://rsdbkhusky.github.io/tags/index.html","excerpt":"","text":""},{"title":"åˆ†ç±»","date":"un55fin55","updated":"un55fin55","comments":true,"path":"categories/index.html","permalink":"http://rsdbkhusky.github.io/categories/index.html","excerpt":"","text":""},{"title":"å‹é“¾","date":"un55fin55","updated":"un55fin55","comments":true,"path":"link/index.html","permalink":"http://rsdbkhusky.github.io/link/index.html","excerpt":"","text":""}],"posts":[{"title":"NOI 2022 æ¸¸è®°","slug":"NOI 2022 æ¸¸è®°","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2022/08/21/NOI 2022 æ¸¸è®°/","link":"","permalink":"http://rsdbkhusky.github.io/2022/08/21/NOI%202022%20%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"Day -7ï¼ˆ8 æœˆ 13 æ—¥ï¼‰ åº”é˜²ç–«çš„ç›¸å…³è¦æ±‚ï¼Œä»Šå¹´çš„ NOI éœ€è¦æå‰åˆ°è¾¾ä¸¾åŠåœ°æ‰€åœ¨çœå¸‚ 7 å¤©ï¼Œäºæ˜¯ä»Šå¤©å°±å‡ºå‘äº†ï¼Œæ—©ä¸Šåœ¨ç«è½¦ç«™åƒçš„éº¦å½“åŠ³ï¼Œè¿˜é¢å¤–ä¹°äº†ä¸€ä»½æ‹¿åˆ°é«˜é“ä¸Šå½“åˆé¥­åƒã€‚åœ¨é«˜é“ä¸Šä¸€ç›´åœ¨æ‰“çš‡å®¤ï¼Œä¸­é—´è¿‡éš§é“çš„æ—¶å€™æ–­ç½‘å¯¼è‡´è¿è¾“å¥½å‡ ç›˜ï¼Œè¡€å‹æ€¥å‰§å‡é«˜ã€‚ æ±Ÿè‹æ˜†å±±è¡—æ™¯å¾ˆå¥½ï¼Œå°±æ˜¯å¤ªçƒ­ã€‚ è´´ä¸¤å¼ æ˜†å±±è¡—æ™¯ï¼š å…¥ä½çš„å®¾é¦†æˆ¿é—´å¾ˆå¤§ã€‚ æ™šä¸Šæ‰“ ABCï¼Œæœ€å 30 ç§’é’Ÿ rk400 ç»“æœç»“æŸæ—¶ rk398â€¦â€¦ï¼ˆæ„Ÿè°¢å¤§è‡ªç„¶çš„é¦ˆèµ ï¼‰ã€‚ Day -6ï¼ˆ8 æœˆ 14 æ—¥ï¼‰ å®¾é¦†æ—©é¥­éå¸¸å¥½ï¼Œç…å¥½çš„åŸ¹æ ¹ğŸ¥“éšä¾¿å–ï¼Œåƒè‚‰åƒåˆ°çˆ½ã€‚ ä¸Šåˆæœ‰å—å¤–æ¨¡æ‹Ÿèµ›ï¼Œè¿™ä¸€å¤©çš„é¢˜ç›®æ¯”è¾ƒé˜³é—´ï¼ŒT1 æ¯”è¾ƒç®€å•ï¼ŒT2ã€T3 ä¹Ÿæœ‰è¶³å¤Ÿçš„éƒ¨åˆ†åˆ†ã€‚ Day -5ï¼ˆ8 æœˆ 15 æ—¥ï¼‰ ä¸Šåˆæœ‰å—å¤–æ¨¡æ‹Ÿèµ›ï¼Œæ€»å…±æ‹¿äº† 50 åˆ†ï¼ŒT1 åªä¼šæ‹¿æœ€ä½çš„æš´åŠ›åˆ†ï¼Œè¿ç¨å¾®é«˜çº§ä¸€ç‚¹çš„æš´åŠ›éƒ½æƒ³ä¸åˆ°ï¼›T2 çœ‹é”™é¢˜äº†ï¼Œåœ†çš„äº¤çœ‹æˆäº†å¹¶ ï¼ˆè°å®¶æŠ¤ç›¾ç”Ÿæˆå™¨è¶Šå»ºæŠ¤ç›¾è¶Šå°å•Šï¼‰ï¼ŒT3 é˜´é—´æç­”é¢˜ä¹Ÿä¸ä¼šã€‚ Day -4ï¼ˆ8 æœˆ 16 æ—¥ï¼‰ ä¸‹åˆæœ‰æ­ç”µå¤šæ ¡ ACM èµ›ï¼Œåˆš T1 æœªæœã€‚ Day -3ï¼ˆ8 æœˆ 17 æ—¥ï¼‰ æ²¡æœ‰æ¯”èµ›ï¼Œå°±æ‰“äº†æ‰“æ¿å­ï¼Œç„¶åæ˜¯æ— æ‰€äº‹äº‹ã€‚ Day -2ï¼ˆ8 æœˆ 18 æ—¥ï¼‰ ä¸‹åˆæœ‰æ­ç”µå¤šæ ¡ ACM èµ›ã€‚æˆ‘å…ˆå†™äº†ä¸€é“ç½‘ç»œæµï¼Œç„¶åå†™äº†ä¸€é“æ•°å½¢ dpï¼Œç»“æœå†™å®Œå‘ç°è¿™é“æ ‘å½¢ dp å·²ç»è¢«é€šè¿‡äº†ï¼Œç„¶åå°±åˆå†™äº†ä¸€é“è´ªå¿ƒå’Œä¸€é“å¤§æ•°æ®ç»“æ„ï¼šLCT+å¹¶æŸ¥é›†+å·¦åå †ã€‚ç»“æœ TLE äº†ï¼Œå¬ $\\text{R{\\color{red}enamoe}}$ è¯´åº”è¯¥æ˜¯ LCT å¸¸æ•°å¤ªå¤§äº†ã€‚ Day -1ï¼ˆ8 æœˆ 19 æ—¥ï¼‰ ç™½å¤©æ‰“äº†æ‰“æ¿å­ï¼Œæ™šä¸Šæ”¶æ‹¾äº†ä¸œè¥¿ï¼Œå‡†å¤‡ç¬¬äºŒå¤©å‡ºå‘ã€‚ Day 1ï¼ˆ8 æœˆ 20 æ—¥ï¼‰ æ—©ä¸Šä»å®¾é¦†æ‰“è½¦ï¼Œä¸åˆ°ä¸€ä¸ªå°æ—¶å°±åˆ°äº†ç›®çš„åœ°æ˜†å±±ç‹„é‚¦åæ›œå­¦æ ¡ã€‚ å­¦æ ¡æ­£é¢ï¼ˆæ¨¡å‹ï¼‰ Day 2ï¼ˆ8 æœˆ 21 æ—¥ï¼‰ Day 3ï¼ˆ8 æœˆ 22 æ—¥ï¼‰ Day 4ï¼ˆ8 æœˆ 23 æ—¥ï¼‰ Day 5ï¼ˆ8 æœˆ 24 æ—¥ï¼‰ Day 6ï¼ˆ8 æœˆ 25 æ—¥ï¼‰ Day 7ï¼ˆ8 æœˆ 26 æ—¥ï¼‰ Day 8ï¼ˆ8 æœˆ 27 æ—¥ï¼‰","categories":[{"name":"ç¼–ç¨‹ï¼ˆ8 æœˆ ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹ï¼ˆ8-æœˆ-ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B%EF%BC%888-%E6%9C%88-%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"ã€Šé«˜ç­‰æ•°å­¦ã€‹ç¬”è®°","slug":"ã€Šé«˜ç­‰æ•°å­¦ã€‹ç¬”è®°","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2022/06/24/ã€Šé«˜ç­‰æ•°å­¦ã€‹ç¬”è®°/","link":"","permalink":"http://rsdbkhusky.github.io/2022/06/24/%E3%80%8A%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ç¬¬ä¸€ç«  æ˜ å°„ä¸å‡½æ•°ç¬¬ä¸€èŠ‚ æ˜ å°„è®¾ Xã€Y æ˜¯ä¸¤ä¸ªéç©ºé›†åˆï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªæ³•åˆ™ $f$ï¼Œä½¿å¾—å¯¹ $X$ ä¸­æ¯ä¸ªå…ƒç´  $x$ï¼ŒæŒ‰æ³•åˆ™ï¼Œåœ¨ $Y$ éƒ½æœ‰å”¯ä¸€ç¡®å®šçš„å…ƒç´  $y$ ä¸ä¹‹å¯¹åº”ï¼Œé‚£ä¹ˆç§° $f$ ä¸ºä» $X$ åˆ° $Y$ çš„æ˜ å°„ï¼ˆåˆç§°ç®—å­ï¼‰ï¼Œè®°ä½œ $f:X\\rightarrow Y$ã€‚ åœ¨æ˜ å°„ $f$ ä¸‹ï¼Œ$y$ ç§°ä¸º $x$ çš„åƒï¼Œè®°ä½œ $y=f(x)$ã€‚$x$ è¢«ç§°ä¸º $y$ çš„ä¸€ä¸ªåŸåƒã€‚ ä¸€ä¸ªæ˜ å°„ $f$ ä¸­ï¼Œ$X$ è¢«ç§°ä¸ºå®šä¹‰åŸŸï¼Œè®°ä½œ $D_f=X$ã€‚$X$ ä¸­æ‰€æœ‰å…ƒç´ ç»„æˆçš„åƒçš„é›†åˆè¢«ç§°ä¸ºå€¼åŸŸï¼Œè®°ä½œ $R_f=f(X)={f(x)|x\\in X}$ã€‚ å¦‚æœ $R_f=Y$ï¼Œå³ç§° $f$ ä¸ºæ»¡å°„ã€‚å¦‚æœ $\\forall x_1,x_2\\in X,f(x_1)\\ne f(x_2)$ï¼Œå³ç§° $f$ ä¸ºå•å°„ã€‚å¦‚æœ $f$ å³ä½¿æ»¡å°„åˆæ˜¯å•å°„ï¼Œå³ç§° $f$ ä¸ºåŒå°„ã€‚ ä»éç©ºé›†åˆ°æ•°é›†çš„æ˜ å°„åˆç§°æ³›å‡½ï¼Œä»éç©ºé›†åˆ°å®ƒè‡ªèº«çš„æ˜ å°„åˆç§°å˜æ¢ï¼Œä»å®æ•°é›†ï¼ˆæˆ–å…¶å­é›†ï¼‰åˆ°å®æ•°é›†çš„æ˜ å°„åˆç§°å‡½æ•°ã€‚ å¦‚æœ $f$ æ˜¯ä» $X$ åˆ° $Y$ çš„å•å°„ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§° $f^{-1}:R_f\\rightarrow X$ ä¸º $f$ çš„é€†æ˜ å°„ã€‚ å¦‚æœæœ‰ä¸¤ä¸ªæ˜ å°„ $g:X\\rightarrow Y_1,f:Y_2\\rightarrow Z$ï¼Œæ»¡è¶³ $Y_1\\subseteq Y_2$ï¼Œåˆ™ $\\forall x\\in X,f(g(x))\\in Z$ã€‚$f(g(x))$ ä¸º $g$ ä¸ $f$ æ„æˆçš„å¤åˆæ˜ å°„ï¼Œè®°ä½œ $f\\circ g:X\\rightarrow Z$ã€‚ ç¬¬äºŒèŠ‚ å‡½æ•°å‡½æ•°çš„æœ‰ç•Œæ€§ï¼šå¯¹äºå‡½æ•° $f$ï¼Œ$I\\subseteq D_f$ï¼Œè‹¥ $\\exists k\\Rightarrow\\forall x\\in I\\Rightarrow f(x)\\le k$ï¼Œåˆ™å‡½æ•° $f$ åœ¨ $I$ ä¸Šæœ‰ä¸Šç•Œã€‚$\\le$ æ”¹ä¸º $\\ge$ å³ä¸ºæœ‰ä¸‹ç•Œã€‚ å‡½æ•°çš„å•è°ƒæ€§ï¼šå¯¹äºå‡½æ•° $f$ï¼Œ$I\\subseteq D_f$ï¼Œè‹¥ $\\forall x_1,x_2,x_1","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"æ¨è¡¨","slug":"æ¨è¡¨","date":"un55fin55","updated":"un44fin44","comments":true,"path":"2022/05/13/æ¨è¡¨/","link":"","permalink":"http://rsdbkhusky.github.io/2022/05/13/%E6%9D%A8%E8%A1%A8/","excerpt":"","text":"æ¨è¡¨çš„æ¦‚å¿µè§ OIWikiã€‚ å‹¾é•¿å…¬å¼ \\operatorname{dim} \\pi_{\\lambda}=\\frac{n !}{\\prod_{x \\in Y(\\lambda)} \\operatorname{hook}(x)}æ¨è¡¨è¡Œåˆ—é•¿åº¦çš„æ„ä¹‰$n\\text{thlis}$ï¼š $n=1$ $n\\text{thlis}$ï¼šç­‰åŒäº $\\text{lis}$ã€‚ $n&gt;1$ $n\\text{thlis}$ï¼šåˆ é™¤æ‰ $1\\text{thlis}\\sim (n!-!1)\\text{thlis}$ å‰©ä¸‹çš„åºåˆ—çš„ $\\text{lis}$ ä¸­æœ€é•¿çš„ã€‚ ä¾‹ï¼šåºåˆ— $(3,1,4,2,5)$ çš„ $\\text{lis}$ æœ‰ $(3,4,5)$ï¼Œ $(1,4,5)$ï¼Œ$(1,2,5)$ã€‚ åˆ å»åå‰©çš„åºåˆ—ä¸º $(1,2)$ï¼Œ$(3,2)$ï¼Œ$(3,4)$ã€‚ å‰©ä½™åºåˆ—çš„ $\\text{lis}$ ä¸º $(1,2)$ï¼Œ$(3)$ã€$(2)$ï¼Œ$(3,4)$ã€‚ åˆ™åŸåºåˆ—çš„ $2\\text{thlis}$ ä¸º $(1,2)$ å’Œ $(3,4)$ã€‚ $n\\text{limlis}$ï¼šåŸåºåˆ—çš„ä¸€ä¸ªå­åºåˆ—ï¼Œæ»¡è¶³è¯¥å­åºåˆ—çš„ $\\text{lis}$ çš„é•¿åº¦ä¸è¶…è¿‡ $n$ï¼Œä¸”è¯¥å­åºåˆ—çš„é•¿åº¦åœ¨æ»¡è¶³è¦æ±‚çš„æ‰€æœ‰å­åºåˆ—ä¸­æœ€å¤§ã€‚ $n\\text{thlds}$ å’Œ $n\\text{limlds}$ çš„å®šä¹‰ä¸ä¹‹ç±»ä¼¼ã€‚ æ¨è¡¨çš„å˜æ¢å®šä¹‰ä»¥ä¸‹ç¬¦å·ï¼š $A=(a_1,a_2\\cdots a_n)$ï¼šæ•°åˆ—ã€‚ $\\lVert A\\rVert$ï¼šæ•°åˆ— $A$ ç”Ÿæˆçš„æ¨è¡¨ã€‚ $\\overline{\\lVert A\\rVert}$ï¼šæ¨è¡¨ $\\lVert A\\rVert$ çš„å½¢çŠ¶ï¼ˆå¿½è§†æ¨è¡¨å†…æ•°å­—ï¼‰ã€‚ $-A=(-a_1,-a_2\\cdots -a_n)$ã€‚ $A^{-1}=(an,a{n-1}\\cdots a_1)$ã€‚ $\\lVert A\\rVert^{-1}$ï¼š$\\lVert A\\rVert$ çš„è½¬ç½®ï¼ŒåŠäº¤æ¢è¡Œå’Œåˆ—ã€‚ æœ‰ä»¥ä¸‹ç»“è®ºï¼š ä¸ç®¡ $A$ ä¸­æœ‰æ²¡æœ‰é‡å¤å…ƒç´ ï¼Œ$\\overline{\\lVert A^{-1}\\rVert}=\\overline{\\lVert -A\\rVert}$ã€‚ å¦‚æœ $A$ ä¸­æ²¡æœ‰é‡å¤å…ƒç´ ï¼Œ$\\lVert A\\rVert^{-1}=\\lVert A^{-1}\\rVert$ï¼Œ$\\overline{\\lVert A\\rVert^{-1}}=\\overline{\\lVert -A\\rVert}$ã€‚ ä»£ç 123456789101112vector&lt;int&gt; yt[MAXn + 10];void Insert(int v) &#123; for (int i = 1; ; ++i) &#123; int siz = yt[i].size(); if (siz == 0 || yt[i][siz - 1] &lt; v) &#123; yt[i].push_back(v); break; &#125; else &#123; swap(*lower_bound(begin(yt[i]), end(yt[i]), v), v); &#125; &#125;&#125; æ¨è¡¨çš„å…¶ä»–æ€§è´¨ æ±‚æœ‰é‡å¤å…ƒç´ çš„æ•°åˆ—çš„ä¸¥æ ¼ä¸Šå‡å­åºåˆ—æ—¶ï¼Œå¯ä»¥ç»™æ•°åˆ—é‡Œçš„å…ƒç´ é™„åŠ ç¬¬äºŒå…³é”®å­—ï¼Œå°† $a_i$ å˜ä¸º $(a_i,n-i+1)$ï¼Œè¿™æ ·ä¸ä¼šå½±å“ç­”æ¡ˆå¹¶ä¸”èƒ½ä½¿æ•°åˆ—é‡Œæ²¡æœ‰ç›¸åŒçš„å…ƒç´ ã€‚ ä¸€ä¸ªæ’åˆ—å’Œä¸¤ä¸ªå½¢çŠ¶ç›¸åŒä½†æ˜¯å†…éƒ¨æ•°å­—é¡ºåºä¸ä¸€å®šç›¸åŒçš„æ¨è¡¨ï¼ˆè¿™ä¸¤ä¸ªæ¨è¡¨æœ‰å…ˆåé¡ºåºï¼‰å½¢æˆåŒå°„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºä¸€ä¸ªæ¨è¡¨çš„å½¢çŠ¶ $\\lambda$ï¼Œä»–çš„å¡«å‘æœ‰ $dim{\\lambda}$ ç§ï¼Œé‚£ä¹ˆæ»¡è¶³ $\\overline{\\lVert P\\rVert}=\\lambda$ çš„æ’åˆ— $P$ æœ‰ $dim^2{\\lambda}$ ä¸ªã€‚ å¯¹äºä»»æ„ä¸€ä¸ªæ¨è¡¨ï¼Œè¯•å›¾ç”¨ $1\\times 2$ å’Œ $2\\times 1$ çš„éª¨ç‰Œä¸é‡å å¯ä¸å®Œå…¨è¦†ç›–åœ°è¦†ç›–è¿™ä¸ªæ¨è¡¨ï¼Œæœ€å¤§è¦†ç›–çš„éª¨ç‰Œæ•°é‡ä¸ºè¡Œåˆ—ç¼–å·å’Œä¸ºå¥‡æ•°çš„æ ¼å­æ•°é‡å’Œè¡Œåˆ—ç¼–å·å’Œä¸ºå¶æ•°çš„æ ¼å­æ•°é‡çš„æœ€å°å€¼ã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"å¹¿ä¹‰å®¹æ–¥åŸç† & äºŒé¡¹å¼åæ¼”","slug":"å¹¿ä¹‰å®¹æ–¥åŸç† & äºŒé¡¹å¼åæ¼”","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2022/03/13/å¹¿ä¹‰å®¹æ–¥åŸç† & äºŒé¡¹å¼åæ¼”/","link":"","permalink":"http://rsdbkhusky.github.io/2022/03/13/%E5%B9%BF%E4%B9%89%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%20&%20%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/","excerpt":"","text":"æœ¬æ–‡ä»…ä½œä¸ºæ•´ç†æ€è·¯ï¼Œæ²¡æœ‰å®šç†çš„ä¸¥æ ¼è¯æ˜ã€‚ å®šä¹‰ã€Œå®¹æ–¥åŸç†ã€å’Œã€Œå¹¿ä¹‰å®¹æ–¥åŸç†ã€è¿™ä¸¤ç« ä¸­ï¼Œå°†ä½¿ç”¨ä»¥ä¸‹å®šä¹‰ã€‚ $A$ï¼šä¸€ä¸ªåŒ…å« $n$ ä¸ªä¸åŒå…ƒç´  $a_1,a_2\\cdots a_n$ çš„é›†åˆã€‚æ³¨æ„ $n$ çš„å«ä¹‰æ˜¯é›†åˆå¤§å°ã€‚ $d_m$ï¼š$A$ çš„å­é›†ä¸­è‡³å°‘åŒ…å« $m$ ä¸ªå…ƒç´ çš„é›†åˆçš„æ•°é‡ã€‚ï¼ˆ$A$ çš„å­é›†ä¸­å¤§å° $\\ge m$ çš„é›†åˆçš„æ•°é‡ï¼‰ $f_m$ï¼š$A$ çš„å­é›†ä¸­æ°å¥½åŒ…å« $m$ ä¸ªå…ƒç´ çš„é›†åˆçš„æ•°é‡ã€‚ï¼ˆ$A$ çš„å­é›†ä¸­å¤§å° $= m$ çš„é›†åˆçš„æ•°é‡ï¼‰ $g_{Aâ€™}$ï¼š$Aâ€™$ æ˜¯ $A$ çš„å­é›†ï¼Œæ»¡è¶³é’¦å®šé€‰ $Aâ€™$ ä¸­æ‰€æœ‰å…ƒç´ ï¼Œå…¶ä»–å…ƒç´ æ— é™åˆ¶çš„æ¡ä»¶çš„ $A$ çš„å­é›†çš„æ•°é‡ã€‚ è®¾æ‰€æœ‰åŒ…å«å…ƒç´  $a_i$ çš„ $A$ çš„å­é›†æ‰€æ„æˆçš„é›†åˆä¸º $X_i$ï¼Œä»¥ä¸Šå®šä¹‰ç”¨éŸ¦æ©å›¾è¡¨è¾¾å¦‚ä¸‹ï¼š ç™½è‰²ä»£è¡¨è¿™éƒ¨åˆ†è¢«ç®—äº† $0$ æ¬¡ï¼Œçº¢è‰²ä»£è¡¨è¿™éƒ¨åˆ†è¢«ç®—äº† $1$ æ¬¡ã€‚ å¯ä»¥å‘ç°ï¼š g_{A'}=\\left|\\bigcap\\limits_{a_i\\in A'}X_i\\right|è¿˜æœ‰ä¸€æ¡æ€§è´¨ï¼š \\sum\\limits_{A'\\subseteq A,|A'|=m}g_{A'}=\\sum\\limits_{i=m}^{i\\le n}\\binom{i}{m}f_iéŸ¦æ©å›¾è¡¨ç¤ºå¦‚ä¸‹ï¼š è“è‰²ä»£è¡¨è¿™éƒ¨åˆ†è¢«ç®—äº† $3$ æ¬¡ã€‚ ä»¥é›†åˆçš„è§’åº¦æ¥ç†è§£å®¹æ–¥åŸç†å’Œå¹¿ä¹‰å®¹æ–¥åŸç†æ¯”è¾ƒåˆ©äºç”¨éŸ¦æ©å›¾æ¥æ•°å½¢ç»“åˆç†è§£ã€‚ä½†æ˜¯åœ¨ OI é¢˜ç›®ä¸­å®¹æ–¥åŸç†çš„è€ƒå¯ŸèƒŒæ™¯ä¸€èˆ¬ä¸æ˜¯é›†åˆï¼Œè€Œæ˜¯æœ‰ $n$ ä¸ªæ€§è´¨ï¼Œæ±‚æ°å¥½æˆ–è‡³å°‘æ»¡è¶³ $m$ ä¸ªæ€§è´¨çš„æ–¹æ¡ˆæ•°ï¼Œè€Œæ»¡è¶³æ¯æ¡æ€§è´¨çš„æ–¹æ¡ˆæ•°ä¼šæœ‰å¾ˆå¤šç§ï¼Œè¿™ç‚¹å’Œé›†åˆä¸åŒï¼Œé›†åˆä¸­æ¯ä¸ªå…ƒç´ å¦‚æœè¢«é€‰æ‹©åªæœ‰ä¸€ç§è¢«é€‰æ‹©çš„æ–¹æ³• ï¼ˆå¥½åƒæ˜¯åºŸè¯ï¼‰ã€‚ å®¹æ–¥åŸç†æˆ‘ä»¬éƒ½çŸ¥é“å®¹æ–¥åŸç†å¯ä»¥æ±‚è‡³å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ çš„å­é›†æ•°ï¼ˆæˆ–è‡³å°‘åŒ…å«ä¸€æ¡æ€§è´¨çš„æ–¹æ¡ˆæ•°ï¼‰ï¼š d_1=\\sum\\limits_{i=1}^{i\\le n}(-1)^{i-1}\\sum\\limits_{A'\\subseteq A,|A'|=i}g_{A'}é›†åˆè®ºçš„å½¢å¼ï¼š \\left|\\bigcup\\limits_{i=1}^{i\\le n}X_i\\right|=\\sum\\limits_{i=1}^{i\\le n}(-1)^{i-1}\\sum\\limits_{p_j","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"ã€Šæ‰˜é©¬æ–¯å¾®ç§¯åˆ†ã€‹æ‘˜è¦","slug":"ã€Šæ‰˜é©¬æ–¯å¾®ç§¯åˆ†ã€‹æ‘˜è¦","date":"un44fin44","updated":"un55fin55","comments":true,"path":"2022/01/27/ã€Šæ‰˜é©¬æ–¯å¾®ç§¯åˆ†ã€‹æ‘˜è¦/","link":"","permalink":"http://rsdbkhusky.github.io/2022/01/27/%E3%80%8A%E6%89%98%E9%A9%AC%E6%96%AF%E5%BE%AE%E7%A7%AF%E5%88%86%E3%80%8B%E6%91%98%E8%A6%81/","excerpt":"","text":"æœ¬æ‘˜è¦åŒ…å«ã€Šæ‰˜é©¬æ–¯å¾®ç§¯åˆ†ã€‹ç¬¬ 0~4 ç« ï¼Œçœç•¥äº†ä¸€äº›éš¾åº¦è¾ƒé«˜çš„ã€OI ä¸­åº”è¯¥ä¸éœ€è¦çš„å°èŠ‚ã€‚ é¢„å¤‡çŸ¥è¯†ä¸€å¯¹ä¸€å‡½æ•° åå‡½æ•° å¯¹æ•° ä¸‰è§’å‡½æ•° å‚æ•°æ›²çº¿ï¼Œå‚æ•°æ–¹ç¨‹ æé™å’Œè¿ç»­æ™®é€šæé™éæ­£å¼å®šä¹‰ æ­£å¼å®šä¹‰ æ€§è´¨ æ±‚å€¼ å•ä¾§æé™å®šä¹‰ æ€§è´¨ ä¸æ— ç©·æœ‰å…³çš„æé™å®šä¹‰ æ€§è´¨ æ±‚å€¼ æ¸è¿‘çº¿ &amp; ç»ˆæå½¢æ€å®šä¹‰ æ±‚å€¼ è¿ç»­å®šä¹‰ åˆ¤å®š æ€§è´¨ æ–œç‡ &amp; åˆ‡çº¿ å˜åŒ–ç‡ &amp; å¯¼æ•° å¯¼æ•°æ™®é€šå¯¼æ•°å®šä¹‰ æ€§è´¨ æ±‚å€¼ å•ä¾§å¯¼æ•° é«˜é˜¶å¯¼æ•° å‚æ•°æ›²çº¿çš„æ–œç‡ æ­¤å¤„ç•¥è¿‡ P209 ä¸‹åŠéƒ¨åˆ† ~ P226 ä¸ŠåŠéƒ¨åˆ†ã€‚ å¯¼æ•°çš„åº”ç”¨æ±‚æå€¼å®šä¹‰ æ€§è´¨ æ±‚å€¼ ç½—å°”å®šç†ä¸ä¸­å€¼å®šç† å¾®åˆ†æ–¹ç¨‹ æ±‚å‡½æ•°å½¢çŠ¶å®šä¹‰ æ€§è´¨ æ­¤å¤„ç•¥è¿‡ P280 ä¸‹åŠéƒ¨åˆ† ~ P338ã€‚ ç§¯åˆ†ä¸å®šç§¯åˆ†å®šä¹‰ æ€§è´¨ æ±‚å€¼ å®šç§¯åˆ†å®šä¹‰ æ€§è´¨ æ±‚å€¼","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"STLå¤§æ€»ç»“","slug":"STLå¤§æ€»ç»“","date":"un22fin22","updated":"un22fin22","comments":true,"path":"2022/01/18/STLå¤§æ€»ç»“/","link":"","permalink":"http://rsdbkhusky.github.io/2022/01/18/STL%E5%A4%A7%E6%80%BB%E7%BB%93/","excerpt":"","text":"æ”¶ä¸‹å§ï¼Œè¿™æ˜¯æˆ‘æœ€åçš„ STL äº†ã€‚ å®¹å™¨ åºåˆ—å¼å®¹å™¨ åŒ…å«ï¼šarrayã€vectorã€dequeã€listã€‚ .fill(val) .assgin(bgit, edit) / .assgin(cnt, val) .erase(...) è¿”å›å€¼ï¼šæŒ‡å‘åˆ æ‰çš„ä¸€ä¸ªï¼ˆæ®µï¼‰å…ƒç´ çš„ä¹‹åçš„ä½ç½®çš„è¿­ä»£å™¨ã€‚ ä¼ å‚æ ¼å¼ .erase(it) .erase(bgit, edit) .insert(...) æ–°æ’å…¥çš„å€¼åœ¨ it ä¹‹å‰ã€‚ è¿”å›å€¼ï¼šå‡è¿”å›ç¬¬ä¸€ä¸ªæ’å…¥çš„å…ƒç´ çš„è¿­ä»£å™¨ï¼ˆå³ä¸‹æ ‡æœ€å°çš„ï¼‰ã€‚ ä¼ å‚æ ¼å¼ .insert(it, val) .insert(it, cnt, val) .insert(it, bgit, edit) .insert(it, initlist) ç¤ºä¾‹ï¼š 1a.insert(begin(a) + 2, &#123;10, 11, 12, 13&#125;); .emplace(it, val) ä¸èƒ½å®Œå…¨æ›¿ä»£ insertï¼Œåªèƒ½æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚ è¿”å›æ’å…¥çš„å…ƒç´ çš„è¿­ä»£å™¨ã€‚ .emplace_back(val) å¯æ›¿ä»£ push_backã€‚ .emplace_front(val) å¯æ›¿ä»£ push_frontã€‚ .capacity() .resize(size) .shrink_to_fit() æ‰€æœ‰å¯å¢å¤§ size çš„å‡½æ•°å‡å¯å¢å¤§ capacityï¼Œä½†ä¸Šè¿°å‡½æ•°ä¸­åªæœ‰ shrink_to_fit å¯å‡å° capacityã€‚ å…³è”å¼å®¹å™¨ åŒ…å«ï¼šmapã€multimapã€setã€multisetã€‚ å› ä¸º map ç³»å’Œ set ç³»çš„æŸ¥è¯¢ç±»çš„æˆå‘˜å‡½æ•°åœ¨ä¼ å‚ä¸Šæœ‰å¾ˆå¤šç›¸åŒçš„ä¸åŒç‚¹ï¼Œæ‰€ä»¥ä»¥ä¸‹è§„å®šä¸‹æ–‡ä¸­ Bttï¼ˆby the typeï¼‰ï¼šå¦‚æœè®¨è®ºçš„æ˜¯ map ç³»ï¼Œåˆ™ â€œBttâ€ ä¸ºé”®å€¼ï¼Œå¦‚æœè®¨è®ºçš„æ˜¯ set ç³»ï¼Œåˆ™ â€œBttâ€ ä¸ºæƒå€¼ï¼Œbtt ä¸ºç±»å‹ä¸ Btt ç›¸åŒçš„å˜é‡ã€‚ .find(btt) è¿”å›é¦–ä¸ª Btt ä¸ btt ç›¸ç­‰çš„å…ƒç´ çš„è¿­ä»£å™¨ã€‚ .count(btt) è¿”å› Btt ä¸ btt ç›¸ç­‰çš„å…ƒç´ çš„ä¸ªæ•°ã€‚ .lower_bound(btt) .upper_bound(btt) .equal_range(btt) è¿”å›ä¸€ä¸ª pair å¯¹è±¡ï¼Œå…¶ä¸­åŒ…å«ä¸¤ä¸ªè¿­ä»£å™¨ï¼Œå…¶ä¸­ pair.first å’Œ lower_bound() æ–¹æ³•çš„è¿”å›å€¼ç­‰ä»·ï¼Œpair.second å’Œ upper_bound() æ–¹æ³•çš„è¿”å›å€¼ç­‰ä»·ã€‚ .erase(...) è¿”å›å€¼ï¼šå¯¹äºä¼ å‚ä¸ºè¿­ä»£å™¨çš„ï¼Œè¿”å›æŒ‡å‘åˆ æ‰çš„ä¸€ä¸ªï¼ˆæ®µï¼‰å…ƒç´ çš„ä¹‹åçš„ä½ç½®çš„è¿­ä»£å™¨ï¼›å¯¹äºä¼ å‚åŸºäº btt çš„ï¼Œè¿”å›åˆ æ‰çš„å…ƒç´ ä¸ªæ•°ã€‚ ä¼ å‚æ ¼å¼ .erase(btt) åˆ æ‰ Btt ä¸º btt çš„å…¨éƒ¨å…ƒç´ ã€‚ .erase(it) .erase(bgit, edit) .insert(...) è§„å®šä¸‹æ–‡ä¸­ Bttï¼šå¦‚æœè®¨è®ºçš„æ˜¯ map ç³»ï¼Œåˆ™ â€œBttâ€ ä¸ºé”®å€¼æƒå€¼äºŒå…ƒç»„ï¼Œå¦‚æœè®¨è®ºçš„æ˜¯ set ç³»ï¼Œåˆ™ â€œBttâ€ ä¸ºæƒå€¼ã€‚ è¿”å›å€¼ï¼ˆè¿™é‡Œæåˆ°çš„è¿”å›å€¼åªé€‚ç”¨äºä¸‹é¢ä¸‰ç§ä¼ å‚æ ¼å¼ï¼‰ æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œé multi ç³»è¿”å› pair&lt;iterator, bool&gt;ï¼Œmulti ç³»è¿”å› iterator æ’å…¥æˆåŠŸï¼Œiterator ä¸ºè¯¥å…ƒç´ è¿­ä»£å™¨ï¼Œbool ä¸º trueã€‚ æ’å…¥å¤±è´¥ï¼ˆset å’Œ map ä¸­å·²æœ‰ Btt ä¸å…¶ç›¸åŒçš„å…ƒç´ ï¼‰ï¼Œiterator å›ä¸ä»– Btt ç›¸åŒçš„é‚£ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼Œbool ä¸º falseã€‚ æ’å…¥å¤šä¸ªå…ƒç´ ï¼Œè¿”å› voidã€‚ ä¼ å‚æ ¼å¼ .insert(btt) .insert(it, beit, edit) .insert(it, initlist) .emplace(...) è¿”å›å€¼ï¼šåŒ insertã€‚ ä¼ å‚æ ¼å¼ .emplace(btt) æ³¨æ„è¿™é‡Œå¦‚æœå†™æˆè¿™æ ·ä¼š CEã€‚ 12map&lt;int, int&gt; m;m.emplace(&#123;1, 2&#125;); åŸå› æ˜¯ç¼–è¯‘å™¨æŠŠ &#123;1, 2&#125; å½“æˆåˆå§‹åŒ–åˆ—è¡¨äº†ï¼Œè™½ç„¶ä½ çš„æ„æ€æ˜¯ &#123;1, 2&#125; æ˜¯ä¸ª pair äºŒå…ƒç»„ã€‚ç”¨ make_pair å°±å¯ä»¥äº†ã€‚ .emplace(key, val)ï¼ˆå¯¹äº map ç³»ï¼‰ ç›¸å½“äºå°†åˆ›å»ºæ–°é”®å€¼å¯¹æ‰€éœ€çš„æ•°æ®ä½œä¸ºå‚æ•°ç›´æ¥ä¼ å…¥ã€‚ ä¸Šæ–‡ä¸­ Btt çš„æ¦‚å¿µè§£é‡Šçš„ä¸æ˜¯å¾ˆæ¸…æ¥šï¼Œæˆ‘åœ¨è¿™é‡Œå†æ¢³ç†ä¸€éã€‚å¯¹äº set ç³»è€Œè¨€ï¼Œä¸€ä¸ªå…ƒç´ åªç”±ä¸€ä¸ªéƒ¨åˆ†ç»„æˆï¼Œå°±æ˜¯ä»–æœ¬èº«çš„æƒå€¼ï¼Œæ‰€ä»¥ Btt å°±æ˜¯æƒå€¼ã€‚è€Œå¯¹äº map ç³»è€Œè¨€ï¼Œä¸€ä¸ªå…ƒç´ ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œé”®å€¼å’Œæƒå€¼ï¼ŒæŸ¥è¯¢ã€åˆ é™¤æ—¶ï¼Œåªéœ€è¦é”®å€¼å°±å¯ä»¥æ‰¾åˆ°ç›¸åº”çš„å…ƒç´ ï¼Œæ‰€ä»¥è¿™æ—¶å€™ Btt ä¸ºé”®å€¼ï¼›è€Œæ’å…¥æ—¶éœ€è¦æä¾›å®Œæ•´çš„ä¿¡æ¯ï¼Œæ‰€ä»¥ Btt ä¸ºé”®å€¼æƒå€¼äºŒå…ƒç»„ã€‚ æ— åºå…³è”å¼å®¹å™¨ä¸­ Btt çš„å®šä¹‰æ–¹æ³•ä¸å…³è”å¼å®¹å™¨çš„ç›¸åŒã€‚ æ— åºå…³è”å¼å®¹å™¨ åŒ…å«ï¼šunordered_mapã€unordered_multimapã€unordered_setã€unordered_multisetã€‚ ä¸æ— åºå¼å®¹å™¨çš„ä¸åŒç‚¹ å†…éƒ¨å­˜å‚¨çš„å…ƒç´ æ˜¯æ— åºçš„ã€‚ æˆå‘˜å‡½æ•°æ²¡æœ‰ lower_boundã€upper_boundï¼Œä½†æ˜¯æœ‰ equal_rangeã€‚ unordered ç³»çš„æ“ä½œä¸éƒ½æ˜¯ $O(1)$ çš„ï¼Œå…¶é€šè¿‡æŒ‡å®šé”®æŸ¥æ‰¾å¯¹åº”çš„å€¼çš„æ“ä½œå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ï¼Œä½†å¯¹äºæ’å…¥æ“ä½œï¼Œå…¶å¤æ‚åº¦ç›¸å½“äºé unordered ç³»ï¼Œä¸”å¸¸æ•°å¤§äºé unordered ç³»ã€‚ å®¹å™¨é€‚é…å™¨ åŒ…å«ï¼šstackã€queueã€priority_queueã€‚ å®¹å™¨é€‚é…å™¨éœ€è¦ä¾èµ–åŸºç¡€å®¹å™¨ï¼Œè€Œä¸”å¯¹äºåŸºç¡€å®¹å™¨æœ‰ä¸€äº›è¦æ±‚ï¼Œå¯¹äºæ¯ç§é€‚é…å™¨æ»¡è¶³è¦æ±‚ï¼Œå¯ä»¥ä½œä¸ºå…¶åŸºç¡€å®¹å™¨çš„å®¹å™¨æ˜¯ï¼šï¼ˆåŠ ç²—çš„ä¸ºé»˜è®¤ä½¿ç”¨çš„ï¼‰ stackï¼švectorã€dequeã€listã€‚ queueï¼šdequeã€listã€‚ priority_queueï¼švectorã€dequeã€‚ ç®—æ³•å‡½æ•°åªåˆ—ä¸¾æˆ‘è®¤ä¸ºæ¯”è¾ƒç”Ÿåƒ»ä½†æ˜¯åœ¨ç®—æ³•ç«èµ›ä¸­èƒ½æ´¾ä¸Šç”¨åœºçš„ã€‚ stable_sort(bgit, edit) ç¨³å®šæ’åºã€‚ partial_sort(bgit, mdit, edit) éƒ¨åˆ†æ’åºï¼Œå‚ä¸æ’åºçš„éƒ¨åˆ†ä¸º $[\\mathrm{bgit}, \\mathrm{edit})$ï¼Œæ’å¥½çš„éƒ¨åˆ†ä¸º $[\\mathrm{bgit}, \\mathrm{mdit})$ã€‚å¤æ‚åº¦ $O(n\\log m)$ã€‚ nth_element(bgit, mdit, egit) å¯»æ‰¾ $k$ å°æ•°ï¼Œå‚ä¸å¯»æ‰¾çš„éƒ¨åˆ†ä¸º $[\\mathrm{bgit}, \\mathrm{edit})$ï¼Œå¯»æ‰¾åˆ°çš„ $k$ å¤§å€¼ä¸‹æ ‡ä¸º $\\mathrm{mdit}$ï¼ˆä¹Ÿå°±æ˜¯ $k=\\mathrm{mdit}-\\mathrm{bgit}+1$ï¼‰ï¼Œä¸”æ»¡è¶³æ‰€æœ‰å·¦ä¾§çš„æ•°éƒ½æ¯”åœ¨å¤§å°å…³ç³»ä¸­éƒ½æ¯”ä»–é å·¦ï¼Œå³ä¾§çš„æ•°éƒ½æ¯”åœ¨å¤§å°å…³ç³»ä¸­éƒ½æ¯”ä»–é å³ï¼Œå¤æ‚åº¦ $O(n)$ã€‚ merge(bgit1, edit1, bgit2, edit2, it3) å°† $[\\mathrm{bgit_1},\\mathrm{edit_1})$ å’Œ $[\\mathrm{bgit_2},\\mathrm{edit_2})$ åšå½’å¹¶æ’åºå­˜å…¥ä»¥ $\\mathrm{it_3}$ ä¸ºå¼€å§‹çš„å®¹å™¨ä¸­ã€‚ inplace_merge(bgit, mdit, edit) å°† $[\\mathrm{bgit},\\mathrm{mdit})$ å’Œ $[\\mathrm{mdit},\\mathrm{edit})$ åšå½’å¹¶æ’åºå­˜å…¥ä»¥ $\\mathrm{bgit}$ ä¸ºå¼€å§‹çš„å®¹å™¨ä¸­ã€‚ find(bgit, edit, val) è¿”å›ç¬¬ä¸€ä¸ªç­‰äº val çš„å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å›æŒ‡å‘ edit çš„è¿­ä»£å™¨ã€‚ find_if(bgit, edit, func) è¿”å›ç¬¬ä¸€ä¸ªä½¿ func == true çš„å…ƒç´ è¿­ä»£å™¨ï¼Œå¦åˆ™è¿”å›æŒ‡å‘ edit çš„è¿­ä»£å™¨ã€‚ find_if_not(bgit, edit, func) ä¸ find_if æ­£å¥½ç›¸åã€‚ equal_range(bgit, edit, val) ç”¨æ³•å’Œæ•ˆæœå’Œå‰é¢å®¹å™¨çš„æˆå‘˜å‡½æ•°ä¸€æ ·ã€‚ swap_ranges(bgit1, edit1, bgit2) äº¤æ¢ $[\\mathrm{bgit_1},\\mathrm{edit_1})$ å’Œ $[\\mathrm{bgit_2},\\mathrm{bgit_2}+\\mathrm{edit_1}-\\mathrm{bgit_1})$ã€‚ next_permutation(bgit, edit) / prev_permutation(bgit, edit) è¿™ä¿©å‡½æ•°åº”è¯¥æ²¡æœ‰äººä¸è®¤è¯†ï¼Œæˆ‘å°±æ˜¯æƒ³æä¸€ä¸‹ä»–ä»¬çš„å¤æ‚åº¦ï¼š$O(n)$ã€‚ å‚è€ƒæ–‡çŒ® C è¯­è¨€ä¸­æ–‡ç½‘ STL æ•™ç¨‹ CppReference äº²æ‰‹ã®å®éªŒ","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŠå¹³é¢äº¤","slug":"åŠå¹³é¢äº¤","date":"un66fin66","updated":"un55fin55","comments":true,"path":"2022/01/15/åŠå¹³é¢äº¤/","link":"","permalink":"http://rsdbkhusky.github.io/2022/01/15/%E5%8D%8A%E5%B9%B3%E9%9D%A2%E4%BA%A4/","excerpt":"","text":"æœ¬æ–‡ç¼ºå°‘æœ‰åŠ›è¯æ˜ï¼Œä¸”éƒ¨åˆ†å†…å®¹å®Œå…¨ç”±ä¸ªäººæ·»åŠ ï¼Œç½‘ä¸Šæ— æ³•æ‰¾åˆ°ç±»ä¼¼ç»“è®ºã€‚å¯èƒ½å­˜åœ¨é”™è¯¯ã€‚è‹¥è¯»è€…å‘ç°é”™è¯¯å¯åœ¨è¯„è®ºåŒºåé¦ˆã€‚ Update 2022-03-05: æ„Ÿè°¢ ä¿Šæ°_Charles çš„æé†’ï¼ŒåŠ å…¥ä¸€ä¸ªå¤–è¾¹æ¡†å¯ä»¥é¿å…æƒ…å†µ 3ï¼ŒåŒæ—¶ä¹Ÿå¤„ç†äº†æ— ç©·å¤§çš„æƒ…å†µã€‚ å¤§å‹ Hack ç°åœºæ•æˆ‘ç›´è¨€ï¼Œç°åœ¨ç½‘ä¸Šå¾ˆå¤š OJ çš„åŠå¹³é¢äº¤æ¨¡æ¿é¢˜æ•°æ®éƒ½å¤ªæ°´äº†ï¼Œè€Œä¸”æœ‰ä¸€äº›ç‰¹æ®Šçš„æ€§è´¨ï¼ˆä¸‹æ–‡ä¸­æœ‰æåŠï¼‰ï¼Œå¯¼è‡´ä¸€äº›æœ‰ç¼ºé™·çš„ä»£ç èƒ½å¤Ÿ ACã€‚ åŠå¹³é¢äº¤ä¸»æµæ¨¡æ¿ï¼ˆæ•°æ®æ°´ï¼‰ï¼Œæ¨èæ¨¡æ¿ï¼ˆç›¸å¯¹å¼ºä¸€äº›ï¼‰ï¼Œéš¾ç”¨çš„æ¨¡æ¿ï¼ˆæ•°æ®æ®è¯´å¼ºï¼Œä½†æ˜¯ POJ çš„åŠŸèƒ½å’Œä½¿ç”¨ä½“éªŒâ€¦â€¦ï¼‰ã€‚ ä¸»è¦æœ‰ 3 ä¸ªéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š åŠå¹³é¢äº¤å¤§å°ä¸º 0ã€‚ åŠå¹³é¢äº¤å¤§å°ä¸º $\\infty$ã€‚ å­˜åœ¨ä¸¤æ¡æ’å®Œåºåç›¸é‚»çš„å‘é‡çš„æè§’å·®å¤§äº $\\pi$ã€‚ å¯¹äºä¸»æµæ¨¡æ¿è€Œè¨€ï¼Œè¿™ä¸‰æ¡éƒ½æ²¡æœ‰ hackï¼Œç¬¬ä¸€æ¡æ²¡æœ‰ hack æ˜¯å› ä¸ºæ•°æ®æ°´ï¼Œåä¸¤æ¡å› ä¸ºæ¨¡æ¿æœ¬èº«å…·æœ‰ç‰¹æ®Šæ€§è´¨ï¼ˆç»™å‡ºäº†è‡³å°‘ä¸€ä¸ªå‡¸åŒ…ï¼‰è€Œä¸ä¼šå‡ºç°ã€‚ æƒ…å†µ 1ï¼Œè¿™ç§æƒ…å†µä¸‹å¦‚æœæœ‰æ–¹å‘ç›¸åçš„å‘é‡ä¸”è¿™ä¸¤ä¸ªå‘é‡çš„åŠå¹³é¢æ— äº¤é›†ï¼Œé‚£ä¹ˆåœ¨æ‰¾äº¤ç‚¹æ—¶ä¼šå‡ºç°å‘å‘å‘ nan æˆ– -nan ï¼Œåˆ¤ä¸€ä¸‹ nan æˆ– -nan å³å¯ï¼Œæ¥ä¸‹æ¥æœ‰ä¸ªæˆ‘å¹¶ä¸ä¼šè¯çš„ç»“è®ºï¼šå¦‚æœæ²¡æœ‰åˆšæ‰é‚£ç§æƒ…å†µï¼ŒåŒç«¯é˜Ÿåˆ—ä¸­æœ€åä¼šåªæœ‰ä¸¤ä¸ªå‘é‡ï¼Œä¸ç”¨ç‰¹åˆ¤ï¼Œå› ä¸ºä¸¤ä¸ªå‘é‡åªä¼šè½¬åŒ–ä¸¤ä¸ªäº¤ç‚¹ï¼Œé¢ç§¯å°±æ˜¯ 0ã€‚ æƒ…å†µ 2 å¾ˆå¥½åˆ¤ï¼Œåˆ¤ä¸€ä¸‹åšå®ŒåŠå¹³é¢äº¤ååŒç«¯é˜Ÿåˆ—ä¸­ç›¸é‚»å…ƒç´ æè§’å·®æ˜¯å¦æœ‰ $\\ge\\pi$ çš„å³å¯ã€‚ æƒ…å†µ 3 çš„è¯æ¯”è¾ƒå¤æ‚ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªæˆ‘å‘ç°çš„ hackï¼Œç›®å‰æˆ‘æ²¡æœ‰åœ¨ç½‘ä¸Šæ‰¾åˆ°é¢˜è§£æåˆ°è¿‡ã€‚hack æ•°æ®ï¼š ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•° $n$ è¡¨ç¤ºå‘é‡ä¸ªæ•°ï¼Œæ¥ä¸‹æ¥ $n$ è¡Œæ¯è¡Œå››ä¸ªæ•´æ•° $x_1,y_1,x_2,y_2$ è¡¨ç¤ºå‘é‡èµ·ç‚¹ã€ç»ˆç‚¹æ¨ªçºµåæ ‡ã€‚ 123432 4 0 02 4 4 04 1 0 2 å›¾ç¤ºï¼š æˆ‘ç›®æµ‹é‡åˆ°è¿™ç§æƒ…å†µæ¢ä¸€ä¸‹ --ri å’Œ ++le çš„é¡ºåºå³å¯ï¼Œä½†æ˜¯æ²¡æœ‰ä¸¥æ ¼è¯æ˜ï¼ˆå¤ªèœäº†ï¼‰ã€‚å¦‚æœå®åœ¨ä¸è¡Œçš„è¯é‡åˆ°è¿™ç§æƒ…å†µ $O(n)$ å¤„ç†ä¸€ä¸‹ä¹Ÿå¯ä»¥ï¼Œå› ä¸ºæ˜¾ç„¶åªä¼šé‡åˆ°ä¸€æ¬¡ã€‚ ä»£ç ä»£ç ä¸­åªæœ‰å¯¹äºæƒ…å†µ 1 çš„ç‰¹åˆ¤ï¼Œæ²¡æœ‰ 2ã€3 çš„ã€‚ 12345678910111213141516171819202122232425262728293031struct Line &#123; Point a, b; double angle; inline bool operator&lt;(const Line sec) const &#123; if (!cmp(angle, sec.angle)) &#123; return area(a, b, sec.b) &lt; 0; &#125; return angle &lt; sec.angle; &#125;&#125; line[MAXn * MAXm + 10]; int cntline;int le = 1, ri, que[MAXn * MAXm + 10];signed main() &#123; // ... sort(line + 1, line + 1 + cntline); for (int i = 1; i &lt;= cntline; ++i) &#123; if (!cmp(line[i].angle, line[i - 1].angle)) continue; while (le &lt; ri &amp;&amp; area(line[i].a, line[i].b, str_int_str(line[que[ri - 1]].a, line[que[ri - 1]].b, line[que[ri]].a, line[que[ri]].b)) &lt;= 0) --ri; while (le &lt; ri &amp;&amp; area(line[i].a, line[i].b, str_int_str(line[que[le]].a, line[que[le]].b, line[que[le + 1]].a, line[que[le + 1]].b)) &lt;= 0) ++le; que[++ri] = i; &#125; while (le &lt; ri - 1 &amp;&amp; area(line[que[le]].a, line[que[le]].b, str_int_str(line[que[ri - 1]].a, line[que[ri - 1]].b, line[que[ri]].a, line[que[ri]].b)) &lt;= 0) --ri; while (le &lt; ri - 1 &amp;&amp; area(line[que[ri]].a, line[que[ri]].b, str_int_str(line[que[le]].a, line[que[le]].b, line[que[le + 1]].a, line[que[le + 1]].b)) &lt;= 0) ++le; // ... double ans = pol_area(point, cntpoint); if (isfinite(ans)) &#123; printf(&quot;%.3lf\\n&quot;, ans); &#125; else &#123; puts(&quot;0.000&quot;); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"å°ç»“è®ºç§¯ç´¯","slug":"å°ç»“è®ºç§¯ç´¯","date":"un44fin44","updated":"un00fin00","comments":true,"path":"2021/12/16/å°ç»“è®ºç§¯ç´¯/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/16/%E5%B0%8F%E7%BB%93%E8%AE%BA%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"å¸¦çº¦æ•° $\\sum$ å˜è¿ç»­ $\\sum$ \\begin{gather} \\text{è®¾}d'=\\dfrac{d}{n}\\\\ \\sum\\limits_{n\\mid d}=\\sum\\limits_{d'=1}^{d'","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"è«æ¯”ä¹Œæ–¯å‡½æ•° & è«æ¯”ä¹Œæ–¯åæ¼”","slug":"è«æ¯”ä¹Œæ–¯å‡½æ•° & è«æ¯”ä¹Œæ–¯åæ¼”","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/12/15/è«æ¯”ä¹Œæ–¯å‡½æ•° & è«æ¯”ä¹Œæ–¯åæ¼”/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/15/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%20&%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","excerpt":"","text":"ä¸€. è«æ¯”ä¹Œæ–¯å‡½æ•°å®šä¹‰è®¾æ­£æ•´æ•° $n$ï¼Œæ ¹æ®å”¯ä¸€åˆ†è§£å®šç†åˆ†è§£ä¸º $p_1^{c_1}p_2^{c_2}\\cdots p_k^{c_k}$ã€‚ è«æ¯”ä¹Œæ–¯å‡½æ•°å¯å®šä¹‰ä¸º $\\mu(n)=\\begin{cases}0&amp;(\\exists i,c_i&gt;1)\\(-1)^k&amp;(else)\\end{cases}$ æ€§è´¨ è«æ¯”ä¹Œæ–¯å‡½æ•°æ˜¯ç§¯æ€§å‡½æ•°ï¼Œåˆ†ç±»è®¨è®ºå¯è¯å¾—ã€‚ å› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨çº¿æ€§ç­›æ³•ç­›è«æ¯”ä¹Œæ–¯å‡½æ•°ã€‚ $\\sum\\limits_{d\\mid n}\\mu(d)=\\begin{cases}1&amp;(n=1)\\0&amp;(n&gt;1)\\end{cases}$ è¯æ˜ï¼š $n=1$ æ—¶ï¼Œæ˜¾ç„¶æˆç«‹ã€‚ $n&gt;1$ æ—¶ï¼š \\begin{gather} \\sum\\limits_{d\\mid n}\\mu(d)=\\sum\\limits_{i=0}^{i\\le c_1}\\sum\\limits_{j=0}^{j\\le c_2}\\cdots\\sum\\limits_{x=0}^{x\\le c_k}\\mu(p_1^ip_2^j\\cdots p_k^x)\\\\ =\\sum\\limits_{i=0}^{i\\le 1}\\sum\\limits_{j=0}^{j\\le 1}\\cdots\\sum\\limits_{x=0}^{x\\le 1}\\mu(p_1^ip_2^j\\cdots p_k^x)\\\\ =\\sum\\limits_{i=0}^{i\\le k}\\binom{k}{i}(-1)^i\\\\ =(-1+1)^k\\\\ =0\\\\ \\end{gather} äºŒ. è«æ¯”ä¹Œæ–¯åæ¼”ç¬¬ä¸€å®šç†è‹¥ $F(n)=\\sum\\limits{d\\mid n}f(d)$ï¼Œåˆ™ $f(n)=\\sum\\limits{d\\mid n}\\mu(d)F(\\dfrac{n}{d})$ è¯æ˜ï¼š \\begin{gather} \\text{è‹¥è¯}f(n)=\\sum\\limits_{d\\mid n}\\mu(d)F(\\dfrac{n}{d})\\\\ \\text{å³è¯}f(n)=\\sum\\limits_{d\\mid n}\\mu(d)\\sum\\limits_{g\\mid \\frac{n}{d}}f(g)\\\\ \\text{å³è¯}f(n)=\\sum\\limits_{d\\mid n}\\sum\\limits_{g\\mid \\frac{n}{d}}\\mu(d)f(g)\\\\ \\end{gather}æˆ‘ä»¬åœ¨è¿™é‡Œéœ€è¦è¯æ˜ $\\sum\\limits{d\\mid n}\\sum\\limits{g\\mid \\frac{n}{d}}=\\sum\\limits{g\\mid n}\\sum\\limits{d\\mid \\frac{n}{g}}$ã€‚ ä»€ä¹ˆæƒ…å†µä¸‹è¿™ä¸¤è€…ç­‰ä»·å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥è¿™æ ·ç†è§£ï¼Œæ¯ä¸ª $\\sum$ï¼Œå½¢å¦‚ $\\sum\\limits{i=1}^{i\\le n}$ çš„ä¹Ÿå¥½ï¼Œå½¢å¦‚ $\\sum\\limits{d\\mid n}$ çš„ä¹Ÿç½¢ï¼Œç›¸å½“äºæ˜¯å¾€åä¼ é€’äº†è‹¥å¹²æ¬¡æ•°ï¼Œæ¯”å¦‚ $\\sum\\limits{d\\mid 6}$ å¾€åä¼ é€’çš„æ•°çš„é›†åˆä¸º ${1,2,3,6}$ã€‚ä¸¤ä¸ª $\\sum$ å°±ç›¸å½“äºä¼ é€’äº†è‹¥å¹²æ¬¡æ•°å¯¹ã€‚é‚£ä¹ˆï¼Œè®¾ $\\sum\\limits{d\\mid n}\\sum\\limits{g\\mid \\frac{n}{d}}$ å‘åä¼ é€’çš„æ•°å¯¹æ„æˆçš„é›†åˆä¸º $S_1$ï¼Œ$\\sum\\limits{g\\mid n}\\sum\\limits{d\\mid \\frac{n}{g}}$ å‘åä¼ é€’çš„æ•°å¯¹æ„æˆçš„é›†åˆä¸º $S_2$ï¼ˆå…¶ä¸­æ•°å¯¹çš„ç¬¬ä¸€ä¸ªä½ç½®è¡¨ç¤º $d$ï¼Œç¬¬äºŒä¸ªä½ç½®è¡¨ç¤º $g$ï¼‰ã€‚å¦‚æœæˆ‘ä»¬èƒ½è¯æ˜ $S_1=S_2$ï¼Œæˆ‘ä»¬å°±èƒ½è¯æ˜ $\\sum\\limits{d\\mid n}\\sum\\limits{g\\mid \\frac{n}{d}}=\\sum\\limits{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}$ã€‚ å› ä¸ºæ¯æ¬¡å‘åä¼ é€’çš„æ˜¯ä¸€ä¸ªæ•°å¯¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªçŸ©é˜µæ¥è¡¨ç¤º $S_1$ å’Œ $S_2$ã€‚ å› ä¸º $d$ ä¸¥æ ¼å•è°ƒï¼Œå¯¹äºæ¯ä¸ª $d$ï¼Œ$g$ ä¹Ÿä¸¥æ ¼å•è°ƒï¼Œæ‰€ä»¥ $S_1$ï¼Œ$S_2$ ä¸­å‡æ²¡æœ‰é‡å¤å…ƒç´ ã€‚æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª $0/1$ çŸ©é˜µæ¥è¡¨ç¤º $S_1$ å’Œ $S_2$ã€‚ ä¾‹å¦‚ $n=6$ æ—¶ $\\sum\\limits{d\\mid n}\\sum\\limits{g\\mid \\frac{n}{d}}$ å¯¹åº”çš„ $0/1$ çŸ©é˜µï¼šï¼ˆæ¯ä¸€è¡Œä»£è¡¨ä¸€ä¸ª $d$ çš„å€¼ï¼Œæ¯ä¸€åˆ—ä»£è¡¨ä¸€ä¸ª $g$ çš„å€¼ï¼Œçœç•¥ $0$ï¼‰ \\begin{bmatrix} &1&2&3&4&5&6\\\\ 1&1&1&1& & &1\\\\ 2&1& &1& & & \\\\ 3&1&1& & & & \\\\ 4& & & & & & \\\\ 5& & & & & & \\\\ 6&1& & & & & \\\\ \\end{bmatrix}æ ¹æ®è¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¤§æ¦‚èƒ½çŒœå‡ºç»“è®ºï¼Œè¿™ä¸ªçŸ©é˜µä¸€å®šæ˜¯æ²¿å¯¹è§’çº¿å¯¹ç§°çš„ï¼Œæˆ‘ä»¬æ¥è¯æ˜ï¼š \\begin{gather} \\text{è‹¥}a[i][j]=1\\\\ \\iff j\\mid \\dfrac{n}{i}\\\\ \\iff i\\mid \\dfrac{n}{j}\\\\ \\iff a[j][i]=1\\\\ \\text{è‹¥}a[i][j]=0\\\\ \\iff j\\nmid \\dfrac{n}{i}\\\\ \\iff i\\nmid \\dfrac{n}{j}\\\\ \\iff a[j][i]=0\\\\ \\end{gather}ç”±æ­¤è¯å¾—è¯¥çŸ©é˜µæ²¿å¯¹è§’çº¿å¯¹ç§°ï¼Œç”±äºè¿™æ¡æ€§è´¨ï¼Œå½“ $\\sum\\limits{d\\mid n}\\sum\\limits{g\\mid \\frac{n}{d}}$ ä¸­ $d$ ä¸ $g$ æ›´æ¢ä½ç½®å˜æˆ $\\sum\\limits{g\\mid n}\\sum\\limits{d\\mid \\frac{n}{g}}$ åï¼Œè¡¨ç¤ºæˆçš„çŸ©é˜µä¸å˜ï¼ˆæ³¨æ„è™½ç„¶å…¬å¼ä¸­ $d,g$ äº¤æ¢ä½ç½®ï¼Œä½†çŸ©é˜µæ¯ä¸€è¡Œä»ä»£è¡¨ä¸€ä¸ª $d$ çš„å€¼ï¼Œæ¯ä¸€åˆ—ä»ä»£è¡¨ä¸€ä¸ª $g$ çš„å€¼ã€‚ç”¨å‘åä¼ æ•°å¯¹çš„æ–¹å¼ç†è§£ï¼Œæ•°å¯¹çš„ç¬¬ä¸€ä¸ªä½ç½®ä»è¡¨ç¤º $d$ï¼Œç¬¬äºŒä¸ªä½ç½®ä»è¡¨ç¤º $g$ï¼‰ã€‚æ•… $S1=S_2$ï¼Œè¯å¾— $\\sum\\limits{d\\mid n}\\sum\\limits{g\\mid \\frac{n}{d}}=\\sum\\limits{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}$ã€‚ æ¥ç€ä¸»çº¿è¯æ˜ï¼š \\begin{gather} \\text{å³è¯}f(n)=\\sum\\limits_{g\\mid n}\\sum\\limits_{d\\mid \\frac{n}{g}}\\mu(d)f(g)\\\\ \\text{å³è¯}f(n)=\\sum\\limits_{g\\mid n}f(g)\\sum\\limits_{d\\mid \\frac{n}{g}}\\mu(d)\\\\ \\end{gather}æ ¹æ®è«æ¯”ä¹Œæ–¯å‡½æ•°çš„æ€§è´¨ï¼Œå‘ç°å³éƒ¨çš„å¾ˆå¤šé¡¹éƒ½ä¹˜æœ‰ $0$ï¼Œæ¶ˆå»ä¹˜æœ‰ $0$ çš„é¡¹å¯å¾—ï¼š \\begin{gather} \\text{å³è¯}f(n)=f(n) \\end{gather}æ˜¾ç„¶æˆç«‹ï¼Œè¯æ¯•ã€‚ æœ¬è¯æ˜è¿‡ç¨‹ç”±ä¸ªäººç‹¬è‡ªå®Œæˆï¼Œä¸”å¼•å…¥äº†æ•°å¯¹å’ŒçŸ©é˜µè¾…åŠ©è¯æ˜ï¼Œæ‰€ä»¥éš¾å…æœ‰äº›å•°å—¦ï¼Œè¯»è€…å¯ä»¥æ€è€ƒç®€åŒ–è¯æ˜è¿‡ç¨‹ã€‚ ç¬¬äºŒå®šç†è‹¥ $F(n)=\\sum\\limits{n\\mid d}f(d)$ï¼Œåˆ™ $f(n)=\\sum\\limits{n\\mid d}\\mu(\\dfrac{d}{n})F(d)$ è¯æ˜ï¼š å‰é¢å’Œç¬¬ä¸€å®šç†æ¨å¯¼è¿‡ç¨‹ç›¸åŒï¼Œä¸€ç›´åˆ°è¿™ä¸€æ­¥ï¼š \\begin{gather} \\text{å³è¯}f(n)=\\sum\\limits_{n\\mid d}\\sum\\limits_{d\\mid g}\\mu(\\dfrac{d}{n})f(g)\\\\ \\end{gather}è¿™é‡Œå¼€å§‹å’Œç¬¬ä¸€å…¬å¼çš„æ¨å¯¼ä¸ä¸€æ ·äº†ã€‚è®¾ $dâ€™=\\dfrac{d}{n}$ï¼Œåˆ™ $d=dâ€™n$ï¼Œå¸¦å…¥å¾—ï¼š \\begin{gather} \\text{å³è¯}f(n)=\\sum\\limits_{n\\mid g}\\sum\\limits_{d'\\mid \\frac{g}{n}}\\mu(d')f(g)\\\\ \\end{gather}è§£é‡Šï¼š$n\\mid d\\mid g$ æ‰€ä»¥ $g$ ä¸€å®šèƒ½å»é $n$ çš„æ‰€æœ‰å€æ•°ï¼Œ$dâ€™$ æ˜¯ $\\dfrac{d}{n}$ï¼Œæ‰€ä»¥ä¸€å®šæœ‰ $dâ€™\\mid \\dfrac{g}{n}$ã€‚ æœ‰äººå¯èƒ½ä¼šé—®ï¼Œè¿™ä¸ªæ€ä¹ˆæ— æ³•ç”¨è¯ç¬¬ä¸€å®šç†æ—¶é‚£æ ·ç”¨æ•°å¯¹å’ŒçŸ©é˜µçš„æ–¹å¼è¯æ˜å‘¢ï¼Œå› ä¸ºç¡®å® $\\sum\\limits{n\\mid d}\\sum\\limits{d\\mid g}\\neq\\sum\\limits{n\\mid g}\\sum\\limits{d\\mid g}$ï¼Œä½†æ˜¯è¿™é‡Œè¿™ä¸¤ä¸ª $\\sum$ å·åé¢å¹¶ä¸ä¼šç”¨åˆ° $d$ çš„å€¼ï¼Œåªä¼šç”¨åˆ° $dâ€™$ï¼Œæ‰€ä»¥åªéœ€è¦ä¿è¯ $dâ€™$ ä¸å˜å°±è¡Œäº†ã€‚ å¯¹åº”åˆ°çŸ©é˜µä¸Šæ¥è¯´ï¼Œä»¥ $n=2$ ä¸¾ä¾‹ï¼Œ$\\sum\\limits{n\\mid d}\\sum\\limits{d\\mid g}$ å¯¹åº”çš„çŸ©é˜µï¼š \\begin{bmatrix} &1&2&3&4&5&6\\\\ 1& & & & & & \\\\ 2& &1& &1& &1\\\\ 3& & & & & & \\\\ 4& & & &1& & \\\\ 5& & & & & & \\\\ 6& & & & & &1\\\\ \\end{bmatrix}$\\sum\\limits{n\\mid g}\\sum\\limits{d\\mid g}$ï¼š \\begin{bmatrix} &1&2&3&4&5&6\\\\ 1& &{\\color{red}1}& &{\\color{red}1}& &{\\color{red}1}\\\\ 2& &1& &1& &1\\\\ 3& & & & & &{\\color{red}1}\\\\ 4& & & &1& & \\\\ 5& & & & & & \\\\ 6& & & & & &1\\\\ \\end{bmatrix}å¯ä»¥çœ‹åˆ°ä¸¤è€…ä¸­æœ‰ä¸åŒä¹‹å¤„çš„è¡Œæ‰€å¯¹åº”çš„ $dâ€™\\notin\\mathbb{Z}$ï¼ˆ$\\dfrac{1}{2}$ å’Œ $\\dfrac{3}{2}$ï¼‰ã€‚ ç»§ç»­è¯æ˜ï¼š \\begin{gather} \\text{å³è¯}f(n)=\\sum\\limits_{n\\mid g}\\sum\\limits_{d'\\mid \\frac{g}{n}}\\mu(d')f(g)\\\\ \\end{gather}æ¥ä¸‹æ¥å°±å’Œç¬¬ä¸€å®šç†çš„è¿‡ç¨‹å®Œå…¨ä¸€æ ·äº†ã€‚ åº”ç”¨å¦‚æœæœ‰ä¸¤ä¸ªå‡½æ•° $f(n)$ å’Œ $F(n)$ï¼Œ$F(n)$ å¥½æ±‚ï¼Œ$f(n)$ ä¸å¥½æ±‚ï¼Œè€Œä¸¤è€…é—´åˆæœ‰ $F(n)=\\sum\\limits{d\\mid n}f(d)$ æˆ–è€… $F(n)=\\sum\\limits{n\\mid d}f(d)$ çš„å…³ç³»ï¼Œå¯ä»¥ä½¿ç”¨è«åã€‚ å°æŠ€å·§ï¼šé‡åˆ° $\\sum\\limits{n\\mid d}$ çš„æ—¶å€™ï¼Œå¯ä»¥è®¾ $dâ€™=\\dfrac{d}{n}$ï¼Œåˆ™ $d=dâ€™n$ï¼Œä»£å…¥å¯å¾—è½¬åŒ–ä¸º $\\sum\\limits{dâ€™=1}^{dâ€™&lt;\\infty}$ï¼Œè¿™æ ·å˜é‡å°±æ˜¯è¿ç»­çš„äº†ã€‚ ä¸¤ä¸ªé‡è¦ç»“è®º $\\sum\\limits_{d\\mid n}\\mu(d)=[n=1]$ è¿™æ¡ç»“è®ºä¸»è¦åç€ç”¨ã€‚ $\\sum\\limits{i=1}^{i\\le n}\\sum\\limits{d\\mid i}=\\sum\\limits_{d=1}^{d\\le n}\\lfloor\\dfrac{n}{d}\\rfloor$","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"æ•´é™¤åˆ†å—","slug":"æ•´é™¤åˆ†å—","date":"un22fin22","updated":"un00fin00","comments":true,"path":"2021/12/14/æ•´é™¤åˆ†å—/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/14/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/","excerpt":"","text":"ä¸€. æ ¸å¿ƒå®šç†æ•´é™¤åˆ†å—ï¼Œåˆç§°æ•°è®ºåˆ†å—ï¼Œå…¶æ ¸å¿ƒæ˜¯ä¸€ä¸ªå®šç†ã€‚ å®šç†ï¼šè®¾ $\\operatorname{diff}$ å‡½æ•°ä¸ºæ±‚ä¸åŒæ•°å€¼çš„ä¸ªæ•°ï¼Œå¦‚ $\\operatorname{diff}{1,1,3,4,6,6,6}=4$ï¼Œåˆ™ $\\mathop{\\operatorname{diff}}\\limits_{i=1}^{i\\le n}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$ æœ€å¤§ä¸è¶…è¿‡ $2\\sqrt{n}$ã€‚ è¯æ˜ï¼š è€ƒè™‘ $i\\in[1,\\sqrt{n}]$ï¼Œæœ€å¤š $\\sqrt{n}$ ä¸ªã€‚æ‰€ä»¥ $\\mathop{\\operatorname{diff}}\\limits_{i=1}^{i\\le\\sqrt{n}}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$ æœ€å¤§ä¸è¶…è¿‡ $\\sqrt{n}$ã€‚ è€ƒè™‘ $i\\in(\\sqrt{n},n]$ï¼Œ$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$ çš„å€¼å•è°ƒä¸å¢ã€‚$\\left\\lfloor\\dfrac{n}{\\left\\lceil\\sqrt{n}\\right\\rceil}\\right\\rfloor$ çš„å€¼æœ€å¤§ä¸º $\\sqrt{n}$ï¼Œ$\\left\\lfloor\\dfrac{n}{n}\\right\\rfloor$ ä¸º $1$ã€‚æ‰€ä»¥ $\\mathop{\\operatorname{diff}}\\limits_{i=\\left\\lceil\\sqrt{n}\\right\\rceil}^{i\\le n}\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$ æœ€å¤§ä¸è¶…è¿‡ $\\sqrt{n}$ã€‚ è¯æ¯•ã€‚ äºŒ. ç¡®å®šåˆ†ç•Œç‚¹ä¸Šä¸€ä¸ªæ ‡é¢˜ä¸­ï¼Œæˆ‘ä»¬è®¤è¯†åˆ°æ•´é™¤åˆ†å—å¤æ‚åº¦çš„æ­£ç¡®æ€§ã€‚è¿™ä¸€ä¸ªæ ‡é¢˜å°†ä¼šè®²è§£å¦‚ä½•ç¡®å®šå—ä¸å—ä¹‹é—´çš„åˆ†ç•Œç‚¹ã€‚ è®¾ $g_n(x)$ ä¸ºå¤§äºç­‰äº $x$ ä¸”è¢« $n$ æ•´é™¤çš„å€¼ä¸ $x$ è¢« $n$ æ•´é™¤çš„å€¼ç›¸åŒçš„æœ€å¤§æ•´æ•°ã€‚å¯ç”¨å…¬å¼è¡¨ç¤ºä¸ºï¼š \\left\\lfloor\\dfrac{n}{x}\\right\\rfloor=\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor,\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor>\\left\\lfloor\\dfrac{n}{g_n(x)+1}\\right\\rfloorå®šç†ï¼š$g_n(x)=\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor$ è¯æ˜ï¼šåªè¦è¯æ˜äº†ä¸Šé¢â€œå¯ç”¨å…¬å¼è¡¨ç¤ºä¸ºâ€çš„ä¸¤ä¸ªå¼å­æˆç«‹ï¼Œå³å¯å®Œæˆè¯æ˜ã€‚ è¯æ˜ç¬¬ä¸€ä¸ªå¼å­ é¦–å…ˆå¼•å…¥ä¸‰ä¸ªæ˜¾ç„¶çš„ä¸œè¥¿ï¼š $\\left\\lfloor n\\right\\rfloor\\le n$ã€‚ å¦‚æœ $n\\le m$ï¼Œé‚£ä¹ˆ $\\left\\lfloor n\\right\\rfloor\\le \\left\\lfloor m\\right\\rfloor$ã€‚ å¦‚æœ $n\\in \\mathbb{Z}$ï¼Œé‚£ä¹ˆ $\\left\\lfloor n\\right\\rfloor=n$ã€‚ å¼€å§‹è¯æ˜ï¼š è¯æ˜ $x\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor$ \\begin{gather} \\dfrac{n}{x}\\ge\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\\\ \\text{åˆ}\\because\\dfrac{n}{x},\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\ne0\\\\ \\Longrightarrow\\dfrac{n}{\\frac{n}{x}}\\le\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\\\ \\Longrightarrow\\left\\lfloor\\dfrac{n}{\\frac{n}{x}}\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor\\\\ \\Longrightarrow\\left\\lfloor x\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor\\\\ \\Longrightarrow x\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{x}\\right\\rfloor}\\right\\rfloor\\\\ \\end{gather} è¿™æ¡ç»“è®ºåœ¨æ¥ä¸‹æ¥çš„è¯æ˜ä¸­ä¸€ç›´ä¼šç”¨åˆ°ã€‚ è¿™ä¸€æ­¥ç›¸å½“äºæ˜¯è¯æ˜äº† $x\\le g_n(x)$ã€‚ è¯æ˜ $\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\ge\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor$ \\begin{gather} x\\le g_n(x)\\\\ \\text{åˆ}\\because x,g_n(x)\\ne0\\\\ \\Longrightarrow\\dfrac{n}{x}\\ge\\dfrac{n}{g_n(x)}\\\\ \\Longrightarrow\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\ge\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor\\\\ \\end{gather} è¯æ˜ $\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor$ \\begin{gather} \\text{å³è¯}\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{\\left\\lfloor \\frac{n}{x}\\right\\rfloor}\\right\\rfloor}\\right\\rfloor\\\\ \\text{è®¾}x'=\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor\\\\ \\text{å³è¯}x'\\le\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{\\left\\lfloor x'\\right\\rfloor}\\right\\rfloor}\\right\\rfloor,\\text{è¯¥å¼å·²è¢«è¯æ˜}\\\\ \\end{gather}ç»¼ä¸Šæ‰€è¿°ï¼Œ$\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor=\\left\\lfloor\\dfrac{n}{g_n(x)}\\right\\rfloor$ è¯æ˜ç¬¬äºŒä¸ªå¼å­ æˆ‘ä»¬å…ˆè®¾ä¸€ä¸‹å¸¦ä½™é™¤æ³•ï¼Œå¸¦ä½™é™¤æ³•æ˜¯æ•°è®ºè¯æ˜çš„å¸¸ç”¨æ‰‹æ®µï¼Œå®ƒèƒ½æœ‰æ•ˆåœ°æ¶ˆæ‰ä¸‹å»æ•´å·ã€‚ è®¾ $n=kx+b~(0\\le b&lt;x)$ï¼Œåˆ™ $\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor=k$ã€‚ è®¾ $n=pk+q~(0\\le q&lt;k)$ï¼Œåˆ™ $\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor=p$ã€‚ \\begin{gather} \\text{è‹¥è¯}\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor>\\left\\lfloor\\dfrac{n}{g_n(x)+1}\\right\\rfloor\\\\ \\text{å³è¯}\\left\\lfloor\\dfrac{n}{x}\\right\\rfloor>\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{\\left\\lfloor \\frac{n}{x}\\right\\rfloor}\\right\\rfloor+1}\\right\\rfloor\\\\ \\text{å³è¯}k>\\left\\lfloor\\dfrac{n}{\\left\\lfloor\\frac{n}{k}\\right\\rfloor+1}\\right\\rfloor\\\\ \\text{å³è¯}k>\\left\\lfloor\\dfrac{n}{p+1}\\right\\rfloor\\\\ \\end{gather} è¿™é‡Œéœ€è¦å…ˆè¯ä¸€ä¸ªå°ç»“è®ºï¼šè‹¥ $a,b,c\\in\\mathbb{Z},a&gt;\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor$ï¼Œåˆ™ $ac&gt;b$ã€‚ \\begin{gather} \\because a\\in\\mathbb{Z},a>\\left\\lfloor\\dfrac{b}{c}\\right\\rfloor\\\\ \\therefore a>\\dfrac{b}{c}\\\\ \\therefore ac>b\\\\ \\end{gather} æ¥ç€ä¸»çº¿çš„è¯æ˜ï¼š \\begin{gather} \\text{å³è¯}k(p+1)>n\\\\ \\text{å³è¯}n","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"VisualStudioå¸¸ç”¨è®¾ç½®","slug":"VisualStudioå¸¸ç”¨è®¾ç½®","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/12/12/VisualStudioå¸¸ç”¨è®¾ç½®/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/12/VisualStudio%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"æ–‡ç« ä¸­çš„çš„è®¾ç½®çº¯å±ä¸ªæ€§åŒ–è®¾ç½®ï¼Œä¾æ®è‡ªèº«å–œå¥½è€Œå®šã€‚ â€œé€‰é¡¹â€èœå•ä»â€œé¡¶éƒ¨æ /è°ƒè¯•/é€‰é¡¹â€å³å¯æ‰“å¼€â€œé€‰é¡¹â€èœå•ï¼Œä¹Ÿæœ‰å…¶ä»–æ‰“å¼€â€œé€‰é¡¹â€èœå•çš„æ–¹æ³•ã€‚ æ¥ä¸‹æ¥çš„ 6 æ¡æ“ä½œéƒ½æ˜¯åœ¨â€œé€‰é¡¹â€èœå•ä¸­å®Œæˆçš„ã€‚ ä¸»é¢˜ï¼šï¼ˆâ€œç¯å¢ƒ/è§†è§‰ä½“éªŒ/é¢œè‰²ä¸»é¢˜/â€ï¼‰ æ·±è‰² å­—ä½“ï¼šï¼ˆâ€œç¯å¢ƒ/å­—ä½“ä¸é¢œè‰²/â€ï¼‰ consolas ç²—ä½“ é”®ç›˜ï¼šï¼ˆâ€œç¯å¢ƒ/é”®ç›˜/ -&gt; æœç´¢â€˜ç¼–è¾‘.åˆ‡æ¢è¡Œæ³¨é‡Šâ€™â€ï¼‰ å¿«æ·é”®è®¾ä¸ºâ€ctrl+/â€œ ä»£ç æ ¼å¼è®¾ç½®ï¼šï¼ˆâ€œæ–‡æœ¬ç¼–è¾‘å™¨/ã€Œä½ è¦è®¾ç½®çš„è¯­è¨€ã€/ä»£ç æ ·å¼/æ ¼å¼è®¾ç½®/â€ï¼‰ çœ‹ç€æ”¹æ”¹ï¼ˆæ ¹æ®ä¸ªäººå£å‘³ï¼‰ å¦‚æœæ˜¯å¤§æ‹¬å·ä¸æ¢è¡Œçš„é€‰æ‰‹ï¼Œå‘ç°ç¼–è¾‘ä»£ç çš„æ—¶å€™å¤§æ‹¬å·è‡ªåŠ¨æ¢è¡Œï¼Œæ£€æŸ¥ä¸€ä¸‹è¿™é‡Œæ˜¯ä¸æ˜¯å‹¾é€‰â€œåœ¨}åè‡ªåŠ¨æ ¼å¼åŒ–ç¨‹åºå—â€äº†ï¼Œå¦‚æœæ˜¯çš„è¯å–æ¶ˆå‹¾é€‰ã€‚ åº•éƒ¨çŠ¶æ€æ ï¼šï¼ˆâ€œç¯å¢ƒ/å¸¸è§„/æ˜¾ç¤ºçŠ¶æ€æ /â€ï¼‰ å–æ¶ˆå‹¾é€‰ å¼•ç”¨å’Œä½œè€…æ›´æ”¹é¡¹ï¼šï¼ˆâ€œæ–‡æœ¬ç¼–è¾‘å™¨/æ‰€æœ‰è¯­è¨€/CodeLens/å¯ç”¨CodeLens/â€ï¼‰ å–æ¶ˆå‹¾é€‰ â€œå±æ€§â€èœå•æ­¤æ¡é¢å‘ c++ é€‰æ‰‹ã€‚ åœ¨ç¼–è¯‘ c++ ä»£ç æ—¶ï¼Œå¦‚æœä½ çš„ä»£ç ä¸­æœ‰ scanf ç­‰ç¼–è¯‘å™¨è®¤ä¸ºä¸å®‰å…¨çš„å‡½æ•°ï¼Œå¯èƒ½æ— æ³•æˆåŠŸç¼–è¯‘ã€‚å¦‚æœä½ æƒ³ä½¿ç”¨è¿™äº›å‡½æ•°ï¼Œä½ éœ€è¦çœ‹ä¸€çœ‹è¿™ä¸€æ¡ã€‚ ä»â€œé¡¶éƒ¨æ /è°ƒè¯•/è°ƒè¯•å±æ€§â€å³å¯æ‰“å¼€â€œå±æ€§â€èœå•ï¼Œæˆ–ä»â€œé¡¶éƒ¨æ /é¡¹ç›®/å±æ€§â€æ‰“å¼€ã€‚ æ‰“å¼€â€œå±æ€§â€èœå•åï¼Œè¿›å…¥â€œé…ç½®å±æ€§/Cã€C++/é¢„å¤„ç†å™¨/é¢„å¤„ç†å™¨å®šä¹‰/ç¼–è¾‘/â€ï¼ŒåŠ å…¥â€œ_CRT_SECURE_NO_WARNINGSâ€å³å¯ã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"è½¯ä»¶","slug":"è½¯ä»¶","permalink":"http://rsdbkhusky.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Gdbä¸­è¾“å‡ºæ ¼å¼ä¼˜åŒ–","slug":"Gdbä¸­printçš„å„ç§å‚æ•°å¯¹æ•ˆæœçš„å½±å“","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/12/12/Gdbä¸­printçš„å„ç§å‚æ•°å¯¹æ•ˆæœçš„å½±å“/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/12/Gdb%E4%B8%ADprint%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E5%AF%B9%E6%95%88%E6%9E%9C%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"gdb æ‰“å¼€ / å…³é—­è¾“å‡ºæ ¼å¼ä¼˜åŒ–çš„å‘½ä»¤ 1set p [options] on/off å¸¸ç”¨çš„ options å‚æ•° array array-index pretty åœ¨è¾“å‡ºä¸åŒç§ç±»å˜é‡æ—¶å„ç§æ ¼å¼ä¼˜åŒ–å‚æ•°çš„æ•ˆæœ array array-indexes pretty å…³è”å¼å®¹å™¨ï¼šsetï¼Œmapâ€¦â€¦ $-$ $-$ $\\surd$ åºåˆ—å¼å®¹å™¨ï¼švectorâ€¦â€¦ $\\surd$ $\\surd$ $-$ å®¹å™¨é€‚é…å™¨ï¼šstackï¼Œpriority_queueâ€¦â€¦ $\\surd$ $\\surd$ $-$ æ™®é€šæ•°ç»„ $\\surd$ $\\surd$ $-$ ç»“æ„ä½“æ•°ç»„ $\\surd$ $\\surd$ $\\times$ $\\surd$ï¼šæ·»åŠ ä¼šæå‡æ•ˆæœã€‚ $\\times$ï¼šæ·»åŠ ä¼šé™ä½æ•ˆæœã€‚ $-$ï¼šæ·»ä¸æ·»åŠ å¯¹æ•ˆæœä¸å½±å“ã€‚ ï¼ˆè¿™é‡Œçš„æ•ˆæœçº¯å±ä¸ªäººè§‚ç‚¹ï¼‰ å›¾ç‰‡ç¤ºä¾‹ï¼š","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"åŒæŒ‡é’ˆä¼˜åŒ–dp & Luogu P1973 [NOI2011] NOI å˜‰å¹´å","slug":"åŒæŒ‡é’ˆä¼˜åŒ–dp & Luogu P1973 [NOI2011] NOI å˜‰å¹´å","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/10/13/åŒæŒ‡é’ˆä¼˜åŒ–dp & Luogu P1973 [NOI2011] NOI å˜‰å¹´å/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/13/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P1973%20[NOI2011]%20NOI%20%E5%98%89%E5%B9%B4%E5%8D%8E/","excerpt":"","text":"é¢˜ç›®ä¼ é€é—¨ ä¸€. æ€è·¯é¦–å…ˆè¿›è¡Œç¦»æ•£åŒ–ï¼Œå°†æ‰€æœ‰åŒºé—´å·¦å³ç«¯ç‚¹ç¦»æ•£åŒ–ï¼Œç¦»æ•£æˆ $m$ ä¸ªâ€œç¦»æ•£ç‚¹â€ï¼Œåªæœ‰è¿™äº›åœ°æ–¹æ‰å¯èƒ½è®¾ç½®ä¸ºæ–­ç‚¹ï¼Œä¸ç„¶ä¸€å®šæ˜¯ä¸ä¼˜çš„ã€‚ é¦–å…ˆè€ƒè™‘æœ´ç´  DPï¼Œè®¾ $sec_{l,r}$ ä¸ºå®Œå…¨è¢«åŒ…å«åœ¨ç¦»æ•£ç‚¹ $l\\sim r$ å†…çš„åŒºé—´æ€»æ•°ï¼Œç›´æ¥ $O(n^3)$ æš´åŠ›æ±‚å°±å¥½äº†ã€‚ $pre_{i,j}$ï¼šç¦»æ•£ç‚¹ $1\\sim i$ å†…åŒ…å«çš„åŒºé—´ï¼Œä¸€ä¸ªç»„åˆ†åˆ° $j$ ä¸ªåŒºé—´æ—¶ï¼Œå¦ä¸€ç»„èƒ½åˆ†åˆ°çš„æœ€å¤§å€¼ã€‚æˆ‘ä»¬çš„æ–¹ç¨‹åº”è¯¥å†™æˆè¿™æ ·ï¼š pre_{i,j}=\\max\\limits_{k=1}^{k","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogu U182676 å®Œå…¨å›¾åˆ‡å‰²","slug":"Luogu U182676 å®Œå…¨å›¾åˆ‡å‰²","date":"un33fin33","updated":"un22fin22","comments":true,"path":"2021/10/06/Luogu U182676 å®Œå…¨å›¾åˆ‡å‰²/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/06/Luogu%20U182676%20%E5%AE%8C%E5%85%A8%E5%9B%BE%E5%88%87%E5%89%B2/","excerpt":"","text":"é¢˜ç›®ä¼ é€é—¨ ï¼ˆé¢˜ç›®éåŸåˆ›ï¼‰ ä¸€. æ€è·¯æ²¡æœ‰è¿é€šæ€§é™åˆ¶çš„æƒ…å†µ$f_{i, j}$ï¼š$i$ ä¸ªç‚¹æ‰€æœ‰è¿è¾¹æƒ…å†µçš„ç®€å•æ— å‘å›¾ï¼ˆæ— é‡è¾¹è‡ªç¯ï¼Œä¸è¦æ±‚è¿é€šï¼‰ï¼Œæ¯ç§æƒ…å†µè¾¹æ•° $j$ æ¬¡æ–¹çš„å’Œã€‚ è€ƒè™‘ $f$ çš„é€’æ¨å¼ï¼Œå› ä¸ºæ²¡æœ‰è¿é€šæ€§è¦æ±‚ï¼Œè¾¹éšä¾¿è¿ï¼Œå¯ä»¥è€ƒè™‘æ¯åŠ å…¥ä¸€ä¸ªç‚¹ï¼Œä»–å’Œå…¶ä»–æ‰€æœ‰ç‚¹çš„è¿è¾¹æƒ…å†µï¼Œæ˜¾ç„¶ï¼Œå¦‚æœåŸæ¥æœ‰ $i - 1$ ä¸ªç‚¹ï¼ŒåŠ å…¥ä¸€ä¸ªç‚¹ï¼Œæ–°è¿è¾¹çš„æ‰€æœ‰æƒ…å†µ $\\begin{cases}\\operatorname{C}{i-1}^{0}\\times\\text{æ–°è¿0è¾¹}\\\\operatorname{C}{i-1}^{1}\\times\\text{æ–°è¿1è¾¹}\\\\cdots\\\\operatorname{C}{i-1}^{i-1}\\times\\text{æ–°è¿i-1è¾¹}\\\\end{cases}$ï¼Œè®¾é›†åˆ $T_i=\\begin{cases}\\operatorname{C}{i-1}^{0}\\text{ä¸ª0}\\\\operatorname{C}{i-1}^{1}\\text{ä¸ª1}\\\\cdots\\\\operatorname{C}{i-1}^{i-1}\\text{ä¸ªi-1}\\\\end{cases}$ï¼Œé›†åˆ $F_i$ è¡¨ç¤º $i$ ä¸ªç‚¹æ‰€æœ‰è¿è¾¹æƒ…å†µçš„ç®€å•æ— å‘å›¾çš„è¾¹æ•°æ„æˆçš„é›†åˆã€‚é‚£ä¹ˆï¼š \\begin{gather} \\because F_i=\\left\\{z\\mid z=x+y,x\\in F_{i-1},y\\in T_i\\right\\}\\\\ \\And f_{i,j}=\\sum\\limits_{z\\in F_i}z^j\\\\ \\therefore f_{i,j}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^j\\\\ \\end{gather}$f_{i,j}$ å¯¹äºä¸åŒçš„ $j$ ç»§ç»­æ‹†è§£è¿™ä¸ªå¼å­ï¼š \\begin{gather} f_{i,0}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^0\\\\ =\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}1\\\\ =\\left|F_{i-1}\\right|\\left|T_{i}\\right|\\\\ =f_{i-1,0}\\times2^{i-1}\\\\ \\end{gather} \\begin{gather} f_{i,1}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^1\\\\ =\\sum\\limits_{y\\in T_{i}}\\sum\\limits_{x\\in F_{i-1}}x+\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}y\\\\ =\\left|T_{i}\\right|\\sum\\limits_{x\\in F_{i-1}}x+\\left|F_{i-1}\\right|\\sum\\limits_{y\\in T_{i}}y\\\\ =2^{i-1}\\times f_{i-1}+f_{i-1,0}\\times\\sum\\limits_{y\\in T_{i}}y\\\\ \\end{gather} \\begin{gather} f_{i,2}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^2\\\\ =\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x^2+y^2+2xy)\\\\ =\\sum\\limits_{y\\in T_{i}}\\sum\\limits_{x\\in F_{i-1}}x^2+\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}y^2+2\\sum\\limits_{x\\in F_{i-1}}x\\sum\\limits_{y\\in T_{i}}y\\\\ =2^{i-1}\\times f_{i-1,2}+f_{i-1,0}\\times \\sum\\limits_{y\\in T_{i}}y^2+2\\times f_{i-1,1}\\times \\sum\\limits_{y\\in T_{i}}y \\end{gather}å¯ä»¥é¢„å¤„ç†å‡º $2^i$ã€$\\sum\\limits{y\\in T{i}}y$ å’Œ $\\sum\\limits{y\\in T{i}}y^2$ã€‚ æœ‰è¿é€šæ€§é™åˆ¶çš„æƒ…å†µ$d_{i, j}$ï¼š$i$ ä¸ªç‚¹æ‰€æœ‰ä¿è¯è¿é€šçš„è¿è¾¹æƒ…å†µçš„ç®€å•æ— å‘å›¾ï¼Œæ¯ç§æƒ…å†µè¾¹æ•° $j$ æ¬¡æ–¹çš„å’Œã€‚ $D_i$ï¼š$i$ ä¸ªç‚¹æ‰€æœ‰ä¿è¯è¿é€šçš„è¿è¾¹æƒ…å†µçš„ç®€å•æ— å‘å›¾çš„è¾¹æ•°æ„æˆçš„é›†åˆã€‚ æ­£éš¾åˆ™åï¼Œä¸æ–¹ä¾¿ç›´æ¥æ¨å‡ºç¬¦åˆæ¡ä»¶çš„æƒ…å†µï¼Œå¯ä»¥ç”¨æ€»çš„æƒ…å†µå‡å»ä¸ç¬¦åˆçš„æƒ…å†µã€‚éšæ„é€‰ä¸€ä¸ªç‚¹ä½œä¸ºåŸºå‡†ï¼Œæšä¸¾è¿™ä¸ªç‚¹æ‰€åœ¨è¿é€šå—çš„å¤§å°ï¼Œæ˜¾ç„¶è¿™ä¸ªç‚¹æ‰€åœ¨è¿é€šå—ä¸€å®šè¿é€šï¼ˆåºŸè¯ï¼‰ï¼Œå‰©ä½™ç‚¹è¿é€šæ€§éšæ„ï¼Œå¦‚æœèŠ‚ç‚¹æ€»æ•° $i$ åŸºå‡†èŠ‚ç‚¹æ‰€åœ¨è¿é€šå—å¤§å°ä¸º $k$ï¼Œé™¤å»é‚£ä¸ªåŸºå‡†èŠ‚ç‚¹ä¸€å®šè¢«é€‰ï¼Œå‰©ä½™ç‚¹ä¸­è¦é€‰ $k-1$ ä¸ªä½œä¸ºè¿é€šå—ä¸­çš„å…¶ä»–èŠ‚ç‚¹ï¼Œæ–¹æ¡ˆæ•° $\\operatorname{C}_{i-1}^{k-1}$ã€‚ \\begin{gather} d_{i,j}=f_{i,j}-\\sum\\limits_{k=1}^{k","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"çº¿æ®µæ ‘å¥—çŸ©é˜µ & Luogu P7453 [THUSCH2017] å¤§é­”æ³•å¸ˆ","slug":"çº¿æ®µæ ‘å¥—çŸ©é˜µ & Luogu P7453 [THUSCH2017] å¤§é­”æ³•å¸ˆ","date":"un00fin00","updated":"un66fin66","comments":true,"path":"2021/09/05/çº¿æ®µæ ‘å¥—çŸ©é˜µ & Luogu P7453 [THUSCH2017] å¤§é­”æ³•å¸ˆ/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97%E7%9F%A9%E9%98%B5%20&%20Luogu%20P7453%20[THUSCH2017]%20%E5%A4%A7%E9%AD%94%E6%B3%95%E5%B8%88/","excerpt":"","text":"é¢˜ç›®ä¼ é€é—¨ æœ¬æ–‡åˆ†æ€è·¯ï¼ˆçº¿æ®µæ ‘å¥—çŸ©é˜µçš„åŸç†ï¼‰ï¼Œç»†èŠ‚å’Œå¡å¸¸ï¼Œä»£ç ä¸‰ä¸ªéƒ¨åˆ†ï¼Œå¤§å®¶å¯ä»¥ç›´æ¥è·³åˆ°è‡ªå·±æƒ³çœ‹çš„ç« èŠ‚ã€‚ é›¶. å‰ç½®çŸ¥è¯†1. çº¿æ®µæ ‘ ä¸ºä»€ä¹ˆæˆ‘çš„é“¾æ¥æŒ‡å‘çš„æ˜¯çº¿æ®µæ ‘ 2ï¼Œ è€Œä¸æ˜¯ 1ï¼Ÿè‡ªç„¶æ˜¯å› ä¸ºæœ¬é¢˜ä¸­çº¿æ®µæ ‘å«æœ‰åŒºé—´ä¹˜çš„è¦æ±‚ï¼ˆè™½ç„¶æ²¡äº†åŒºé—´åŠ ï¼‰ï¼Œå¼ºçƒˆå»ºè®®è¦å†™è¿™é“é¢˜çš„åŒå­¦å…ˆç†Ÿç»ƒå†™å‡ºè¿™é“é¢˜ï¼ˆæˆ‘å°±æ˜¯çº¿æ®µæ ‘æ²¡å†™å¯¹è°ƒäº†å¥½é•¿æ—¶é—´ï¼‰ã€‚ 2. çŸ©é˜µè¿ç®— å»ºè®®å°†çŸ©é˜µè¿›è¡Œå°è£…å¹¶é‡è½½è¿ç®—ç¬¦ï¼Œå› ä¸ºåœ¨æœ¬ä½“çš„å¤§ç é‡ä¸‹ä¸é‡è½½ä¸ªè¿ç®—ç¬¦å†™èµ·æ¥çœŸçš„å¾ˆéš¾å—ã€‚ ä¸€. çº¿æ®µæ ‘å¥—çŸ©é˜µï¼ˆæ€è·¯ï¼‰ å¦‚æœè¿™é¢˜åªè¦æ±‚æˆ‘ä»¬ç»´æŠ¤ä¸€ç§å…ƒç´ ï¼Œæˆ–æ˜¯å„ç§å…ƒç´ ä¹‹é—´æ²¡æœ‰å½±å“ï¼Œé‚£è¿™å°±æ˜¯ä¸ªçº¿æ®µæ ‘çš„æ¿é¢˜ã€‚å…³é”®æ˜¯è¿™å‡ ç§å…ƒç´ ä¼šç›¸äº’å½±å“ã€‚ ä½†æ˜¯æˆ‘ä»¬å‘ç°ï¼Œè¿™äº›æ“ä½œå…¶å®éƒ½å¯ä»¥é€šè¿‡çŸ©é˜µä¹˜æ³•æ¥å®ç°ã€‚æ¯”å¦‚æ“ä½œä¸€ï¼ˆG çŸ©é˜µå°±æ˜¯æˆ‘ä»£ç ä¸­å˜é‡åä¸º G çš„çŸ©é˜µï¼‰ï¼š æ“ä½œå››ï¼š ï¼ˆå…¶ä»–æ“ä½œçš„è½¬ç§»çŸ©é˜µè§â€œä¸‰. ä»£ç â€ï¼‰ çº¿æ®µæ ‘ä¸Šçš„çŸ©é˜µåªéœ€å¼€ $1 \\times 4$ï¼ˆè€Œæˆ‘å¼€äº† $4 \\times 4$ï¼Œä¸è¿‡ä¹Ÿå¡è¿‡å»äº†ï¼‰ï¼Œå…¶ä¸­ä¸‰åˆ—çš„ä¸Šç»´æŠ¤ä¸‰ç§å…ƒç´ ï¼Œå¦ä¸€åˆ—ç»´æŠ¤å¸¸æ•° $1$ã€‚ è½¬ç§»çŸ©é˜µéœ€è¦å¼€ $4 \\times 4$ã€‚ é‚£ä¹ˆæ¯ä¸ªæ“ä½œå°±æ˜¯å°†ä¸€ä¸ªåŒºé—´ä¸Šçš„æ‰€æœ‰çŸ©é˜µä¹˜ä¸Šä¸€ä¸ªæ•°çŸ©é˜µï¼Œå¦‚æœæŠŠä¸€ä¸ªçŸ©é˜µçœ‹ä½œä¸€ä¸ªæ•°ï¼Œé‚£è¿™å°±æ˜¯çº¿æ®µæ ‘è£¸é¢˜ï¼Œæ‰€ä»¥ï¼ŒæŠŠä¸€ä¸ªæ”¯æŒåŒºé—´ä¹˜å’Œæ±‚åŒºé—´å’Œçš„çº¿æ®µæ ‘çš„ mul æ•°ç»„ï¼ˆä¹˜æ³•æ‡’æ ‡è®°ï¼‰å’Œ sum æ•°ç»„ï¼ˆåŒºé—´å’Œï¼‰çš„æ•°æ®ç±»å‹æ”¹ä¸º $4 \\times 4$ çŸ©é˜µæˆ– $1 \\times 4$ å‘é‡ï¼Œmul[xxx] = 1 æ”¹ä¸º mul[xxx] = I ï¼ˆIï¼šå•ä½çŸ©é˜µï¼‰å°±è¡Œäº†ã€‚ äºŒ. å¡å¸¸ ä¸è¦ä½¿ç”¨ long longï¼Œæœ‰æº¢å‡ºé£é™©çš„åœ°æ–¹ç”¨å¼ºåˆ¶è½¬æ¢å°±å¥½äº†ã€‚ ä½¿ç”¨å¿«è¯»æˆ–ï¼š 123std::ios::sync_with_stdio(false);std::cin.tie(nullptr);std::cout.tie(nullptr); å¼€ O2ã€‚ å¦‚æœè¿˜å¡ä¸è¿‡å»ï¼Œé‚£å°±åº”è¯¥è¯•è¯•å°†çº¿æ®µæ ‘ä¸Šçš„ $4 \\times 4$ çŸ©é˜µæ¢æˆ $1 \\times 4$ çš„å‘é‡ã€‚ ä¸‰. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;cstdio&gt;#include&lt;cstring&gt;#define re registertypedef long long ll;const int MAXn = 2e5 + 5e4;const int MAXmat = 4;const int MOD = 998244353;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;struct Mat &#123; int mat[MAXmat][MAXmat]; Mat() &#123; memset(mat, 0, sizeof(mat)); &#125; Mat(int a[MAXmat][MAXmat]) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = a[i][j]; &#125; &#125; &#125; inline void operator=(Mat x) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = x.mat[i][j]; &#125; &#125; &#125; inline Mat operator+(Mat x) &#123; Mat ans; for (int i = 0; i &lt; MAXmat; ++i) &#123; for (int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = ((ll)mat[i][j] + x.mat[i][j]) % MOD; &#125; &#125; return ans; &#125; inline Mat operator*(Mat x) &#123; Mat ans; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int k = 0; k &lt; MAXmat; ++k) &#123; int a = mat[i][k]; for (re int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = ((ll)a * x.mat[k][j] + ans.mat[i][j]) % MOD; &#125; &#125; &#125; return ans; &#125; inline Mat operator^(int x) &#123; Mat ans, base; for (re int i = 0; i &lt; MAXmat; ++i) &#123; ans.mat[i][i] = 1; &#125; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; base.mat[i][j] = mat[i][j]; &#125; &#125; while (x) &#123; if (x &amp; 1) &#123; ans = ans * base; &#125; base = base * base; x &gt;&gt;= 1; &#125; return ans; &#125;&#125;;int I_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat I(I_);int le[MAXn * 4 + 10], ri[MAXn * 4 + 10];Mat sum[MAXn * 4 + 10], mul[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = (sum[id &lt;&lt; 1] + sum[(id &lt;&lt; 1) + 1]);&#125;inline void pushdown(int id) &#123; sum[id &lt;&lt; 1] = (sum[id &lt;&lt; 1] * mul[id]); sum[(id &lt;&lt; 1) + 1] = (sum[(id &lt;&lt; 1) + 1] * mul[id]); mul[id &lt;&lt; 1] = (mul[id &lt;&lt; 1] * mul[id]); mul[(id &lt;&lt; 1) + 1] = (mul[(id &lt;&lt; 1) + 1] * mul[id]); mul[id] = I;&#125;void BuildUseArr(int id, int l, int r, Mat *a) &#123; le[id] = l; ri[id] = r; mul[id] = I; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(id &lt;&lt; 1, l, mid, a); BuildUseArr((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;void Mul(int id, int l, int r, Mat k) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; mul[id] = (mul[id] * k); sum[id] = (sum[id] * k); &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Mul(id &lt;&lt; 1, l, r, k); if (r &gt; mid) Mul((id &lt;&lt; 1) + 1, l, r, k); pushup(id); &#125;&#125;Mat Sum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; Mat ans; if (l &lt;= mid) ans = Sum(id &lt;&lt; 1, l, r); if (r &gt; mid) ans = (ans + Sum((id &lt;&lt; 1) + 1, l, r)); return ans; &#125;&#125;int n, m;Mat a[MAXn + 10], G;int A_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;1, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat A(A_);int B_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 1, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat B(B_);int C_[MAXmat][MAXmat] = &#123; &#123;1, 0, 1, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;,&#125;;Mat C(C_);int D_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;, // [3][0] = v&#125;;Mat D(D_);int E_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 1, 0&#125;, &#123;0, 0, 0, 1&#125;, // [1][1] = v&#125;;Mat E(E_);int F_[MAXmat][MAXmat] = &#123; &#123;1, 0, 0, 0&#125;, &#123;0, 1, 0, 0&#125;, &#123;0, 0, 0, 0&#125;, &#123;0, 0, 0, 1&#125;, // [3][2] = v&#125;;Mat F(F_);signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i].mat[0][0]), read(a[i].mat[0][1]), read(a[i].mat[0][2]); a[i].mat[0][3] = 1; &#125; BuildUseArr(1, 1, n, a); read(m); for (re int i = 1, opt, l, r, v; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(l), read(r); Mul(1, l, r, A); break; case 2: read(l), read(r); Mul(1, l, r, B); break; case 3: read(l), read(r); Mul(1, l, r, C); break; case 4: read(l), read(r), read(v); D.mat[3][0] = v; Mul(1, l, r, D); break; case 5: read(l), read(r), read(v); E.mat[1][1] = v; Mul(1, l, r, E); break; case 6: read(l), read(r), read(v); F.mat[3][2] = v; Mul(1, l, r, F); break; case 7: read(l), read(r); G = Sum(1, l, r); printf(&quot;%d %d %d\\n&quot;, G.mat[0][0], G.mat[0][1], G.mat[0][2]); break; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P2518 [HAOI2010]è®¡æ•°","slug":"è®¡æ•°","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2021/09/02/è®¡æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/02/%E8%AE%A1%E6%95%B0/","excerpt":"","text":"é¢˜ç›®ä¼ é€é—¨ ä¸€. æ€è·¯1. æ‹†åˆ†åŸæ•°ï¼ˆæ•°ä½DPæ€æƒ³ï¼‰æ±‚æŸä¸ªåŒºé—´çš„æ•°ä¸­æ»¡è¶³æŸä¸ªæ¡ä»¶çš„æ•°çš„ä¸ªæ•°ï¼Œè¿™æ˜¯å…¸å‹çš„æ•°ä½ DP é¢˜çš„å¥—è·¯ã€‚äºæ˜¯æˆ‘ä»¬å¯ä»¥è¯•ç€æ‹†åˆ†è¿™ä¸ªæ•°ï¼ŒæŠŠ [0, åŸæ•°) è¿™ä¸ªåŒºé—´æŒ‰ä½æ‹†æˆä¸€äº›åŒºé—´ï¼š æˆ‘ä»¬åªéœ€è®¡ç®—å‡ºæ‰€æœ‰æ•´å—åŒºé—´ä¸­æ»¡è¶³æ¡ä»¶çš„æ•°å¹¶æ±‚å’Œå°±å¥½äº†ã€‚ 2. å¤„ç†æ¯ä¸ªåŒºé—´ï¼ˆå¤šé‡é›†æ’åˆ—ï¼‰æ‰€è°“ç¬¦åˆè¦æ±‚ï¼Œå°±æ˜¯ç”±åŸæ•°ä¸­çš„æ¯ä¸€ä½ä¸Šçš„éé›¶æ•°å’Œä»»æ„ä¸ªé›¶æŒ‰ä½æ‹¼å‡‘è€Œæˆã€‚çœ‹ä¼¼è¿™ä¸ªè¦æ±‚ä¸å¥½å¤„ç†ï¼Œå®åˆ™å®Œå…¨å¯ä»¥é€šè¿‡å¤šé‡é›†æ’åˆ—å¾—å‡ºã€‚ å¤šé‡é›†æ’åˆ—ï¼Œå°†ä¸€ä¸ªå¯ä»¥æœ‰é‡å¤å…ƒç´ çš„é›†åˆä¸­çš„å…ƒç´ è¿›è¡Œæ’åˆ—çš„æ–¹æ¡ˆæ•°ï¼Œå¦‚ï¼š{1, 3, 3}ï¼Œå¤šé‡é›†æ’åˆ—ï¼š[1, 3, 3]ï¼Œ[3, 1, 3]ï¼Œ[3, 3, 1]ï¼Œå…±ä¸‰ç§ã€‚è¿™ç¯‡æ–‡ç« ä¸­è®¾å¤šé‡é›†æ’åˆ—çš„ç¬¦å·ä¸º $\\operatorname{Pmult}(cnt_1, cnt_2 \\ldots cnt_n)$ï¼Œå¦‚ {1, 3, 3} çš„æ’åˆ—æ˜¯ $\\operatorname{Pmult}(1, 2)$ã€‚ åº”ç”¨åˆ°è¿™é¢˜ä¸Šæ¥å°±æ˜¯ä¾‹å¦‚ [0, 1000) è¿™ä¸ªåŒºé—´ï¼Œé¦–ä½æ˜¯ â€œ0â€ï¼Œé™¤äº†é¦–ä½å¤–è¿˜æœ‰ 3 ä½ï¼Œæœ‰ä¸¤ä¸ªéé›¶æ•°å­— â€œ1â€ï¼Œâ€2â€ã€‚ç­”æ¡ˆå°±æ˜¯ ä¸€ä¸ª â€œ1â€ï¼Œä¸€ä¸ª â€œ2â€ï¼Œä¸€ä¸ª â€œ0â€ï¼ˆâ€0â€ çš„ä¸ªæ•°ä¸ºé™¤é¦–ä½å¤–çš„ä½æ•° - éé›¶ä½æ•°ï¼‰ï¼Œå³ $\\operatorname{Pmult}(1, 1, 1)$ã€‚ å¤šé‡é›†æ’åˆ—çš„è®¡ç®—å…¬å¼å°±æ˜¯ï¼š \\operatorname{Pmult}(cnt_1, cnt_2 \\ldots cnt_n) = \\operatorname{C}_{sumcnt}^{cnt_1} \\times \\operatorname{C}_{sumcnt - cnt_1}^{cnt_2} \\times \\ldots \\times \\operatorname{C}_{sumcnt - cnt_1 - cnt_2 - \\ldots - cnt_{n - 1}}^{cnt_n}~~~~(sumcnt = \\sum\\limits_{i = 1}^n cnt_i)ç®€ç•¥è¯æ˜å°±æ˜¯ä½ æœ‰ $sumcnt$ ä¸ªç©ºï¼Œå…ˆå°† $cnt1$ ä¸ªç›¸åŒç‰©å“æ”¾è¿›å»ï¼Œå°±æ˜¯ $\\operatorname{C}{sumcnt}^{cnt_1}$ ç§ï¼Œç©ºçš„æ•°é‡å˜ä¸º $sumcnt - cnt_1$ ä¸ªï¼Œä»¥æ­¤ç±»æ¨ã€‚ 3. ä»£ç å®ç°ä¸­çš„ç»†èŠ‚ï¼š æ‹†åˆ†åŸæ•°æ˜¯ä»é«˜ä½å¾€ä½ä½ã€‚æ¯ä¸€æ¬¡å¤„ç†å®Œä¸€ä½å¤„ç†ä¸‹ä¸€ä½ä¹‹å‰ï¼Œå¦‚æœè¿™ä¸€ä½éé›¶ï¼Œå°† cnt æ•°ç»„ä¸­è¿™ä¸€ä½æ•°å­—çš„æ•°é‡å‡ä¸€ï¼Œå› ä¸ºä¹‹åå¤„ç†çš„æ›´ä½ä½ä¸­ï¼Œé«˜ä½æ˜¯ç¡®å®šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´æ— æ³•åœ¨ä½¿ç”¨é«˜ä½çš„è¿™ä¸ªæ•°å­—äº†ã€‚å¦‚ â€œ1020â€ å¤„ç†å®Œ [0, 1000) åï¼Œä¹‹åæ‰€æœ‰åŒºé—´çš„åƒä½éƒ½æ˜¯ â€œ1â€ï¼Œ â€œ1â€ æ— æ³•å†å‚ä¸æ’åˆ—ï¼Œæ‰€ä»¥ç›´æ¥ --cnt[1]ã€‚ å¤„ç†æŸä¸ªéé›¶ä½æ—¶ï¼Œå…ˆæšä¸¾è¯¥ä½ï¼Œå°†è¿˜å‰©ä¸‹çš„æ•°ï¼ˆè¿˜å‰©ä¸‹ â€œxâ€ï¼Œå³ cnt[x] &gt; 0ï¼‰ä¸­å°äºæ”¹ä½åŸæ•°çš„ä¾æ¬¡å¡«åˆ°è¯¥ä½ï¼Œå†ç”¨å¤šé‡é›†æ’åˆ—ç®—å‡ºå‰©ä¸‹çš„ä½çš„æ’åˆ—æ•°ã€‚ï¼ˆå…·ä½“è§ä»£ç ï¼‰ é‡åˆ°ä¸ºé›¶çš„ä½å¦‚ â€œ1020â€ ä¸­ä¸ªä½å’Œç™¾ä½ï¼Œä»–ä»¬æ‹†åˆ†å‡ºçš„åŒºé—´æ²¡æœ‰æ•°ï¼Œç›´æ¥è·³è¿‡å°±å¥½ï¼Œä¸æµªè´¹ç¨‹åºè¿è¡Œæ—¶é—´ã€‚ äºŒ. ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans; // cnt[x]: &quot;x&quot;æ•°è¿˜å¯å‚ä¸æ’åˆ—çš„æ•°é‡ï¼Œä¹Ÿå°±æ˜¯&quot;x&quot;åœ¨å½“å‰ä½å’Œæ¯”å½“å‰ä½ä½çš„ä½ä¸­çš„æ•°é‡ã€‚ // cnt[10]: åœ¨å½“å‰ä½å’Œæ¯”å½“å‰ä½ä½çš„ä½ä¸­&quot;0&quot;çš„æ•°é‡ã€‚ // sumcnt: Sum&#123;cnt[1] ~ cnt[9]&#125;ï¼Œç”¨äºè®¡ç®—&quot;0&quot;çš„ä¸ªæ•°ã€‚signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P3225 [HNOI2012]çŸ¿åœºæ­å»º","slug":"çŸ¿åœºæ­å»º","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/08/18/çŸ¿åœºæ­å»º/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/18/%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/","excerpt":"","text":"ä¸€. æ€è·¯0. å‰ç½®çŸ¥è¯†ï¼šå‰²ç‚¹ï¼Œv-dccï¼ˆå†è¯´ä¸€éï¼Œæ— å‘å›¾æœ‰çš„æ˜¯åŒè¿é€šåˆ†é‡ï¼Œæ²¡æœ‰å¼ºè¿é€šåˆ†é‡ä¸€è¯´ï¼ï¼‰ã€‚â€‹ è¿™é‡Œæ¨èå‡ é“æ¨¡æ¿é¢˜ï¼Œå­¦ä¹  Tarjan å»ºè®®æŠŠä»–ä»¬éƒ½ A äº†ï¼š dcc å‰²è¾¹ï¼šLuogu Stdã€‚ dcc å‰²ç‚¹ï¼šLuogu Stdã€‚ e-dccï¼šLuogu Stdã€‚ v-dccï¼šLuogu Stdã€‚ sccï¼šLuogu Stdã€‚ scc ç¼©ç‚¹ï¼šLuoguã€‚ ï¼ˆæ²¡æœ‰æ‰¾åˆ°åŒè¿é€šåˆ†é‡çš„ç¼©ç‚¹æ¨¡æ¿ï¼ŒçŸ¥é“çš„å°ä¼™ä¼´æ¬¢è¿åœ¨è¯„è®ºä¸­è¡¥å……ï¼‰ è“ä¹¦ä¸Šè¿™éƒ¨åˆ†è®²çš„å¾ˆè¯¦ç»†ã€‚ é‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬ä»¥è¿™ä¸ªå›¾ä¸ºä¾‹è®²è§£æ­¤é¢˜ï¼š å‘½åä¸‰ä¸ªåŒè¿é€šåˆ†é‡ä¸ºï¼šAï¼ŒBï¼ŒCã€‚çº¢è‰²çš„ä¸ºå‰²ç‚¹ã€‚ 1. ä¸€ä¸ªåŒ…å«ä¸€ä¸ªå‰²ç‚¹çš„åŒè¿é€šåˆ†é‡ï¼ˆAï¼ŒCï¼‰ éå‰²ç‚¹åå¡Œï¼š æ²¡æœ‰å…³ç³»ï¼Œæ¯”å¦‚ A ä¸­ 1 å·ç‚¹åå¡Œï¼Œ3 å·ç‚¹ä¸­çš„äººå¯ä»¥æ¥åˆ°å‰²ç‚¹ï¼ˆ2 å·ç‚¹ï¼‰ï¼Œç„¶åå»å¾€å…¶ä»–åŒè¿é€šåˆ†é‡ä¸­çš„å‡ºå£é€ƒç”Ÿã€‚ å‰²ç‚¹åå¡Œï¼š æ¯”å¦‚ 2 å·å¡Œäº†ï¼Œ1 å·å’Œ 3 å·ä¸­å°±å¿…é¡»æœ‰ä¸€ä¸ªå‡ºå£ã€‚ ç»¼ä¸Šï¼Œå¯¹äºåŒ…å«ä¸€ä¸ªå‰²ç‚¹çš„åŒè¿é€šåˆ†é‡ï¼Œéœ€è¦å»º $1$ ä¸ªå‡ºå£ï¼Œæ–¹æ¡ˆæ•°ä¸º $\\operatorname{size} - 1$ã€‚ï¼ˆ$\\operatorname{size}$ï¼šè¯¥ dcc å¤§å°ï¼‰ã€‚ 2. ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªåŠä»¥ä¸Šä¸ªå‰²ç‚¹çš„åŒè¿é€šåˆ†é‡ï¼ˆBï¼‰ éå‰²ç‚¹åå¡Œï¼šï¼ˆåŒ 1 - 1ï¼‰ å‰²ç‚¹åå¡Œï¼š è¿™æ¬¡æƒ…å†µä¸åŒäº†ï¼Œå¡Œäº†ä¸€ä¸ªå‰²ç‚¹ï¼Œè¿˜æœ‰è‡³å°‘ä¸€ä¸ªå‰²ç‚¹å¯ä»¥ä¾›é‡Œé¢çš„å·¥äººç¦»å¼€è¿™ä¸ª dccã€‚ ç»¼ä¸Šï¼Œå¯¹äºåŒ…å«ä¸¤ä¸ªåŠä»¥ä¸Šä¸ªå‰²ç‚¹çš„åŒè¿é€šåˆ†é‡ï¼Œæ ¹æœ¬æ— éœ€å»ºå‡ºå£ã€‚ çœ‹åˆ°è¿™é‡Œï¼Œå¾ˆå¤šäººæœ‰ é—®é¢˜ äº†ï¼šå¦‚æœå…¨æ˜¯åŒ…å«ä¸¤ä¸ªåŠä»¥ä¸Šä¸ªå‰²ç‚¹çš„ dccï¼Œæ‰€æœ‰äººæ€»æƒ³ç€å¾€å…¶ä»– dcc è·‘ï¼Œå…¶ä»– dcc å´ä¹Ÿæ²¡å‡ºå£æ€ä¹ˆåŠã€‚é‚£ä¹ˆæ­å–œä½ ï¼Œè¿™ç§æƒ…å†µæ ¹æœ¬ä¸å¯èƒ½æˆç«‹ã€‚æ¯”å¦‚æœ‰ä¸€åœˆåƒ B ä¸€æ ·çš„ dcc æ‹¼åœ¨ä¸€èµ·ï¼š ä½†å†ä»”ç»†çœ‹ï¼Œä¸€å½“å½¢æˆç¯ï¼Œå‰²ç‚¹å°±ç›´æ¥æ²¡æœ‰äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸Šå›¾ 4 ä¸ªçº¢è‰²ç‚¹éƒ½åº”è¯¥æ˜¯ç™½è‰²çš„ï¼Œè¿™å°±æ˜¯ç¬¬ä¸‰ç§æƒ…å†µï¼ˆå¾…ä¼šè¦è®²ï¼‰ã€‚ è€Œå¦‚æœç¯ä¸åˆæ‹¢ï¼Œä¸¤ç«¯å¿…ç„¶å­˜åœ¨åŒ…å«ä¸€ä¸ªå‰²ç‚¹çš„ dccï¼Œä¹Ÿå°±è‡ªç„¶èƒ½æˆåŠŸé€ƒç¦»ï¼š 3. ç¯å¦‚æœæ˜¯ä¸€ä¸ªç¯ï¼Œçœ‹ä¸Šå»å»ºä¸€ä¸ªå‡ºå£å°±è¡Œäº†ï¼Œä½†è¿˜è¦è€ƒè™‘å‡ºå£åå¡Œçš„æƒ…å†µï¼æ‰€ä»¥éœ€è¦å»º $2$ ä¸ªå‡ºå£ã€‚æ–¹æ¡ˆæ•°ä¸º $\\operatorname{C}^2_{\\operatorname{size}} = \\dfrac{\\operatorname{size} \\times (\\operatorname{size} - 1)}{2}$ã€‚ 4. æœ€ç»ˆç»“æœ å‡ºå£æ•°ï¼šå°†æ‰€æœ‰ dcc å»ºçš„å‡ºå£æ•°ç›¸åŠ ã€‚ æ–¹æ¡ˆæ•°ï¼šå°†æ‰€æœ‰ dcc çš„æ–¹æ¡ˆæ•°ç›¸ä¹˜ã€‚ï¼ˆä¹˜æ³•åŸç†ï¼‰ äºŒ. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e4;const int MAXm = 3e5;template &lt;class T&gt;inline void read(T&amp; a) &#123; re char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); re T x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125;a = x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int top, stk[MAXn + 10], cntdcc;vector&lt;int&gt; dcc[MAXn + 10];bool is[MAXn + 10];int root, cntdfs, dfs[MAXn + 10], low[MAXn + 10];void Init() &#123; cntnex = top = root = cntdfs = 0; memset(head, 0, sizeof(head)); memset(nex, 0, sizeof(nex)); memset(to, 0, sizeof(to)); memset(stk, 0, sizeof(stk)); memset(is, 0, sizeof(is)); memset(dfs, 0, sizeof(dfs)); memset(low, 0, sizeof(low)); for (re int i = 1; i &lt;= cntdcc; ++i) &#123; dcc[i].clear(); &#125; cntdcc = 0;&#125;void Tarjan(int cur) &#123; int times = 0; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; ++cntdcc; dcc[cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (dfs[cur] &lt;= low[to[i]]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; is[cur] = 1; &#125; ++cntdcc; int instk; do &#123; instk = stk[top--]; dcc[cntdcc].push_back(instk); &#125; while (instk != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; else &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; &#125;&#125;int n, m;signed main() &#123; int T = 0; while (~scanf(&quot;%lld&quot;, &amp;m)) &#123; if (m == 0) &#123; break; &#125; ++T; n = 0; Init(); for (re int i = 1, u, v; i &lt;= m; ++i) &#123; read(u), read(v); n = max(n, u); n = max(n, v); if (u == v) &#123; continue; &#125; Insert(u, v); Insert(v, u); &#125; for (re int i = n; i; --i) &#123; if (!dfs[i]) &#123; root = i; Tarjan(i); &#125; &#125;// é™¤æ ¸å¿ƒä»¥å¤–çš„éƒ½æ˜¯çº¯æ¿å­// ---------------æ ¸å¿ƒ--------------- int ans1 = 0, ans2 = 1; for (re int i = 1; i &lt;= cntdcc; ++i) &#123; int cnt = 0; for (re vector&lt;int&gt;::iterator j = dcc[i].begin(); j != dcc[i].end(); ++j) &#123; if (is[*j]) &#123; ++cnt; &#125; &#125; if (cnt == 1) &#123; ++ans1; ans2 *= dcc[i].size() - 1; &#125; else if (cnt == 0) &#123; ans1 += 2; ans2 *= dcc[i].size() * (dcc[i].size() - 1) / 2; &#125; &#125;// ---------------æ ¸å¿ƒ--------------- printf(&quot;Case %lld: %lld %lld\\n&quot;, T, ans1, ans2); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Luogu P4544 [USACO10NOV]Buying Feed G","slug":"Buying Feed G","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Buying Feed G/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Buying%20Feed%20G/","excerpt":"","text":"P4544 USACO10NOV Buying Feed Gæ”¾åœ¨å‰é¢ï¼šæœ¬æ–¹æ³•æ—¶é—´å¤æ‚åº¦ä¸º $O(nW)$ ï¼Œå•è°ƒé˜Ÿåˆ—ä¼˜åŒ– DPã€‚æœ¬é¢˜è¿˜æœ‰ä¸€é“å¼±åŒ–ç‰ˆï¼Œæ¬¢è¿å¤§ä½¬åˆ‡å®Œè¿™é¢˜é¡ºä¾¿æŠŠé‚£é¢˜ä¹Ÿåˆ‡äº†ï¼Œå¹¶æ¬¢è¿å¤§å®¶æ¥è¯¥é¢˜é¢˜è§£çœ‹æˆ‘çš„å¦ä¸€ç¯‡åšå®¢ã€‚ ä¸€. å˜é‡å£°æ˜ï¼š $W$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $K$ï¼Œåˆ°å®¶æ—¶åº”å¸¦çš„é¥²æ–™å¨æ•°ï¼Œç›¸å½“äºèƒŒåŒ…ä¸­çš„èƒŒåŒ…æœ€å¤§æ‰¿é‡ï¼ˆweightï¼‰ã€‚ $n$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $N$ï¼Œå•†åº—æ•°é‡ï¼Œç›¸å½“äºèƒŒåŒ…é—®é¢˜ä¸­çš„ç‰©å“æ•°ã€‚ $x_i$ï¼šåŒé¢˜ç›®ä¸­çš„ $x_i$ã€‚ $w_i$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $f_i$ï¼Œå•†åº— $i$ é£Ÿç‰©æ•°é‡ã€‚ $v_i$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $c_i$ï¼Œå•†åº— $i$ é£Ÿç‰©å•ä»·ã€‚ äºŒ. æ€è·¯1. æ€è€ƒè§£æ³• è·¯çº¿ä¸Šåé¢çš„å•†åº—ä¸ä¼šå½±å“è·¯çº¿å‰åŠéƒ¨åˆ†çš„æœ€ä¼˜è§£ï¼Œç¬¦åˆæ— åæ•ˆæ€§ã€‚ æœ‰æœ€å¤§å®¹é‡ $W$ï¼Œæœ‰å¯é€‰æ‹©çš„ç‰©å“ï¼Œæ¯ä¸ªç‰©å“æœ‰é‡é‡å’Œä»·å€¼ï¼Œæ˜æ˜¾æ˜¯èƒŒåŒ…ç±»é—®é¢˜ã€‚ æ‰€ä»¥è€ƒè™‘èƒŒåŒ… DPã€‚ 2. åˆå§‹çŠ¶æ€$d_{i,j}=\\begin{cases} 0&amp;(i=0~\\land~j=0)\\ \\infty&amp;(else) \\end{cases}$ 3. ç»“æŸçŠ¶æ€$d_{\\operatorname{home},W}$ ï¼ˆ$\\operatorname{home}$ï¼šè§ä»£ç å’Œä»£ç ä¸­çš„æ³¨é‡Šï¼‰ 4. ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹$d_{i,j}$ï¼šå·²ç»ç»è¿‡å‰ $i$ ä¸ªå•†åº—ï¼ˆå·²åˆ° $i$ å·å•†åº—ä¹°äº†ä¸œè¥¿ä½†è¿˜æ²¡æœ‰å¾€ $i+1$ å·èµ°ï¼‰ä¸”æ°å¥½ä¸€å…±ä¹°äº† $j$ ä»½é£Ÿç‰©æ—¶æœ€å°‘èŠ±è´¹çš„è´¹ç”¨ã€‚ æœ¬é¢˜å°±æ˜¯ä¸€é“æ”¹è£…ç‰ˆçš„å¤šé‡èƒŒåŒ…é—®é¢˜ï¼Œå°±åŠ äº†ä¸€ä¸ªè½¬ç§»èŠ±è´¹ï¼Œè½¬ç§»èŠ±è´¹æ€ä¹ˆæ±‚å‘¢ï¼Ÿ$i$ åº—ä¸ä¸Šä¸€å®¶åº—è·ç¦»å·®ä¸º $xi-x{i-1}$ï¼Œè‹¥åœ¨ $i$ å·åº—ä¹‹å‰ä¹°çš„é£Ÿç‰©ä»½æ•°ä¸€å…±ä¸º $k$ ï¼Œåœ¨ $i$ åº—è´­ç‰©åè½¦ä¸Šçš„é£Ÿç‰©ä»½æ•°ä¸º $j$ï¼Œåˆ™è¿™æ®µè·¯ä¸Šè½¦è¾†è¿é€çš„é£Ÿç‰©æ•°ä¸º $k$ã€‚è½¬ç§»èŠ±è´¹å°±æ˜¯ $(xi-x{i-1})\\times k^2$ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œæœ´ç´ çŠ¶è½¬æ–¹ç¨‹ï¼š$d{i,j}=\\min{k=0}^{k\\leqslant j}\\left{d{i-1,k}+(x_i-x{i-1})\\times k^2+v_i\\times (j-k)\\right}$ 5. å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–ï¼ˆé‡ç‚¹ï¼‰æšä¸¾ $i$ å¤æ‚åº¦ä¸º $O(n)$ï¼Œæšä¸¾ $j$ å¤æ‚åº¦ä¸º $O(W)$ï¼Œæšä¸¾ $k$ æœ€åæƒ…å†µä¸‹å¤æ‚åº¦ä¹Ÿæ˜¯ $O(W)$ã€‚æ€»å¤æ‚åº¦ $O(nW^2)$ æ˜¾ç„¶ä¼šè¶…ã€‚é‚£ä¹ˆè®©æˆ‘ä»¬è§‚å¯Ÿä¸€ä¸‹çŠ¶è½¬æ–¹ç¨‹ï¼š ~~~~~~~~d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2+v_i\\times (j-k)\\right\\}\\Longrightarrow d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times k+v_i\\times j\\right\\}é‡ç‚¹ä¸€ ï¼šè§‚å¯Ÿä¸Šé¢è¿™ä¸ªæ‹†äº†ä¸ªæ‹¬å·çš„æ–¹ç¨‹ï¼Œå·¦è¾¹æ˜¯æˆ‘ä»¬è¦å»æ±‚çš„çŠ¶æ€ï¼Œåœ¨è¯¥çŠ¶æ€ä¸‹ï¼Œ$i$ å’Œ $j$ æ˜¯å·²çŸ¥çš„ï¼Œå› ä¸ºè¯¥çŠ¶æ€å°±æ˜¯ç”± $i$ å’Œ $j$ å®šä¹‰çš„ï¼Œ$i$ å’Œ $j$ åœ¨ä¸€ä¸ªå…·ä½“çš„çŠ¶æ€ä¸‹ä¸ºå¸¸é‡ï¼ˆæˆ–è€…æ¢ä¸€ç§è§£é‡Šï¼š$i$ å’Œ $j$ æ˜¯ç”¨ for å¾ªç¯æšä¸¾å‡ºæ¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å½“ç„¶çŸ¥é“ä»–çš„å€¼ï¼‰ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°† $v_i\\times j$ æå‡ºæ‹¬å·ã€‚å¯å¾—ï¼š \\Longrightarrow d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times k\\right\\}+v_i\\times jé‡ç‚¹äºŒï¼šè¿™ä¸ªæ–¹ç¨‹ä¸­çš„å˜é‡åªæœ‰ $k$ï¼Œè€Œåˆæœ‰ $k\\leqslant j$ï¼Œå› ä¸ºåœ¨ $i$ åº—è´­ç‰©åçš„é£Ÿç‰©æ•°ä¸å¯èƒ½ä½äºè´­ç‰©å‰ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–ã€‚å•è°ƒé˜Ÿåˆ—ä¸­å­˜æ”¾çš„å°±æ˜¯ $\\min$ å†…çš„éƒ¨åˆ† $d{i-1,k}+(x_i-x{i-1})\\times k^2-vi\\times k$ ï¼ˆåœ¨è¿™é‡Œæˆ‘ä»¬æŠŠå®ƒç§°ä½œ $calc{i,k}$ï¼‰ï¼Œå¯¹äºæ¯ä¸€ä¸ª $i$ ï¼Œå°† $j$ ä» $0$ åˆ° $W$ æšä¸¾ä¸€éï¼Œå¯¹äºæ¯ä¸ª $j$ å…ˆå°†å®ƒä½œä¸º $k$ è®¡ç®— $calc{i,k}$ å¹¶æ”¾åˆ°å•è°ƒé˜Ÿåˆ—ä¸­ï¼Œå†å…ˆè®¡ç®—çŠ¶æ€ $d{i.j}$ã€‚ ä¸‰. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define re register#define int long longconst int MAXn = 500;const int MAXW = 10000;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;template &lt;class T&gt;inline T min(T a, T b) &#123; return a &lt; b ? a : b;&#125;struct Shop &#123; int x; int w; int v; Shop(): x(0), w(0), v(0)&#123;&#125; Shop(int x_, int w_, int v_): x(x_), w(w_), v(v_) &#123;&#125; inline bool operator &lt; (Shop &amp;a) &#123; return this-&gt;x &lt; a.x; &#125;&#125;;Shop shop[MAXn + 10];int W, n, d[MAXn + 10][MAXW + 10];int head, tail, que[MAXW + 10];inline int calc(int i, int k) &#123; return d[i - 1][k] + (shop[i].x - shop[i - 1].x) * k * k - shop[i].v * k;&#125;signed main() &#123; int E; read(W), read(E), read(n); shop[0] = Shop(0, 0, 0); //æœ¬äººå°†èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆå®¶ï¼‰æ—¶å½“åšé£Ÿç‰©æ•°ä¸º 0 çš„å•†åº—ï¼Œè¿™æ ·èƒ½é¿å…ç‰¹åˆ¤ï¼Œæ‰€ä»¥â€œhomeâ€å°±æ˜¯n+1 for (re int i = 1, x, w, v; i &lt;= n; ++i) &#123; read(x), read(w), read(v); shop[i] = Shop(x, w, v); &#125; shop[n + 1] = Shop(E, 0, 0); //åŒä¸Š sort(shop, shop + n + 2); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (re int i = 1; i &lt;= n + 1; ++i) &#123; //iï¼šå½“å‰é˜¶æ®µæ˜¯åœ¨å“ªä¸ªåº— head = 1; tail = 0; for (re int j = 0; j &lt;= W; ++j) &#123; //jï¼šå½“å‰çŠ¶æ€è¦æ±‚åœ¨æ­¤å¤„å•†åº—è´­ä¹°åè½¦ä¸Šæœ‰å¤šå°‘é¥²æ–™ while (calc(i, que[tail]) &gt; calc(i, j) &amp;&amp; head &lt;= tail) --tail; if (j - que[head] &gt; shop[i].w &amp;&amp; head &lt;= tail) ++head; que[++tail] = j; d[i][j] = calc(i, que[head]) + shop[i].v * j; &#125; &#125; printf(&quot;%lld&quot;, d[n + 1][W]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogu CF679A Bear and Prime 100","slug":"Bear and Prime 100","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Bear and Prime 100/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Bear%20and%20Prime%20100/","excerpt":"","text":"CF679A Bear and Prime 100ä¸€. å®¡é¢˜ï¼š1. å‰ææ¡ä»¶ï¼š æ—  2. è¯¢é—® &amp; è¾“å…¥ï¼š è¯¢é—®ï¼šï¼ˆæœ€å¤š $20$ æ¬¡ï¼‰ è¾“å‡ºä¸€ä¸ªæ•° $x$ï¼Œä»£è¡¨è¯¢é—® $x$ æ˜¯å¦æ˜¯è¢«çŒœæ•°çš„çº¦æ•°ã€‚ è¾“å…¥ï¼š è¯»å…¥ä¸€ä¸ªå­—ç¬¦ yes æˆ– no ä»£è¡¨è¿™ä¸ªæ•°æ˜¯å¦æ˜¯è¢«çŒœæ•°çš„çº¦æ•°ã€‚ 3. è¾“å‡ºï¼š è¯¥æ•°æ˜¯å¦æ˜¯ç´ æ•°ã€‚ äºŒ. æ€è·¯ æˆ‘ä»¬çŸ¥é“è´¨æ•°çš„å› æ•°æœ‰ä¸”åªæœ‰ $1$ å’Œè‡ªå·±ï¼Œä¹Ÿå°±æ˜¯ $1$ å’Œä¸€ä¸ªè´¨æ•°ã€‚æ‰€ä»¥ç¬¬ä¸€æ„Ÿè§‰æ˜¯æŠŠ $1-100$ çš„è´¨æ•°é—®ä¸€éã€‚ä½†å¾ˆå¿«å‘ç°è¯¢é—®æ¬¡æ•°ä¸å¤Ÿã€‚è€Œä¸”ä¹Ÿç”¨ä¸ç€ï¼Œå› ä¸ºï¼Œå¦‚æœåªé—® 1-50 å†…çš„è´¨æ•°ï¼š å¦‚æœæœ‰2ä¸ªåŠä»¥ä¸Šçš„ $yes$ å›ç­”ï¼Œç›´æ¥åˆ¤æ–­ä¸ºåˆæ•°ã€‚ å¦‚æœæœ‰ä¸€ä¸ª $yes$ å›ç­”ï¼Œ$51-100$ ä¸å¯èƒ½æœ‰å› æ•°ï¼Œé‚£æ ·æ‰€çŒœæ•°å°±è¶…100äº†ã€‚ å¦‚æœæ—  $yes$ å›ç­”ï¼Œ$51-100$ å¿…æœ‰ä¸”åªæœ‰ä¸€ä¸ªå› æ•°ï¼Œå°±æ˜¯ä»–æœ¬èº«å‘€ã€‚æ‰€ä»¥é—® $51-100$ çš„è´¨æ•°æ˜¯æ— æ„ä¹‰çš„ã€‚ é—®å®Œè´¨æ•°è¿˜ä¸å¤Ÿï¼Œä¾‹å¦‚ 4 å°±åˆ¤æ–­ä¸å‡ºæ¥ï¼Œå› ä¸ºæœ¬äº¤äº’ç¨‹åºåªåˆ¤æ–­æœ‰æ²¡æœ‰è¿™ä¸ªå› æ•°ï¼Œä¸èƒ½è¯´å‡ºè¯¥å› æ•°ä¸ªæ•°ã€‚æ‰€ä»¥è¿˜å¾—åˆ¤æ–­è´¨æ•°çš„å¹³æ–¹æ•°ï¼ˆ$100$ ä»¥å†…çš„ï¼‰ ä¸‰. ä»£ç å› ä¸ºæ¯ä¸ªè¾“å‡ºåéƒ½è·Ÿäº†endlï¼Œæ‰€ä»¥ä¸éœ€è¦åŠ fflush(stdout)ã€‚ 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int primes[20] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47&#125;; //1-50å†…è´¨æ•°ï¼Œå…±15ä¸ªint sq_nums[10] = &#123;4, 9, 25, 49&#125;; //è´¨æ•°çš„å¹³æ–¹æ•°(100ä»¥å†…çš„) string feedback; //äº¤äº’è¿”å›çš„å­—ç¬¦ä¸²bool once; //æ˜¯å¦å·²ç»è¿”å›è¿‡ä¸€æ¬¡yesäº†int main() &#123; for (int i = 0; i &lt; 15; ++i) &#123; cout &lt;&lt; primes[i] &lt;&lt; endl; cin &gt;&gt; feedback; if (feedback == &quot;yes&quot;) &#123; if (!once) &#123; once = 1; &#125; else &#123; cout &lt;&lt; &quot;composite&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; cout &lt;&lt; sq_nums[i] &lt;&lt; endl; cin &gt;&gt; feedback; if (feedback == &quot;yes&quot;) &#123;//è¿™äº›å¹³æ–¹æ•°æœ¬æ¥å°±æ˜¯åˆæ•°ï¼Œæ‰€ä»¥åªè¦è¿”å›1æ¬¡yeså°±å¯ä»¥åˆ¤æ–­äº† cout &lt;&lt; &quot;composite&quot; &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; &quot;prime&quot; &lt;&lt; endl; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogo P2616 [USACO10JAN]Buying Feed, II S","slug":"Buying Feed, II S","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Buying Feed, II S/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Buying%20Feed,%20II%20S/","excerpt":"","text":"P2616 USACO10 JANBuying Feed, II Sæ”¾åœ¨å‰é¢ï¼šä¸ºå¯¹åº”â€œæ™®åŠ-â€çš„éš¾åº¦ï¼Œæœ¬æ–‡è®²è§£çš„æ˜¯ $O(nW^2)$ å¤æ‚åº¦çš„æœ´ç´  DPï¼Œå¦‚æƒ³æŒ‘æˆ˜æ›´é«˜éš¾åº¦è¯·è¿› Hereï¼Œå¹¶æ¬¢è¿å¤§å®¶æ¥è¯¥é¢˜é¢˜è§£çœ‹æˆ‘çš„å¦ä¸€ç¯‡åšå®¢ä¸Šçš„ $O(nW)$ è§£æ³•ã€‚ ä¸€. å˜é‡å£°æ˜ï¼š $W$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $K$ï¼Œåˆ°å®¶æ—¶åº”å¸¦çš„é¥²æ–™å¨æ•°ï¼Œç›¸å½“äºèƒŒåŒ…ä¸­çš„èƒŒåŒ…æœ€å¤§æ‰¿é‡ï¼ˆweightï¼‰ã€‚ $n$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $N$ï¼Œå•†åº—æ•°é‡ï¼Œç›¸å½“äºèƒŒåŒ…é—®é¢˜ä¸­çš„ç‰©å“æ•°ã€‚ $x_i$ï¼šåŒé¢˜ç›®ä¸­çš„ $x_i$ã€‚ $w_i$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $f_i$ï¼Œå•†åº— $i$ é£Ÿç‰©æ•°é‡ã€‚ $v_i$ï¼šä»£æ›¿é¢˜ç›®ä¸­çš„ $c_i$ï¼Œå•†åº— $i$ é£Ÿç‰©å•ä»·ã€‚ äºŒ. æ€è·¯1. æ€è€ƒè§£æ³• è·¯çº¿ä¸Šåé¢çš„å•†åº—ä¸ä¼šå½±å“è·¯çº¿å‰åŠéƒ¨åˆ†çš„æœ€ä¼˜è§£ï¼Œç¬¦åˆæ— åæ•ˆæ€§ã€‚ æœ‰æœ€å¤§å®¹é‡ $W$ï¼Œæœ‰å¯é€‰æ‹©çš„ç‰©å“ï¼Œæ¯ä¸ªç‰©å“æœ‰é‡é‡å’Œä»·å€¼ï¼Œæ˜æ˜¾æ˜¯èƒŒåŒ…ç±»é—®é¢˜ã€‚ æ‰€ä»¥è€ƒè™‘èƒŒåŒ… DPã€‚ 2. åˆå§‹çŠ¶æ€$d_{i,j}=\\begin{cases} 0&amp;(i=0~\\land~j=0)\\ \\infty&amp;(else) \\end{cases}$ 3. ç»“æŸçŠ¶æ€$d_{\\operatorname{home},W}$ ï¼ˆ$\\operatorname{home}$ï¼šè§ä»£ç å’Œä»£ç ä¸­çš„æ³¨é‡Šï¼‰ 4. ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹$d_{i,j}$ï¼šå·²ç»ç»è¿‡å‰ $i$ ä¸ªå•†åº—ï¼ˆå·²åˆ° $i$ å·å•†åº—ä¹°äº†ä¸œè¥¿ä½†è¿˜æ²¡æœ‰å¾€ $i+1$ å·èµ°ï¼‰ä¸”æ°å¥½ä¸€å…±ä¹°äº† $j$ ä»½é£Ÿç‰©æ—¶æœ€å°‘èŠ±è´¹çš„è´¹ç”¨ã€‚ æœ¬é¢˜å°±æ˜¯ä¸€é“æ”¹è£…ç‰ˆçš„å¤šé‡èƒŒåŒ…é—®é¢˜ï¼Œå°±åŠ äº†ä¸€ä¸ªè½¬ç§»èŠ±è´¹ï¼Œè½¬ç§»èŠ±è´¹æ€ä¹ˆæ±‚å‘¢ï¼Ÿ$i$ åº—ä¸ä¸Šä¸€å®¶åº—è·ç¦»å·®ä¸º $xi-x{i-1}$ï¼Œè‹¥åœ¨ $i$ å·åº—ä¹°çš„é£Ÿç‰©ä»½æ•°ä¸º $k$ ï¼Œåœ¨ $i$ åº—è´­ç‰©åè½¦ä¸Šçš„é£Ÿç‰©ä»½æ•°ä¸º $j$ï¼ˆ$j$ å’Œ $k$ è¿™ä¸¤ä¸ªé‡éƒ½æ˜¯ for å¾ªç¯æšä¸¾å‡ºæ¥çš„ï¼‰ï¼Œåˆ™è¿™æ®µè·¯ä¸Šè½¦è¾†è¿é€çš„é£Ÿç‰©æ•°ä¸º $j-k$ã€‚è½¬ç§»èŠ±è´¹å°±æ˜¯ $(xi-x{i-1})\\times (j-k)$ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼ŒçŠ¶è½¬æ–¹ç¨‹ï¼š$d{i,j}=\\min{k=0}^{k\\leqslant wi}\\left{d{i-1,j-k}+(xi-x{i-1})\\times (j-k)+v_i\\times k\\right}$ ä¸‰. ä»£ç ä»£ç ä¸­æœ‰ä¸€äº›ä¾‹å¦‚æ„é€ å‡½æ•°å’Œé‡è½½è¿ç®—ç¬¦ä¸€æ ·çš„æŠ€å·§ï¼Œè¿™äº›æš‚æ—¶ä¸ä¼šä¹Ÿä¸å¦¨ç¢ç†è§£ç®—æ³•ï¼Œåªéœ€çœ‹ main å‡½æ•°ä¸­çš„å†…å®¹å°±è¡Œäº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define re registerconst int MAXn = 500;const int MAXW = 10000;template &lt;class T&gt; //æ¨¡æ¿å‡½æ•°inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;inline int min(int a, int b) &#123; return a &lt; b ? a : b;&#125;struct Shop &#123; int x; int w; int v; Shop(): x(0), w(0), v(0)&#123;&#125; //æ„é€ å‡½æ•° Shop(int x_, int w_, int v_): x(x_), w(w_), v(v_) &#123;&#125; //åŒä¸Š inline bool operator &lt; (Shop &amp;a) &#123; //é‡è½½è¿ç®—ç¬¦ return this-&gt;x &lt; a.x; &#125;&#125;;Shop shop[MAXn + 10];int W, n, d[MAXn + 10][MAXW + 10];int main() &#123; int E; read(W), read(E), read(n); shop[0] = Shop(0, 0, 0); //æœ¬äººå°†èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆå®¶ï¼‰æ—¶å½“åšé£Ÿç‰©æ•°ä¸º 0 çš„å•†åº—ï¼Œè¿™æ ·èƒ½é¿å…ç‰¹åˆ¤ï¼Œæ‰€ä»¥â€œhomeâ€å°±æ˜¯n+1 for (re int i = 1, x, w, v; i &lt;= n; ++i) &#123; read(x), read(w), read(v); shop[i] = Shop(x, w, v); &#125; shop[n + 1] = Shop(E, 0, 0); //åŒä¸Š sort(shop, shop + n + 2); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (re int i = 1; i &lt;= n + 1; ++i) &#123; //iï¼šå½“å‰é˜¶æ®µæ˜¯åœ¨å“ªä¸ªåº— for (re int j = W; j &gt;= 0; --j) &#123; //jï¼šå½“å‰çŠ¶æ€è¦æ±‚è½¦ä¸Šæœ‰å¤šå°‘é¥²æ–™ for (re int k = 0; k &lt;= shop[i].w; ++k) &#123; //kï¼šå½“å‰è½¬ç§»ä¸­è¦ä»æœ¬åº—ä¹°å¤šå°‘é¥²æ–™ if (j &lt; k) continue; d[i][j] = min(d[i][j], d[i - 1][j - k] + (shop[i].x - shop[i - 1].x) * (j - k) + k * shop[i].v); &#125; &#125; &#125; printf(&quot;%d&quot;, d[n + 1][W]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogu CF727C Guess the Array","slug":"Guess the Array","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Guess the Array/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Guess%20the%20Array/","excerpt":"","text":"CF727C Guess the Arrayæ³¨ï¼šæœ¬æ–‡å«äº¤äº’é¢˜ endl ä¸ fflush ä¸åŒç§ç±»çš„é…åˆä½¿ç”¨æ•ˆæœçš„ æµ‹è¯•ï¼ˆè§ â€œå››â€ï¼‰ ä¸€. å®¡é¢˜ï¼š1. å‰ææ¡ä»¶ï¼š ä¸€ä¸ªæ•° $n$ ä»£è¡¨æ•°ç»„ä¸­æ•°çš„ä¸ªæ•°ã€‚ 2. è¯¢é—® &amp; è¾“å…¥ï¼š è¯¢é—®ï¼š è¾“å‡ºä¸¤ä¸ªæ•° $x$ï¼Œ$y$ ã€‚ä»£è¡¨è¯¢é—® $a_x$ å’Œ $a_y$ çš„å’Œã€‚ æ ¼å¼ï¼š? x y è¾“å…¥ï¼š è¯»å…¥ä¸€ä¸ªæ•°ä»£è¡¨è¿™ä¸¤ä¸ªæ•°çš„å’Œã€‚ 3. è¾“å‡ºï¼š æ•°ç»„ä¸­æ‰€æœ‰æ•°çš„å€¼ã€‚æ ¼å¼ï¼š! a[1] a[2] a[3] ... a[n] äºŒ. æ€è·¯1. æ€è€ƒè§£æ³•æˆ‘ä»¬å¯ä»¥ä¸ä¸€å£æ°”æŠŠ $n$ æ¬¡éƒ½è¯¢é—®å®Œï¼ˆå½“ç„¶æœ€åè‚¯å®šæ˜¯éƒ½è¦è¯¢é—®å®Œçš„ï¼‰ï¼Œæ—¢ç„¶ $n$ ä¸ªæ•°è¯¢é—® $n$ æ¬¡ä¸€å®šæœ‰è§£ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å…ˆè¯¢é—® $a_1+a_2$ ï¼Œ $a_2+a_3$ ä»¥åŠ $a_3+a_1$ ã€‚è¿™æ ·å°±èƒ½å…ˆè®¡ç®—å‡º $a_1$ï¼Œ$a_2$ ä»¥åŠ $a_3$ã€‚ åªè¦æœ‰äº†ä¸€ä¸ªæ•°çš„å…·ä½“å€¼ï¼Œæˆ‘ä»¬æ¯è¯¢é—®ä¸€æ¬¡å°±å¯ä»¥ç®—å‡ºä¸€ä¸ªæ•°çš„å…·ä½“å€¼ï¼Œè¿™æ ·ä¸€æ°”å‘µæˆï¼Œé¿å…äº†ä¸€å£æ°”è¯¢é—®å®Œåå †ç§¯è¿‡å¤šæ¡ä»¶æ— ä»ä¸‹æ‰‹çš„æƒ…å†µã€‚ 2. å…·ä½“å®ç° å‰ä¸‰ä¸ªæ•°ï¼š è§£æ³•æœ‰å¾ˆå¤šï¼Œå¦‚ \\ \\ \\ \\ \\begin{cases}x+y=a\\\\y+z=b\\\\z+x=c\\end{cases}\\Longrightarrow 2x+2y+2z=a+b+c\\Longrightarrow x+y+z=\\dfrac{a+b+c}{2}\\Longrightarrow x=\\dfrac{a+b+c}{2}-b $y$ï¼Œ$z$ åŒç†ã€‚ å‰©ä¸‹çš„æ•°ï¼š æ¥ä¸‹æ¥è¯¢é—®$a_1+a_4$ï¼Œ$a_1+a_5$ . . . $a_1+a_n$ã€‚ ä¸‰. ä»£ç 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5000;int n;int add12,add13,add23; //addxy:ç¬¬xä¸ªå’Œç¬¬yä¸ªæ•°çš„å’Œint add[MAXn + 10]; //add[x]:ç¬¬1ä¸ªå’Œç¬¬xä¸ªæ•°çš„å’Œint first; //ç¬¬ä¸€ä¸ªæ•°çš„å€¼int main() &#123; scanf(&quot;%d&quot;, &amp;n); cout &lt;&lt; &quot;? 1 2&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add12); cout &lt;&lt; &quot;? 2 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add23); cout &lt;&lt; &quot;? 1 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add13);//è¿™é‡Œç”¨äº†endlå°±ä¸éœ€è¦fflush(stdout)äº† first = (add13 - add23 + add12) &gt;&gt; 1;//è¯»å…¥å‰ä¸‰ä¸ªæ•°é—´ä¸¤ä¸¤å€¼å¾—å’Œï¼Œå¹¶è®¡ç®—ç¬¬ä¸€ä¸ªæ•° for (int i = 4 ; i &lt;= n; ++i) &#123; cout &lt;&lt; &quot;? 1 &quot; &lt;&lt; i &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add[i]); &#125;//è¯»å…¥ç¬¬1ä¸ªæ•°å’Œç¬¬4-nä¸ªæ•°é—´ä¸¤ä¸¤çš„å€¼ cout &lt;&lt; &quot;! &quot; &lt;&lt; first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add12 - first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add23 - add12 + first; fflush(stdout); for(int i = 4; i &lt;= n; ++i) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; add[i] - first; &#125;&#125; å››. endl ä¸ fflushå¯¹äº¤äº’é¢˜æ¥è¯´ï¼Œå¼„æ¸…æ¥š endl å’Œ fflush æ€ä¹ˆç”¨æ ¼å¤–é‡è¦ã€‚ä¸å¤šåºŸè¯äº†ï¼Œç›´æ¥æ‘†ä¸Šæµ‹è¯•ç»“æœï¼š ç»“è®ºï¼šendl åé¢ ä¸ç”¨è·Ÿ fflushï¼Œä½†å¦‚æœæ²¡æœ‰ endl ï¼ˆæˆ–æ˜¯ç”¨ printfï¼‰è¦åŠ ä¸Š fflush(stdout)ã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogu P1654 OSU!","slug":"OSU!","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/07/21/OSU!/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/OSU!/","excerpt":"","text":"P1654 OSU!æ”¾åœ¨å‰é¢ï¼šè¿™æ˜¯ä¸€é“æœŸæœ›dpå¤§æ°´é¢˜ï¼Œå±äºé‚£ç§çœ‹é¢˜è§£ä¸€çœ‹å°±ä¼šï¼Œè‡ªå·±å†™ä¸€å†™å°±åºŸçš„é‚£ç§ã€‚ ä¸€. æ€è·¯ï¼ˆä¸æƒ³çœ‹æˆ‘å‰é¢å” å¨å°±ç›´æ¥çœ‹ä»£ç å§ï¼‰ 1. ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹$d_i$ï¼š$i$ æ¬¡æ“ä½œåå¾—çš„åˆ†æ•°ã€‚åˆ™ $E(d_i)$ï¼š$i$ æ¬¡æ“ä½œåæœŸæœ›çš„çš„åˆ†æ•°ã€‚ ç¬¬ $i$ è½®åï¼Œå¾—åˆ†å‘ç”Ÿäº†æ€æ ·çš„å˜åŒ–äº†å‘¢ï¼Ÿæˆ‘ä»¬å…ˆåªçœ‹ä»æœ€è¿‘ä¸€æ¬¡å¤±è´¥åç®—èµ·çš„æˆåŠŸçš„ä¸€æ®µï¼Œ$i$ è½®å‰å¾—åˆ†æ˜¯ $x^3$ï¼Œå¦‚æœä½ $i$ æ¬¡æˆåŠŸï¼Œ$i$ è½®åæ˜¯ $(x+1)^3=x^3+3x^2+3x+1$ï¼Œåä¹‹æ˜¯ $0$ã€‚å˜åŒ–äº† $3x^2+3x+1$ã€‚å†åŠ ä¸Šä¹‹å‰çš„å¾—åˆ† $d_{i-1}$ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œå·²çŸ¥æˆè´¥æƒ…å†µçš„çŠ¶è½¬æ–¹ç¨‹ï¼š $xi=\\begin{cases}0&amp;(fail)\\x{i-1}+1&amp;(success)\\end{cases}$ ${x^2}i=\\begin{cases}0&amp;(fail)\\{x^2}{i-1}+2x_{i-1}+1&amp;(success)\\end{cases}$ $di=d{i-1}+\\begin{cases}0&amp;(fail)\\3{x^2}{i-1}+3x{i-1}+1&amp;(success)\\end{cases}$ è®¾ç¬¬ $i$ æ¬¡æˆåŠŸçš„å‡ ç‡ä¸º $prob_i$ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼ŒæœŸæœ›çŠ¶è½¬æ–¹ç¨‹ï¼š \\begin{aligned} E(x)_i&=prob_i\\times (E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &=prob_i\\times (E(x)_{i-1}+1) \\\\ E({x^2})_i&=prob_i\\times(E({x^2})_{i-1}+2E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &=prob_i\\times(E({x^2})_{i-1}+2E(x)_{i-1}+1) \\\\ E(d)_i&=E(d)_{i-1}+prob_i\\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &=E(d)_{i-1}+prob_i\\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1) \\\\ \\end{aligned}2. å‘ç‚¹ $E(a^2)\\ne E(a)^2$ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸èƒ½å°†çŠ¶è½¬æ–¹ç¨‹ä¸­çš„ $E(x^2)$ ç”¨ $E(x)$ è¡¨ç¤ºã€‚ $d\\ne x^3$ $d$ æ¯” $x^3$ è¿˜é¢å¤–éœ€è¦è€ƒè™‘ä¹‹å‰çš„ç´¯è®¡å¾—åˆ†ï¼Œä¹Ÿå°±æ˜¯ $di$ è¦åŠ ä¸Š $d{i-1}$ã€‚ $E(d)$ã€$E(x^2)$ å’Œ $E(x)$ æ›´æ–°çš„é¡ºåº å¦‚æœä½ ä¸å¼€æ•°ç»„ï¼Œå°±è¦æ ¼å¤–æ³¨æ„è¿™ä¸€ç‚¹ã€‚$d$ çš„æœŸæœ›çŠ¶è½¬æ–¹ç¨‹ä¸­ç”¨åˆ° $E(d)$ã€ $E(x^2)$ å’Œ $E(x)$ï¼›$x^2$ çš„ç”¨åˆ° $E(x^2)$ å’Œ $E(x)$ï¼›$x$ çš„åªç”¨åˆ°è‡ªå·±ï¼Œå¹¶ä¸”ç”¨çš„éƒ½æ˜¯ä¸Šä¸€é˜¶æ®µçš„ã€‚æ‰€ä»¥å…ˆåˆ·æ–° $E(d)$ï¼Œå†åˆ·æ–° $E(x^2)$ï¼Œæœ€å $E(x)$ã€‚ äºŒ. ä»£ç 123456789101112#include&lt;cstdio&gt;int n; double prob, d, x2, x;int main() &#123; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; scanf(&quot;%lf&quot;, &amp;prob); d = d + prob * (3 * x2 + 3 * x + 1); x2 = prob * (x2 + 2 * x + 1); x = prob * (x + 1); &#125; printf(&quot;%.1lf&quot;, d);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"OIä¸­çš„æ•°è®º","slug":"OIä¸­çš„æ•°è®º","date":"un33fin33","updated":"un44fin44","comments":true,"path":"2021/07/21/OIä¸­çš„æ•°è®º/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA/","excerpt":"","text":"ä¸€. è´¨æ•°æ¦‚å¿µ $\\varphi(n)$ï¼š$1\\sim n$ ä¸­ä¸ $n$ äº’è´¨çš„æ•°çš„ä¸ªæ•°ã€‚ å¦‚æœå½“ $a, b$ äº’è´¨æ—¶ï¼Œæœ‰ $f(a\\times b)=f(a)\\times (b)$ã€‚é‚£ä¹ˆç§°å‡½æ•° $f$ ä¸ºç§¯æ€§å‡½æ•°ã€‚è‹¥ $f$ æ˜¯ç§¯æ€§å‡½æ•°ï¼Œä¸”åœ¨ç®—æœ¯åŸºæœ¬å®šç†ä¸­ $n=\\prod{i=1}^{m}p{i}^{c{i}}$ï¼Œåˆ™æ˜¾ç„¶ $f(n)=\\prod{i=1}^{m}f\\left(p{i}^{c{i}}\\right)$ã€‚ æ€§è´¨ $1\\sim n$ ä¸­è´¨æ•°çš„ä¸ªæ•°ï¼šçº¦ $\\dfrac{n}{\\ln n}$ã€‚ æ¬§æ‹‰å‡½æ•° $\\forall n&gt;1,1 \\sim n$ ä¸­ä¸ $n$ äº’è´¨çš„æ•°çš„å’Œä¸º $\\dfrac{n}{2}\\times\\varphi(n)$ã€‚ è¯æ˜ï¼šå› ä¸º $\\gcd(n,x)=gcd(n,n-x)$ï¼Œæ‰€ä»¥ $1\\sim n$ ä¸­ä¸ $n$ äº’è´¨çš„æ•°æ€»æ˜¯æˆå¯¹å‡ºç°ï¼Œå¹³å‡å€¼ä¸º $\\dfrac{n}{2}$ï¼Œæ€»å’Œä¸º $\\dfrac{n}{2}\\times\\varphi(n)$ã€‚ è‹¥ $a, b$ äº’è´¨, åˆ™ $\\varphi(a\\times b)=\\varphi(a)\\times\\varphi(b)$ã€‚ è¯æ˜ï¼šæ ¹æ®ä¸‹æ–‡æ¬§æ‹‰å‡½æ•°å•ç‚¹è®¡ç®—å…¬å¼ç›´æ¥å¾—å‡ºã€‚ è®¾ $p$ ä¸ºè´¨æ•°ï¼Œè‹¥ $p \\mid n$ ä¸” $p^{2} \\mid n$ï¼Œåˆ™ $\\varphi(n)=\\varphi(\\dfrac{n}{p})\\times p$. è¯æ˜ï¼šç”±æ¡ä»¶å¾— $n$ ä¸ $\\dfrac{n}{p}$ è´¨å› å­ç§ç±»ç›¸åŒï¼Œåªæ˜¯æŒ‡æ•°ä¸åŒï¼Œå°† $\\varphi(n)$ å’Œ $\\varphi(\\dfrac{n}{p})$ æ ¹æ®ä¸‹æ–‡å•ç‚¹è®¡ç®—å…¬å¼æ‹†åˆ†å‘ç°ä»–ä»¬çš„å•†ä¸º $p$ã€‚ è®¾ $p$ ä¸ºè´¨æ•°ï¼Œè‹¥ $p \\mid n$ ä½† $p^{2} \\nmid n$ï¼Œåˆ™ $\\varphi(n)=\\varphi(\\dfrac{n}{p})\\times(p-1)$ã€‚ è¯æ˜ï¼šç”±æ¡ä»¶å¾— $p$ ä¸ $\\dfrac{n}{p}$ äº’è´¨ï¼Œç”±æ€§è´¨ 2 å¯å¾— $\\varphi(n)=\\varphi(\\dfrac{n}{p})\\times\\varphi(p)=\\varphi(\\dfrac{n}{p})\\times(p-1)$ã€‚ $\\sum_{d\\mid n}\\varphi(d)=n$ã€‚ è¯æ˜ï¼šè®¾ $n,m$ äº’è´¨ï¼Œ$n=p_1^{c_1}p_2^{c_2}\\cdots$ï¼Œ$m=p_1â€™^{~c_1â€™}p_2â€™^{~c_2â€™}\\cdots$ã€‚ \\begin{gather} \\sum_{d\\mid nm}\\varphi(d)=\\sum\\limits_{i=0}^{c_1}\\sum\\limits_{j=0}^{c_2}\\cdots\\sum\\limits_{k=0}^{c_1'}\\sum\\limits_{l=0}^{c_2'}\\cdots\\varphi(p_1^ip_2^j\\cdots p_1'^{~k}p_2'^{~l}\\cdots)\\\\ =\\sum\\limits_{i=0}^{c_1}\\sum\\limits_{j=0}^{c_2}\\cdots\\varphi(p_1^ip_2^j\\cdots)\\sum\\limits_{k=0}^{c_1'}\\sum\\limits_{l=0}^{c_2'}\\cdots\\varphi(p_1'^{~k}p_2'^{~l}\\cdots)\\\\ =\\sum_{f\\mid n}\\varphi(f)\\sum_{g\\mid m}\\varphi(g)\\\\ \\end{gather} æ‰€ä»¥ $\\sum_{d\\mid n}\\varphi(d)$ æ˜¯ç§¯æ€§å‡½æ•°ã€‚ è®¾ $n$ çš„è´¨å› å­ç§ç±»å…± $k$ ç§ã€‚ \\begin{gather} \\sum_{d\\mid n}\\varphi(d)=\\prod_{i=1}^{i\\le k}\\sum_{f\\mid p_i^{c_i}}\\varphi(f)\\\\ =\\prod_{i=1}^{i\\le k}\\sum_{j=0}^{j\\le c_i}\\varphi(p_i^j)\\\\ \\text{ç”±ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼å¯å¾—}\\sum_{j=0}^{j\\le c_i}\\varphi(p_i^j)=p_i^{c_i}\\\\ =\\prod_{i=1}^{i\\le k}p_i^{c_i}\\\\ =n\\\\ \\end{gather} å…¬å¼ å•ç‚¹è®¡ç®—å…¬å¼ï¼š$\\varphi(n)=n \\times \\dfrac{p{1}-1}{p{1}} \\times \\dfrac{p{2}-1}{p{2}} \\times \\cdots \\times \\dfrac{p{m}-1}{p{m}}=n \\times \\prod_{\\text{è´¨æ•°} p \\mid n}\\left(1-\\dfrac{1}{p}\\right)$ã€‚ æ„Ÿæ€§ç†è§£ï¼šå¯¹äº $n$ çš„æ¯ä¸ªè´¨å› å­ $p$ æ¥è¯´ï¼Œ$1\\sim n$ ä¸­æœ‰è¿™ä¸ªè´¨å› å­çš„æ•°åœ¨æ‰€æœ‰æ•°ä¸­çš„æ¯”ä¾‹ä¸º $\\dfrac{1}{p}$ï¼Œè¿™éƒ¨åˆ†è‚¯å®šæ— æ³•ä¸ $n$ äº’è´¨ï¼Œå‰©ä¸‹ $\\dfrac{p-1}{p}$ å¯èƒ½ä¸ $n$ äº’è´¨ï¼Œè¿™æ˜¯è€ƒè™‘ä¸€ä¸ªè´¨å› å­çš„æƒ…å†µã€‚è€ƒè™‘æ‰€æœ‰è´¨å› å­çš„æƒ…å†µå°±æ˜¯ $\\prod_{\\text{è´¨æ•°}p\\mid n}\\left(1-\\dfrac{1}{p}\\right)$ï¼Œå†ä¹˜ä¸Š $1\\sim n$ ä¸­æ•´æ•°ä¸ªæ•°ã€‚ é€’æ¨å¼ï¼š$\\varphi(p\\times i)=\\varphi(i)\\times\\begin{cases}p&amp;(p\\mid i)\\p-1&amp;(p\\nmid i)\\end{cases}$ã€‚ ç”±æ€§è´¨ 3ã€4 å¯å¾—ã€‚ ä»£ç  å•ç‚¹è´¨æ•°ç­› è¯•é™¤æ³• åŒºé—´è´¨æ•°ç­› åŸƒæ°ç­› çº¿æ€§ç­› è‡ªç”±åŒºé—´è´¨æ•°ç­› åŒç­›æ³•ï¼ˆç­›å°ç´ æ•°å†ç­›åŒºé—´ç´ æ•°ï¼‰ å•ç‚¹è´¨å› æ•°åˆ†è§£ è¯•é™¤æ³• å•ç‚¹æ¬§æ‹‰å‡½æ•°â€”â€”è´¨å› æ•°åˆ†è§£ï¼ˆæ±‚å€¼å…¬å¼ï¼‰ åŒºé—´æ¬§æ‹‰å‡½æ•°â€”â€”çº¿æ€§æ³•ï¼ˆç§¯æ€§æ€§è´¨ï¼‰ è‡ªç”±åŒºé—´æ¬§æ‹‰å‡½æ•°â€”â€”åŒç­›æ³•ï¼ˆæ±‚å€¼å…¬å¼ï¼‰ äºŒ. çº¦æ•°æ€§è´¨ $n$ çš„çº¦æ•°ä¸ªæ•°ä¸Šç•Œï¼š$2\\sqrt{n}$ã€‚ è¯•é™¤æ³•çš„æ¨è®ºã€‚ $1\\sim n$ æ¯ä¸ªæ•°çº¦æ•°ä¸ªæ•°çš„æ€»å’Œï¼šçº¦ $n\\log n$ã€‚ å€æ•°æ³•çš„æ¨è®ºï¼š ä¼°ç®—æ¯ä¸ªæ•°çš„çº¦æ•°å’Œæ¯”è¾ƒéš¾ï¼Œå¯ä»¥åè¿‡æ¥è€ƒè™‘æ¯ä¸ªæ•°çš„è´¡çŒ®ï¼Œå³æ¯ä¸ªæ•°ä¼šä½œä¸ºå¤šå°‘ä¸ªæ•°ï¼ˆ$1\\sim n$ å†…ï¼‰çš„çº¦æ•°ã€‚ $1\\sim n$ çš„è´¡çŒ®åˆ†åˆ«æ˜¯ $\\dfrac{n}{1},\\dfrac{n}{2},\\dfrac{n}{3}\\cdots\\dfrac{n}{n}$ï¼Œå¯å‘ç°ä¸ªæ•°çº¦æ˜¯ $n\\log n$ã€‚ $0\\sim 2\\times 10^9$ ä¸­çº¦æ•°ä¸ªæ•°æœ€å¤šçš„æ•°çš„çº¦æ•°ä¸ªæ•°æ˜¯ $1600$ã€‚ å…¬å¼ æ­£çº¦æ•°ä¸ªæ•°ï¼š$\\left(c{1}+1\\right) \\times\\left(c{2}+1\\right) \\times \\cdots \\times\\left(c{m}+1\\right)=\\prod{i=1}^{m}\\left(c_{i}+1\\right)$ã€‚ æ­£çº¦æ•°å’Œï¼š$\\left(1+p{1}+p{1}^{2}+\\cdots+p{1}^{c{1}}\\right) \\times\\cdots \\times\\left(1+p{m}+p{m}^{2}+\\cdots+p{m}^{c{m}}\\right)=\\prod{i=1}^{m}\\left(\\sum{j=0}^{c{i}}\\left(p{i}\\right)^{j}\\right)$ã€‚ è¯æ˜ï¼šä½¿ç”¨ç»„åˆæ•°è¯æ˜å³å¯ã€‚ ä»£ç  $gcd~lcm$ å•ç‚¹çº¦æ•°ç­› è¯•é™¤æ³• åŒºé—´çº¦æ•°ç­› å€æ•°æ³•ï¼ˆåŸƒæ°ï¼‰ ä¸‰. ä½™æ•°æ¦‚å¿µ å¯¹äº $\\forall a \\in[0, m-1]$ï¼Œåˆ ${a+k m}(k \\in \\mathbb{Z})$ çš„æ‰€æœ‰æ•°æ¨¡ $m$ åŒä½™ï¼Œä½™æ•°éƒ½æ˜¯ $a_{0}$ è¯¥é›†åˆç§°ä¸ºä¸€ä¸ªæ¨¡ $m$ çš„åŒä½™ç±»ï¼Œç®€è®°ä¸º $\\bar{a}$ ã€‚ æ¨¡ $m$ çš„åŒä½™ç±»ä¸€å…±æœ‰ $m$ ä¸ªï¼Œåˆ†åˆ«ä¸º $\\overline{0}, \\overline{1}, \\overline{2}, \\cdots, \\overline{m-1}$ ã€‚å®ƒä»¬æ„æˆ $m$ çš„å®Œå…¨å‰©ä½™ç³»ã€‚ $1 \\sim m$ ä¸­ä¸ $m$ äº’è´¨çš„æ•°ä»£è¡¨çš„åŒä½™ç±»å…±æœ‰ $\\varphi(m)$ ä¸ªï¼Œå®ƒä»¬æ„æˆ $m$ çš„ç®€åŒ–å‰©ä½™ç³»ã€‚ ä¾‹å¦‚, æ¨¡ 10 çš„ç®€åŒ–å‰©ä½™ç³»ä¸º ${\\overline{1}, \\overline{3}, \\overline{7}, \\overline{9}}$ ã€‚ ä¹˜æ³•å°é—­ï¼šé›†åˆä¸­çš„ä»»æ„ä¸¤ä¸ªå…ƒç´ è¿›è¡Œä¹˜æ³•è¿ç®—ï¼Œå¾—åˆ°çš„ç»“æœè¿˜åœ¨è¿™ä¸ªé›†åˆä¸­ã€‚ ç®€åŒ–å‰©ä½™ç³»çš„æ€§è´¨ï¼š$m$ çš„ç®€åŒ–å‰©ä½™ç³»å…³äº $m$ ä¹˜æ³•å°é—­ã€‚ è¯æ˜ï¼šè®¾ $m$ çš„ç®€åŒ–å‰©ä½™ç³»ä¸­ä¸¤æ•°ä¸º $a,b$ï¼Œåˆ™ $a\\times b$ ä¹Ÿä¸ $m$ äº’è´¨ï¼Œæ ¹æ®ä½™æ•°çš„æ€§è´¨ï¼Œ $a\\times b\\bmod m$ ä¹Ÿä¸ $m$ äº’è´¨ã€‚ è‹¥æ•´æ•° $b, m$ äº’è´¨ï¼Œå¹¶ä¸” $b \\mid a$ï¼Œåˆ™å­˜åœ¨ä¸€ä¸ªæ•´æ•° $x$ï¼Œä½¿å¾— $a / b \\equiv a \\times x(\\bmod m)$ ã€‚ç§° $x$ ä¸º $b$ çš„æ¨¡ $m$ ä¹˜æ³•é€†å…ƒï¼Œè®°ä¸º $b^{-1}(\\bmod m)$ã€‚å› ä¸º $a / b \\equiv a \\times b^{-1} \\equiv a / b \\times b \\times b^{-1}(\\bmod m)$ï¼Œæ‰€ä»¥ $b \\times b^{-1} \\equiv 1(\\bmod m)$ã€‚ å®šç† / å…¬å¼ æ¬§æ‹‰å®šç†ï¼šè‹¥æ­£æ•´æ•° $x, n$ äº’è´¨ï¼Œåˆ™ $x^{\\varphi(n)} \\equiv 1(\\bmod n)$ï¼Œå…¶ä¸­ $\\varphi(n)$ ä¸ºæ¬§æ‹‰å‡½æ•°ã€‚ è¯æ˜ï¼šè®¾é›†åˆ $S$ ä¸º $n$ çš„ç®€åŒ–å‰©ä½™ç³»ï¼Œè®°ä½œ ${\\overline{a}1,\\overline{a}_2\\cdots\\overline{a}{\\varphi(n)}}$ï¼Œ$T$ ä¸º $n$ çš„ç®€åŒ–å‰©ä½™ç³»ä¸­æ‰€æœ‰æ•°ä¹˜ä¸Š $x$ æ„æˆçš„é›†åˆï¼Œè®°ä½œ ${\\overline{x\\times a}1,\\overline{x\\times a}_2\\cdots \\overline{x\\times a}{\\varphi(n)}}$ã€‚ è¯æ˜æ‰€æœ‰ $T$ ä¸­å…ƒç´ éƒ½åœ¨ $S$ ä¸­ï¼š å› ä¸º $x,n$ äº’è´¨ï¼Œæ‰€ä»¥ $\\gcd(x,n)=1$ï¼Œæ‰€ä»¥ $\\gcd(x\\bmod n, n)=1$ã€‚åˆå› ä¸ºç®€åŒ–å‰©ä½™ç³»å…·æœ‰ä¹˜æ³•å°é—­çš„æ€§è´¨ï¼Œæ‰€ä»¥ $x\\times a_i\\in S$ è¯æ˜æ‰€æœ‰ $T$ ä¸­å…ƒç´ åœ¨æ¨¡æ„ä¹‰ä¸‹ä¸é‡å¤ï¼š åè¯æ³•ã€‚è‹¥ $a_i$ å’Œ $a_j$ æ˜¯ $S$ ä¸­ä¸¤ä¸ªä¸åŒå…ƒç´ ï¼Œä¸” $x\\times a_i\\equiv x\\times a_j(\\bmod n)$ï¼Œåˆ™ $x\\times(a_i-a_j)\\equiv0(\\bmod n)$ã€‚åˆå› ä¸º $x\\not\\equiv 0(\\bmod n)$ï¼Œæ‰€ä»¥ $a_i-a_j\\equiv 0(\\bmod n)$ï¼Œ$a_i\\equiv a_j(\\bmod n)$ã€‚çŸ›ç›¾ã€‚ è¯æ˜ $S=T$ï¼š å› ä¸º 1 å’Œ 2ï¼Œåˆå› ä¸º $S$ã€$T$ ä¸­å…ƒç´ æ•°é‡ç›¸ç­‰ï¼Œæ‰€ä»¥ $S=T$ã€‚ è¯æ˜å®šç†ï¼š \\begin{gather} \\because x^{\\varphi(n)}a_1a_2\\cdots a_{\\varphi(n)}\\equiv (xa_1)(xa_2)\\cdots(xa_{\\varphi(n)})\\equiv a_1a_2\\cdots a_{\\varphi(n)}(\\bmod n)\\\\ \\therefore a^{\\varphi(n)}\\equiv 1(\\bmod n)\\\\ \\end{gather} è´¹é©¬å°å®šç†ï¼šè‹¥ $p$ æ˜¯è´¨æ•°ï¼Œåˆ™å¯¹äºä»»æ„æ•´æ•° $a$ï¼Œæœ‰ $a^{p} \\equiv a(\\bmod p)$ã€‚ æ¬§æ‹‰å®šç†ä¸­ $n$ ä¸ºè´¨æ•°ï¼Œä¸¤è¾¹åŒä¹˜ $a$ çš„æƒ…å†µã€‚ æ¬§æ‹‰å®šç†æ¨è®º1ï¼šè‹¥æ­£æ•´æ•° $a, n$ äº’è´¨ï¼Œåˆ™å¯¹äºä»»æ„æ­£æ•´æ•° $b$ï¼Œæœ‰ $a^{b} \\equiv a^{b \\bmod \\varphi(n)}(\\bmod n)$ã€‚ è¯æ˜ï¼šè®¾ $b=k\\times \\varphi(n)+r$ã€‚ \\begin{gather} \\because a^b\\equiv a^b(\\bmod n),a^{\\varphi(n)}\\equiv 1(\\bmod n)\\\\ \\therefore a^b\\times (1^{-1})^k\\equiv a^b\\times ((a^{\\varphi(n)})^{-1})^k(\\bmod n)\\\\ a^b\\equiv a^{b \\bmod \\varphi(n)}(\\bmod n)\\\\ \\end{gather} æ¬§æ‹‰å®šç†æ¨è®º2ï¼šå½“ $a, n$ ä¸ä¸€å®šäº’è´¨ä¸” $b&gt;\\varphi(n)$ æ—¶, æœ‰ $a^{b} \\equiv a^{b \\bmod \\varphi(n)+\\varphi(n)}(\\bmod n)$ã€‚ è¯æ˜ï¼šç•¥ã€‚ è£´èœ€å®šç†ï¼šå¯¹äºä»»æ„æ•´æ•° $a, b$ï¼Œå­˜åœ¨ä¸€å¯¹æ•´æ•° $x, y$ï¼Œæ»¡è¶³ $a x+b y=\\operatorname{gcd}(a, b)$ã€‚ è¯æ˜ï¼š $b=0$ æ—¶ï¼Œæœ‰ $\\begin{cases}x=0\\y=1\\end{cases}$ æ»¡è¶³ã€‚ $b&gt;0$ æ—¶ã€‚è®¾ $b\\times xâ€™+(a\\bmod b)\\times yâ€™=\\gcd(b,a\\bmod b)$ã€‚ b\\times x'+(a-\\left\\lfloor \\dfrac{a}{b}\\right\\rfloor\\times b)\\times y'=gcd(a,b)\\\\ a\\times y'+b\\times(x'-\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor\\times y')=gcd(a,b) æ‰€ä»¥ï¼Œæœ‰ $\\begin{cases}x=yâ€™\\y=xâ€™-\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor\\times yâ€™\\end{cases}$ æ»¡è¶³ã€‚ æ–¹ç¨‹ $a x+b y=c$ çš„é€šè§£ï¼š$x=\\frac{c}{d} x{0}+k \\frac{b}{d},\\quad y=\\frac{c}{d} y{0}-k \\frac{a}{d}(k \\in \\mathbb{Z})$ã€‚ ä»£ç  $exgcd$ æ±‚é€†å…ƒ å•ç‚¹â€”â€”$exgcd$ã€è´¹é©¬å°å®šç† åŒºé—´â€”â€”çº¿æ€§æ±‚é€†å…ƒ ä»»æ„ $n$ æ•°â€”â€”å‰ç¼€ç§¯ $crt$","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P2432 zxbsmkçˆ±æŸ¥é”™","slug":"zxbsmkçˆ±æŸ¥é”™","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/zxbsmkçˆ±æŸ¥é”™/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/zxbsmk%E7%88%B1%E6%9F%A5%E9%94%99/","excerpt":"","text":"P2432 zxbsmkçˆ±æŸ¥é”™ä¸€. å®¡é¢˜ï¼š1.å·²çŸ¥&amp;è¾“å…¥ï¼š ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º $L$ çš„æ–‡æœ¬ä¸²ã€‚ ç»™å‡º $W$ ä¸ªå•è¯ä¸²ã€‚ 2.ç›®æ ‡&amp;è¾“å‡ºï¼š åœ¨æ–‡æœ¬ä¸²ä¸­åˆ é™¤å°½é‡å°‘çš„å­—æ¯ä½¿å¾—æ–‡æœ¬ä¸²åªæœ‰ç”±è¯ä¸²æ„æˆï¼Œè¾“å‡ºè¿™ä¸ªæœ€å°‘åˆ é™¤çš„å­—æ¯æ•°ã€‚ äºŒ. æ€è·¯1. æ€è€ƒè§£æ³• æ–‡æœ¬ä¸²åé¢çš„å†…å®¹ä¸ä¼šå½±å“æ–‡æœ¬ä¸²å‰åŠéƒ¨åˆ†çš„æœ€ä¼˜è§£ï¼Œç¬¦åˆæ— åæ•ˆæ€§ã€‚ è‹¥æŠŠæ–‡æœ¬ä¸²å³ç«¯ä½ç½®ä½œä¸ºçŠ¶æ€ï¼Œæ–‡æœ¬ä¸²å³ç«¯ä½ç½®è¾ƒé å³çš„çŠ¶æ€éœ€è¦é€šè¿‡æ–‡æœ¬ä¸²å³ç«¯ä½ç½®è¾ƒé å·¦çš„çŠ¶æ€å¾—åˆ°ï¼ˆå¦‚ $di$ éœ€è¦é€šè¿‡ $d_0 \\dots d{i-1}$ çš„å…¶ä¸­ä¹‹ä¸€å¾—åˆ°ï¼‰ï¼Œç¬¦åˆå­é—®é¢˜é‡å æ€§ã€‚ æ‰€ä»¥è€ƒè™‘DPã€‚ 2. ç¡®å®šçŠ¶æ€è½¬ç§»æ–¹ç¨‹$d_i$ï¼šå‰ $i$ ä¸ªå­æ¯çš„æ–‡æœ¬ä¸²ä¸­æœ€å°‘åˆ é™¤çš„å­—æ¯æ•°ã€‚ $txtidx$ï¼šç”¨è¯¥ç¬¬ $j$ ä¸ªå•è¯ä¸²åŒ¹é…å‰ $i$ ä¸ªå­æ¯çš„æ–‡æœ¬ä¸²ï¼ŒåŒ¹é…å®Œæ—¶æ–‡æœ¬ä¸²çš„ä¸‹æ ‡ã€‚ï¼ˆ3. ä¸­æœ‰è¯¦è§£ï¼‰ $delcnt$ï¼šç”¨è¯¥ç¬¬ $j$ ä¸ªå•è¯ä¸²åŒ¹é…å‰ $i$ ä¸ªå­æ¯çš„æ–‡æœ¬ä¸²ï¼ŒåŒ¹é…è¿‡ç¨‹ä¸­å¤±é…çš„æ¬¡æ•°ã€‚ï¼ˆ3. ä¸­æœ‰è¯¦è§£ï¼‰ $seccessmatch$ï¼šç”¨è¯¥ç¬¬ $j$ ä¸ªå•è¯ä¸²åŒ¹é…å‰ $i$ ä¸ªå­æ¯çš„æ–‡æœ¬ä¸²ï¼Œæ˜¯å¦åŒ¹é…æˆåŠŸã€‚ï¼ˆ3. ä¸­æœ‰è¯¦è§£ï¼‰ ç»¼ä¸Šæ‰€è¿°ï¼ŒçŠ¶è½¬æ–¹ç¨‹ï¼š$di=\\min{j=1}^{W}\\begin{cases}d{i-1}+1&amp;(seccessmatch=false)\\d{txtidx}+delcnt&amp;(seccessmatch=true)\\end{cases}$ 3.ç»†èŠ‚&amp;è¯¦è§£åæ­£è·Ÿå­—ç¬¦ä¸²æœ‰å…³é¢˜çš„é¢˜è§£ï¼Œæ²¡å›¾æˆ‘æ˜¯çœ‹ä¸æ‡‚ã€‚ æ¯”å¦‚æ–‡æœ¬ä¸²æ˜¯ cabbcxyz ï¼Œæˆ‘ä»¬ç°åœ¨æ­£åœ¨æ±‚ $d_5$ ï¼ˆ$i=5$ï¼‰ ç”¨å…¶ä¸­ä¸€ä¸ªå•è¯ä¸² abc åŒ¹é…ï¼Œç”¨æŸä¸ªå•è¯åŒ¹é…æ—¶ä¸ç”¨ç®¡å…¶ä»–å•è¯ã€‚ åˆå§‹æ—¶æŠŠ $txtidx$ è®¾ä¸º $i$ ï¼ˆä¹Ÿå°±æ˜¯ $5$ï¼‰ï¼Œ$wordidx$ è®¾ä¸ºå•è¯é•¿åº¦ï¼Œ $delcnt$ è®¾ä¸º $0$ ã€‚ï¼ˆæ³¨æ„ $delnum$ ä¸æ˜¯æ•´ä¸ªæ–‡æœ¬ä¸²åˆ å»çš„å­—æ¯ä¸ªæ•°ï¼Œè€Œæ˜¯å½“å‰æƒ…å†µä¸‹åŒ¹é…è¿‡éƒ¨åˆ†çš„æ–‡æœ¬ä¸²çš„åˆ å»å­—æ¯ä¸ªæ•°ã€‚3. ä¸­æœ‰è¯¦è§£ï¼‰ åˆå§‹æ—¶ï¼š ç¬¬ä¸€æ¬¡åŒ¹é…åï¼š ç¬¬äºŒæ¬¡åŒ¹é…åï¼š ç¬¬ä¸‰æ¬¡åŒ¹é…åï¼š ç¬¬å››æ¬¡åŒ¹é…åï¼š ä¸‰. ä»£ç ä»£ç ä¸­æœ‰æ¯”è¾ƒè¯¦ç»†çš„æ³¨é‡Šã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXwordcnt = 600;//å•è¯æ•°é‡æœ€å¤§å€¼ const int MAXwordlen = 25;//å•è¯é•¿åº¦æœ€å¤§å€¼ const int MAXtxtlen = 300;//æ–‡æœ¬é•¿åº¦æœ€å¤§å€¼ int wordcnt/*å•è¯æ•°é‡*/, txtlen/*æ–‡æœ¬é•¿åº¦*/;char word[MAXwordcnt + 10][MAXwordlen + 10]/*å•è¯*/, txt[MAXtxtlen + 10]/*æ–‡æœ¬*/;int d[MAXtxtlen];//DPæ•°ç»„ int main() &#123; scanf(&quot;%d %d&quot;, &amp;wordcnt, &amp;txtlen); scanf(&quot;%s&quot;, txt + 1); for (int i = 1; i &lt;= wordcnt; ++i) &#123; scanf(&quot;%s&quot;, word[i] + 1); &#125; d[0] = 0; for (int i = 1; i &lt;= txtlen; ++i) &#123; d[i] = d[i - 1] + 1;//å¦‚æœæ²¡æœ‰å•æ¬¡å¾—ä»¥å†æ¬¡ä½ç½®åŒ¹é…ï¼Œéœ€è¦åˆ é™¤çš„å•è¯æ•°++ for (int j = 1; j &lt;= wordcnt; ++j) &#123; int wordidx = strlen(word[j] + 1);//æ­¤æ—¶å•è¯ä¸²çš„ä¸‹æ ‡ int txtidx;//æ­¤æ—¶æ–‡æœ¬ä¸²çš„ä¸‹æ ‡ int delcnt = 0;//å½“å‰æƒ…å†µä¸‹åŒ¹é…è¿‡éƒ¨åˆ†çš„æ–‡æœ¬ä¸²çš„åˆ å»å­—æ¯ä¸ªæ•° bool seccessmatch = 0;//æ˜¯å¦åŒ¹é…æˆåŠŸ for (txtidx = i; txtidx &gt;= 1; --txtidx) &#123; if (wordidx == 0) &#123;//wordidx == 0ä»£è¡¨å•è¯å·²ç»åŒ¹é…å®Œäº† seccessmatch = 1; break; &#125; if (txt[txtidx] == word[j][wordidx]) &#123;//å¦‚æœå•è¯ä¸²ä¸æ–‡æœ¬ä¸²åœ¨è¯¥ä½ç½®ç›¸åŒ... --wordidx; //é‚£ä¹ˆåŒ¹é…ä¸‹ä¸€ä½ &#125; else &#123; //å¦åˆ™... ++delcnt; //éœ€è¦åˆ çš„ä¸ªæ•°++ &#125; &#125; if (wordidx == 0) &#123;//wordidx == 0ä»£è¡¨å•è¯å·²ç»åŒ¹é…å®Œäº† seccessmatch = 1; &#125; if (seccessmatch) &#123; //å¦‚æœæˆåŠŸåŒ¹é…... d[i] = min(d[i], d[txtidx] + delcnt);//è½¬ç§»çŠ¶æ€ &#125; &#125; &#125; printf(&quot;%d&quot;, d[txtlen]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"UVA 1025 åŸå¸‚é‡Œçš„é—´è° A Spy in the Metro","slug":"åŸå¸‚é‡Œçš„é—´è°","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/åŸå¸‚é‡Œçš„é—´è°/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%9F%8E%E5%B8%82%E9%87%8C%E7%9A%84%E9%97%B4%E8%B0%8D/","excerpt":"","text":"UVA1025 åŸå¸‚é‡Œçš„é—´è° A Spy in the Metroï¼ˆæœ¬é¢˜æœ‰å¤šå€ç»éªŒå“¦ï¼‰ ä¸€. æ€è·¯1. æ€è€ƒè§£æ³• æ—¶é—´ æ˜¯ä¸ªå¥½çš„ DP é˜¶æ®µï¼Œæ—¶é—´è½´ä¸Šé åå‘ç”Ÿçš„ä¸ä¼šå½±å“å‰é¢çš„äº‹ï¼Œåæ˜ åˆ°æœ¬é¢˜ä¸Šå°±æ˜¯ Maria ä¹‹åæ€ä¹ˆèµ°ä¸ä¼šå½±å“ç°åœ¨çš„æœ€ä¼˜è§£ï¼Œç¬¦åˆæ— åæ•ˆæ€§ã€‚ Maria æ—¢å¯ä»¥ä¹˜å‘ä¸œçš„åœ°é“ï¼Œåˆå¯ä»¥ä¹˜å‘è¥¿çš„åœ°é“ï¼Œè¿˜å¯ä»¥å‘†ç€ä¸åŠ¨ã€‚é‚£ä¹ˆä¸€ç§æƒ…å†µå¯ä»¥ç”±å¤šç§æƒ…å†µè€Œæ¥ï¼Œå¤šç§æƒ…å†µä¹Ÿå¯ä»¥å‘å±•æˆä¸€ç§æƒ…å†µï¼Œå„ç§æƒ…å†µäº’ç›¸äº¤ç»‡ï¼Œç¬¦åˆå­é—®é¢˜é‡å æ€§ã€‚ æ‰€ä»¥è€ƒè™‘ DPã€‚ 2. å‰ç¼€å’Œåˆå§‹åŒ– é¢˜ç›®ç»™å‡ºäº†ç«™çš„æ—¶é—´é—´è·å’Œæ¯åˆ—åœ°é“å‘è½¦æ—¶çš„æ—¶é—´ï¼ˆåªä¼šä»é¦–æœ«ä¸¤ç«™å‘è½¦ï¼‰ï¼Œäº‹å®ä¸Šï¼Œåœ°é“åœ¨å‰è¿›ä¸­åˆ°è¾¾æ¯ç«™çš„æ—¶é—´å°±æ˜¯ä¸ªå‰ç¼€å’Œ ï¼ˆå·å·ç‚¹å¼€æ ‡ç­¾æˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹åˆ°å‰ç¼€å’Œï¼‰ï¼Œåˆ°è¾¾æŸç«™çš„æ—¶é—´å°±æ˜¯å‰é¢æ‰€æœ‰ç«™æ—¶é—´é—´è·ä¹‹å’Œï¼Œå½“ç„¶è¿˜è¦åŠ ä¸Šå‘è½¦æ—¶é—´ã€‚ 3. DPæˆ‘é‡‡ç”¨çš„æ˜¯ åˆ·è¡¨æ³•ï¼Œå½“ç„¶ï¼Œå¡«è¡¨æ³• ä¹Ÿå¯ä»¥ã€‚ æ‰€éœ€æ¡ä»¶ï¼š $stabet_i$ï¼šç«™ $i-1$ ä¸ç«™ $i$ é—´ç›¸éš”çš„æ—¶é—´ã€‚ $canright{i,j}(canleft{i,j})$ï¼š$i$ æ—¶åˆ» $j$ ç«™æ˜¯å¦æœ‰å¼€å‘æœ«ç«™ï¼ˆé¦–ç«™ï¼‰çš„ç«è½¦ã€‚ $d_{i,j}$ï¼šå¾—åˆ° $i$ æ—¶åˆ»åœ¨ $j$ ç«™è¿™ç§çŠ¶æ€æœ€å°‘çš„åœç•™æ—¶é—´ã€‚ é€šè¿‡å‰ç¼€å’Œæˆ‘ä»¬å·²ç»å¾—åˆ° $canright$ ä»¥åŠ$canleft$ æ•°ç»„ã€‚æ¥ä¸‹æ¥å°±æ˜¯çŠ¶æ€è½¬ç§»äº†ã€‚ åˆå§‹çŠ¶æ€ï¼š æ˜“å¾—ï¼Œåº”åˆå§‹åŒ–ä¸ºï¼š $d_{i,j}=\\begin{cases}0&amp;(i=0~\\land~j=1)\\\\infty&amp;(else)\\end{cases}$ å…¶ä¸­ $\\infty$ ä»£è¡¨æ— æ³•åˆ°è¾¾ã€‚ çŠ¶æ€è½¬ç§»ï¼š å› ä¸ºæœ¬é¢˜çš„é˜¶æ®µä¹‹é—´ä¸åƒæ™®é€šçš„0/1èƒŒåŒ…é‚£æ ·åªä¼šç”±ä¸Šä¸€é˜¶æ®µè½¬ç§»åˆ°ï¼Œè€Œæ˜¯ä¹Ÿä¼šç”±å¾ˆå¤šä¸ªå•ä½æ—¶é—´ä¹‹å‰çš„é˜¶æ®µè½¬ç§»åˆ°ï¼ˆç«™ä¸ç«™ä¹‹é—´çš„æ—¶é—´ä¸æ­¢1ï¼‰ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹©å¤šç»´æ•°ç»„è€Œéæ»šåŠ¨æ•°ç»„ã€‚ é¦–å…ˆï¼Œæ— è®ºæ­¤åˆ»æ­¤ç«™æœ‰æ²¡æœ‰åœ°é“ï¼Œéƒ½å¯ä»¥åœ¨æœ¬ç«™ç­‰å¾…ï¼Œè¿™æ˜¯æ™®éçš„è½¬ç§»ï¼›å¦å¤–ï¼Œå¦‚æœæ­¤åˆ»æ­¤ç«™æ°å¥½æœ‰åœ°é“ï¼Œå¯ä»¥åšç‰¹æ®Šçš„è½¬ç§»ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼ŒçŠ¶è½¬æ–¹ç¨‹ï¼šï¼ˆå› ä¸ºæ˜¯åˆ·è¡¨æ³•ï¼ŒçŠ¶è½¬æ–¹ç¨‹ä¸æ–¹ä¾¿å†™åœ¨ä¸€ä¸ªæ‹¬å·é‡Œï¼Œè’Ÿè’»å°±è¿™ä¹ˆå†™äº† qwqï¼‰ ï¼ˆ$\\operatorname{self}$ ä»£è¡¨è‡ªå·±ï¼‰ \\begin{aligned} &d_{i,j}=\\min(\\operatorname{self},~d_{i-1,j}+1)&(i>0) \\\\ &d_{i+stabet_{j+1},j+1}=\\min(\\operatorname{self},~d_{i,j})&(canright_{i,j}=true) \\\\ &d_{i+stabet_j,j-1}=\\min(\\operatorname{self},~d_{i,j})&(canleft_{i,j}=true) \\\\ \\end{aligned} ç»“æœçŠ¶æ€ï¼š $d_{T,n}$ äºŒ. ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 50;const int MAXT = 2000;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, T, stabet[MAXn + 10], rightcnt, leftcnt; bool canright[MAXT + 10][MAXn + 10], canleft[MAXT + 10][MAXn + 10]; int d[MAXT + 10][MAXn + 10]; int main() &#123; int k = 0; read(n); while (n) &#123; ++k; memset(canright, 0, sizeof(canright)); // memset(canleft, 0, sizeof(canleft)); //å¤šç»„æ•°æ®è¦åˆå§‹åŒ– memset(d, 0x3f, sizeof(d)); // read(T); for (int i = 2; i &lt;= n; ++i) &#123; read(stabet[i]); &#125; int time; // read(rightcnt); // for (int i = 1; i &lt;= rightcnt; ++i) &#123; // read(time); // canright[time][1] = 1; // for (int j = 2; j &lt;= n; ++j) &#123; // time += stabet[j]; // canright[time][j] = 1; // &#125; // &#125; //è¾¹è¯»å…¥è¾¹ç”¨å‰ç¼€å’Œè®¡ç®—canrightå’Œcanleftæ•°ç»„ read(leftcnt); // for (int i = 1; i &lt;= leftcnt; ++i) &#123; // read(time); // canleft[time][n] = 1; // for (int j = n - 1; j &gt;= 1; --j) &#123; // time += stabet[j + 1]; // canleft[time][j] = 1; // &#125; // &#125; // d[0][1] = 0; for (int i = 0; i &lt;= T; ++i) &#123; // for (int j = 1; j &lt;= n; ++j) &#123; // if (i) // d[i][j] = min(d[i][j], // d[i - 1][j] + 1); // if (canright[i][j]) // d[i + stabet[j + 1]][j + 1] = min(d[i + stabet[j + 1]][j + 1], //åŠ¨æ€è§„åˆ’ d[i][j] );// if (canleft[i][j]) // d[i + stabet[j]][j - 1] = min(d[i + stabet[j]][j - 1], // d[i][j] ); // &#125; // &#125; // if (d[T][n] == INF) &#123; printf(&quot;Case Number %d: impossible\\n&quot;, k); &#125; else &#123; printf(&quot;Case Number %d: %d\\n&quot;, k, d[T][n]); &#125; read(n); &#125; &#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"å¯¹æ‹","slug":"å¯¹æ‹","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/å¯¹æ‹/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%AF%B9%E6%8B%8D/","excerpt":"","text":"åœ¨ OI èµ›åˆ¶ ä¸­ï¼Œä»£ç åªèƒ½äº¤ä¸€æ¬¡ï¼Œè¿™æ˜¯æ¯”èµ›ä¸ OJ æœ€å¤§çš„ä¸åŒã€‚æˆ‘ä»¬å¦‚æœä¸èƒ½ä¿è¯ä»£ç æ˜¯æ­£ç¡®çš„ï¼Œå°±éœ€è¦å¯¹æ‹ï¼š code1/2.cppï¼šæš´åŠ›åŠæ­£è§£ä»£ç ã€‚ random.cppï¼šéšæœºæ•°æ®ç”Ÿæˆå™¨ã€‚ match.cppï¼šå¯¹æ‹ç¨‹åºï¼š ä¸€. å¯¹æ‹ç¨‹åº12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstdlib&gt;int T = 100;signed main() &#123; while (T--) &#123; system(&quot;./random &gt; in.txt&quot;); system(&quot;./1 &lt; in.txt &gt; 1.txt&quot;); system(&quot;./2 &lt; in.txt &gt; 2.txt&quot;); if (system(&quot;diff -b 1.txt 2.txt&quot;)) &#123; printf(&quot;Error!!!\\n&quot;); exit(1); &#125; else &#123; printf(&quot;Ok\\n&quot;); &#125; &#125;&#125; æ³¨æ„å¤´æ–‡ä»¶ã€‚ äºŒ. éšæœºæ•°ç¨‹åºä¸»æ¨ mt19937 ï¼ˆéœ€è¦ c++11ï¼‰ã€‚éšæœºæ•°èŒƒå›´åˆ° $2^{19937}-1$ã€‚å®Œå…¨ä¸ç”¨æ‹…å¿ƒä¸å¤Ÿç”¨ï¼Œå…·ä½“å®ä¾‹ï¼š 1234567#include&lt;random&gt;#include&lt;ctime&gt;using namespace std;mt19937 rd(time(0));int random(int l, int r) &#123; return rd() % (r - l + 1) + l;&#125; ä¸‰. å›¾åƒç¤ºä¾‹ Your browser does not support the video tag.","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"Luogu P3868 [TJOI2009]çŒœæ•°å­—","slug":"çŒœæ•°å­—","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/çŒœæ•°å­—/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%8C%9C%E6%95%B0%E5%AD%97/","excerpt":"","text":"P3868 [TJOI2009]çŒœæ•°å­—ä¸€. æ€è·¯é¦–å…ˆæ‹¿é“é¢˜çœ‹åˆ°æ¡ä»¶ç»™å‡ºä¸¤ç»„æ•°ï¼Œå…¶ä¸­ä¸€ç»„äº’ç´ ï¼Œè®©çŒœä¸€ä¸ªæ•°å­—ã€‚è‡ªç„¶è€Œç„¶å¾€ crt ä¸Šæƒ³ã€‚ä½†ä¸ºä»€ä¹ˆæ˜¯ crt å‘¢ï¼Ÿ $\\forall i \\in [1,k]$ï¼Œæœ‰ $b_i \\mid (n - a_i)$ï¼Œè¿™å¥è¯å¯ä»¥åŒ–ä¸ºä¸€ç»„åŒä½™æ–¹ç¨‹ï¼Œå†ç§»é¡¹å¯å¾—æ ‡å‡†çš„ crt æ ¼å¼ï¼š ~~~~~~~~~~~~~~\\begin{cases} n - a_1 \\equiv 0 &(\\operatorname{mod}~b_1) \\\\ n - a_2 \\equiv 0 &(\\operatorname{mod}~b_2) \\\\ \\cdots \\\\ n - a_k \\equiv 0 &(\\operatorname{mod}~b_k) \\\\ \\end{cases} \\\\ ~\\\\ \\Longrightarrow\\begin{cases} n \\equiv a_1 &(\\operatorname{mod}~b_1) \\\\ n \\equiv a_2 &(\\operatorname{mod}~b_2) \\\\ \\cdots \\\\ n \\equiv a_k &(\\operatorname{mod}~b_k) \\\\ \\end{cases}ç„¶å crt æ±‚è§£å°±å¥½äº†ã€‚crt â€”â€”ä¸­å›½å‰©ä½™å®šç†å°±æ˜¯æä¾›äº†ä¸€ä¸ªè§£åŒä½™æ–¹ç¨‹ç»„ $\\begin{cases}x \\equiv a1 &amp;(\\operatorname{mod}~m_1) \\ x \\equiv a_2 &amp;(\\operatorname{mod}~m_2) \\ \\cdots \\ x \\equiv a_n &amp;(\\operatorname{mod}~m_n) \\ \\end{cases}$ çš„å…¬å¼ï¼Œå³ $x = \\sum\\limits{i = 1}^{n} { ai \\times M_i \\times t_i }$ï¼Œå…¶ä¸­ $M_i = \\dfrac{\\prod\\limits{j = 1}^{n}m_j}{m_i}$ï¼Œ $t_i = \\operatorname{inv}(M_i)$ã€‚å…¬å¼çš„æ¨å¯¼è¯¦è§ OI-Wikiã€‚ äºŒ. å‘ç‚¹äº¤ä»£ç ä¸Šå»ä¸€çœ‹ï¼Œä¸ºä»€ä¹ˆåªæœ‰ 90 åˆ†ï¼Ÿæœ€åä¸€ä¸ªç‚¹ WA æ‰äº†ï¼Œå¹¶ä¸”æ˜¾ç¤ºç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—è¾“å‡ºäº†å‡å·ã€‚çœ‹æ¥æ˜¯çˆ† long long äº†ã€‚æ‰€ä»¥éœ€è¦é¾Ÿé€Ÿå¿«é€Ÿä¹˜é˜²æ­¢çˆ† long longã€‚ï¼ˆæœ¬è’Ÿè’»ä¸ä¼šlong doubleï¼‰ ä¸‰. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 10;template &lt;typename T&gt;inline T qmul(T x, T y, T mod) &#123; if (x == 0 || y == 0) return 0; T ret = 0; while (y) &#123; if (y &amp; 1) ret = ((ret % mod) + (x % mod)) % mod; y &gt;&gt;= 1; x = ((x % mod) + (x % mod)) % mod; &#125; return ret;&#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int a, int m) &#123; int k, inv; exgcd(a, m, inv, k); return (inv % m + m) % m;&#125;int crt(int cnta, int *a, int *m) &#123; int prod = 1, ans = 0; for (re int i = 1; i &lt;= cnta; ++i) &#123; prod *= m[i]; &#125; for (re int i = 1, M; i &lt;= cnta; ++i) &#123; M = prod / m[i]; ans = (ans + qmul(qmul(a[i], M, prod), inv(M, m[i]), prod)) % prod; &#125; return ans;&#125;int n, a[MAXn + 10], m[MAXn + 10];signed main() &#123; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;m[i]); &#125; printf(&quot;%lld\\n&quot;, crt(n, a, m));&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P3601 ç­¾åˆ°é¢˜","slug":"ç­¾åˆ°é¢˜","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/ç­¾åˆ°é¢˜/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%AD%BE%E5%88%B0%E9%A2%98/","excerpt":"","text":"P3601 ç­¾åˆ°é¢˜ä¸€. æ€è·¯$1 \\le l \\le r \\le 10^{12}$ï¼Œ$r-l \\le 10^6$ã€‚å¾ˆæ˜¾ç„¶ï¼Œä¼ ç»Ÿçš„ç”¨æ¬§æ‹‰å‡½æ•°æ˜¯ç§¯æ€§å‡½æ•°è¿™æ¡æ€§è´¨çš„ä» $1$ æ‰«åˆ°åŒºé—´å³ç«¯çš„æ–¹æ³•è‚¯å®šä¸è¡Œã€‚è™½ç„¶ä¼ ç»Ÿçš„æ–¹æ³•ä¸è¡Œã€‚ä½†æ¬§æ‹‰å‡½æ•°è¿˜æœ‰ä¸€æ¡æœ‰ç”¨çš„å…¬å¼ï¼š$\\varphi(n)=n \\times \\prod\\limits_{i=1}^{n}\\dfrac{p_i-1}{p_i}$ ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åªè¦çŸ¥é“ $l \\sim r$ ä¸­æ‰€æœ‰æ•°çš„è´¨å› æ•°åˆ†è§£å°±å¥½äº†ã€‚ä¸éš¾å‘ç°ä¸€ä¸ªæ•° $n$ çš„è´¨å› æ•°ä¸­æœ‰ä¸€ä¸ªæˆ–é›¶ä¸ªå¤§äº $\\sqrt{n}$ ã€‚é‚£ä¹ˆæˆ‘ä»¬æŠŠå°äºç­‰äº $\\sqrt{r}$ çš„è´¨æ•°å§‘ä¸”ç§°ä¸ºâ€œå°è´¨æ•°â€ï¼›å¤§äº $\\sqrt{r}$ çš„å«â€œå¤§è´¨æ•°â€ã€‚ å…ˆé¢„å¤„ç†å‡ºæ‰€æœ‰å°è´¨æ•°ï¼ˆä¹Ÿå°±æ˜¯ $1 \\sim 10^6$ å†…çš„ï¼‰å¼€ä¸€ä¸ªæ•°ç»„ $inv$ æ¯ä¸ªä½ç½®é¢„å¤„ç†ä¸ºä¸‹æ ‡çš„å€¼ï¼ˆå°±æ˜¯ $\\varphi(n)=n \\times \\prod\\limits{i=1}^{n}\\dfrac{p_i-1}{p_i}$ ä¸­çš„ç­‰å¼å³è¾¹çš„ $n$ï¼‰ï¼Œç„¶åç”¨å€æ•°æ³•æšä¸¾æ‰€æœ‰å°è´¨æ•°åœ¨ $l \\sim r$ åŒºé—´ä¸­çš„å€æ•°ï¼Œå°†ç›¸åº”çš„ $inv_i$ ä¹˜ä¸Š $\\prod\\limits{i=1}^{n}\\dfrac{p_i-1}{p_i}$ã€‚ å½“ç„¶ï¼Œä¸è¦å¿˜äº†å¤§è´¨æ•°ï¼Œå› ä¸ºæ¯ä¸ªæ•°è‡³å¤šæœ‰ä¸€ä¸ªå¤§è´¨æ•°ï¼Œæ‰€ä»¥å¤§è´¨æ•°ä¹Ÿå¾ˆå¥½å¤„ç†ã€‚å¼€ä¸€ä¸ªæ•°ç»„ $bidprime$ å…¨åˆå§‹åŒ–ä¸ºä¸‹æ ‡ã€‚ç”¨å€æ•°æ³•æšä¸¾ $prime_i$ çš„å€æ•°æšä¸¾åˆ°ç›¸åº”çš„ $inv_j$ æ—¶ï¼Œé¡ºä¾¿æŠŠ $bigprime_j$ ä¸­æ‰€æœ‰çš„çš„å› æ•° $prime_i$ å‰”é™¤ã€‚æœ€åå°±å¾—åˆ°äº†æ¯ä¸ªæ•°çš„å¤§è´¨æ•°ã€‚ äºŒ. ç»†èŠ‚æœ€é‡è¦çš„ç»†èŠ‚å°±æ˜¯æšä¸¾å°æŒ‡æ•°çš„å€æ•°æ—¶ä»å‡ æšä¸¾äº†ã€‚è®¾è¯¥å°è´¨æ•°ä¸º $p$ï¼ŒåŒºé—´å·¦ç«¯ç‚¹ä¸º $l$ ã€‚ç­”æ¡ˆæ˜¯ $\\max{ p^2, \\left\\lceil\\dfrac{l}{p}\\right\\rceil \\times p }$ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿé¦–å…ˆå°äº $p^2$ çš„ $p$ çš„å€æ•°åœ¨æšä¸¾ $2$ï¼Œ$3$ ç­‰æ¯”å®ƒæ›´å°çš„è´¨æ•°æ—¶å°±å·²ç»æšä¸¾è¿‡äº†ã€‚è€Œ $\\left\\lceil\\dfrac{l}{p}\\right\\rceil \\times p $ æ˜¯å¤§äºç­‰äº $l$ çš„ç¬¬ä¸€ä¸ª $p$ çš„å€æ•°ã€‚ ä¸‰. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register #define int long longconst int MAXprime = 1e6;const int MAXn = 1e6;const int MOD = 666623333;template &lt;class T&gt;inline T max(T a, T b) &#123; return a &gt; b ? a : b;&#125;int cntp, prime[MAXprime / 5 + 100];bool notp[MAXprime + 10];void PrimeSieve(int up) &#123; //çº¿æ€§ç­›ä¸è§£é‡Š notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) prime[++cntp] = i; int upj = up / i; for (re int j = 1; j &lt;= cntp &amp;&amp; prime[j] &lt;= upj; ++j) &#123; notp[i * prime[j]] = 1; if (!(i % prime[j])) break; &#125; &#125;&#125;int ans, l, r, phi[MAXn + 10], bigprime[MAXn + 10];signed main() &#123; PrimeSieve(MAXprime); scanf(&quot;%lld %lld&quot;, &amp;l, &amp;r); for (re int i = l; i &lt;= r; ++i) &#123; //åˆå§‹åŒ– phi[i - l] = bigprime[i - l] = i; &#125; for (re int i = 1; i &lt;= cntp; ++i) &#123; //å€æ•°æ³•ï¼šæšä¸¾æ‰€æœ‰å°è´¨æ•°çš„å€æ•° for (re int j = max(prime[i] * prime[i], (int)ceil((double)l / prime[i]) * prime[i]); j &lt;= r; j += prime[i]) &#123; phi[j - l] = phi[j - l] / prime[i] * (prime[i] - 1); while (!(bigprime[j - l] % prime[i])) &#123; bigprime[j - l] /= prime[i]; &#125; &#125; &#125; for (re int i = l; i &lt;= r; ++i) &#123; //å¤„ç†å¤§è´¨æ•° if (bigprime[i - l] &gt; 1) &#123; phi[i - l] = phi[i - l] / bigprime[i - l] * (bigprime[i - l] - 1); &#125; &#125; for (re int i = l; i &lt;= r; ++i) &#123; //æ±‚å’Œ ans = (ans + i - phi[i - l]) % MOD; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"è®°ä¸€åªå°å‚»èœ‚","slug":"è®°ä¸€åªå°å‚»èœ‚","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/è®°ä¸€åªå°å‚»èœ‚/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E8%AE%B0%E4%B8%80%E5%8F%AA%E5%B0%8F%E5%82%BB%E8%9C%82/","excerpt":"","text":"ä»Šå¤©ï¼Œ2021 å¹´ 6 æœˆ 28 æ—¥ã€‚ ç¬ƒè¡Œæ¥¼ 5 æ¥¼ ç¬¬ä¸‰æœºæˆ¿ï¼Œä¸è¶³ 40 cm çš„ç‹­çª„é—¨ç¼ä¸­ï¼Œé’»è¿›äº†ä¸€åªèœ‚ã€‚ è¿™åªèœ‚æ¯”è¾ƒè‚¥å¤§ï¼Œå·¨èº«ä¿®å°¾ï¼Œé’é¡¹é‡‘ç¿…ã€‚ è¿›æ¥å°±ç›˜æ—‹åœ¨å¤©èŠ±æ¿ä¸Šé¢ï¼ŒåŠå¤©èµ¶ä¸ä¸‹æ¥ã€‚ å‚»æ­»äº†ï¼Œå¥¹è¦ä¹ˆä¸€ç›´æ’ç¯ç®¡ï¼Œè¦ä¹ˆä¸€ç›´ç›˜æ—‹ç€é£ï¼Œç»™å¥¹æ°äº†äº›é¥¼å¹²ä¹Ÿä¸åƒã€‚ ç¨æ™šäº›çš„æ—¶å€™ï¼Œæ°ä»æœºæˆ¿çš„å¤–é¢è¿›æ¥äº†ï¼Œä½†æ˜¯æ°å“¥è¦æ€ä¹ˆæŠŠå¥¹ä»é«˜åº¦ 4m çš„é«˜é«˜å¤©èŠ±æ¿ä¸­å†èµ¶å‡ºå»å•Šï¼ å¤©å•Šï¼Œå¥¹æ€ä¹ˆä¸€ç›´åœ¨é£ï¼ŒçœŸçš„ä¸ç´¯å—ã€‚ æ”¾å¼ ç…§ç‰‡ï¼š åˆè¿‡äº†ä¸€ä¼š å¥¹ä¸çŸ¥ä»€ä¹ˆæ—¶å€™åˆé£åˆ°ç¯æ³¡ç®¡ä¸Šé¢äº†ï¼ŒåŠå¤©ä¸€ç›´æ²¡åŠ¨é™ã€‚ æˆ‘å¥½æ€•å•Šã€‚ è¢«æ°å“¥ä¸€æ‰«å¸šæ‰“ä¸‹æ¥ï¼Œä¼°è®¡æ˜¯æ²¡äº†ã€‚","categories":[{"name":"æ‚è°ˆ","slug":"æ‚è°ˆ","permalink":"http://rsdbkhusky.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"é”æœº","slug":"é”æœº","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/é”æœº/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%94%81%E6%9C%BA/","excerpt":"","text":"ä½œä¸ºä¸€å $OIer$ï¼Œæˆ‘ä»¬æ—¶æ—¶åˆ»åˆ»éƒ½æœ‰è¢« $jc$ çš„é£é™©ã€‚è¿™äº‹æˆ‘ä»¬éœ€è¦ä¸€æ¬¾ç®€å•çš„é”æœºç¨‹åºæ¥é”æ­»ä¿æŠ¤æˆ‘ä»¬çš„ç”µè„‘ï¼š 12345678910#include&lt;windows.h&gt; #include&lt;winable.h&gt; #include&lt;time.h&gt;int main() &#123; FreeConsole(); while(1) &#123; if (clock() &gt; 10000) break; BlockInput(1); &#125; &#125; æ¯”å¦‚è¿™å°±æ˜¯ä¸€ä¸ª $10$ ç§’é’Ÿçš„é”æœº ï¼Œclock() å‡½æ•°çš„å•ä½æ˜¯ $ms$ã€‚ å¦‚æœæ— æ•ˆè¯•è¯•ç”¨ç®¡ç†å‘˜èº«ä»½è¿è¡Œã€‚ å°å¿ƒåˆ«å¤šæ•°äº†ä¸ª $0$ã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"Luogu P3833 [SHOI2012]é­”æ³•æ ‘","slug":"é­”æ³•æ ‘","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/é­”æ³•æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%AD%94%E6%B3%95%E6%A0%91/","excerpt":"","text":"P3833 [SHOI2012]é­”æ³•æ ‘æ”¾åœ¨å‰é¢çš„å‰é¢ï¼šæœ¬æ–‡æœ‰æ ‘å‰–å›¾è§£æ”¾åœ¨å‰é¢ï¼šä¸€é“æ ‘å‰–æ¿å­é¢˜ï¼Œå…³äºæ ‘å‰–çš„æ•™ç¨‹ç½‘ä¸Šæ•°ä¸èƒœæ•°ï¼Œæˆ‘å°±åª æ¦‚è¿° ä¸€ä¸‹ï¼Œå°±ä¸é€ è½®å­äº†ï¼Œå…·ä½“ç»†èŠ‚è¯·è§ OI WIKIã€‚ ä¸€. è¿‡ç¨‹æ¦‚è¿°0. åŸºç¡€ï¼šé‚»æ¥è¡¨ï¼Œçº¿æ®µæ ‘ã€‚1. ç¬¬ä¸€æ¬¡ dfsï¼šæ±‚å‡ºè¯¥æœ‰æ ¹æ ‘ï¼ˆå¦‚æœé¢˜ç›®æ²¡æ˜ç¡®æ ¹å°±ä»»é€‰ä¸€ä¸ªï¼‰æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œæ·±åº¦ï¼Œï¼ˆä»¥ä»–ä¸ºæ ¹çš„ï¼‰å­æ ‘çš„å¤§å°ï¼Œ é‡å„¿å­ã€‚ 2. ç¬¬äºŒæ¬¡ dfsï¼šæ±‚å‡ºè¯¥æœ‰æ ¹æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„ dfs åºâ€”â€” $dfs$ï¼Œæ¯ä¸ª dfs å¯¹åº”çš„èŠ‚ç‚¹ç¼–å·â€”â€” $dfsidx$ï¼ˆ$i=dfsidx_{dfs_i}$ï¼‰ï¼Œæ‰€åœ¨é‡é“¾çš„é“¾é¡¶â€”â€” $top$ï¼Œå…¶å­æ ‘ä¸­èŠ‚ç‚¹ä¸­ dfs åºæœ€å¤§çš„ä¸€ä¸ªâ€”â€” $bottom$ã€‚ç”¨é€”ï¼š $dfs$ï¼šè‹¥è¿™æ£µæ ‘ä¸Šæœ¬æ¥å°±æœ‰æƒå€¼éœ€è¦ç”¨å®ƒè¾…åŠ©ç»™çº¿æ®µæ ‘å»ºæ ‘ã€‚æœ¬é¢˜ä¸­æ— ç”¨ã€‚ $dfsidx$ï¼šç”¨ä»–å°†çº¿æ®µæ ‘ä¸ŠèŠ‚ç‚¹çš„ç¼–å·è½¬åŒ–ä¸ºçº¿æ®µæ ‘ä¸ŠèŠ‚ç‚¹çš„ç¼–å·ã€‚ $top$ï¼šè¿›è¡Œæ ‘é“¾ä¸Šæ“ä½œæ—¶éœ€è¦ã€‚ï¼ˆè¯¦è§æˆ‘çš„ä»£ç å’Œ OI WIKIï¼‰ $bottom$ï¼šè¿›è¡Œå­æ ‘ä¸Šæ“ä½œæ—¶éœ€è¦ã€‚ï¼ˆè¯¦è§æˆ‘çš„ä»£ç å’Œ OI WIKIï¼‰ 3. æƒå€¼å¢å‡ä¸æŸ¥è¯¢ï¼šè¯¦è§£è§ OI WIKIï¼Œè¿™é‡Œåªæ”¾ä¸¤å¼ å›¾ï¼š æ ‘å’Œdfsåºï¼š ï¼ˆmadebyï¼šå¤§ä½¬ EternalAlexander çš„ OI Painterï¼‰ å¦ä¸€å¼ dfså›¾ï¼š æœ‰ç‚¹å…ˆåºéå†å†…å‘³äº†ï¼Œåªä¸è¿‡ä¸æ˜¯æ ¹å·¦å³ï¼Œè€Œæ˜¯æ ¹é‡è½»ã€‚ç”±æ­¤ä¹Ÿå¯å‘ç°ï¼šæ ‘ä¸Šä¸€æ¡é‡é“¾æˆ–ä¸€æ£µå­æ ‘éƒ½æ˜¯çº¿æ®µæ ‘ä¸Šè¿ç»­çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ­£æ˜¯æ ‘å‰–çš„æ ¸å¿ƒã€‚ äºŒ. ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include&lt;bits/stdc++.h&gt;using namespace std;#define re registertypedef long long LL;const int MAXn = 1e5;const int MAXm = MAXn - 1;template &lt;class T&gt;inline void read(T &amp;x) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T s(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;x = s;&#125;int cntnext, head[MAXn + 10], nex[MAXm + 10], to[MAXm + 10];//////inline void Insert(int from, int too) &#123; // nex[++cntnext] = head[from]; //é‚»æ¥è¡¨ head[from] = cntnext; // to[cntnext] = too; //////&#125; struct Node &#123; //////çº¿æ®µæ ‘ LL sum; // int l; // int r; // LL add; //&#125;; //Node stt[MAXn * 4 + 10]; //void _BuildUseArray_(int nodeid, int l, int r, LL *array) &#123; // stt[nodeid].l = l; // stt[nodeid].r = r; // if (l == r) &#123; // stt[nodeid].sum = array[l]; // return; // &#125; // int mid = (l + r) &gt;&gt; 1; // _BuildUseArray_((nodeid &lt;&lt; 1), l, mid, array); // _BuildUseArray_((nodeid &lt;&lt; 1) + 1, mid + 1, r, array); // stt[nodeid].sum = (stt[(nodeid &lt;&lt; 1)].sum + stt[(nodeid &lt;&lt; 1) + 1].sum);&#125; //void _Build0_(int nodeid, int l, int r) &#123; // stt[nodeid].l = l; // stt[nodeid].r = r; // if (l == r) &#123; // return; // &#125; // int mid = (l + r) &gt;&gt; 1; // _Build0_((nodeid &lt;&lt; 1), l, mid); // _Build0_((nodeid &lt;&lt; 1) + 1, mid + 1, r); //&#125; //void _Spread_(int nodeid) &#123; // stt[(nodeid &lt;&lt; 1)].sum = ( stt[(nodeid &lt;&lt; 1)].sum + ((stt[(nodeid &lt;&lt; 1)].r - stt[(nodeid &lt;&lt; 1)].l + 1) * stt[nodeid].add) ); stt[(nodeid &lt;&lt; 1) + 1].sum = ( stt[(nodeid &lt;&lt; 1) + 1].sum + (stt[nodeid].add * (stt[(nodeid &lt;&lt; 1) + 1].r - stt[(nodeid &lt;&lt; 1) + 1].l + 1)) ); // stt[(nodeid &lt;&lt; 1)].add = (stt[(nodeid &lt;&lt; 1)].add + stt[nodeid].add); stt[(nodeid &lt;&lt; 1) + 1].add = (stt[(nodeid &lt;&lt; 1) + 1].add + stt[nodeid].add); // stt[nodeid].add = 0; /// &#125; ////////// çº¿æ®µæ ‘ void _Add_(int nodeid, int l, int r, LL k) &#123; /// if (stt[nodeid].l &gt;= l &amp;&amp; stt[nodeid].r &lt;= r) &#123; // stt[nodeid].add = (stt[nodeid].add + k); // stt[nodeid].sum = (stt[nodeid].sum + k * (stt[nodeid].r - stt[nodeid].l + 1)); return; // &#125; // _Spread_(nodeid); // int mid = (stt[nodeid].l + stt[nodeid].r) &gt;&gt; 1; // if (l &lt;= mid) _Add_((nodeid &lt;&lt; 1), l, r, k); // if (mid &lt; r) _Add_((nodeid &lt;&lt; 1) + 1, l, r, k); // stt[nodeid].sum = (stt[(nodeid &lt;&lt; 1)].sum + stt[(nodeid &lt;&lt; 1) + 1].sum);&#125; //LL _Eva_(int nodeid, int l, int r) &#123; // if (stt[nodeid].l &gt;= l &amp;&amp; stt[nodeid].r &lt;= r) // return stt[nodeid].sum; // _Spread_(nodeid); // LL val = 0; // int mid = (stt[nodeid].l + stt[nodeid].r) &gt;&gt; 1; // if (l &lt;= mid) val = (val + _Eva_((nodeid &lt;&lt; 1), l, r)); // if (mid &lt; r) val = (val + _Eva_((nodeid &lt;&lt; 1) + 1, l, r)); return val; //&#125; //void BuildUseArray(int l, int r, LL *array) &#123; // _BuildUseArray_(1, l, r, array); //&#125; //void Build0(int l, int r) &#123; // memset(stt, 0, sizeof(stt)); // _Build0_(1, l, r); //&#125; //void Add(int l, int r, LL k) &#123; // _Add_(1, l, r, k); //&#125; //LL Eva(int l, int r) &#123; // return _Eva_(1, l, r); //&#125; //////çº¿æ®µæ ‘ int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];//æ ‘å‰– int Dfs1(int nodeid, int fat, int deep) &#123; //// int size = 1; /// int maxsiz = 0; // int maxer = 0; // int eachsiz; // fa[nodeid] = fat; // dep[nodeid] = deep; // for (re int i = head[nodeid]; i; i = nex[i]) &#123; // eachsiz = Dfs1(to[i], nodeid, deep + 1); // size += eachsiz; // if (eachsiz &gt; maxsiz) &#123; // maxsiz = eachsiz; // maxer = to[i]; // &#125; // &#125; // siz[nodeid] = size; // hson[nodeid] = maxer; // return size; //&#125; // //int cntdfs, dfs[MAXn + 10], dfsidx[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10]; void Dfs2(int nodeid, int topp) &#123; // dfs[++cntdfs] = nodeid; // dfsidx[nodeid] = cntdfs; // top[nodeid] = topp; // if (hson[nodeid]) &#123; // Dfs2(hson[nodeid], topp); // for (int i = head[nodeid]; i; i = nex[i]) &#123; // if (to[i] != fa[nodeid] &amp;&amp; to[i] != hson[nodeid]) &#123; // Dfs2(to[i], to[i]); // &#125; // &#125; // &#125; // bottom[nodeid] = dfs[cntdfs]; //&#125; /// ////////// æ ‘å‰– void TreePathAdd(int x, int y, int k) &#123; /// while (top[x] != top[y]) &#123; // if (dep[top[x]] &gt; dep[top[y]]) &#123; // swap(x, y); // &#125; // Add(dfsidx[top[y]], dfsidx[y], k); // y = fa[top[y]]; // &#125; // if (dep[x] &gt; dep[y]) &#123; // swap(x, y); // &#125; // Add(dfsidx[x], dfsidx[y], k); //&#125; // //LL TreePathEva(int x, int y) &#123; // LL sum = 0; // while (top[x] != top[y]) &#123; // if (dep[top[x]] &gt; dep[top[y]]) &#123; // swap(x, y); // &#125; // sum += Eva(dfsidx[top[y]], dfsidx[y]); // y = fa[top[y]]; // &#125; // if (dep[x] &gt; dep[y]) &#123; // swap(x, y); // &#125; // sum += Eva(dfsidx[x], dfsidx[y]); // return sum; //&#125; // //void SonTreeAdd(int rootid, int k) &#123; // Add(dfsidx[rootid], dfsidx[bottom[rootid]], k); //&#125; // //LL SonTreeEva(int rootid) &#123; // return Eva(dfsidx[rootid], dfsidx[bottom[rootid]]); //&#125; //////æ ‘å‰– int n, q;int main() &#123; read(n); Build0(1, n); for (re int i = 1, from, to; i &lt; n; ++i) &#123; read(from), read(to); Insert(from + 1, to + 1); &#125; Dfs1(1, 0, 1); Dfs2(1, 1); read(q); for (re int i = 1, from, to, val, opt, root; i &lt;= q; ++i) &#123; getchar(); opt = getchar(); switch (opt) &#123; case &#x27;A&#x27;: read(from), read(to), read(val); TreePathAdd(from + 1, to + 1, val); break; case &#x27;Q&#x27;: read(root); printf(&quot;%lld\\n&quot;, SonTreeEva(root + 1)); break; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"å¡æ—¶","slug":"å¡æ—¶","date":"un22fin22","updated":"un66fin66","comments":true,"path":"2021/06/08/å¡æ—¶/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/08/%E5%8D%A1%E6%97%B6/","excerpt":"","text":"ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨å„å¤§è®¡ç®—æœºç«èµ›çš„èµ›åœºä¸Šï¼Œæ€»ä¼šæœ‰é‚£ä¹ˆä¸€æ ·ä¸œè¥¿ä»¤äººå¤´ç–¼ï¼Œä»¤æš´åŠ›çˆ†é›¶ï¼Œä»¤æœç´¢æ¬²å“­æ— æ³ªï¼›åœ¨å„å¤§åœ¨çº¿è¯„æµ‹ç³»ç»Ÿä¸Šï¼Œæ€»ä¼šæœ‰é‚£ä¹ˆä¸‰ä¸ªå­—æ¯æ•™ $n^2$ å¤±è´¥ï¼Œæ•™ $2^n$ æ— å¥ˆï¼Œæ•™ $n!$ ä¸€ä¸ªç‚¹éƒ½æ‹¿ä¸åˆ°ã€‚æ²¡é”™ï¼Œé‚£å°±æ˜¯ T-L-Eã€‚ ä»Šå¤©å°±æ¥åˆ†äº«åˆ†äº«æ€ä¹ˆé¿å…è¿™ä¸‰ä¸ªå¤§å­—çš„å‡ºç°ã€‚ æ­£æ–‡å¡æ—¶ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å¡æ—¶é—´ï¼Œç”¨å°½æ—¶é—´é™åˆ¶ä¸­çš„æ¯ä¸€å¾®ç§’ï¼Œæœç´¢çš„è¯å°±ç®—æ²¡æœå®Œï¼ŒæŠŠå±€éƒ¨æœ€å°å€¼è¾“å‡ºè‡³å°‘æœ‰å¯èƒ½ Aï¼Œå½“ç„¶å¦‚æœä½ çš„ç®—æ³•å¤ªå·®ä¹Ÿé¡¶å¤šåªèƒ½æŠŠ $TLE$ å˜æˆ $WA$ é‚£ä¹ˆå¼€å§‹å§ï¼ 1.ä»£ç ç›´æ¥æ”¾ä»£ç ï¼šï¼ˆé€’å½’åŒç†æˆ‘å°±ä¸å†æ”¾ä¸€éäº†ï¼‰ 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#include&lt;ctime&gt;using namespace std;#define re registerint main() &#123; for (re int i = 0; ; ++i)&#123; if (i &gt;= 500000000 &amp;&amp; i % 1000000 == 0 &amp;&amp; clock() &gt;= 990) &#123; printf(&quot;How many done: %d\\n&quot;, i); printf(&quot;Time used: %.6lf\\n&quot;, (double) clock() / CLOCKS_PER_SEC); /*åœ¨è¿™é‡Œè¾“å‡ºâ€œæ­£è§£â€*/ exit(EXIT_SUCCESS); &#125; /*åœ¨è¿™é‡Œæ”¾ç¨‹åºçš„ä¸»ä½“*/ &#125;&#125; 2.è®²è§£ #include&lt;cmath&gt; å¤´æ–‡ä»¶è®°å¾—åŠ ä¸Š &quot;if (i &gt;= 500000000 &amp;&amp; i % 1000000 == 0 &amp;&amp; clock() &gt;= 990)&quot; é‡ç‚¹ï¼ i &gt;= 500000000 â€‹ $500000000$ æ˜¯ä½ ä¼°è®¡çš„è¯¥å¾ªç¯ä½“èƒ½åœ¨è§„å®šæ—¶é—´èƒ½æ‰§è¡Œçš„æ¬¡æ•°ï¼Œå¾€å°ä¼°è®¡ä¸€ç‚¹ï¼ä¸ç„¶ç¨‹åºæ¥ä¸åŠåˆ¤æ–­ clock() &gt;= 990 å°±è¶…æ—¶äº†ã€‚ i % 1000000 == 0 â€‹ å› ä¸º clock å‡½æ•°çš„å¸¸æ•°å¾ˆå¤§ï¼Œå°½é‡å°‘æ˜¯æ‰§è¡Œä»–ï¼Œ æ‰€ä»¥åŠ è¿™ä¸ªæ¥å‡å°‘ clock() çš„æ‰§è¡Œæ¬¡æ•°ï¼Œ $1000000$ è¿™ä¸ªæ•°åˆ«è®¾å¤ªå¤§ï¼Œä¸ç„¶ä¹Ÿå®¹æ˜“æ²¡å¡ä½è€Œè¶…æ—¶ã€‚ clock() &gt;= 990 â€‹ æ•´ä¸ªå¡æ—¶ä¸­æœ€é‡è¦çš„éƒ¨åˆ†ï¼Œæ³¨æ„ä¸¤ç‚¹ï¼šä¸€ã€990 è¿™ä¸ªæ•°å­—å–å†³äºæ“ä½œç³»ç»Ÿï¼Œå› ä¸º $Windows$ çš„ CLOCKS_PER_SEC æ˜¯ $1000$ , $Linux$ ä¸‹æ˜¯ $1000000$ ï¼Œä¹Ÿå°±æ˜¯ $Window$ çš„ clock() è¿”å›å€¼å•ä½ä¸ºæ¯«ç§’ï¼Œ $Linux$ æ˜¯å¾®ç§’ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªå¡æ—¶ç¨‹åºè¦æ˜¯åœ¨ $Linux$ ä¸Šæµ‹ $990$ åº”è¯¥ä¸º $990000$ã€‚äºŒã€ä¸è¦å¤ªè´ªäº†ï¼Œ $1$ ç§’çš„é¢˜å¼€ä¸ª $980000$ å°±è¡Œäº†ï¼Œå¯åˆ«çœŸå¼€åˆ°å¼€ $1000000$ã€‚ å…³äºä¸‰è€…çš„é¡ºåº â€‹ æˆ‘ä»¬çŸ¥é“ï¼Œå‡ ä¸ª &amp;&amp; æˆ– || éš”å¼€çš„è¯­å¥é¡ºåºä¸ä¸€æ ·å¯èƒ½ä¼šæœ‰ä¸åŒçš„ç»“æœï¼Œå› ä¸ºå¦‚æœè®¡ç®—æœºé€šè¿‡é å‰çš„è¯­å¥èƒ½åˆ¤æ–­æ•´ä¸ªè¯­å¥çš„å¸ƒå°”å€¼å°±ä¸ä¼šæ‰§è¡Œåé¢çš„ï¼Œï¼ˆå¦‚ &amp;&amp; ä¹‹é—´å‡ºç° false , || ä¹‹é—´å‡ºç° true ï¼‰ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åº”è¯¥å°†è€—æ—¶å°‘çš„åˆ¤å®šæ”¾åœ¨å‰é¢ï¼Œè€—æ—¶ &gt;= $&lt;$ % $&lt;$ clock()ï¼Œæ‰€ä»¥æˆ‘ä»¬æŒ‰è¿™ä¸ªé¡ºåºæ”¾ç½®ã€‚å¦åˆ™ï¼Œå¡æ—¶çš„è€—æ—¶ç”šè‡³è¦æ¯”æœç´¢æœ¬èº«è€—æ—¶é«˜ï¼Œå¾—ä¸å¿å¤±ã€‚ exit(EXIT_SUCCESS) â€œç›¸å½“äº return 0 ï¼Œä¸ return 0 ä¸åŒçš„æ˜¯ï¼Œæ— è®ºä»–åœ¨å“ªæ‰§è¡Œï¼ˆåŒ…æ‹¬é™¤ main ä»¥å¤–çš„å‡½æ•°ï¼‰ï¼Œæ•´ä¸ªç¨‹åºç«‹å³ç»“æŸã€‚ä¾é é€’å½’çš„æœç´¢ä¸èƒ½ç”¨ return 0 æ¥åœæ­¢ï¼Œéœ€è¦ç”¨å®ƒã€‚ 3.ç»“æœ","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"è¿è¡Œæ—¶é—´æµ‹è¯•","slug":"è¿è¡Œæ—¶é—´æµ‹è¯•","date":"un22fin22","updated":"un66fin66","comments":true,"path":"2021/06/08/è¿è¡Œæ—¶é—´æµ‹è¯•/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95/","excerpt":"","text":"æœ‰ä¸€å¤©ï¼Œæˆ‘åœ¨ç½‘ä¸Šçœ‹åˆ°æœ‰äººè¯´é‡è½½ max() å‡½æ•°æ˜¯ä¸€ç§æœ‰ç”¨çš„å¡å¸¸æŠ€å·§ï¼Œä»Šå¤©å°±æ¥æµ‹ä¸€ä¸‹é‡è½½ max() åˆ°åº•æ˜¯æœ‰ç”¨è¿˜æ˜¯å¸®äº†å€’å¿™ã€‚ æ­£æ–‡1.ä»£ç ç›´æ¥æ”¾ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;#define re registertypedef long long LL;LL numof = 100000000;/*åœ¨è¿™é‡Œåšåˆå§‹åŒ–å’Œå‡†å¤‡å·¥ä½œ*/inline int Max(int a, int b) &#123; return a &gt; b ? a : b;&#125;/*åœ¨è¿™é‡Œåšåˆå§‹åŒ–å’Œå‡†å¤‡å·¥ä½œ*/int main() &#123; printf(&quot;Time to do %lld is &quot;, numof) ; clock_t emptystart = clock(); for (re LL i = 0; i &lt; numof; ++i) &#123; &#125; clock_t emptyend = clock(); clock_t teststart = clock(); for (re LL i = 0; i &lt; numof; ++i) &#123; /*åœ¨è¿™é‡Œæ”¾æµ‹è¯•ä»£ç */ max(13, 12); //Max(13, 12); /*åœ¨è¿™é‡Œæ”¾æµ‹è¯•ä»£ç */ &#125; clock_t testend = clock(); printf(&quot;%.6lf\\n&quot;, (double) ((testend - teststart) - (emptyend - emptystart)) / CLOCKS_PER_SEC); &#125; 2.è®²è§£ å¦‚æœ numof è®¾å¾—æ¯”è¾ƒå¤§æœ€å¥½åŠ ä¸Š emptystart å’Œ emptyend æ¥æ’é™¤å¾ªç¯æœ¬èº«çš„è€—æ—¶ã€‚ 123printf(&quot;%.6lf\\n&quot;, (double) ((testend - teststart) - (emptyend - emptystart)) / CLOCKS_PER_SEC); å¾ˆç®€å•ã€‚ 3.ç»“æœ C è‡ªå¸¦çš„ maxï¼š è‡ªåˆ¶çš„ Maxï¼š æ˜¯æœ‰ä¼˜åŒ–çš„ï¼Œä½†æ•ˆæœå¹¶ä¸æ˜æ˜¾ . . .","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"01åˆ†æ•°è§„åˆ’","slug":"TemLib/01åˆ†æ•°è§„åˆ’","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/01åˆ†æ•°è§„åˆ’/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","excerpt":"","text":"P4377 USACO18OPEN Talent Show G12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 250;const int MAXW = 1e3;const double MAXfrac = 1e6;const double EPS = 1e-8;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, W, w[MAXn + 10], t[MAXn + 10]; double v[MAXn + 10];double d[MAXW + 10];double calc(double x) &#123; for (int i = 1; i &lt;= n; ++i) &#123; v[i] = (double)t[i] - (double)w[i] * x; &#125; memset(d, 0xc2, sizeof(d)); d[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = W; ~j; --j) &#123; int k = min(j + w[i], W); d[k] = max(d[k], d[j] + v[i]); &#125; &#125; return d[W];&#125;signed main() &#123; read(n, W); for (int i = 1; i &lt;= n; ++i) &#123; read(w[i], t[i]); &#125; double L = 0, R = MAXfrac; while (R - L &gt; EPS) &#123; double mid = (L + R) / 2; if (calc(mid) &gt; 0) &#123; L = mid; &#125; else &#123; R = mid; &#125; &#125; printf(&quot;%d\\n&quot;, int(L * 1000));&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"01èƒŒåŒ…","slug":"TemLib/01èƒŒåŒ…","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/01èƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/01%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1048 [NOIP2005 æ™®åŠç»„] é‡‡è¯123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;LL n, W;LL d[MAXW + 10];inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = W; i &gt;= w; i--) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"2-Sat","slug":"TemLib/2-Sat","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/2-Sat/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/2-Sat/","excerpt":"","text":"P4782 ã€æ¨¡æ¿ã€‘2-SAT é—®é¢˜ 1. æš´åŠ›åˆ¤æ–­åšæ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e6;const int MAXm = 1e6;const int MAXnd = MAXn * 2;const int MAXeg = MAXm * 2;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int sta[MAXnd + 10];int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n, m;int top, stk[MAXnd + 10];inline int otherside(int cur) &#123; if (cur &gt; n) return cur - n; else return cur + n;&#125;bool Dfs(int cur) &#123; if (sta[cur] == 1) return 1; if (sta[cur] == -1) return 0; sta[cur] = 1; sta[otherside(cur)] = -1; stk[++top] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; if (!Dfs(to[i])) return 0; &#125; return 1;&#125;signed main() &#123; read(n, m); for (int i = 1, a, opta, b, optb; i &lt;= m; ++i) &#123; read(a, opta, b, optb); Insert(opta ? a : a + n, optb ? b + n : b); Insert(optb ? b : b + n, opta ? a + n : a); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (sta[i]) continue; top = 0; if (!Dfs(i)) &#123; while (top) &#123; sta[stk[top]] = sta[otherside(stk[top])] = 0; --top; &#125; if (!Dfs(i + n)) &#123; puts(&quot;IMPOSSIBLE&quot;); return 0; &#125; &#125; &#125; puts(&quot;POSSIBLE&quot;); for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d &quot;, sta[i + n] == 1 ? 1 : 0); &#125; puts(&quot;&quot;); return 0;&#125; 2. Tarjan ä¼˜åŒ–åšæ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const int MAXnd = MAXn * 2;const int MAXeg = MAXm * 2;int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntscc, inscc[MAXnd + 10]; vector&lt;int&gt; scc[MAXnd + 10];int top, stk[MAXnd + 10]; bool instk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]] == 0) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); &#125; else if (instk[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; ++cntscc; int x; do &#123; x = stk[top--]; instk[x] = 0; inscc[x] = cntscc; scc[cntscc].push_back(x); &#125; while (x != cur); &#125;&#125;int n, m, N;inline int otherside(int x) &#123; if (x &gt; n) return x - n; else return x + n;&#125;bool chosescc[MAXnd + 10];bool chosen[MAXn + 10];signed main() &#123; read(n, m); N = n * 2; for (int i = 1, x, a, y, b; i &lt;= m; ++i) &#123; read(x, a, y, b); Insert(a ? x : x + n, b ? y + n : y); Insert(b ? y : y + n, a ? x + n : x); &#125; for (int i = 1; i &lt;= N; ++i) &#123; if (dfs[i] == 0) &#123; Tarjan(i); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (inscc[i] == inscc[n + i]) &#123; puts(&quot;IMPOSSIBLE&quot;); return 0; &#125; &#125; puts(&quot;POSSIBLE&quot;); for (int i = 1; i &lt;= cntscc; ++i) &#123; if (chosescc[inscc[otherside(scc[i][0])]] == 0) &#123; chosescc[i] = 1; &#125; &#125; for (int i = 1; i &lt;= cntscc; ++i) &#123; if (chosescc[i]) &#123; for (auto j: scc[i]) &#123; if (j &gt; n) &#123; chosen[j - n] = 1; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d &quot;, chosen[i]); &#125; puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"AVL","slug":"TemLib/AVL","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/AVL/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/AVL/","excerpt":"","text":"Luogu P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138int root;int cntnd;int fa[MAXn + 10], son[MAXn + 10][2], hig[MAXn + 10];int val[MAXn + 10], cnt[MAXn + 10], siz[MAXn + 10];inline void pushup(int id) &#123; hig[id] = max(hig[son[id][0]], hig[son[id][1]]) + 1; siz[id] = siz[son[id][0]] + siz[son[id][1]] + cnt[id];&#125;inline int side(int id) &#123; return son[fa[id]][1] == id;&#125;inline void rotate(int id) &#123; int y = fa[id], z = fa[y], sideid = side(id), s = son[id][sideid ^ 1]; if (z) &#123;son[z][side(y)] = id;&#125; fa[id] = z; son[y][sideid] = s; if (s) &#123;fa[s] = y;&#125; son[id][sideid ^ 1] = y; fa[y] = id; pushup(y); pushup(id);&#125;inline void avl(int id) &#123; if (abs(hig[son[id][0]] - hig[son[id][1]]) &gt;= 2) &#123; int b = hig[son[id][0]] &lt; hig[son[id][1]], big = son[id][b]; if (hig[son[big][b]] &lt; hig[son[big][b ^ 1]]) rotate(son[big][b ^ 1]); int nwrt = son[id][b]; rotate(nwrt); if (fa[nwrt] == 0) root = nwrt; &#125;&#125;int top, stk[MAXn + 10];void Insert(int v) &#123; int id = root; top = 0; while (id) &#123; stk[++top] = id; if (v &lt; val[id]) id = son[id][0]; else if (v &gt; val[id]) id = son[id][1]; else break; &#125; if (id) &#123; ++cnt[id]; while (top) pushup(stk[top--]); &#125; else &#123; ++cntnd; if (stk[top]) son[stk[top]][v &gt; val[stk[top]]] = cntnd; else root = cntnd; fa[cntnd] = stk[top]; hig[cntnd] = 1; val[cntnd] = v; cnt[cntnd] = 1; siz[cntnd] = 1; while (top) &#123; pushup(stk[top]); avl(stk[top]); --top; &#125; &#125;&#125;void Delete(int v) &#123; int id = root; top = 0; while (id) &#123; stk[++top] = id; if (v &lt; val[id]) id = son[id][0]; else if (v &gt; val[id]) id = son[id][1]; else break; &#125; if (id) &#123; --cnt[id]; if (cnt[id]) &#123; while (top) pushup(stk[top--]); &#125; else &#123; if (son[id][0] == 0 &amp;&amp; son[id][1] == 0) &#123; if (top) --top; if (stk[top]) son[stk[top]][val[id] &gt; val[stk[top]]] = 0; else root = 0; &#125; else if (son[id][0] == 0 || son[id][1] == 0) &#123; if (top) --top; int s = son[id][son[id][0] == 0]; if (stk[top]) &#123; son[stk[top]][val[id] &gt; val[stk[top]]] = s; fa[s] = stk[top]; &#125; else &#123; root = s; fa[s] = 0; &#125; &#125; else &#123; int pre = son[id][0]; while (pre) &#123; stk[++top] = pre; pre = son[pre][1]; &#125; pre = stk[top--]; val[id] = val[pre]; cnt[id] = cnt[pre]; son[stk[top]][stk[top] != id] = son[pre][0]; if (son[pre][0]) fa[son[pre][0]] = stk[top]; &#125; while (top) &#123; pushup(stk[top]); avl(stk[top]); --top; &#125; &#125; &#125;&#125;int ValtoRank(int v) &#123; int id = root, ans = 1; while (id) &#123; if (v &lt; val[id]) &#123; id = son[id][0]; &#125; else if (v &gt; val[id]) &#123; ans += siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; else &#123; ans += siz[son[id][0]]; break; &#125; &#125; return ans;&#125;int RanktoId(int rk) &#123; int id = root; while (true) &#123; if (rk &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rk &lt;= siz[son[id][0]] + cnt[id]) &#123; return id; &#125; else &#123; rk -= siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; &#125;&#125;int PreId(int v) &#123; return RanktoId(ValtoRank(v) - 1);&#125;int NexId(int v) &#123; return RanktoId(ValtoRank(v + 1));&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Acè‡ªåŠ¨æœº","slug":"TemLib/Acè‡ªåŠ¨æœº","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/Acè‡ªåŠ¨æœº/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Ac%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"ac è‡ªåŠ¨æœºæœ‰ä¸¤ç§ï¼Œtrie æ ‘ç‰ˆå’Œ trie å›¾ç‰ˆã€‚ æ³¨æ„äº‹é¡¹ï¼š trie æ ‘ç‰ˆå¯ä»¥ç›´æ¥å°†æ ¹ï¼ˆç©ºä¸²çš„èŠ‚ç‚¹ï¼‰çš„ä¸‹æ ‡è®¾ä¸º 1ï¼Œè€Œ trie å›¾ç‰ˆè‹¥å°†æ ¹è®¾ä¸º 1 è¿˜éœ€å°† son æ•°ç»„çš„åˆå€¼å…¨éƒ¨è®¾ä¸º 1ã€‚ åœ¨å‡½æ•° evafail ä¸­ï¼Œé¦–å…ˆæ’å…¥é˜Ÿåˆ—çš„ä¸åº”è¯¥æ˜¯æ ¹èŠ‚ç‚¹ï¼Œè€Œåº”è¯¥æ˜¯æ ¹èŠ‚ç‚¹çš„å„¿å­èŠ‚ç‚¹ã€‚è¿™ä¸ kmp çš„å‡½æ•° evafail ä¸­å˜é‡ i ä» 2 å¼€å§‹çš„åŸå› ä¸€è‡´ã€‚ trie æ ‘ç‰ˆä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243int cntnd, son[MAXsumlenb + 10][26 + 2], fail[MAXsumlenb + 10];int cntep[MAXsumlenb + 10];void insert(int lenb, char *b) &#123; int cur = 0; for (int i = 1; i &lt;= lenb; ++i) &#123; if (son[cur][b[i]] == 0) son[cur][b[i]] = ++cntnd; cur = son[cur][b[i]]; &#125; ++cntep[cur];&#125;int l, r; int que[MAXsumlenb + 10];void evafail() &#123; l = 1, r = 0; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; fail[son[0][i]] = 0; que[++r] = son[0][i]; &#125; &#125; while (l &lt;= r) &#123; int i = que[l++]; for (int k = 0; k &lt; 26; ++k) &#123; if (son[i][k]) &#123; int j = fail[i]; while (j &amp;&amp; son[j][k] == 0) j = fail[j]; if (son[j][k]) j = son[j][k]; fail[son[i][k]] = j; que[++r] = son[i][k]; &#125; &#125; &#125;&#125;bool vis[MAXsumlenb + 10];ll match(int lena, char *a) &#123; ll ans = 0; int j = 0; for (int i = 1; i &lt;= lena; ++i) &#123; while (j &amp;&amp; son[j][a[i]] == 0) j = fail[j]; if (son[j][a[i]]) j = son[j][a[i]]; // ... &#125; return ans;&#125; trie å›¾ç‰ˆä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041int cntnd, son[MAXsumlenb + 10][26 + 2], fail[MAXsumlenb + 10];int cntep[MAXsumlenb + 10];void insert(int lenb, char *b) &#123; int cur = 0; for (int i = 1; i &lt;= lenb; ++i) &#123; if (son[cur][b[i]] == 0) son[cur][b[i]] = ++cntnd; cur = son[cur][b[i]]; &#125; ++cntep[cur];&#125;int l, r; int que[MAXsumlenb + 10];void evafail() &#123; l = 1, r = 0; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; fail[son[0][i]] = 0; que[++r] = son[0][i]; &#125; &#125; while (l &lt;= r) &#123; int i = que[l++]; for (int k = 0; k &lt; 26; ++k) &#123; if (son[i][k]) &#123; fail[son[i][k]] = son[fail[i]][k]; que[++r] = son[i][k]; &#125; else &#123; son[i][k] = son[fail[i]][k]; &#125; &#125; &#125;&#125;bool vis[MAXsumlenb + 10];ll match(int lena, char *a) &#123; ll ans = 0; int j = 0; for (int i = 1; i &lt;= lena; ++i) &#123; j = son[j][a[i]]; // ... &#125; return ans;&#125; é¢˜ç›®Luogu P3808 ã€æ¨¡æ¿ã€‘AC è‡ªåŠ¨æœºï¼ˆç®€å•ç‰ˆï¼‰ï¼ˆæ³¨ï¼šè¯¥é¢˜æ•°æ®è¿‡æ°´ï¼Œä¸å»ºè®®ä½œä¸ºæµ‹è¯•ä»£ç æ˜¯å¦æ­£ç¡®çš„æ ‡å‡†ï¼‰ ä»¥ trie æ ‘ç‰ˆä¸ºä¾‹ï¼Œä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXn = 1e6;const int MAXlena = 1e6;const int MAXlenb = 1e6;const int MAXsumlenb = 1e6;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXsumlenb + 10], cntnex, nex[MAXsumlenb + 10], to[MAXsumlenb + 10];inline void connect(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int cntnd, son[MAXsumlenb + 10][26 + 2], fail[MAXsumlenb + 10];int cntep[MAXsumlenb + 10];void insert(int lenb, char *b) &#123; int cur = 0; for (int i = 1; i &lt;= lenb; ++i) &#123; if (son[cur][b[i]] == 0) son[cur][b[i]] = ++cntnd; cur = son[cur][b[i]]; &#125; ++cntep[cur];&#125;int l, r; int que[MAXsumlenb + 10];void evafail() &#123; l = 1, r = 0; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; fail[son[0][i]] = 0; que[++r] = son[0][i]; &#125; &#125; while (l &lt;= r) &#123; int i = que[l++]; for (int k = 0; k &lt; 26; ++k) &#123; if (son[i][k]) &#123; int j = fail[i]; while (j &amp;&amp; son[j][k] == 0) j = fail[j]; if (son[j][k]) j = son[j][k]; fail[son[i][k]] = j; que[++r] = son[i][k]; &#125; &#125; &#125;&#125;bool vis[MAXsumlenb + 10];ll match(int lena, char *a) &#123; ll ans = 0; int j = 0; for (int i = 1; i &lt;= lena; ++i) &#123; while (j &amp;&amp; son[j][a[i]] == 0) j = fail[j]; if (son[j][a[i]]) j = son[j][a[i]]; int k = j; while (k &amp;&amp; vis[k] == 0) &#123; vis[k] = 1; ans += cntep[k]; k = fail[k]; &#125; &#125; return ans;&#125;int n;int lena; char a[MAXlena + 10];int lenb; char b[MAXlenb + 10];signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, b + 1); lenb = strlen(b + 1); for (int j = 1; j &lt;= lenb; ++j) b[j] -= &#x27;a&#x27;; insert(lenb, b); &#125; evafail(); scanf(&quot;%s&quot;, a + 1); lena = strlen(a + 1); for (int i = 1; i &lt;= lena; ++i) a[i] -= &#x27;a&#x27;; printf(&quot;%lld\\n&quot;, match(lena, a)); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Astar","slug":"TemLib/Astar","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Astar/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Astar/","excerpt":"","text":"A* è§£å…«æ•°ç Luogu P1379 å…«æ•°ç éš¾é¢˜ 1234567891011121314151617181920212223priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; pq;unordered_map&lt;string, int&gt; d;int Astar() &#123; d[bg] = 0; pq.push(make_pair(0 + Manh(bg), bg)); while (!pq.empty()) &#123; string sta = pq.top().second; pq.pop(); if (sta == ed) &#123; return d[sta]; &#125; Trans(sta); // Trans(string sta)å‡½æ•°å°†staå¯è½¬ç§»åˆ°çš„çŠ¶æ€å­˜åˆ°dealæ•°ç»„é‡Œ int D = d[sta] + 1; for (int i = 1; i &lt;= cntdeal; ++i) &#123; if (!d.count(deal[i]) || d[deal[i]] &gt; D) &#123; d[deal[i]] = D; pq.push(make_pair(D + Manh(deal[i]), deal[i])); // Manh(string sta)å‡½æ•°æ±‚staåˆ°endçš„æ€»æ›¼å“ˆé¡¿é•¿åº¦ï¼Œå³ä¼°ä»·å‡½æ•° &#125; &#125; &#125; return -1;&#125; A* è§£kçŸ­è·¯Acwing 178. ç¬¬KçŸ­è·¯ 123456789101112131415161718192021222324int Astar(int s, int t, int kth) &#123; if (dis[s] == INF) return -1; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; int times = 0; pq.push(make_pair(0 + dis[s], s)); while (!pq.empty()) &#123; int cur = pq.top().second, dist = pq.top().first - dis[cur]; pq.pop(); if (cur == t) &#123; if (++times == kth) &#123; return dist; &#125; &#125; for (int i = head[cur]; i; i = nex[i]) &#123; pq.push(make_pair(dist + wei[i] + dis[to[i]], to[i])); &#125; &#125; return -1;&#125;signed main() &#123; // ... Dijkstra(t); // åå‘è¾¹ä¸Šè·‘ Dij printf(&quot;%d\\n&quot;, Astar(s, t, kth)); // æ­£å‘è¾¹ä¸Šè·‘ A*&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"æœç´¢","slug":"æœç´¢","permalink":"http://rsdbkhusky.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Bsgs","slug":"TemLib/Bsgs","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Bsgs/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Bsgs/","excerpt":"","text":"P3846 [TJOI2007] å¯çˆ±çš„è´¨æ•°/ã€æ¨¡æ¿ã€‘BSGS 123456789101112unordered_map&lt;int, int&gt; mp;int Bsgs(int a, int b, int p) &#123; if (1 % p == b % p) return 0; int k = sqrt(p) + 1; for (int i = 0, val = b % p; i &lt; k; ++i, val = val * a % p) &#123; mp[val] = i; &#125; for (int i = 1, ak = power(a, k, p), val = ak; i &lt;= k; ++i, val = val * ak % p) &#123; if (mp.count(val)) return k * i - mp[val]; &#125; return -1;&#125; Luogu P4195 ã€æ¨¡æ¿ã€‘æ‰©å±• BSGS/exBSGS 12345678910111213141516int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; /* ... */ &#125;inline int inv(int a, int p) &#123; /* ... */ &#125;unordered_map&lt;int, int&gt; mp;inline int Bsgs(int a, int b, int p) &#123; /* ... */ &#125;int exBsgs(int a, int b, int p) &#123; b = (b % p + p) % p; int d = gcd(a, p); if (d == 1) &#123; return Bsgs(a, b, p); &#125; else &#123; if (1 % p == b % p) return 0; if (b % d) return NINF; else return exBsgs(a, b / d * inv(a / d, p / d), p / d) + 1; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Cdqè§£ä¸‰ç»´ååº","slug":"TemLib/Cdqè§£ä¸‰ç»´ååº","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/Cdqè§£ä¸‰ç»´ååº/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Cdq%E8%A7%A3%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940struct Ele &#123; int cnt, idx; int a, b, c; inline bool operator==(const Ele sec) const &#123; return a == sec.a &amp;&amp; b == sec.b &amp;&amp; c == sec.c; &#125;&#125;;inline bool cmpc(Ele fir, Ele sec) &#123; if (fir.c != sec.c) return fir.c &lt; sec.c; else if (fir.b != sec.b) return fir.b &lt; sec.b; else return fir.a &lt; sec.a;&#125;inline bool cmpb(Ele fir, Ele sec) &#123; if (fir.b != sec.b) return fir.b &lt; sec.b; else return fir.a &lt; sec.a;&#125;Ele tmpele[MAXn + 10];int cntele; Ele ele[MAXn + 10];int idx[MAXn + 10], ans[MAXn + 10];void cdq(int l, int r) &#123; if (l == r) return; else &#123; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int i = l; for (int j = mid + 1; j &lt;= r; ++j) &#123; while (i &lt;= mid &amp;&amp; ele[i].b &lt;= ele[j].b) &#123; modify(ele[i].a, ele[i].cnt, mxa); ++i; &#125; ans[ele[j].idx] += query(ele[j].a); &#125; for (int k = l; k &lt; i; ++k) &#123; modify(ele[k].a, -ele[k].cnt, mxa); &#125; inplace_merge(ele + l, ele + 1 + mid, ele + 1 + r, cmpb); &#125;&#125; Luogu P3810 ã€æ¨¡æ¿ã€‘ä¸‰ç»´ååºï¼ˆé™Œä¸ŠèŠ±å¼€ï¼‰ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXa = 2e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, mxa;int t[MAXa + 10];inline int lowbit(int x) &#123; return x &amp; -x;&#125;inline void modify(int p, int v, int n) &#123; while (p &lt;= n) &#123; t[p] += v; p += lowbit(p); &#125;&#125;inline int query(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;struct Ele &#123; int cnt, idx; int a, b, c; inline bool operator==(const Ele sec) const &#123; return a == sec.a &amp;&amp; b == sec.b &amp;&amp; c == sec.c; &#125;&#125;;inline bool cmpc(Ele fir, Ele sec) &#123; if (fir.c != sec.c) return fir.c &lt; sec.c; else if (fir.b != sec.b) return fir.b &lt; sec.b; else return fir.a &lt; sec.a;&#125;inline bool cmpb(Ele fir, Ele sec) &#123; if (fir.b != sec.b) return fir.b &lt; sec.b; else return fir.a &lt; sec.a;&#125;Ele tmpele[MAXn + 10];int cntele; Ele ele[MAXn + 10];int idx[MAXn + 10], ans[MAXn + 10];void cdq(int l, int r) &#123; if (l == r) return; else &#123; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int i = l; for (int j = mid + 1; j &lt;= r; ++j) &#123; while (i &lt;= mid &amp;&amp; ele[i].b &lt;= ele[j].b) &#123; modify(ele[i].a, ele[i].cnt, mxa); ++i; &#125; ans[ele[j].idx] += query(ele[j].a); &#125; for (int k = l; k &lt; i; ++k) &#123; modify(ele[k].a, -ele[k].cnt, mxa); &#125; inplace_merge(ele + l, ele + 1 + mid, ele + 1 + r, cmpb); &#125;&#125;int bucans[MAXn + 10];signed main() &#123; read(n, mxa); for (int i = 1; i &lt;= n; ++i) &#123; read(tmpele[i].a, tmpele[i].b, tmpele[i].c); tmpele[i].cnt = 1; &#125; sort(tmpele + 1, tmpele + 1 + n, cmpc); for (int i = 1; i &lt;= n; ++i) &#123; if (cntele &amp;&amp; ele[cntele] == tmpele[i]) ++ele[cntele].cnt; else &#123; ++cntele; ele[cntele] = tmpele[i]; ele[cntele].idx = cntele; &#125; idx[i] = cntele; &#125; for (int i = 1; i &lt;= cntele; ++i) &#123; ans[i] = ele[i].cnt - 1; &#125; cdq(1, cntele); for (int i = 1; i &lt;= n; ++i) &#123; ++bucans[ans[idx[i]]]; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d\\n&quot;, bucans[i]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Cyaronæ¨¡æ¿","slug":"TemLib/Cyaronæ¨¡æ¿","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/Cyaronæ¨¡æ¿/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Cyaron%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"æ¨èä¸€æ¬¾ä¸é”™çš„æ•°æ®ç”Ÿæˆå™¨ï¼šCYaRonï¼Œä¸€ä¸ªåŸºäºPythonçš„æµ‹è¯•æ•°æ®ç”Ÿæˆåº“ã€‚èƒ½å¤Ÿç”Ÿæˆä¸€éƒ¨åˆ†ä¿¡æ¯ç«èµ›ä¸­éœ€è¦çš„æ•°æ®ï¼Œæ“ä½œç®€å•ï¼Œæ˜“å…¥é—¨ã€‚ é¡¹ç›®åœ°å€ éƒ¨ç½²åŠåŸºæœ¬è¯­æ³•è¯¦è§ luogu å®˜æ–¹æ–‡æ¡£ã€‚ å¸¸ç”¨æ¨¡æ¿ æ•°æ®ç”Ÿæˆ 1234567891011121314151617from cyaron import *_n = ati([1, 7, 50, 1E4])_m = ati([1, 11, 100, 1E4])for i in range(1, 4): io = IO(file_prefix = &quot;name&quot;, data_id = i) n = _n[i] m = _m[i] s = randint(1, n) t = randint(1, n) graph = Graph.graph(n, m, weight_limit = 5) io.input_writeln(n, m, s, t) io.input_writeln(graph) io.output_gen(&quot;std&quot;) å¯¹æ‹ 12345678910111213141516171819from cyaron import *for i in range(1000): print(&quot;Case:&#123;0&#125;&quot;.format(i)) iostd = IO(&quot;name.in&quot;, &quot;name.stdout&quot;) iotest = IO(&quot;name.in&quot;, &quot;name.testout&quot;) n = randint(1, 3) m = randint(n - 1, 5) s = randint(1, n) t = randint(1, n) graph = Graph.UDAG(n, m, weight_limit = 10) iostd.input_writeln(n, m, s, t) iostd.input_writeln(graph.to_str(shuffle = True)) iostd.output_gen(&quot;./std&quot;) iotest.output_gen(&quot;./test&quot;) Compare.output(&quot;name.testout&quot;, std = &quot;name.stdout&quot;)","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Floydè§£æœ€å°ç¯","slug":"TemLib/Floydè§£æœ€å°ç¯","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Floydè§£æœ€å°ç¯/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Floyd%E8%A7%A3%E6%9C%80%E5%B0%8F%E7%8E%AF/","excerpt":"","text":"P6175 æ— å‘å›¾çš„æœ€å°ç¯é—®é¢˜#include&lt;bits/stdc++.h&gt; using namespace std; const int MAXn = 1e2; const int INF = 0x20202020; template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#39;0&#39; || c &gt; &#39;9&#39;);register T x(c - &#39;0&#39;);while (c = getchar(), c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125; template &lt;typename T, typename ...Argv&gt; inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...); &#125; int n, m, ans = INF; int wei[MAXn + 10][MAXn + 10], dis[MAXn + 10][MAXn + 10]; signed main() &#123; read(n, m); memset(wei, 0x20, sizeof(wei)); memset(dis, 0x20, sizeof(dis)); for (int i = 1; i &lt;= n; ++i) &#123; wei[i][i] = dis[i][i] = 0; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); wei[u][v] = wei[v][u] = dis[u][v] = dis[v][u] = min(dis[u][v], w); &#125; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j || j == k || k == i) continue; ans = min(ans, wei[i][k] + wei[k][j] + dis[j][i]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125; if (ans == INF) &#123; printf(&quot;No solution.\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, ans); &#125; &#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Exgcdæ±‚é€†å…ƒ","slug":"TemLib/Exgcdæ±‚é€†å…ƒ","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Exgcdæ±‚é€†å…ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Exgcd%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒæ­¤é¢˜ä¸æ˜¯æ±‚å•ä¸ªé€†å…ƒçš„æ¨¡æ¿é¢˜ï¼Œä½†å¯ä»¥ç”¨è¿™é“æ¨¡æ¿é¢˜æ£€éªŒè¿™ç§æ±‚é€†æ–¹æ³•çš„æ­£ç¡®æ€§ï¼ˆæ²¡æœ‰WAï¼‰ 123456789101112131415int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Gcd Lcm","slug":"TemLib/Gcd Lcm","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Gcd Lcm/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Gcd%20Lcm/","excerpt":"","text":"P1029 [NOIP2001 æ™®åŠç»„] æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°é—®é¢˜1. æœ€å¤§å…¬çº¦æ•°(gcd) è¾—è½¬ç›¸é™¤æ³• 123int gcd(int a, int b) return b ? gcd(b, a % b) : a;&#125; æ›´ç›¸å‡æŸæœ¯ å¸¦å–æ¨¡çš„ 123456789101112131415int gcd(int a, int b) &#123; int twice = 1; while (a % 2 == 0 &amp;&amp; b % 2 == 0) &#123; a /= 2, b /= 2; twice *= 2; &#125; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return twice * a;&#125; ä¸å¸¦å–æ¨¡çš„ 12345678910int gcd(int a, int b) &#123; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return a;&#125; 2. æœ€å°å…¬å€æ•°123int lcm(int a, int b) &#123; return a / gcd(a, b) * b; &#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Johnsonå…¨æºæœ€çŸ­è·¯","slug":"TemLib/Johnsonå…¨æºæœ€çŸ­è·¯","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Johnsonå…¨æºæœ€çŸ­è·¯/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Johnson%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P5905 ã€æ¨¡æ¿ã€‘Johnson å…¨æºæœ€çŸ­è·¯ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 3e3;const int MAXm = 6e3;const int INF = 1e9;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline void clear(priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; &amp;pq) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pqempty; pq = pqempty;&#125;int head[MAXn + 10], cntnex, nex[MAXm + MAXn + 10], from[MAXm + MAXn + 10], to[MAXm + MAXn + 10], wei[MAXm + MAXn + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; from[cntnex] = u; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m;int h[MAXn + 10], cntinque[MAXn + 10]; bool inque[MAXn + 10]; queue&lt;int&gt; q;bool Spfa(int sour) &#123; fill(begin(h), end(h), INF); h[sour] = 0; q.push(sour); inque[sour] = 1; ++cntinque[sour]; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (h[to[i]] &gt; h[cur] + wei[i]) &#123; h[to[i]] = h[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; ++cntinque[to[i]]; if (cntinque[to[i]] &gt; n + 1) &#123; return 0; &#125; &#125; &#125; &#125; &#125; return 1;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10]; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;void Dijkstra(int sour) &#123; memset(vis, 0, sizeof(vis)); fill(begin(dis), end(dis), INF); dis[sour] = 0; pq.push(make_pair(0, sour)); while (!pq.empty()) &#123; int cur = pq.top().second; pq.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; pq.push(make_pair(dis[to[i]], to[i])); &#125; &#125; &#125;&#125;signed main() &#123; read(n, m); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); Insert(u, v, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; Insert(n + 1, i, 0); &#125; if (!Spfa(n + 1)) &#123; puts(&quot;-1&quot;); return 0; &#125; for (int i = 1; i &lt;= cntnex; ++i) &#123; wei[i] = wei[i] + h[from[i]] - h[to[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int ans = 0; Dijkstra(i); for (int j = 1; j &lt;= n; ++j) &#123; if (dis[j] == INF) &#123; ans += j * INF; &#125; else &#123; ans += j * (dis[j] - h[i] + h[j]); &#125; &#125; printf(&quot;%lld\\n&quot;, ans); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Kdæ ‘","slug":"TemLib/Kdæ ‘","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Kdæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Kd%E6%A0%91/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106struct Point &#123; int x, y;&#125;;inline bool cmpx(Point fir, Point sec) &#123; if (fir.x == sec.x) &#123; return fir.y &lt; sec.y; &#125; return fir.x &lt; sec.x;&#125;inline bool cmpy(Point fir, Point sec) &#123; if (fir.y == sec.y) &#123; return fir.x &lt; sec.x; &#125; return fir.y &lt; sec.y;&#125;inline double distpp(Point a, Point b) &#123; return sqrt((double)(a.x - b.x) * (a.x - b.x) + (double)(a.y - b.y) * (a.y - b.y));&#125;struct Rect &#123; int x1, x2, y1, y2; inline Rect operator+(const Rect sec) const &#123; Rect ans; ans.x1 = min(x1, sec.x1); ans.x2 = max(x2, sec.x2); ans.y1 = min(y1, sec.y1); ans.y2 = max(y2, sec.y2); return ans; &#125;&#125;;inline double distpr(Point a, Rect b) &#123; double ans = 0; if (a.x &lt; b.x1) ans += (double)(a.x - b.x1) * (a.x - b.x1); if (a.x &gt; b.x2) ans += (double)(a.x - b.x2) * (a.x - b.x2); if (a.y &lt; b.y1) ans += (double)(a.y - b.y1) * (a.y - b.y1); if (a.y &gt; b.y2) ans += (double)(a.y - b.y2) * (a.y - b.y2); return sqrt(ans);&#125;int n;Point a[MAXn + 10];int root, ls[MAXn + 10], rs[MAXn + 10];Rect area[MAXn + 10];inline void pushup(int id) &#123; area[id].x1 = area[id].x2 = a[id].x; area[id].y1 = area[id].y2 = a[id].y; if (ls[id]) area[id] = area[id] + area[ls[id]]; if (rs[id]) area[id] = area[id] + area[rs[id]];&#125;int Build(int l, int r) &#123; if (l &gt; r) return 0; int mid = (l + r) &gt;&gt; 1; double avx = 0, avy = 0, vax = 0, vay = 0; for (int i = l; i &lt;= r; ++i) &#123; avx += a[i].x; avy += a[i].y; &#125; avx /= r - l + 1; avy /= r - l + 1; for (int i = l; i &lt;= r; ++i) &#123; vax += (a[i].x - avx) * (a[i].x - avx); vay += (a[i].y - avy) * (a[i].y - avy); &#125; if (vax &gt; vay) nth_element(a + l, a + mid, a + 1 + r, cmpx); else nth_element(a + l, a + mid, a + 1 + r, cmpy); ls[mid] = Build(l, mid - 1); rs[mid] = Build(mid + 1, r); pushup(mid); return mid;&#125;double ans = INF;void query(int id, int idx) &#123; if (id == 0) return; if (id != idx) ans = min(ans, distpp(a[id], a[idx])); double distls = distpr(a[idx], area[ls[id]]), distrs = distpr(a[idx], area[rs[id]]); if (distls &lt; ans &amp;&amp; distrs &lt; ans) &#123; if (distls &lt; distrs) &#123; query(ls[id], idx); if (distrs &lt; ans) query(rs[id], idx); &#125; else &#123; query(rs[id], idx); if (distls &lt; ans) query(ls[id], idx); &#125; &#125; else if (distls &lt; ans) &#123; query(ls[id], idx); &#125; else if (distrs &lt; ans) &#123; query(rs[id], idx); &#125;&#125;void Solve() &#123; for (int i = 1; i &lt;= n; ++i) &#123; query(root, i); &#125;&#125;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i].x, a[i].y); &#125; root = Build(1, n); Solve(); printf(&quot;%.4lf\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"Kruskalé‡æ„æ ‘","slug":"TemLib/Kruskalé‡æ„æ ‘","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/Kruskalé‡æ„æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Kruskal%E9%87%8D%E6%9E%84%E6%A0%91/","excerpt":"","text":"Luogu P4768 [NOI2018] å½’ç¨‹ 1234567891011121314int N;void ExKruskal() &#123; InitAdjList(); InitDisSet(); N = n; sort(eg + 1, eg + 1 + m); for (int i = 1, ancu, ancv; i &lt;= m; ++i) &#123; ancu = anc(eg[i].u); ancv = anc(eg[i].v); if (ancu == ancv) continue; father[ancu] = father[ancv] = ++N; Insert(N, ancu, 0); Insert(N, ancv, 0); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Kmp","slug":"TemLib/Kmp","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/Kmp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Kmp/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ Luogu P3375 ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é… ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940int fail[MAXlenb + 10];void evafail(int lenb, char *b) &#123; int j = 0; fail[1] = j; for (int i = 2; i &lt;= lenb; ++i) &#123; while (j &amp;&amp; b[j + 1] != b[i]) j = fail[j]; if (b[j + 1] == b[i]) ++j; fail[i] = j; &#125;&#125;bool ismatch[MAXlena + 10];void match(int lena, char *a, int lenb, char *b) &#123; int j = 0; for (int i = 1; i &lt;= lena; ++i) &#123; while (j &amp;&amp; (j == lenb || b[j + 1] != a[i])) j = fail[j]; if (b[j + 1] == a[i]) ++j; if (j == lenb) ismatch[i - lenb + 1] = 1; &#125;&#125;int lena; char a[MAXlena + 10];int lenb; char b[MAXlenb + 10];signed main() &#123; scanf(&quot;%s&quot;, a + 1); lena = strlen(a + 1); scanf(&quot;%s&quot;, b + 1); lenb = strlen(b + 1); evafail(lenb, b); match(lena, a, lenb, b); for (int i = 1; i &lt;= lena; ++i) &#123; if (ismatch[i]) &#123; printf(&quot;%d\\n&quot;, i); &#125; &#125; for (int i = 1; i &lt;= lenb; ++i) &#123; printf(&quot;%d &quot;, fail[i]); &#125; puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Manacher","slug":"TemLib/Manacher","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Manacher/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Manacher/","excerpt":"","text":"P3805 ã€æ¨¡æ¿ã€‘manacher ç®—æ³•1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e7 + 1e6;char str[MAXn * 2 + 10];int rad[MAXn * 2 + 10];void EvaRad(int len) &#123; for (int i = 1, l = 1, r = 0; i &lt;= len; ++i) &#123; if (i &gt; r) rad[i] = 0; else rad[i] = min(r - i, rad[r + l - i]); while (i + rad[i] &lt; len &amp;&amp; i - rad[i] &gt; 1 &amp;&amp; str[i + rad[i] + 1] == str[i - rad[i] - 1]) ++rad[i]; if (i + rad[i] &gt; r) &#123; r = i + rad[i]; l = i - rad[i]; &#125; &#125;&#125;char strfirst[MAXn + 10];int len1, len2, ans;signed main() &#123; scanf(&quot;%s&quot;, (strfirst + 1)); len1 = strlen(strfirst + 1); str[++len2] = &#x27;#&#x27;; for (int i = 1; i &lt;= len1; ++i) &#123; str[++len2] = strfirst[i]; str[++len2] = &#x27;#&#x27;; &#125; EvaRad(len2); for (int i = 1; i &lt;= len2; ++i) &#123; ans = max(ans, i &amp; 1 ? (rad[i] &amp; (~1)) : (rad[i] &amp; (~1)) + 1); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Splay","slug":"TemLib/Splay","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/Splay/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Splay/","excerpt":"","text":"é¢˜ç›®åˆé›†ï¼š ç»´æŠ¤é€’å¢çš„ä¸­åºéå† P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ æŒ‰é¢˜ç›®è¦æ±‚ç»´æŠ¤çš„ä¸­åºéå†ï¼ˆä¸­åºéå†ç»´æŠ¤åºåˆ—ï¼‰ P3391 ã€æ¨¡æ¿ã€‘æ–‡è‰ºå¹³è¡¡æ ‘ æ“ä½œåˆé›†+Splayå»ºæ ‘ï¼šP2042 [NOI2005] ç»´æŠ¤æ•°åˆ— Splay åˆå¹¶ P3224 [HNOI2012]æ°¸æ— ä¹¡ æ³¨æ„äº‹é¡¹ï¼š é¢˜ç›®ã€Œæ™®é€šå¹³è¡¡æ ‘ã€ä¸­å‡½æ•° precid å’Œ nexid ä¸­çš„å˜é‡ ans åˆå€¼åº”è®¾ä¸ºæ¯”å“¨å…µèŠ‚ç‚¹çš„æ›´å°å’Œæ›´å¤§ï¼Œå¦‚å“¨å…µèŠ‚ç‚¹è®¾ä¸º NINF å’Œ INFï¼Œåˆ™ ans åˆå€¼å¯è®¾ä¸º NINF - 1 å’Œ INF + 1ã€‚ Luogu P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, root, son[MAXn + 10][2], fa[MAXn + 10];int cnt[MAXn + 10], siz[MAXn + 10], val[MAXn + 10];inline void pushup(int id) &#123; siz[id] = cnt[id] + siz[son[id][0]] + siz[son[id][1]];&#125;inline bool side(int id) &#123; return son[fa[id]][1] == id;&#125;inline void rotate(int id) &#123; int y = fa[id], z = fa[y], sideid = side(id), s = son[id][sideid ^ 1]; if (z) &#123;son[z][side(y)] = id;&#125; fa[id] = z; son[y][sideid] = s; if (s) &#123;fa[s] = y;&#125; son[id][sideid ^ 1] = y; fa[y] = id; pushup(y); pushup(id);&#125;inline void splay(int id, int goal = 0) &#123; int y; while (fa[id] != goal) &#123; y = fa[id]; if (fa[y] != goal) &#123; if (side(id) == side(y)) rotate(y); else rotate(id); &#125; rotate(id); &#125; if (goal == 0) root = id;&#125;void build() &#123; cntnd = 2; root = 1; son[1][1] = 2; cnt[1] = 1; siz[1] = 2; val[1] = NINF; fa[2] = 1; cnt[2] = 1; siz[2] = 1; val[2] = INF;&#125;int valtorank(int v) &#123; int ans = 1, id = root, faid = 0; while (id) &#123; faid = id; if (v &lt; val[id]) &#123; id = son[id][0]; &#125; else if (v == val[id]) &#123; ans += siz[son[id][0]]; break; &#125; else &#123; ans += siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; &#125; splay(faid); return ans;&#125;int ranktoid(int rk) &#123; int id = root; while (true) &#123; if (rk &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rk &lt;= siz[son[id][0]] + cnt[id]) &#123; break; &#125; else &#123; rk -= siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; &#125; splay(id); return id;&#125;int precid(int v) &#123; int ans = NINF - 1, anser = -1, id = root, faid = 0; while (id) &#123; faid = id; if (val[id] &gt;= v) &#123; id = son[id][0]; &#125; else &#123; if (ans &lt; val[id]) &#123; ans = val[id]; anser = id; &#125; id = son[id][1]; &#125; &#125; splay(faid); return anser;&#125;int nexid(int v) &#123; int ans = INF + 1, anser = -1, id = root, faid = 0; while (id) &#123; faid = id; if (val[id] &lt;= v) &#123; id = son[id][1]; &#125; else &#123; if (ans &gt; val[id]) &#123; ans = val[id]; anser = id; &#125; id = son[id][0]; &#125; &#125; splay(faid); return anser;&#125;void insert(int v) &#123; int prec = precid(v), nex = nexid(v); splay(prec); splay(nex, prec); int id = son[nex][0]; if (id == 0) &#123; id = ++cntnd; son[nex][0] = id; fa[id] = nex; val[id] = v; &#125; ++cnt[id]; pushup(id); pushup(nex); pushup(prec);&#125;void delet(int v) &#123; int prec = precid(v), nex = nexid(v); splay(prec); splay(nex, prec); int id = son[nex][0]; if (id == 0) return; --cnt[id]; pushup(id); pushup(nex); pushup(prec); if (cnt[id] == 0) &#123; son[nex][0] = 0; &#125;&#125;int n;signed main() &#123; build(); read(n); for (int i = 1, opt, x; i &lt;= n; ++i) &#123; read(opt, x); if (opt == 1) insert(x); else if (opt == 2) delet(x); else if (opt == 3) printf(&quot;%d\\n&quot;, valtorank(x) - 1); else if (opt == 4) printf(&quot;%d\\n&quot;, val[ranktoid(x + 1)]); else if (opt == 5) printf(&quot;%d\\n&quot;, val[precid(x)]); else if (opt == 6) printf(&quot;%d\\n&quot;, val[nexid(x)]); &#125; return 0;&#125; Luogu P3391 ã€æ¨¡æ¿ã€‘æ–‡è‰ºå¹³è¡¡æ ‘ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, root, son[MAXn + 10][2], fa[MAXn + 10];int siz[MAXn + 10], val[MAXn + 10];int lzrev[MAXn + 10];inline void putrev(int id) &#123; swap(son[id][0], son[id][1]); lzrev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (lzrev[id]) &#123; if (son[id][0]) putrev(son[id][0]); if (son[id][1]) putrev(son[id][1]); lzrev[id] = 0; &#125;&#125;inline void pushup(int id) &#123; siz[id] = 1 + siz[son[id][0]] + siz[son[id][1]];&#125;inline bool side(int id) &#123; return son[fa[id]][1] == id;&#125;inline void rotate(int id) &#123; int y = fa[id], z = fa[y], sideid = side(id), s = son[id][sideid ^ 1]; if (z) &#123;son[z][side(y)] = id;&#125; fa[id] = z; son[y][sideid] = s; if (s) &#123;fa[s] = y;&#125; son[id][sideid ^ 1] = y; fa[y] = id; pushup(y); pushup(id);&#125;inline void splay(int id, int goal = 0) &#123; int y; while (fa[id] != goal) &#123; y = fa[id]; if (fa[y] != goal) &#123; if (side(id) == side(y)) rotate(y); else rotate(id); &#125; rotate(id); &#125; if (goal == 0) root = id;&#125;int build2(int l, int r, int f) &#123; int rt = ++cntnd, mid = (l + r) &gt;&gt; 1; fa[rt] = f; val[rt] = mid; if (l &lt; mid) son[rt][0] = build2(l, mid - 1, rt); if (r &gt; mid) son[rt][1] = build2(mid + 1, r, rt); pushup(rt); return rt;&#125;void build1(int n) &#123; cntnd = 2; root = 1; son[1][1] = 2; val[1] = NINF; fa[2] = 1; val[2] = INF; son[2][0] = build2(1, n, 2); pushup(2); pushup(1);&#125;int ranktoid(int rk) &#123; int id = root; while (true) &#123; pushdown(id); if (rk &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rk &lt;= siz[son[id][0]] + 1) &#123; break; &#125; else &#123; rk -= siz[son[id][0]] + 1; id = son[id][1]; &#125; &#125; splay(id); return id;&#125;void modifyrev(int l, int r) &#123; int prec = ranktoid(l - 1), nex = ranktoid(r + 1); splay(prec); splay(nex, prec); int tar = son[nex][0]; if (tar) putrev(tar);&#125;void traversal(int id) &#123; pushdown(id); if (son[id][0]) traversal(son[id][0]); if (val[id] != NINF &amp;&amp; val[id] != INF) printf(&quot;%d &quot;, val[id]); if (son[id][1]) traversal(son[id][1]);&#125;int n, m;signed main() &#123; read(n, m); build1(n); for (int i = 1, l, r; i &lt;= m; ++i) &#123; read(l, r); modifyrev(l + 1, r + 1); &#125; traversal(root); puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Stè¡¨","slug":"TemLib/Stè¡¨","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/Stè¡¨/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/St%E8%A1%A8/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 12345678910111213141516int mx[MAXn + 10][MAXlog2_n + 2];void build(int n, int *a) &#123; int log2_n = log(n) / ln2; for (int i = 1; i &lt;= n; ++i) &#123; mx[i][0] = a[i]; &#125; for (int i = 1; i &lt;= log2_n; ++i) &#123; for (int j = 1, topj = n - power2[i] + 1; j &lt;= topj; ++j) &#123; mx[j][i] = max(mx[j][i - 1], mx[j + power2[i - 1]][i - 1]); &#125; &#125;&#125;int querymax(int l, int r) &#123; int loglen = log(r - l + 1) / ln2; return max(mx[l][loglen], mx[r - power2[loglen] + 1][loglen]);&#125; Luogu P3865 ã€æ¨¡æ¿ã€‘ST è¡¨ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXlog2_n = 16;const int MAXm = 2e6;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;double ln2 = log(2);int power2[MAXlog2_n + 10];void evapower2(int n) &#123; power2[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; power2[i] = power2[i - 1] * 2; &#125;&#125;int mx[MAXn + 10][MAXlog2_n + 2];void build(int n, int *a) &#123; int log2_n = log(n) / ln2; for (int i = 1; i &lt;= n; ++i) &#123; mx[i][0] = a[i]; &#125; for (int i = 1; i &lt;= log2_n; ++i) &#123; for (int j = 1, topj = n - power2[i] + 1; j &lt;= topj; ++j) &#123; mx[j][i] = max(mx[j][i - 1], mx[j + power2[i - 1]][i - 1]); &#125; &#125;&#125;int querymax(int l, int r) &#123; int loglen = log(r - l + 1) / ln2; return max(mx[l][loglen], mx[r - power2[loglen] + 1][loglen]);&#125;int n, m;int a[MAXn + 10];signed main() &#123; read(n, m); evapower2(log(n) / ln2); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; build(n, a); for (int i = 1, l, r; i &lt;= m; ++i) &#123; read(l, r); printf(&quot;%d\\n&quot;, querymax(l, r)); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Treap","slug":"TemLib/Treap","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Treap/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Treap/","excerpt":"","text":"P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, son[MAXn + 10][2], siz[MAXn + 10], num[MAXn + 10], val[MAXn + 10], rd[MAXn + 10];inline void pushup(int cur) &#123; siz[cur] = siz[son[cur][0]] + siz[son[cur][1]] + num[cur];&#125;inline void rotate(int &amp;cur, int side) &#123; int y = son[cur][side ^ 1]; int z = son[y][side]; son[cur][side ^ 1] = z; son[y][side] = cur; pushup(cur); pushup(y); cur = y;&#125;inline void Insert(int &amp;cur, int v) &#123; if (!cur) &#123; cur = ++cntnd; siz[cur] = num[cur] = 1; val[cur] = v; rd[cur] = rand(); &#125; else if (v == val[cur]) &#123; ++siz[cur]; ++num[cur]; &#125; else &#123; int side = (v &gt; val[cur]); Insert(son[cur][side], v); if (rd[son[cur][side]] &gt; rd[cur]) &#123; rotate(cur, side ^ 1); &#125; else &#123; ++siz[cur]; &#125; &#125;&#125;inline void Delete(int &amp;cur, int v) &#123; if (!cur) &#123; ; &#125; else if (v == val[cur]) &#123; if (num[cur] &gt; 2) &#123; --num[cur]; &#125; else if (!son[cur][0] &amp;&amp; !son[cur][1]) &#123; --num[cur]; --siz[cur]; if (!siz[cur]) cur = 0; return; &#125; else if (son[cur][0] &amp;&amp; !son[cur][1]) &#123; rotate(cur, 1); Delete(son[cur][1], v); &#125; else if (!son[cur][0] &amp;&amp; son[cur][1]) &#123; rotate(cur, 0); Delete(son[cur][0], v); &#125; else &#123; int side = (rd[son[cur][0]] &lt; rd[son[cur][1]]); rotate(cur, side ^ 1); Delete(son[cur][side ^ 1], v); &#125; --siz[cur]; &#125; else &#123; int side = (v &gt; val[cur]); Delete(son[cur][side], v); pushup(cur); &#125;&#125;inline int valtorank(int cur, int v) &#123; if (!cur) return 0; if (v &lt; val[cur]) &#123; return valtorank(son[cur][0], v); &#125; else if (v &gt; val[cur]) &#123; return siz[son[cur][0]] + num[cur] + valtorank(son[cur][1], v); &#125; else &#123; return siz[son[cur][0]]; &#125;&#125;inline int ValtoRank(int cur, int v) &#123; return valtorank(cur, v) + 1;&#125;inline int RanktoVal(int cur, int rank) &#123; if (!cur) return -INF; if (rank &gt;= siz[son[cur][0]] + 1 &amp;&amp; rank &lt;= siz[son[cur][0]] + num[cur]) &#123; return val[cur]; &#125; else if (rank &lt;= siz[son[cur][0]]) &#123; return RanktoVal(son[cur][0], rank); &#125; else &#123; return RanktoVal(son[cur][1], rank - (siz[son[cur][0]] + num[cur])); &#125;&#125;inline int Pre(int cur, int v) &#123; if (!cur) return -INF; if (val[cur] &gt;= v) &#123; return Pre(son[cur][0], v); &#125; else &#123; return max(val[cur], Pre(son[cur][1], v)); &#125;&#125;inline int Nex(int cur, int v) &#123; if (!cur) return INF; if (val[cur] &lt;= v) &#123; return Nex(son[cur][1], v); &#125; else &#123; return min(val[cur], Nex(son[cur][0], v)); &#125;&#125;int n, root;signed main() &#123; read(n); for (int i = 1, opt, x; i &lt;= n; ++i) &#123; read(opt, x); if (opt == 1) Insert(root, x); else if (opt == 2) Delete(root, x); else if (opt == 3) printf(&quot;%d\\n&quot;, ValtoRank(root, x)); else if (opt == 4) printf(&quot;%d\\n&quot;, RanktoVal(root, x)); else if (opt == 5) printf(&quot;%d\\n&quot;, Pre(root, x)); else if (opt == 6) printf(&quot;%d\\n&quot;, Nex(root, x)); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"WqsäºŒåˆ†","slug":"TemLib/WqsäºŒåˆ†","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/WqsäºŒåˆ†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Wqs%E4%BA%8C%E5%88%86/","excerpt":"","text":"Luogu P2619 [å›½å®¶é›†è®­é˜Ÿ]Tree I Luogu P5633 æœ€å°åº¦é™åˆ¶ç”Ÿæˆæ ‘ CF802O April Foolsâ€™ Problem (hard) 1234567891011121314151617int WqsDic() &#123; int L = -MAXw, R = MAXw, M; int ans, chosea; while (L &lt; R) &#123; M = (L + R + 1) &gt;&gt; 1; Check(M, ans, chosea); if (chosea &gt; need) &#123; L = M; &#125; else if (chosea &lt; need) &#123; R = M - 1; &#125; else &#123; return ans; &#125; &#125; Check(L, ans, chosea); return ans;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Zå‡½æ•°","slug":"TemLib/Zå‡½æ•°","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/Zå‡½æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Z%E5%87%BD%E6%95%B0/","excerpt":"","text":"è¯è¯´è¿™ç©æ„å’Œ Kmp æœ‰å•¥å…³ç³»è¦æŠŠå®ƒç§°ä¸ºæ‰©å±• Kmpã€‚ P5410 ã€æ¨¡æ¿ã€‘Zå‡½æ•° ä¸€ä¸ªä¸²çš„ Z å‡½æ•° å› ä¸ºä»£ç ä¸­ i != 1ï¼Œæ‰€ä»¥å¯ä»¥çœå»è¾¹ç•Œåˆ¤æ–­ã€‚ 123456789int z[MAXn + 10];void EvaZ(char *str, int n) &#123; z[1] = n; for (int i = 2, l = 0, r = 0; i &lt;= n; ++i) &#123; if (i &lt;= r) z[i] = min(r - i + 1, z[i - l + 1]); while (str[i + z[i]] == str[1 + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; &#125;&#125; ä¸¤ä¸ªä¸²çš„ Z å‡½æ•° è®¾æ–‡æœ¬ä¸²ä¸º $t$ï¼Œæ¨¡å¼ä¸²ä¸º $p$ã€‚ç›¸å½“äºè®© $s=p+\\diamond+t$ï¼Œæ±‚ $s$ çš„ Z å‡½æ•°ã€‚ä»£ç ä¸­å®šä¹‰äº†ä¸€ä¸ª Y å‡½æ•°ï¼Œçœå»äº†æ‹¼æ¥æ“ä½œï¼Œå®é™…ä¸Šåšæ³•æ˜¯ç›¸åŒçš„ï¼Œå°±æ˜¯å…ˆæ±‚ä¸€ä¸‹æ¨¡å¼ä¸²çš„ Z å‡½æ•°ï¼Œå†ç”¨ä¸€ä¸ª Y Boxä¼˜åŒ–ï¼Œæ–‡æœ¬ä¸²çš„ Y Box å’Œæ¨¡å¼ä¸²çš„Â·å‰ç¼€ç›¸åŒã€‚ 123456789int y[MAXn + 10];void EvaY(char *txt, char *wrd, int n, int m) &#123; EvaZ(wrd, m); for (int i = 1, l = 0, r = 0; i &lt;= n; ++i) &#123; if (i &lt;= r) y[i] = min(r - i + 1, z[i - l + 1]); while (i + y[i] &lt;= n &amp;&amp; 1 + y[i] &lt;= m &amp;&amp; txt[i + y[i]] == wrd[1 + y[i]]) ++y[i]; if (i + y[i] - 1 &gt; r) l = i, r = i + y[i] - 1; &#125;&#125; è‡ªå·±ç³Šçš„å¥‡è‘©åšæ³• æ—¢ç„¶å¯ä»¥å…ˆæ±‚æ¨¡å¼ä¸²çš„ Z å‡½æ•°ï¼Œå†ç”¨ Box ä¼˜åŒ–ï¼Œä¸ºä»€ä¹ˆä¸èƒ½å…ˆæ±‚æ–‡æœ¬ä¸²çš„ Z å‡½æ•°ï¼Œå†ç”¨ Box ä¼˜åŒ–å‘¢ï¼Ÿäºæ˜¯æˆ‘ç³Šäº†è¿™ä¸ªå¥‡è‘©åšæ³•ï¼ŒLuogu æ˜¯å¯ä»¥è¿‡çš„ï¼Œå½“ç„¶æœ€åŠ£å¤æ‚åº¦â€¦â€¦æˆ‘æ²¡æœ‰ç®—ï¼Œåº”è¯¥æ˜¯éçº¿æ€§çš„ï¼Œæ‰€ä»¥è€ƒè¯•æ—¶å½“ç„¶ä¸è¦ç”¨ã€‚ 1234567891011121314int y[MAXn + 10];void EvaY(char *txt, char *wrd, int n, int m) &#123; z[1] = n; while (1 + y[1] &lt;= n &amp;&amp; 1 + y[1] &lt;= m &amp;&amp; txt[1 + y[1]] == wrd[1 + y[1]]) ++y[1]; for (int i = 2, l = 0, r = 0; i &lt;= n; ++i) &#123; if (i &lt;= r) z[i] = min(r - i + 1, z[i - l + 1]); y[i] = min(z[i], y[i - l + 1]); while (i + y[i] &lt;= n &amp;&amp; 1 + y[i] &lt;= m &amp;&amp; txt[i + y[i]] == wrd[1 + y[i]]) ++y[i]; while (txt[i + z[i]] == txt[1 + z[i]]) ++z[i]; if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"ä¸‰åˆ†","slug":"TemLib/ä¸‰åˆ†","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/ä¸‰åˆ†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%89%E5%88%86/","excerpt":"","text":"ä¸‰åˆ†åªæ”¯æŒä¸¥æ ¼å‡¸å‡½æ•°ã€‚æ¯”å¦‚è¦åœ¨å‡½æ•° $d$ ä¸Šä¸‰åˆ†ï¼Œå‡½æ•° $d$ å®šä¹‰åŸŸä¸Šçš„ç›¸é‚»ä½ç½®ï¼ˆæ¯”å¦‚ p - EPS å’Œ p + EPS æˆ– p å’Œ p + 1ï¼‰çš„å€¼ä¸åŒã€‚å¦‚æœç›¸é‚»ä½ç½®å€¼ç›¸åŒå¯ä»¥ç”¨å¤æ‚åº¦ä¸æ­£ç¡®çš„ä¸‰åˆ†ï¼ˆè¯¦è§ã€Œæ•´æ•°ä¸‰åˆ†-éä¸¥æ ¼å‡¸å‡½æ•°ã€ï¼‰ æ•´æ•°ä¸‰åˆ†ä¸¥æ ¼å‡¸å‡½æ•°123456789101112131415inline int calc(int p) &#123; /* ... */ &#125;int TDic() &#123; int l = 1, r = cntmap, dis, lmid, rmid; while (l &lt; r) &#123; dis = (r - l) / 3; lmid = l + dis; rmid = r - dis; if (calc(lmid) &lt;= calc(rmid)) &#123; l = lmid + 1; &#125; else &#123; r = rmid - 1; &#125; &#125; return l;&#125; éä¸¥æ ¼å‡¸å‡½æ•°æœ€åå¤æ‚åº¦ä¸º $O(n)$ã€‚ 123456789101112131415161718192021222324252627inline int calc(int p) &#123; /* ... */ &#125;int TDic(int l, int r) &#123; int dis, lmid, rmid, calclmid, calcrmid; while (l &lt; r) &#123; dis = (r - l) / 3; lmid = l + dis; rmid = r - dis; calclmid = calc(lmid); calcrmid = calc(rmid); if (calclmid &lt; calcrmid) &#123; l = lmid + 1; &#125; else if (calclmid &gt; calcrmid) &#123; r = rmid - 1; &#125; else &#123; int p1 = TDic(l, lmid), p2 = TDic(lmid + 1, rmid - 1), p3 = TDic(rmid, r); int calcp1 = calc(p1), calcp2 = calc(p2), calcp3 = calc(p3); if (calcp1 &gt; calcp2) &#123; return p1; &#125; else if (calcp3 &gt;= calcp2) &#123; return p3; &#125; else &#123; return p2; &#125; &#125; &#125; return l;&#125; å®æ•°ä¸‰åˆ†P3382 ã€æ¨¡æ¿ã€‘ä¸‰åˆ†æ³• 123456789101112inline double calc(double p) &#123;/* ... */&#125;void TDic(double l, double r) &#123; double mid; while (r - l &gt;= EPS) &#123; mid = (l + r) / 2; if (calc(mid - EPS) &gt; calc(mid + EPS)) &#123; r = mid; &#125; else &#123; l = mid; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘","slug":"TemLib/ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P4180 [BJWC2010]ä¸¥æ ¼æ¬¡å°ç”Ÿæˆæ ‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = 3e5;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m, root = 1;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int fat[MAXn + 10];int anc(int x) &#123; return fat[x] = fat[x] == x ? x : anc(fat[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fat[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fat[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];bool intree[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); intree[i] = 1; &#125; &#125; return ans;&#125;void mergemax(int &amp;ansmax, int &amp;anscmx, int max1, int cmx1, int max2, int cmx2) &#123; if (max1 &gt; max2) &#123; ansmax = max1; anscmx = max(max2, cmx1); &#125; else if (max1 &lt; max2) &#123; ansmax = max2; anscmx = max(max1, cmx2); &#125; else &#123; ansmax = max1; anscmx = max(cmx1, cmx2); &#125;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], maxx[MAXn * 4 + 10], cmax[MAXn * 4 + 10];void pushup(int id) &#123; mergemax(maxx[id], cmax[id], maxx[id &lt;&lt; 1], cmax[id &lt;&lt; 1], maxx[(id &lt;&lt; 1) + 1], cmax[(id &lt;&lt; 1) + 1]);&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; maxx[id] = a[l]; cmax[id] = -INF; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(id &lt;&lt; 1, l, mid, a); BuildUseArr((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;pair&lt;int, int&gt; Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return make_pair(maxx[id], cmax[id]); &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid &amp;&amp; r &gt; mid) &#123; int ansmax, anscmx; pair&lt;int, int&gt; left, right; left = Eva(id &lt;&lt; 1, l, r); right = Eva((id &lt;&lt; 1) + 1, l, r); mergemax(ansmax, anscmx, left.first, left.second, right.first, right.second); return make_pair(ansmax, anscmx); &#125; else if (l &lt;= mid) &#123; return Eva(id &lt;&lt; 1, l, r); &#125; else &#123; return Eva((id &lt;&lt; 1) + 1, l, r); &#125; &#125;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; ndwei[to[i]] = wei[i]; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125;&#125;pair&lt;int, int&gt; TreePathEva(int x, int y) &#123; int ansmax = -INF, anscmx = -INF; int tmpansmax, tmpanscmx; pair&lt;int, int&gt; tmp; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; tmp = Eva(1, nddfs[top[y]], nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; if (x == y) &#123; return make_pair(ansmax, anscmx); &#125; else &#123; tmp = Eva(1, nddfs[x] + 1, nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; return make_pair(ansmax, anscmx); &#125;&#125;int ans, diff = INF;signed main() &#123; cntnex = 1; read(n), read(m); int tmp = 0; for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); if (u == v) &#123; ++tmp; continue; &#125; edge[i - tmp] = Edge(u, v, w); &#125; m -= tmp; ans = Kruskal(); for (re int i = 1; i &lt;= m; ++i) &#123; Insert(edge[i].u, edge[i].v, edge[i].w); Insert(edge[i].v, edge[i].u, edge[i].w); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArr(1, 1, n, idxwei); for (re int i = 1; i &lt;= m; ++i) &#123; if (!intree[i]) &#123; pair&lt;int, int&gt; tmp = TreePathEva(edge[i].u, edge[i].v); if (tmp.first == edge[i].w) &#123; diff = min(diff, edge[i].w - tmp.second); &#125; else &#123; diff = min(diff, edge[i].w - tmp.first); &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans + diff);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"ä¸­å›½å‰©ä½™å®šç†(crt)","slug":"TemLib/ä¸­å›½å‰©ä½™å®šç†(crt)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/ä¸­å›½å‰©ä½™å®šç†(crt)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86(crt)/","excerpt":"","text":"P1495 ã€æ¨¡æ¿ã€‘ä¸­å›½å‰©ä½™å®šç†(CRT)/æ›¹å†²å…»çŒª$x=\\sum\\limits_{i=1}^{n}a_i\\times M_i\\times M^{-1}_i(\\operatorname{mod}~m_i)~\\operatorname{mod}m$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 10;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;int n, a[MAXn + 10], m[MAXn + 10];int Crt() &#123; int ans = 0, mulm = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mulm = mulm * m[i]; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; int M = mulm / m[i]; ans = (ans + ((a[i] * M) % mulm * inv(M, m[i])) % mulm) % mulm; &#125; return ans;&#125;signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(m[i]), read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Crt());&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"ä¸»å¸­æ ‘","slug":"TemLib/ä¸»å¸­æ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/ä¸»å¸­æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š è®°ä¸»å¸­æ ‘å¼€åœ¨é•¿åº¦ä¸º $n$ çš„åŒºé—´ä¸Šï¼Œæ“ä½œæ•°ä¸º $m$ï¼Œ$\\text{lay}n=\\lceil\\log n\\rceil+1$ï¼Œæ ‡è®°æ°¸ä¹…åŒ–ç‰ˆçš„æœ€å¤§ç©ºé—´å ç”¨é‡ï¼ˆè‹¥åˆå§‹ç‰ˆæœ¬ä¸ºç©ºï¼‰ä¸º $m\\text{lay}n$ã€‚ å‡½æ•° modify ç­‰æœ‰ä¸¤ç§å†™æ³•ï¼Œã€Œä¼ å…¥ idã€å’Œã€Œä¸ä¼ å…¥ idï¼Œè¿”å› idã€ï¼Œå»ºè®®ä½¿ç”¨åä¸€ç§ã€‚ Luogu P3834 ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–çº¿æ®µæ ‘ 2 ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 2e5;const int MAXa = 1e9;const int MAXlay = 32;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn * MAXlay;int root[MAXn + 10];int cntnd, ls[MAXnd + 10], rs[MAXnd + 10];int siz[MAXnd + 10];inline void pushup(int id) &#123; siz[id] = siz[ls[id]] + siz[rs[id]];&#125;inline void clone(int id, int verid) &#123; ls[id] = ls[verid]; rs[id] = rs[verid]; siz[id] = siz[verid];&#125;int modify(int verid, int p, int le, int ri) &#123; int id = ++cntnd; clone(id, verid); if (le == ri) &#123; ++siz[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) ls[id] = modify(ls[verid], p, le, mid); else rs[id] = modify(rs[verid], p, mid + 1, ri); pushup(id); &#125; return id;&#125;int query(int lid, int rid, int rk, int le, int ri) &#123; if (le == ri) &#123; return le; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; int tmp = siz[ls[rid]] - siz[ls[lid]]; if (rk &lt;= tmp) &#123; return query(ls[lid], ls[rid], rk, le, mid); &#125; else &#123; return query(rs[lid], rs[rid], rk - tmp, mid + 1, ri); &#125; &#125;&#125;int n, m;signed main() &#123; read(n, m); for (int i = 1, a; i &lt;= n; ++i) &#123; read(a); root[i] = modify(root[i - 1], a, -MAXa, MAXa); &#125; for (int i = 1, l, r, rk; i &lt;= m; ++i) &#123; read(l, r, rk); printf(&quot;%d\\n&quot;, query(root[l - 1], root[r], rk, -MAXa, MAXa)); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"äºŒåˆ†","slug":"TemLib/äºŒåˆ†","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/äºŒåˆ†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%88%86/","excerpt":"","text":"é‡ç‚¹ï¼š $mid$ å– $l+r$ è¿˜æ˜¯ $l+r+1$ã€‚ â€œ $=$ â€œ çš„è¯åº”è¯¥ç®—é‚£ç§æƒ…å†µã€‚ ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, x, arr[MAXn + 10];int a() &#123; //å¤§äºç­‰äºä¸­æœ€å°çš„(lower_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int b() &#123; //å¤§äºä¸­æœ€å°çš„(upper_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int c() &#123; //å°äºä¸­æœ€å¤§çš„ int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int d() &#123; //å°äºç­‰äºä¸­æœ€å¤§çš„ int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int main() &#123; read(n), read(x); for (re int i = 1; i &lt;= n; ++i) &#123; read(arr[i]); &#125; printf(&quot;%d %d %d %d\\n&quot;, a(), b(), c(), d()); // printf(&quot;%d %d\\n&quot;, int(lower_bound(arr + 1, arr + 1 + n, x) - arr), int(upper_bound(arr + 1, arr + 1 + n, x) - arr));&#125; ç»“æœï¼š","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"äºŒåˆ†å›¾","slug":"TemLib/äºŒåˆ†å›¾","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/äºŒåˆ†å›¾/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"","text":"Luogu P3386 ã€æ¨¡æ¿ã€‘äºŒåˆ†å›¾æœ€å¤§åŒ¹é… Luogu P1350 è½¦çš„æ”¾ç½® Luogu P6062 USACO05JAN Muddy Fields G Luogu P3355 éª‘å£«å…±å­˜é—®é¢˜ 12345678910111213141516171819202122232425262728293031323334353637bool vis[MAXnd + 10];int match[MAXnd + 10];bool Dfs(int cur) &#123; if (vis[cur]) return 0; // vis[cur] = 1; // å¦‚æœåªæ˜¯æ±‚æœ€å¤§åŒ¹é…ï¼Œä¸æ±‚æœ€å°ç‚¹è¦†ç›–å’Œæœ€å¤§ç‹¬ç«‹é›†å¯ä»¥ä¸ç”¨ç»™å·¦éƒ¨ç‚¹æ‰“æ ‡è®°ï¼Œå¯ä»¥ä¸åŠ è¿™ä¸¤è¡Œã€‚ for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; vis[to[i]] = 1; if (!match[to[i]] || Dfs(match[to[i]])) &#123; match[to[i]] = cur; return 1; &#125; &#125; return 0;&#125;int ans1, ans2, mincover[MAXnd + 10];signed main() &#123; // ...... for (int i = 1; i &lt;= cntleft; ++i) &#123; memset(vis, 0, sizeof(vis)); if (Dfs(i)) ++ans1; &#125; for (int i = cntleft + 1, top = cntleft + cntright; i &lt;= top; ++i) &#123; if (match[i]) match[match[i]] = 1; &#125; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= cntleft; ++i) &#123; if (!match[i]) Dfs(i); &#125; for (int i = 1; i &lt;= cntleft; ++i) &#123; if (!vis[i]) mincover[++ans2] = i; &#125; for (int i = cntleft + 1, top = cntleft + cntright; i &lt;= top; ++i) &#123; if (vis[i]) mincover[++ans2] = i; &#125; // ans1 == ans2&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"äºŒå‰å †","slug":"TemLib/äºŒå‰å †","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/äºŒå‰å †/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%8F%89%E5%A0%86/","excerpt":"","text":"P3378 ã€æ¨¡æ¿ã€‘å †å¤§æ ¹å †12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; int opt; n = read(); while (n--) &#123; opt = read(); switch (opt) &#123; case 1: Insert(read()); break; case 2: printf(&quot;%d\\n&quot;, GetRoot()); break; case 3: PopRoot(); break; &#125; &#125;&#125; å°æ ¹å †123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &gt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &lt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &gt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; Insert(1); Insert(3); Insert(1); Insert(7); Insert(11); Insert(25); cout &lt;&lt; GetRoot() &lt;&lt; endl; PopRoot(); cout &lt;&lt; GetRoot() &lt;&lt; endl;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"äºŒå‰æœç´¢æ ‘","slug":"TemLib/äºŒå‰æœç´¢æ ‘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/äºŒå‰æœç´¢æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"P5076 ã€æ·±åŸº16.ä¾‹7ã€‘æ™®é€šäºŒå‰æ ‘ï¼ˆç®€åŒ–ç‰ˆï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;const int INF = 2147483647;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());register bool f = c == &#x27;-&#x27;;register T s = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -s : s;&#125;struct Node &#123; int l, r, siz, cnt, val;&#125;;Node nd[MAXn + 10];int cnt;void Insert(int id, int val) &#123; ++nd[id].siz; if (nd[id].val == val) &#123; ++nd[id].cnt; &#125; else if (nd[id].val &lt; val) &#123; if (!nd[id].r) &#123; nd[++cnt].val = val; nd[id].r = cnt; &#125; Insert(nd[id].r, val); &#125; else &#123; if (!nd[id].l) &#123; nd[++cnt].val = val; nd[id].l = cnt; &#125; Insert(nd[id].l, val); &#125;&#125; int ValtoRank(int id, int val) &#123; if (!id) &#123; return 1; &#125; if (nd[id].val == val) &#123; return nd[nd[id].l].siz + 1; &#125; else if (nd[id].val &lt; val) &#123; return nd[nd[id].l].siz + nd[id].cnt + ValtoRank(nd[id].r, val); &#125; else &#123; return ValtoRank(nd[id].l, val); &#125;&#125;int RanktoVal(int id, int rank) &#123; if (!id) &#123; return -123456789; &#125; if (rank &lt;= nd[nd[id].l].siz) &#123; return RanktoVal(nd[id].l, rank); &#125; else if (rank &gt; nd[nd[id].l].siz + nd[id].cnt) &#123; return RanktoVal(nd[id].r, rank - nd[nd[id].l].siz - nd[id].cnt); &#125; else &#123; return nd[id].val; &#125;&#125;int EvaPreVal(int id, int val) &#123; if (!id) &#123; return -INF; &#125; if (nd[id].val &gt;= val) &#123; return EvaPreVal(nd[id].l, val); &#125; else &#123; return max(nd[id].val, EvaPreVal(nd[id].r, val)); &#125;&#125;int EvaNexVal(int id, int val) &#123; if (!id) &#123; return INF; &#125; if (nd[id].val &lt;= val) &#123; return EvaNexVal(nd[id].r, val); &#125; else &#123; return min(nd[id].val, EvaNexVal(nd[id].l, val)); &#125;&#125;int root = 1, n, opt, x;int main() &#123; read(n); nd[1].cnt = 1; nd[1].l = 2; nd[1].siz = 2; nd[1].val = INF; nd[2].cnt = 1; nd[2].siz = 1; nd[2].val = -INF; cnt += 2; for (re int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: printf(&quot;%d\\n&quot;, ValtoRank(root, x) - 1); break; case 2: printf(&quot;%d\\n&quot;, RanktoVal(root, x + 1)); break; case 3: printf(&quot;%d\\n&quot;, EvaPreVal(root, x)); break; case 4: printf(&quot;%d\\n&quot;, EvaNexVal(root, x)); break; case 5: Insert(root, x); break; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"äºŒç»´å‡¸åŒ…","slug":"TemLib/äºŒç»´å‡¸åŒ…","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/äºŒç»´å‡¸åŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š æ­£ç€æ’å…¥ä¸€éï¼Œå€’ç€æ’å…¥ä¸€éï¼Œæœ€åè¿˜è¦ç”¨ 1 å·ç‚¹å¼¹ä¸€ä¸‹æ ˆé¡¶ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627int n;Point a[MAXn + 10];int bottomc, cntc, c[MAXn + 10]; bool inc[MAXn + 10];inline void pop(int id) &#123; while (cntc &gt; bottomc &amp;&amp; sig((a[c[cntc - 1]] &gt;&gt; a[c[cntc]]) &amp; (a[c[cntc]] &gt;&gt; a[id])) &lt;= 0) &#123; inc[c[cntc]] = 0; --cntc; &#125; &#125;inline void push(int id) &#123; inc[id] = 1; c[++cntc] = id;&#125;void evaconv() &#123; bottomc = 1; cntc = 0; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; pop(i); push(i); &#125; bottomc = cntc; for (int i = n; i; --i) &#123; if (inc[i]) continue; pop(i); push(i); &#125; pop(1);&#125; Luogu P2742 [USACO5.1]åœˆå¥¶ç‰›Fencing the Cows /ã€æ¨¡æ¿ã€‘äºŒç»´å‡¸åŒ… ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const double EPS = 1e-8;inline int sig(double x) &#123; if (x &lt; -EPS) return -1; else if (x &gt; EPS) return 1; else return 0;&#125;struct Point &#123; double x, y; inline Point operator&gt;&gt;(Point sec) &#123;return Point&#123;sec.x - x, sec.y - y&#125;;&#125; inline double operator*(Point sec) &#123;return x * sec.x + y * sec.y;&#125; inline double operator&amp;(Point sec) &#123;return x * sec.y - y * sec.x;&#125; inline bool operator&lt;(const Point sec) const &#123; if (x != sec.x) return x &lt; sec.x; else return y &lt; sec.y; &#125;&#125;;inline double length(Point a) &#123; return sqrt(a * a);&#125;int n;Point a[MAXn + 10];int bottomc, cntc, c[MAXn + 10]; bool inc[MAXn + 10];inline void pop(int id) &#123; while (cntc &gt; bottomc &amp;&amp; sig((a[c[cntc - 1]] &gt;&gt; a[c[cntc]]) &amp; (a[c[cntc]] &gt;&gt; a[id])) &lt;= 0) &#123; inc[c[cntc]] = 0; --cntc; &#125; &#125;inline void push(int id) &#123; inc[id] = 1; c[++cntc] = id;&#125;void evaconv() &#123; bottomc = 1; cntc = 0; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; pop(i); push(i); &#125; bottomc = cntc; for (int i = n; i; --i) &#123; if (inc[i]) continue; pop(i); push(i); &#125; pop(1);&#125;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lf%lf&quot;, &amp;a[i].x, &amp;a[i].y); &#125; evaconv(); double ans = 0; for (int i = 1; i &lt; cntc; ++i) &#123; ans += length(a[c[i]] &gt;&gt; a[c[i + 1]]); &#125; ans += length(a[c[cntc]] &gt;&gt; a[c[1]]); printf(&quot;%.2lf\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"äºŒç»´æ ‘çŠ¶æ•°ç»„","slug":"TemLib/äºŒç»´æ ‘çŠ¶æ•°ç»„","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/äºŒç»´æ ‘çŠ¶æ•°ç»„/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"1234567891011121314151617181920212223int t[MAXn + 10][MAXn + 10];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline void Add(int x, int y, int k, int topx, int topy) &#123; for (int i = x; i &lt;= topx; i += lowbit(i)) &#123; for (int j = y; j &lt;= topy; j += lowbit(j)) &#123; t[i][j] += k; &#125; &#125;&#125;inline int Sum(int x, int y) &#123; int ans = 0; for (int i = x; i; i -= lowbit(i)) &#123; for (int j = y; j; j -= lowbit(j)) &#123; ans += t[i][j]; &#125; &#125; return ans;&#125;inline int Sec(int x1, int y1, int x2, int y2) &#123; return Sum(x2, y2) - Sum(x1 - 1, y2) - Sum(x2, y1 - 1) + Sum(x1 - 1, y1 - 1);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"äºŒç»´è®¡ç®—å‡ ä½•","slug":"TemLib/äºŒç»´è®¡ç®—å‡ ä½•","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/äºŒç»´è®¡ç®—å‡ ä½•/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182const double EPS = 1e-10;const double INF = 1e15;const double PI = acos(-1);const double SQRT2 = sqrt(2);inline int sig(double x) &#123; if (x &gt; EPS) return 1; else if (x &lt; -EPS) return -1; else return 0;&#125;struct Point &#123; double x, y; inline Point operator+(Point sec) &#123;return Point&#123;x + sec.x, y + sec.y&#125;&#125;; inline Point operator&gt;&gt;(Point sec) &#123;return Point&#123;sec.x - x, sec.y - y&#125;&#125;; inline Point *operator*(double sec) &#123;return Point&#123;x * sec, y * sec&#125;&#125;; inline double operator*(Point sec) &#123;return x * sec.x + y * sec.y&#125;; inline double operator%(Point sec) &#123;return x * sec.y - sec.x * y&#125;;&#125;;inline double length(Point v1) &#123; return sqrt(v1 * v1);&#125;inline double angle(Point v1) &#123; return atan2(v1.y, v1.x);&#125;inline double angle(Point v1, Point v2) &#123; return acos((v1 * v2) / length(v1) / length(v2));&#125;inline double rotate(Point v1, double angle) &#123; double sn = sin(angle), cs = cos(angle); return Point&#123;cs * v1.x - sn * v1.y, sn * v1.x + cs * v1.y&#125;;&#125;inline double area(Point p1, Point p2, Point p3) &#123; return (p1 &gt;&gt; p2) % (p1 &gt;&gt; p3);&#125;inline double proj(Point p1, Point p2, Point p3) &#123; return ((p1 &gt;&gt; p2) * (p1 &gt;&gt; p3)) / length(p1 &gt;&gt; p2);&#125;inline bool poi_on_str(Point a, Point b, Point c) &#123; return sig((a &gt;&gt; c) % (b &gt;&gt; c)) == 0;&#125;inline double poi_dist_str(Point a, Point b, Point c) &#123; return fabs((a &gt;&gt; b) % (a &gt;&gt; c)) / length(a &gt;&gt; b);&#125;inline double poi_dist_seg(Point a, Point b, Point c) &#123; if (a == b) return length(a &gt;&gt; c); if ((a &gt;&gt; b) * (a &gt;&gt; c) &lt;= 0) return length(a &gt;&gt; c); if ((b &gt;&gt; a) * (b &gt;&gt; c) &lt;= 0) return length(b &gt;&gt; c); return poi_dist_str(a, b, c);&#125;inline bool poi_on_seg(Point a, Point b, Point c) &#123; return sig(poi_dist_seg(a, b, c)) == 0;&#125;inline Point poi_proj_str(Point a, Point b, Point c) &#123; return a + (a &gt;&gt; b) * (((a &gt;&gt; b) * (a &gt;&gt; c)) / ((a &gt;&gt; b) * (a &gt;&gt; b)));&#125;inline bool seg_on_seg(Point a, Point b, Point c, Point d) &#123; if (poi_on_seg(c, d, a) || poi_on_seg(c, d, b) || poi_on_seg(a, b, c) || poi_on_seg(a, b, d)) return 1; return sig((a &gt;&gt; b) % (a &gt;&gt; c)) * sig((a &gt;&gt; b) % (a &gt;&gt; d)) &lt; 0 &amp;&amp; sig((c &gt;&gt; d) % (c &gt;&gt; a)) * sig((c &gt;&gt; d) % (c &gt;&gt; b)) &lt; 0;&#125;inline Point str_int_str(Point a, Point b, Point c, Point d) &#123; return a + ((a &gt;&gt; b) * (((c &gt;&gt; d) % (c &gt;&gt; a)) / ((a &gt;&gt; b) % (c &gt;&gt; d))));&#125;inline double pol_area(Point point[], int n) &#123; double ans = 0; Point zero(0, 0); for (int i = 1; i &lt; n; ++i) &#123; ans += (zero &gt;&gt; point[i]) % (zero &gt;&gt; point[i + 1]); &#125; ans += (zero &gt;&gt; point[n]) % (zero &gt;&gt; point[1]); return ans / 2;&#125;inline int poi_on_pol(Point a, Point b[], int n) &#123; int cnt = 0; Point far(PI * 1e6, SQRT2 * 1e6); for (int i = 1; i &lt; n; ++i) &#123; if (poi_on_seg(b[i], b[i + 1], a)) return 1; if (seg_on_seg(b[i], b[i + 1], a, far)) ++cnt; &#125; if (poi_on_seg(b[n], b[1], a)) return 1; if (seg_on_seg(b[n], b[1], a, far)) ++cnt; if (cnt &amp; 1) return 2; else return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"äºŒç»´è´¹ç”¨èƒŒåŒ…","slug":"TemLib/äºŒç»´è´¹ç”¨èƒŒåŒ…","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/äºŒç»´è´¹ç”¨èƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1855 æ¦¨å–kkksc031234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW1 = 200;const int MAXW2 = 200;const int INF = 0x3f3f3f3f;int n, W1, W2;int d[MAXW1 + 10][MAXW2 + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;int eva_maxV(int W1, int W2) &#123; int ans = -INF; for (int i = 0; i &lt;= W1; i++) &#123; for (int j = 0; j &lt;= W2; j++) ans = max(ans, d[i][j]); &#125; return ans;&#125;int main() &#123; n = read(); W1 = read(); W2 = read(); int v, w1, w2; for (int i = 1; i &lt;= n; i++) &#123; v = 1; w1 = read(); w2 = read(); for (int j = W1; j &gt;= w1; j--) &#123; for (int k = W2; k &gt;= w2; k--) d[j][k] = max(d[j][k], d[j - w1][k - w2] + v); &#125; &#125; cout &lt;&lt; eva_maxV(W1, W2);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åˆ†å—","slug":"TemLib/åˆ†å—","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/åˆ†å—/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E5%9D%97/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š åˆ†å—å¯ä»¥çœ‹ä½œä¸€ä¸ªä¸¤å±‚çš„çº¿æ®µæ ‘ã€‚ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132void build(int n, int *a) &#123; sizb = sqrt(n); int l = 1, r = sizb; while (l &lt;= n) &#123; le[++cntb] = l; ri[cntb] = r; len[cntb] = r - l + 1; for (int i = l; i &lt;= r; ++i) &#123; inb[i] = cntb; // ... &#125; l = r + 1, r = min(l + sizb - 1, n); &#125;&#125;void modify(int l, int r, int v) &#123; int inbl = inb[l], inbr = inb[r]; if (inbl == inbr) &#123; // ... &#125; else &#123; // ... &#125;&#125;int query(int l, int r) &#123; int inbl = inb[l], inbr = inb[r]; int ans = 0; if (inbl == inbr) &#123; // ... &#125; else &#123; // ... &#125; return ans;&#125; Luogu P2357 å®ˆå¢“äºº ä¸å»ºè®®ä½¿ç”¨çº¿æ®µæ ‘çš„æ¨¡æ¿é¢˜æµ‹è¯•åˆ†å—ä»£ç ï¼Œæ•°æ®è¿‡æ°´ï¼ˆä¸åŠ ã€Œquery -&gt; if (inbl == inbr) -&gt; ans += (r - l + 1) * lzaddb[inbl];ã€ä¹Ÿèƒ½è¿‡ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e5;const int MAXsqrtn = 448;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int sizb, cntb, le[MAXsqrtn + 10], ri[MAXsqrtn + 10], len[MAXsqrtn + 10], inb[MAXn + 10];int sumb[MAXsqrtn + 10], lzaddb[MAXsqrtn + 10];int sums[MAXn + 10];void build(int n, int *a) &#123; sizb = sqrt(n); int l = 1, r = sizb; while (l &lt;= n) &#123; le[++cntb] = l; ri[cntb] = r; len[cntb] = r - l + 1; for (int i = l; i &lt;= r; ++i) &#123; inb[i] = cntb; sumb[cntb] += a[i]; sums[i] = a[i]; &#125; l = r + 1, r = min(l + sizb - 1, n); &#125;&#125;void modify(int l, int r, int v) &#123; int inbl = inb[l], inbr = inb[r]; if (inbl == inbr) &#123; sumb[inbl] += (r - l + 1) * v; for (int i = l; i &lt;= r; ++i) sums[i] += v; &#125; else &#123; sumb[inbl] += (ri[inbl] - l + 1) * v; for (int i = l; i &lt;= ri[inbl]; ++i) sums[i] += v; sumb[inbr] += (r - le[inbr] + 1) * v; for (int i = le[inbr]; i &lt;= r; ++i) sums[i] += v; for (int i = inbl + 1; i &lt; inbr; ++i) &#123; sumb[i] += len[i] * v; lzaddb[i] += v; &#125; &#125;&#125;int query(int l, int r) &#123; int inbl = inb[l], inbr = inb[r]; int ans = 0; if (inbl == inbr) &#123; for (int i = l; i &lt;= r; ++i) ans += sums[i]; ans += (r - l + 1) * lzaddb[inbl]; &#125; else &#123; for (int i = l; i &lt;= ri[inbl]; ++i) ans += sums[i]; ans += (ri[inbl] - l + 1) * lzaddb[inbl]; for (int i = le[inbr]; i &lt;= r; ++i) ans += sums[i]; ans += (r - le[inbr] + 1) * lzaddb[inbr]; for (int i = inbl + 1; i &lt; inbr; ++i) ans += sumb[i]; &#125; return ans;&#125;int n, m;int a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; build(n, a); for (int i = 1, opt, l, r, v; i &lt;= m; ++i) &#123; read(opt); if (opt == 1) &#123; read(l, r, v); modify(l, r, v); &#125; else if (opt == 2) &#123; read(v); sumb[1] += v; sums[1] += v; &#125; else if (opt == 3) &#123; read(v); sumb[1] -= v; sums[1] -= v; &#125; else if (opt == 4) &#123; read(l, r); printf(&quot;%lld\\n&quot;, query(l, r)); &#125; else &#123; printf(&quot;%lld\\n&quot;, lzaddb[1] + sums[1]); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åˆ†ç»„èƒŒåŒ…","slug":"TemLib/åˆ†ç»„èƒŒåŒ…","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/åˆ†ç»„èƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1757 é€šå¤©ä¹‹åˆ†ç»„èƒŒåŒ…123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 1000;const int MAXW = 1000;int n, W;int v[MAXn + 10];int w[MAXn + 10];int team[MAXn + 10][MAXn + 10];int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void put_in() &#123; W = read(); n = read(); int teamid; for (int i = 1; i &lt;= n; i++) &#123; w[i] = read(); v[i] = read(); teamid = read(); team[teamid][++team[teamid][0]] = i; &#125;&#125;void rec(int v[], int w[], int W)&#123; for (int i = 1; i &lt;= MAXn; i++) &#123; if (team[i][0]) &#123; for (int j = W; j &gt;= 0; j--) &#123; for (int k = 1; k &lt;= team[i][0]; k++) &#123; if (j &gt;= w[team[i][k]]) d[j] = max(d[j], d[j - w[team[i][k]]] + v[team[i][k]]); &#125; &#125; &#125; &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v, w, W); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åˆ†è§£è´¨å› æ•°","slug":"TemLib/åˆ†è§£è´¨å› æ•°","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/åˆ†è§£è´¨å› æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/","excerpt":"","text":"åˆ†è§£è´¨å› æ•°çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼šéå†æ³•å’Œæšä¸¾è´¨æ•°æ³•ï¼Œéå†æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(\\sqrt n)$ï¼›æšä¸¾è´¨æ•°æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(\\dfrac{\\sqrt n}{\\ln \\sqrt n})$ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ª $O(n)$ çš„é¢„å¤„ç†ã€‚ æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ éå†æ³•ä»£ç ï¼š 12345678910111213141516171819int cntpc, p[MAXlog2_x + 10], c[MAXlog2_x + 10];void evapc(int x) &#123; cntpc = 0; int sqrtx = sqrt(x); for (int i = 2; i &lt;= sqrtx; ++i) &#123; if (x % i == 0) &#123; p[++cntpc] = i; c[cntpc] = 0; while (x % i == 0) &#123; ++c[cntpc]; x /= i; &#125; &#125; &#125; if (x &gt; 1) &#123; p[++cntpc] = x; c[cntpc] = 1; &#125;&#125; æšä¸¾è´¨æ•°æ³•ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536bool notpr[MAXx + 10]; int cntpr, pr[MAXx / 10 + 100];void evapr(int n) &#123; notpr[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; &#125; for (int j = 1, toppj = n / i; j &lt;= cntpr &amp;&amp; pr[j] &lt;= toppj; ++j) &#123; notpr[i * pr[j]] = 1; if (i % pr[j] == 0) break; &#125; &#125;&#125;int cntpc, p[MAXlog2_x + 10], c[MAXlog2_x + 10];void evapc(int x) &#123; cntpc = 0; int sqrtx = sqrt(x); for (int i = 1; i &lt;= cntpr &amp;&amp; pr[i] &lt;= sqrtx; ++i) &#123; if (x % pr[i] == 0) &#123; p[++cntpc] = pr[i]; c[cntpc] = 0; while (x % pr[i] == 0) &#123; ++c[cntpc]; x /= pr[i]; &#125; &#125; &#125; if (x &gt; 1) &#123; p[++cntpc] = x; c[cntpc] = 1; &#125;&#125;evapr(MAXx);evapc(x1); evapc(x2); // ...","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å‰ç¼€ç§¯æ³•æ±‚é€†å…ƒ","slug":"TemLib/å‰ç¼€ç§¯æ³•æ±‚é€†å…ƒ","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å‰ç¼€ç§¯æ³•æ±‚é€†å…ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%8D%E7%BC%80%E7%A7%AF%E6%B3%95%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P5431 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ 2123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e6;#define int long longtemplate &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ans * x % mod; &#125; x = x * x % mod; y &gt;&gt;= 1; &#125; return ans;&#125;int inv(int n, int mod) &#123; int inv = power(n, mod - 2, mod); return (inv % mod + mod) % mod;&#125;int n, p, k, a[MAXn + 10], pi[MAXn + 10], mi[MAXn + 10], invv, ans;signed main() &#123; read(n), read(p), read(k); pi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); pi[i] = (pi[i - 1] * a[i]) % p; &#125; mi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mi[i] = (mi[i - 1] * k) % p; &#125; invv = inv(pi[n], p); for (re int i = n; i; --i) &#123; ans = (ans + mi[i] * (invv * pi[i - 1] % p)) % p; invv = (invv * a[i]) % p; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å‰²ç‚¹ & ç‚¹åŒè¿é€šåˆ†é‡","slug":"TemLib/å‰²ç‚¹ & ç‚¹åŒè¿é€šåˆ†é‡","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å‰²ç‚¹ & ç‚¹åŒè¿é€šåˆ†é‡/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%B2%E7%82%B9%20&%20%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"P3388 ã€æ¨¡æ¿ã€‘å‰²ç‚¹ï¼ˆå‰²é¡¶ï¼‰123456789101112131415161718192021222324252627282930313233int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXnd + 10&gt; iscut;void Tarjan(int cur, int root) &#123; dfs[cur] = low[cur] = ++cntdfs; int times = 0; bool havcnt = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], root); low[cur] = min(low[cur], low[to[i]]); if (!havcnt) &#123; if (low[to[i]] &gt;= dfs[cur]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; havcnt = 1; ++cntcut; iscut[cur] = 1; &#125; &#125; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, i); &#125; &#125;&#125; T103492 ã€æ¨¡æ¿ã€‘ç‚¹åŒè¿é€šåˆ†é‡12345678910111213141516171819202122232425262728293031323334353637int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntdcc; vector&lt;int&gt; dcc[MAXnd + 10];int top, stk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; dcc[++cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt;= dfs[cur]) &#123; ++cntdcc; int x; do &#123; x = stk[top--]; dcc[cntdcc].push_back(x); &#125; while (x != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"å‰²è¾¹ & è¾¹åŒè¿é€šåˆ†é‡","slug":"TemLib/å‰²è¾¹ & è¾¹åŒè¿é€šåˆ†é‡","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å‰²è¾¹ & è¾¹åŒè¿é€šåˆ†é‡/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%B2%E8%BE%B9%20&%20%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"T103481 ã€æ¨¡æ¿ã€‘å‰²è¾¹123456789101112131415161718192021222324252627int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125;&#125; T103489 ã€æ¨¡æ¿ã€‘è¾¹åŒè¿é€šåˆ†é‡1234567891011121314151617181920212223242526272829303132333435363738394041int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;int cntdcc, indcc[MAXnd + 10];void EvaDcc(int cur) &#123; indcc[cur] = cntdcc; for (int i = head[cur]; i; i = nex[i]) &#123; if (indcc[to[i]] || iscut[i]) continue; EvaDcc(to[i]); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!indcc[i]) &#123; ++cntdcc; EvaDcc(i); &#125; &#125;&#125; å¦‚æœåªè®©è¾“å‡ºè¾¹åŒçš„ä¸ªæ•°ï¼Œæ¡¥æ•°+ä¸è¿é€šçš„å›¾æ•°ä¹Ÿæ˜¯æ­£ç¡®ç­”æ¡ˆã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"åŠ¨æ€dp","slug":"TemLib/åŠ¨æ€dp","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/åŠ¨æ€dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81dp/","excerpt":"","text":"Luogu P4719 ã€æ¨¡æ¿ã€‘â€åŠ¨æ€ DPâ€&amp;åŠ¨æ€æ ‘åˆ†æ²» 1234567891011121314151617Mat g[MAXn + 10];void Update(int x, int v) &#123; g[x].a[1][0] -= val[x]; g[x].a[1][0] += v; while (fa[top[x]]) &#123; Mat last = query(1, nddfs[top[x]], ed[x]); modifyRepPoint(1, nddfs[x], g[x]); Mat now = query(1, nddfs[top[x]], ed[x]); x = fa[top[x]]; g[x].a[0][0] -= max(last.a[0][0], last.a[1][0]); g[x].a[0][0] += max(now.a[0][0], now.a[1][0]); g[x].a[0][1] = g[x].a[0][0]; g[x].a[1][0] -= last.a[0][0]; g[x].a[1][0] += now.a[0][0]; &#125; modifyRepPoint(1, nddfs[x], g[x]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"åŠ¨æ€äºŒç»´å‡¸åŒ…","slug":"TemLib/åŠ¨æ€äºŒç»´å‡¸åŒ…","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/åŠ¨æ€äºŒç»´å‡¸åŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/","excerpt":"","text":"CF70D Professorâ€™s task çœç•¥å·éƒ¨åˆ†è§ äºŒç»´è®¡ç®—å‡ ä½•æ¨¡æ¿ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct Point &#123; double x, y, ang; // ... inline bool operator&lt;(const Point sec) const &#123; return ang &lt; sec.ang; &#125;&#125;;// ...typedef set&lt;Point&gt;::iterator it;set&lt;Point&gt; s;inline it Prec(it x) &#123; return x == begin(s) ? --end(s) : --x;&#125;inline it Nex(it x) &#123; return (++x) == end(s) ? begin(s) : x;&#125;void Solve(Point p) &#123; pair&lt;it, bool&gt; pr = s.insert(p); if (pr.second == 0) return; if (s.size() &lt;= 3) return; it cur = pr.first; it prec = Prec(cur), nex = Nex(cur); if (sig((*cur - *prec) % (*nex - *cur)) &lt;= 0) &#123; s.erase(cur); return; &#125; it i = Prec(cur), j = Prec(i); while (s.size() &gt; 3 &amp;&amp; sig((*i - *j) % (*cur - *i)) &lt;= 0) &#123; s.erase(i); i = j; j = Prec(j); &#125; i = Nex(cur), j = Nex(i); while (s.size() &gt; 3 &amp;&amp; sig((*i - *cur) % (*j - *i)) &lt;= 0) &#123; s.erase(i); i = j; j = Nex(j); &#125;&#125;bool Query(Point p) &#123; it nex = s.lower_bound(p); if (nex == end(s)) nex = begin(s); it prec = Prec(nex); return sig((p - *prec) % (*nex - p)) &lt;= 0;&#125;int n;signed main() &#123; read(n); Point o&#123;x: PI / 100.0, y: SQRT2 / 100.0, ang: 0.0&#125;, ori[4]; for (int i = 1, opt, x, y; i &lt;= 3; ++i) &#123; read(opt, x, y); o.x += x; o.y += y; ori[i].x = x * 3; ori[i].y = y * 3; &#125; for (int i = 1; i &lt;= 3; ++i) &#123; ori[i].ang = angle(o, ori[i]); Solve(ori[i]); &#125; Point p; for (int i = 4, opt, x, y; i &lt;= n; ++i) &#123; read(opt, x, y); p.x = x * 3; p.y = y * 3; p.ang = angle(o, p); if (opt == 1) &#123; Solve(p); &#125; else &#123; puts(Query(p) ? &quot;YES&quot; : &quot;NO&quot;); &#125; &#125; return 0;&#125; Point o&#123;x: PI / 100.0, y: SQRT2 / 100.0, ang: 0.0&#125; è¿™é‡Œä½¿ç”¨äº†åŸç‚¹åç§»æ³•ï¼Œç»™äº†åŸç‚¹ä¸€ä¸ªæ— ç†æ•°å¢é‡ï¼Œè¿™æ˜¯ä¸ºäº†é¿å…æè§’ç›¸ç­‰çš„ç‚¹çš„æƒ…å†µï¼Œå¦‚æœä¸åŠ è¿™å¥å¯èƒ½ä¼š ${\\color{red}\\mathrm{W!A}}$ï¼Œè¿˜æœ‰ä¸€ç§ä¸å»ºè®®ä½¿ç”¨çš„é¿å… ${\\color{red}\\mathrm{W!A}}$ çš„æ–¹æ³•æ˜¯å¢åŠ æ’åºå…³é”®å­—æ³•ï¼Œå°†ä»£ç ç¬¬å››è¡Œçš„å‡½æ•°æ”¹ä¸ºï¼š 123456inline bool operator&lt;(const Point sec) const &#123; if (!cmp(ang, sec.ang)) &#123; return x &lt; sec.x; &#125; return ang &lt; sec.ang;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘","slug":"TemLib/åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š ä¿®æ”¹æ“ä½œæ—¶å½“å‰ç‚¹å¯èƒ½å­˜åœ¨ï¼ˆid ä¸ä¸º 0ï¼‰ä¹Ÿå¯èƒ½ä¸å­˜åœ¨ï¼ˆid ä¸º 0ï¼‰ï¼Œè€Œä¸”ä¸å­˜åœ¨çš„è¯è¿˜è¦ç»™ä¸Šä¸€å±‚ç‚¹çš„å„¿å­æ•°ç»„å’Œæ ¹æ•°ç»„èµ‹å€¼ï¼Œæ‰€ä»¥å»ºè®®å¯¹å‚æ•°å˜é‡ id ä½¿ç”¨å¼•ç”¨ã€‚ æŸ¥è¯¢æ“ä½œéœ€è¦ç‰¹åˆ¤ä¸å­˜åœ¨çš„èŠ‚ç‚¹ï¼ˆid ä¸º 0ï¼‰ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627int cntnd, root, ls[MAXnd + 10], rs[MAXnd + 10];int sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;void modify(int &amp;id, int p, int le, int ri) &#123; if (id == 0) id = ++cntnd; if (le == ri) &#123; ++sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) modify(ls[id], p, le, mid); else modify(rs[id], p, mid + 1, ri); pushup(id); &#125;&#125;int query(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += query(ls[id], l, r, le, mid); if (r &gt; mid) ans += query(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125; Luogu P5459 [BJOI2016]å›è½¬å¯¿å¸ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXa = 1e5;const int MAXsuma = MAXn * MAXa;const int MAXlay = 36;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn * MAXlay;int cntnd, root, ls[MAXnd + 10], rs[MAXnd + 10];int sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;void modify(int &amp;id, int p, int le, int ri) &#123; if (id == 0) id = ++cntnd; if (le == ri) &#123; ++sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) modify(ls[id], p, le, mid); else modify(rs[id], p, mid + 1, ri); pushup(id); &#125;&#125;int query(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += query(ls[id], l, r, le, mid); if (r &gt; mid) ans += query(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;int n, L, R;int prefa[MAXn + 10];int ans;signed main() &#123; read(n, L, R); for (int i = 1; i &lt;= n; ++i) &#123; read(prefa[i]); prefa[i] += prefa[i - 1]; &#125; for (int i = n; i; --i) &#123; modify(root, prefa[i], -MAXsuma, MAXsuma); ans += query(root, L + prefa[i - 1], R + prefa[i - 1], -MAXsuma, MAXsuma); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŠ¨æ€æ ‘(lct)","slug":"TemLib/åŠ¨æ€æ ‘(lct)","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/åŠ¨æ€æ ‘(lct)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E6%A0%91(lct)/","excerpt":"","text":"ç”¨ä¸‹å›¾è¡¨ç¤ºä¸€é¢— Splayï¼Œå…¶ä¸­ä»å·¦åˆ°å³ä¸ºä¸­åºéå†ï¼Œè§’æ ‡ä»£è¡¨æ ¹ï¼Œè™šçº¿ç®­å¤´ä»£è¡¨æ ¹çš„çˆ¶äº²ï¼ˆå¦‚æœè™šçº¿ç®­å¤´æŒ‡å‘è‡ªå·±ä»£è¡¨æŒ‡å‘ $0$ï¼‰ã€‚ æ¯”å¦‚ä¸‹é¢è¿™é¢—ç”±ä¸¤é¢— Splay ç»„æˆçš„è¾…åŠ©æ ‘ï¼š è¯¥è¾…åŠ©æ ‘ç”¨ç‚¹çº¿æ³•è¡¨ç¤ºå°±æ˜¯ï¼š è¯¥è¾…åŠ©æ ‘å¯¹åº”çš„åŸæ ‘æ˜¯ï¼š ä¸‹é¢æ¥å›¾è§£ Lct çš„è¿™å‡ ç§åŸºæœ¬æ“ä½œã€‚ $\\text{splay}(x)$ splay æ“ä½œæ˜¯ splay åˆ°å½“å‰ Splay çš„æ ¹ã€‚ è¿™é¢— splay åº•ä¸‹çš„å‡ æ¡æŒ‡å‘å®ƒçš„è™šè¾¹ä»£è¡¨å¯èƒ½æœ‰è‹¥å¹²ä¸ª splay æŒ‡å‘è¯¥ splay çš„èŠ‚ç‚¹ï¼Œå½“ç„¶ä¹Ÿå¯èƒ½æ²¡æœ‰ã€‚ $\\text{access}(x)$ access æ“ä½œçš„å…·ä½“å›¾ç¤ºï¼Œä¸Šè¾¹ä¸ºè¾…åŠ©æ ‘çš„å˜åŒ–å›¾ç¤ºï¼Œä¸‹è¾¹ä¸ºåŸæ ‘çš„å˜åŒ–å›¾ç¤ºï¼š $\\text{makeroot}(x)$ $\\text{findroot}(x)$ $\\text{Split}(x,y)$ æ³¨æ„äº‹é¡¹ï¼š å¯¹ç‚¹ x è°ƒç”¨å‡½æ•° splay ä¹‹å‰ï¼Œå¿…é¡»è¦ä¿è¯ x åˆ°å½“å‰ splay çš„æ ¹çš„è·¯å¾„ä¸Šæ²¡æœ‰æ‡’æ ‡è®°äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯ä»¥è°ƒç”¨å‡½æ•° splay(x) å½“ä¸”ä»…å½“ï¼š ç‚¹ x æ˜¯ä»å½“å‰ splay çš„æ ¹é€’å½’åœ°æ‰¾ä¸‹æ¥çš„ï¼Œåœ¨å‘ä¸‹é€’å½’çš„è¿‡ç¨‹ä¸­è°ƒç”¨äº†å‡½æ•° pushdownã€‚ ä¸Šä¸€æ­¥è°ƒç”¨äº† update(x)ã€‚ å‡½æ•° rotate å’Œ splay ä¸­åˆ¤æ–­çˆ¶äº²å­˜ä¸å­˜åœ¨çš„æ–¹æ³•åº”ä¸º if (isroot(fa[x]) == 0)ï¼ˆç‚¹ x æ¢æˆå…¶ä»–ç‚¹åŒç†ï¼‰ã€‚ Luogu P3690 ã€æ¨¡æ¿ã€‘åŠ¨æ€æ ‘ï¼ˆLink Cut Treeï¼‰ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int ndval[MAXn + 10];int son[MAXn + 10][2], fa[MAXn + 10];int xorr[MAXn + 10];int lzrev[MAXn + 10];inline void putrev(int id) &#123; swap(son[id][0], son[id][1]); lzrev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (lzrev[id]) &#123; if (son[id][0]) putrev(son[id][0]); if (son[id][1]) putrev(son[id][1]); lzrev[id] = 0; &#125;&#125;inline void pushup(int id) &#123; xorr[id] = ndval[id] ^ xorr[son[id][0]] ^ xorr[son[id][1]];&#125;inline int isroot(int id) &#123; return son[fa[id]][0] != id &amp;&amp; son[fa[id]][1] != id;&#125;inline int side(int id) &#123; return son[fa[id]][1] == id;&#125;inline void rotate(int id) &#123; int y = fa[id], z = fa[y], sideid = side(id), s = son[id][sideid ^ 1]; if (isroot(y) == 0) &#123;son[z][side(y)] = id;&#125; fa[id] = z; son[id][sideid ^ 1] = y; fa[y] = id; son[y][sideid] = s; if (s) &#123;fa[s] = y;&#125; pushup(y); pushup(id);&#125;void splay(int id) &#123; int y; while (isroot(id) == 0) &#123; y = fa[id]; if (isroot(y) == 0) &#123; if (side(id) == side(y)) rotate(y); else rotate(id); &#125; rotate(id); &#125;&#125;int cntpa, pa[MAXn + 10];void update(int id) &#123; cntpa = 0; while (true) &#123; pa[++cntpa] = id; if (isroot(id)) break; id = fa[id]; &#125; for (int i = cntpa; i; --i) &#123; pushdown(pa[i]); &#125;&#125;void access(int x) &#123; int backupx = x; for (int s = 0; x; s = x, x = fa[x]) &#123; update(x); splay(x); son[x][1] = s; pushup(x); &#125; update(backupx); splay(backupx);&#125;void makeroot(int x) &#123; access(x); putrev(x);&#125;int findroot(int x) &#123; access(x); int rt = x; while (true) &#123; pushdown(rt); if (son[rt][0] == 0) break; rt = son[rt][0]; &#125; splay(rt); return rt;&#125;void split(int x, int y) &#123; makeroot(x); access(y);&#125;void link(int x, int y) &#123; makeroot(x); if (findroot(y) != x) fa[x] = y;&#125;void cut(int x, int y) &#123; makeroot(x); if (findroot(y) == x &amp;&amp; fa[y] == x &amp;&amp; son[y][0] == 0) &#123; son[x][1] = fa[y] = 0; pushup(x); &#125;&#125;int n, m;signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(ndval[i]); pushup(i); &#125; for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt, x, y); if (opt == 0) &#123; split(x, y); printf(&quot;%d\\n&quot;, xorr[y]); &#125; else if (opt == 1) &#123; link(x, y); &#125; else if (opt == 2) &#123; cut(x, y); &#125; else &#123; update(x); splay(x); ndval[x] = y; pushup(x); &#125; &#125; return 0;&#125; å…¶ä¸­ putrev å’Œ pushdown è¿™ä¸¤ä¸ªå‡½æ•°æœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼Œå…ˆ swap ç‰ˆï¼ˆå°±æ˜¯ä¸Šé¢ä»£ç ç”¨çš„çš„ç‰ˆæœ¬ï¼‰ï¼š 12345678910inline void putrev(int id) &#123; swap(son[id][0], son[id][1]); lzrev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (lzrev[id]) &#123; putrev(son[id][0]); putrev(son[id][1]); lzrev[id] = 0; &#125;&#125; å swap ç‰ˆï¼š 12345678910inline void putrev(int id) &#123; lzrev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (lzrev[id]) &#123; swap(son[id][0], son[id][1]); putrev(son[id][0]), putrev(son[id][1]); lzrev[id] = 0; &#125;&#125; å¦‚æœä½¿ç”¨ç¬¬äºŒä¸ªç‰ˆæœ¬ï¼Œé‚£ä¹ˆéœ€è¦ä¿è¯åœ¨ splay ä¸­ä»ä¸Šå¾€ä¸‹æ“ä½œæ—¶æ‰€æœ‰å¯¹å„¿å­èŠ‚ç‚¹çš„æ“ä½œå’Œè¯¢é—®éƒ½åº”è¯¥åœ¨ pushdown ä¹‹åè¿›è¡Œã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘","slug":"TemLib/åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘æœ‰ä¸¤ç§å†™æ³•ï¼Œæ ‡è®°æ°¸ä¹…åŒ–å’ŒåŠ¨æ€æ‰©å±•ã€‚ æ³¨æ„äº‹é¡¹ï¼š æ ‡è®°æ°¸ä¹…åŒ–ç‰ˆä½¿ç”¨ä¸Šæœ‰ä¸€å®šå±€é™æ€§ï¼Œåªæœ‰åœ¨å„ç§æ‡’æ ‡è®°ä¹‹é—´ä¸å†²çªçš„æƒ…å†µä¸‹æ‰èƒ½ä½¿ç”¨ï¼ˆå¦‚åŠ æ³•æ ‡è®°å’Œä¹˜æ³•æ ‡è®°ä¼šç›¸å†²çªï¼Œä¸èƒ½ä½¿ç”¨æ ‡è®°æ°¸ä¹…åŒ–ä¸»å¸­æ ‘ï¼‰ï¼›è€ŒåŠ¨æ€æ‰©å±•ç‰ˆæ²¡æœ‰è¿™ç§é™åˆ¶ã€‚ è®°ä¸»å¸­æ ‘å¼€åœ¨é•¿åº¦ä¸º $n$ çš„åŒºé—´ä¸Šï¼Œæ“ä½œæ•°ä¸º $m$ï¼Œ$\\text{lay}n=\\lceil\\log n\\rceil+1$ï¼Œæ ‡è®°æ°¸ä¹…åŒ–ç‰ˆçš„æœ€å¤§ç©ºé—´å ç”¨é‡ï¼ˆè‹¥åˆå§‹ç‰ˆæœ¬ä¸ºç©ºï¼‰ä¸º $4m\\text{lay}n$ï¼›åŠ¨æ€æ‰©å±•ç‰ˆçš„æœ€å¤§ç©ºé—´å ç”¨é‡ï¼ˆè‹¥åˆå§‹ç‰ˆæœ¬ä¸ºç©ºï¼‰ä¸º $5m\\text{lay}n$ï¼ˆä¸ç¡®å®šï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼‰ã€‚ åŠ¨æ€æ‰©å±•ç‰ˆçš„å‡½æ•° modify ä¸­æ“ä½œ pushdown è¦æåˆ°æœ€å‰é¢ï¼Œå¹¶æ”¹ä¸ºå¯¹èŠ‚ç‚¹ verid è¿›è¡Œ pushdownï¼Œè¿™æ˜¯ä¸ºäº†é¿å…æå‰åˆ›å»ºèŠ‚ç‚¹ id çš„å„¿å­ã€‚ å‡½æ•° build å’Œ modify ç­‰æœ‰ä¸¤ç§å†™æ³•ï¼Œã€Œä¼ å…¥ idã€å’Œã€Œä¸ä¼ å…¥ idï¼Œè¿”å› idã€ï¼Œå»ºè®®ä½¿ç”¨åä¸€ç§ã€‚ æ ‡è®°æ°¸ä¹…åŒ–ç‰ˆLuogu U220120 ã€æ¨¡æ¿ã€‘åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘1 ä»£ç ï¼ˆè¯¥ä»£ç ä¸å¸¦å–æ¨¡ï¼Œä¸èƒ½ ACï¼‰ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXnlay = 18;const int MAXm = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn * 4 + MAXnlay * MAXm * 4;int cntroot, root[MAXm + 10];int cntnd, ls[MAXnd + 10], rs[MAXnd + 10];int sum[MAXnd + 10];int lzadd[MAXnd + 10];inline void clone(int id, int verid) &#123; ls[id] = ls[verid]; rs[id] = rs[verid]; sum[id] = sum[verid]; lzadd[id] = lzadd[verid];&#125;inline void putadd(int id, int v, int len) &#123; sum[id] += v * len; lzadd[id] += v;&#125;inline void passadd(int id, int v, int len) &#123; sum[id] += v * len;&#125;int build(int *suma, int le, int ri) &#123; int id = ++cntnd; sum[id] = suma[ri] - suma[le - 1]; if (le == ri) &#123; ; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id] = build(suma, le, mid); rs[id] = build(suma, mid + 1, ri); &#125; return id;&#125;int modify(int verid, int l, int r, int v, int le, int ri) &#123; int id = ++cntnd; clone(id, verid); if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; putadd(id, v, ri - le + 1); &#125; else &#123; passadd(id, v, min(r, ri) - max(l, le) + 1); int mid = (le + ri) &gt;&gt; 1; if (l &lt;= mid) ls[id] = modify(ls[verid], l, r, v, le, mid); if (r &gt; mid) rs[id] = modify(rs[verid], l, r, v, mid + 1, ri); &#125; return id;&#125;int query(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1, ans = lzadd[id] * (min(r, ri) - max(l, le) + 1); if (l &lt;= mid) ans += query(ls[id], l, r, le, mid); if (r &gt; mid) ans += query(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;int t, n, m;int a[MAXn + 10];signed main() &#123; read(t, n, m); if (t == 1) &#123; for (int i = 1; i &lt;= n; ++i)&#123; read(a[i]); a[i] = a[i] + a[i - 1]; &#125; root[0] = build(a, 1, n); &#125; for (int i = 1, opt, ver, l, r, v; i &lt;= m; ++i) &#123; read(opt, ver, l, r); if (opt == 1) &#123; read(v); root[++cntroot] = modify(root[ver], l, r, v, 1, n); &#125; else &#123; printf(&quot;%lld\\n&quot;, query(root[ver], l, r, 1, n)); &#125; &#125; return 0;&#125; åŠ¨æ€æ‰©å±•ç‰ˆLuogu U220120 ã€æ¨¡æ¿ã€‘åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘1 ä»£ç ï¼ˆè¯¥ä»£ç ä¸å¸¦å–æ¨¡ï¼Œä¸èƒ½ ACï¼‰ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXlayn = 18;const int MAXm = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn * 4 + MAXm * MAXlayn * 5;int cntroot, root[MAXn + 10];int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], inroot[MAXnd + 10];int sum[MAXnd + 10];int lzadd[MAXnd + 10];inline void clone(int id, int verid) &#123; ls[id] = ls[verid]; rs[id] = rs[verid]; inroot[id] = inroot[verid]; sum[id] = sum[verid]; lzadd[id] = lzadd[verid];&#125;inline void putadd(int id, int len, int v) &#123; sum[id] += v * len; lzadd[id] += v;&#125;inline void pushdown(int id, int len) &#123; if (len == 1) return; if (lzadd[id]) &#123; if (inroot[ls[id]] != inroot[id]) &#123; int oldson = ls[id]; clone(ls[id] = ++cntnd, oldson); inroot[ls[id]] = inroot[id]; &#125; if (inroot[rs[id]] != inroot[id]) &#123; int oldson = rs[id]; clone(rs[id] = ++cntnd, oldson); inroot[rs[id]] = inroot[id]; &#125; putadd(ls[id], (len &gt;&gt; 1) + (len &amp; 1), lzadd[id]); putadd(rs[id], len &gt;&gt; 1, lzadd[id]); lzadd[id] = 0; &#125;&#125;inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int build(int inrt, int *a, int le, int ri) &#123; int id = ++cntnd; inroot[id] = inrt; if (le == ri) &#123; sum[id] = a[le]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id] = build(inrt, a, le, mid); rs[id] = build(inrt, a, mid + 1, ri); pushup(id); &#125; return id;&#125;int modify(int verid, int inrt, int l, int r, int v, int le, int ri) &#123; pushdown(verid, ri - le + 1); int id = ++cntnd; clone(id, verid); inroot[id] = inrt; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; putadd(id, ri - le + 1, v); &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (l &lt;= mid) ls[id] = modify(ls[verid], inrt, l, r, v, le, mid); if (r &gt; mid) rs[id] = modify(rs[verid], inrt, l, r, v, mid + 1, ri); pushup(id); &#125; return id;&#125;int query(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id, ri - le + 1); int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += query(ls[id], l, r, le, mid); if (r &gt; mid) ans += query(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;int t, n, m;int a[MAXn + 10];signed main() &#123; read(t, n, m); ++cntroot; if (t == 1) &#123; for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; root[cntroot] = build(cntroot, a, 1, n); &#125; for (int i = 1, opt, ver, l, r, v; i &lt;= m; ++i) &#123; read(opt, ver, l, r); ++ver; if (opt == 1) &#123; read(v); ++cntroot; root[cntroot] = modify(root[ver], cntroot, l, r, v, 1, n); &#125; else &#123; printf(&quot;%lld\\n&quot;, query(root[ver], l, r, 1, n)); &#125; &#125; return 0;&#125; Luogu U220145 ã€æ¨¡æ¿ã€‘åŒºé—´ä¿®æ”¹ä¸»å¸­æ ‘2 ä»£ç ï¼ˆè¯¥ä»£ç ä¸å¸¦å–æ¨¡ï¼Œä¸èƒ½ ACï¼‰ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXlayn = 18;const int MAXm = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn * 4 + MAXm * MAXlayn * 5;int cntroot, root[MAXn + 10];int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], inroot[MAXnd + 10];int sum[MAXnd + 10];int lzmul[MAXnd + 10], lzadd[MAXnd + 10];inline void clone(int id, int verid) &#123; ls[id] = ls[verid]; rs[id] = rs[verid]; inroot[id] = inroot[verid]; sum[id] = sum[verid]; lzadd[id] = lzadd[verid]; lzmul[id] = lzmul[verid];&#125;inline void putmul(int id, int v) &#123; sum[id] = sum[id] * v; lzadd[id] = lzadd[id] * v; lzmul[id] = lzmul[id] * v;&#125;inline void putadd(int id, int len, int v) &#123; sum[id] += v * len; lzadd[id] += v;&#125;inline void pushdown(int id, int len) &#123; if (len == 1) return; if (lzadd[id] != 0 || lzmul[id] != 1) &#123; if (inroot[ls[id]] != inroot[id]) &#123; int oldson = ls[id]; clone(ls[id] = ++cntnd, oldson); inroot[ls[id]] = inroot[id]; &#125; if (inroot[rs[id]] != inroot[id]) &#123; int oldson = rs[id]; clone(rs[id] = ++cntnd, oldson); inroot[rs[id]] = inroot[id]; &#125; if (lzmul[id] != 1) &#123; putmul(ls[id], lzmul[id]); putmul(rs[id], lzmul[id]); lzmul[id] = 1; &#125; if (lzadd[id] != 0) &#123; putadd(ls[id], (len &gt;&gt; 1) + (len &amp; 1), lzadd[id]); putadd(rs[id], len &gt;&gt; 1, lzadd[id]); lzadd[id] = 0; &#125; &#125;&#125;inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;void init() &#123; fill(begin(lzmul), end(lzmul), 1);&#125;int build(int inrt, int *a, int le, int ri) &#123; int id = ++cntnd; inroot[id] = inrt; if (le == ri) &#123; sum[id] = a[le]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id] = build(inrt, a, le, mid); rs[id] = build(inrt, a, mid + 1, ri); pushup(id); &#125; return id;&#125;int modifyadd(int verid, int inrt, int l, int r, int v, int le, int ri) &#123; pushdown(verid, ri - le + 1); int id = ++cntnd; clone(id, verid); inroot[id] = inrt; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; putadd(id, ri - le + 1, v); &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (l &lt;= mid) ls[id] = modifyadd(ls[verid], inrt, l, r, v, le, mid); if (r &gt; mid) rs[id] = modifyadd(rs[verid], inrt, l, r, v, mid + 1, ri); pushup(id); &#125; return id;&#125;int modifymul(int verid, int inrt, int l, int r, int v, int le, int ri) &#123; pushdown(verid, ri - le + 1); int id = ++cntnd; clone(id, verid); inroot[id] = inrt; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; putmul(id, v); &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (l &lt;= mid) ls[id] = modifymul(ls[verid], inrt, l, r, v, le, mid); if (r &gt; mid) rs[id] = modifymul(rs[verid], inrt, l, r, v, mid + 1, ri); pushup(id); &#125; return id;&#125;int query(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id, ri - le + 1); int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += query(ls[id], l, r, le, mid); if (r &gt; mid) ans += query(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;int t, n, m;int a[MAXn + 10];signed main() &#123; init(); read(t, n, m); ++cntroot; if (t == 1) &#123; for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; root[cntroot] = build(cntroot, a, 1, n); &#125; for (int i = 1, opt, ver, l, r, v; i &lt;= m; ++i) &#123; read(opt, ver, l, r); ++ver; if (opt == 1) &#123; read(v); ++cntroot; root[cntroot] = modifyadd(root[ver], cntroot, l, r, v, 1, n); &#125; else if (opt == 2) &#123; read(v); ++cntroot; root[cntroot] = modifymul(root[ver], cntroot, l, r, v, 1, n); &#125; else &#123; printf(&quot;%lld\\n&quot;, query(root[ver], l, r, 1, n)); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¢å¡æ–¯å®šç†","slug":"TemLib/å¢å¡æ–¯å®šç†","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¢å¡æ–¯å®šç†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/","excerpt":"","text":"P3807 ã€æ¨¡æ¿ã€‘å¢å¡æ–¯å®šç†/Lucas å®šç†$\\operatorname{C}^mn\\operatorname{mod}p=\\operatorname{C}^{m/p}{n/p}\\times \\operatorname{C}^{m\\operatorname{mod}p}_{n \\operatorname{mod}p}\\operatorname{mod}p$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#define re registertypedef long long ll;const int MAXC = 1e5 + 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int x, int p) &#123; int ans, k; exgcd(x, p, ans, k); return (ans % p + p) % p;&#125;int fac[MAXC + 10];void EvaFac(int top, int p) &#123; fac[0] = 1; for (re int i = 1; i &lt;= top; ++i) &#123; fac[i] = ((ll)fac[i - 1] * i) % p; &#125;&#125;int C(int n, int m, int p) &#123; if (n &lt; m) return 0; return (ll)fac[n] * inv(fac[m], p) % p * inv(fac[n - m], p) % p;&#125;int Lucas(int n, int m, int p) &#123; if (!m) return 1; return (ll)Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;&#125;int T, n, m, p;int main() &#123; read(T); while (T--) &#123; read(n), read(m), read(p); EvaFac(MAXC, p); n += m; m = n - m; printf(&quot;%d\\n&quot;, Lucas(n, m, p)); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŸæ ¹","slug":"TemLib/åŸæ ¹","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/åŸæ ¹/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8E%9F%E6%A0%B9/","excerpt":"","text":"Luogu P6091 ã€æ¨¡æ¿ã€‘åŸæ ¹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108int cntp, p[MAXn + 10]; bool notp[MAXn + 10];int ola[MAXn + 10];void EvaOla(int n) &#123; notp[1] = 1; ola[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notp[i] == 0) &#123; p[++cntp] = i; ola[i] = i - 1; &#125; for (int j = 1, toppj = n / i; j &lt;= cntp &amp;&amp; p[j] &lt;= toppj; ++j) &#123; notp[i * p[j]] = 1; if (i % p[j]) &#123; ola[i * p[j]] = ola[i] * (p[j] - 1); &#125; else &#123; ola[i * p[j]] = ola[i] * p[j]; break; &#125; &#125; &#125;&#125;int cntpf, pf[MAXn + 10];void EvaPf(int n) &#123; cntpf = 0; int tmpn = n, sqrtn = sqrt(n); for (int i = 1; p[i] &lt;= sqrtn; ++i) &#123; if (tmpn % p[i] == 0) &#123; pf[++cntpf] = p[i]; while (tmpn % p[i] == 0) tmpn /= p[i]; &#125; &#125; if (notp[tmpn] == 0) &#123; pf[++cntpf] = tmpn; &#125;&#125;inline bool HavG(int mod) &#123; if (mod == 2 || mod == 4) return 1; EvaPf(mod); if (cntpf == 1 &amp;&amp; pf[1] != 2) &#123; return 1; &#125; else if (cntpf == 2 &amp;&amp; (pf[1] == 2 || pf[2] == 2)) &#123; if ((mod / 2) % 2) &#123; return 1; &#125; &#125; return 0;&#125;inline int CntG(int mod) &#123; return ola[ola[mod]];&#125;inline bool isG(int a, int mod) &#123; if (gcd(a, mod) != 1) return 0; for (int i = 1; i &lt;= cntpf; ++i) &#123; if (power(a, ola[mod] / pf[i], mod) == 1) &#123; return 0; &#125; &#125; return 1;&#125;int cntg, g[MAXn + 10];void EvaG(int mod) &#123; cntg = 0; EvaPf(ola[mod]); int firg; for (int i = 1; i &lt; mod; ++i) &#123; if (isG(i, mod)) &#123; firg = i; break; &#125; &#125; for (int i = 1; i &lt;= ola[mod]; ++i) &#123; if (gcd(i, ola[mod]) == 1) &#123; g[++cntg] = power(firg, i, mod); &#125; &#125; sort(g + 1, g + 1 + cntg);&#125;int n, d;int T;signed main() &#123; EvaOla(MAXn); read(T); while (T--) &#123; read(n, d); int tmpcntg; if (HavG(n) == 0) &#123; tmpcntg = 0; &#125; else &#123; tmpcntg = CntG(n); &#125; if (tmpcntg &lt; d) &#123; printf(&quot;%lld\\n&quot;, tmpcntg); puts(&quot;&quot;); &#125; else &#123; EvaG(n); printf(&quot;%lld\\n&quot;, cntg); for (int i = 1, topi = cntg / d; i &lt;= topi; ++i) &#123; printf(&quot;%lld &quot;, g[i * d]); &#125; puts(&quot;&quot;); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¯é‡é›†å…¨æ’åˆ—","slug":"TemLib/å¯é‡é›†å…¨æ’åˆ—","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¯é‡é›†å…¨æ’åˆ—/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8F%AF%E9%87%8D%E9%9B%86%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"P2518 [HAOI2010]è®¡æ•°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans;signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŒä½™æœ€çŸ­è·¯","slug":"TemLib/åŒä½™æœ€çŸ­è·¯","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/åŒä½™æœ€çŸ­è·¯/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P3403 è·³æ¥¼æœº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXnd = 5e5;const int MAXn = 12;const int MAXeg = MAXnd * MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10], wei[MAXeg + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;bool vis[MAXnd + 10]; int dis[MAXnd + 10];priority_queue&lt;pair&lt;int, int&gt;&gt; q;void Dijkstra(int root, int rootdis) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = rootdis; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int n, l, r, a[MAXn + 10], ans;signed main() &#123; read(n, l, r); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; sort(a + 1, a + 1 + n); for (int i = 0; i &lt; a[1]; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; Insert(i, (i + a[j]) % a[1], a[j]); &#125; &#125; Dijkstra(0, 0); for (int i = 0; i &lt; a[1]; ++i) &#123; if (dis[i] &gt; r) continue; ans += (r - dis[i]) / a[1] + 1; if (dis[i] &gt; l - 1) continue; ans -= (l - 1 - dis[i]) / a[1] + 1; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"åç¼€æ•°ç»„ & Heightæ•°ç»„","slug":"TemLib/åç¼€æ•°ç»„ & Heightæ•°ç»„","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/åç¼€æ•°ç»„ & Heightæ•°ç»„/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%20&%20Height%E6%95%B0%E7%BB%84/","excerpt":"","text":"Acwing 2715. åç¼€æ•°ç»„ 1234567891011121314151617181920212223242526272829303132333435363738int sa[MAXn + 10], rk[MAXn + 10], x[MAXn * 2 + 10], y[MAXn * 2 + 10], buc[MAXn + 10];void EvaSaRk(int n, int m, char *str) &#123; for (int i = 1; i &lt;= n; ++i) ++buc[x[i] = str[i] - &#x27;0&#x27; + 1]; for (int i = 2; i &lt;= m; ++i) buc[i] += buc[i - 1]; for (int i = n; i; --i) sa[buc[x[i]]--] = i; for (int half = 1; ; half &lt;&lt;= 1) &#123; int cnty = 0; for (int i = n - half + 1; i &lt;= n; ++i) y[++cnty] = i; for (int i = 1; i &lt;= n; ++i) if (sa[i] &gt; half) y[++cnty] = sa[i] - half; memset(buc, 0, sizeof(buc)); for (int i = 1; i &lt;= n; ++i) ++buc[x[i]]; for (int i = 2; i &lt;= m; ++i) buc[i] += buc[i - 1]; for (int i = n; i; --i) sa[buc[x[y[i]]]--] = y[i]; swap(x, y); m = 0; for (int i = 1; i &lt;= n; ++i) &#123; x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + half] == y[sa[i - 1] + half]) ? m : ++m; &#125; if (m == n) break; &#125; for (int i = 1; i &lt;= n; ++i) &#123; rk[sa[i]] = i; &#125;&#125;int ht[MAXn + 10];void EvaHt(int n, char *str) &#123; for (int i = 1, k = 0, j; i &lt;= n; ++i) &#123; if (rk[i] == 1) continue; if (k) --k; j = sa[rk[i] - 1]; while (str[i + k] == str[j + k]) ++k; ht[rk[i]] = k; &#125;&#125;EvaSaRk(n, &#x27;z&#x27; - &#x27;0&#x27; + 1, str);EvaHt(n, str);","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"åç¼€è‡ªåŠ¨æœº(SAM) & ä¼ªå¹¿ä¹‰åç¼€è‡ªåŠ¨æœº(FGSAM)","slug":"TemLib/åç¼€è‡ªåŠ¨æœº(SAM) & ä¼ªå¹¿ä¹‰åç¼€è‡ªåŠ¨æœº(FGSAM)","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/åç¼€è‡ªåŠ¨æœº(SAM) & ä¼ªå¹¿ä¹‰åç¼€è‡ªåŠ¨æœº(FGSAM)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA(SAM)%20&%20%E4%BC%AA%E5%B9%BF%E4%B9%89%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA(FGSAM)/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ åç¼€è‡ªåŠ¨æœºä»£ç ï¼š 12345678910111213141516171819202122232425262728int cntnd, root, last, son[MAXnd + 10][26 + 2], fail[MAXnd + 10], mxlen[MAXnd + 10];int cntep[MAXnd + 10];void init() &#123; cntnd = root = last = 1;&#125;void extend(int ch) &#123; int a, b, c; a = c = last; b = last = ++cntnd; mxlen[b] = mxlen[a] + 1; cntep[b] = 1; for (; c &amp;&amp; son[c][ch] == 0; c = fail[c]) son[c][ch] = b; if (c == 0) &#123; fail[b] = root; &#125; else &#123; int d = son[c][ch]; if (mxlen[d] == mxlen[c] + 1) &#123; fail[b] = d; &#125; else &#123; int e = ++cntnd; memcpy(son[e], son[d], sizeof(son[e])); fail[e] = fail[d]; mxlen[e] = mxlen[c] + 1; fail[b] = fail[d] = e; for (; c &amp;&amp; son[c][ch] == d; c = fail[c]) son[c][ch] = e; &#125; &#125;&#125; Luogu P3804 ã€æ¨¡æ¿ã€‘åç¼€è‡ªåŠ¨æœº (SAM) ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const int MAXnd = MAXn * 2;int head[MAXnd + 10], cntnex, nex[MAXnd + 10], to[MAXnd + 10];void connect(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int cntnd, root, last, son[MAXnd + 10][26 + 2], fail[MAXnd + 10], mxlen[MAXnd + 10];int cntep[MAXnd + 10];void init() &#123; cntnd = root = last = 1;&#125;void extend(int ch) &#123; int a, b, c; a = c = last; b = last = ++cntnd; mxlen[b] = mxlen[a] + 1; cntep[b] = 1; for (; c &amp;&amp; son[c][ch] == 0; c = fail[c]) son[c][ch] = b; if (c == 0) &#123; fail[b] = root; &#125; else &#123; int d = son[c][ch]; if (mxlen[d] == mxlen[c] + 1) &#123; fail[b] = d; &#125; else &#123; int e = ++cntnd; memcpy(son[e], son[d], sizeof(son[e])); fail[e] = fail[d]; mxlen[e] = mxlen[c] + 1; fail[b] = fail[d] = e; for (; c &amp;&amp; son[c][ch] == d; c = fail[c]) son[c][ch] = e; &#125; &#125;&#125;void buildfailtree() &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; connect(fail[i], i); &#125;&#125;ll ans;void dfs(int cur) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; dfs(to[i]); cntep[cur] += cntep[to[i]]; &#125; if (cntep[cur] &gt; 1) ans = max(ans, (ll)cntep[cur] * mxlen[cur]);&#125;int len; char str[MAXn + 10];signed main() &#123; init(); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); for (int i = 1; i &lt;= len; ++i) &#123; extend(str[i] - &#x27;a&#x27;); &#125; buildfailtree(); dfs(root); printf(&quot;%lld\\n&quot;, ans); return 0;&#125; ä¼ªå¹¿ä¹‰åç¼€è‡ªåŠ¨æœºä»£ç ï¼š 123456789101112131415161718192021222324252627282930int cntnd, root, last, son[MAXnd + 10][26 + 2], fail[MAXnd + 10], mxlen[MAXnd + 10];void init() &#123; cntnd = root = last = 1;&#125;void extend(int ch = -1) &#123; int a, b, c; a = c = last; b = last = ++cntnd; mxlen[b] = mxlen[a] + 1; if (ch == -1) &#123; fail[b] = root; return; &#125; for (; c &amp;&amp; son[c][ch] == 0; c = fail[c]) son[c][ch] = b; if (c == 0) &#123; fail[b] = root; &#125; else &#123; int d = son[c][ch]; if (mxlen[d] == mxlen[c] + 1) &#123; fail[b] = d; &#125; else &#123; int e = ++cntnd; copy(begin(son[d]), end(son[d]), begin(son[e])); fail[e] = fail[d]; mxlen[e] = mxlen[c] + 1; fail[b] = fail[d] = e; for (; c &amp;&amp; son[c][ch] == d; c = fail[c]) son[c][ch] = e; &#125; &#125;&#125; Luogu P6139 ã€æ¨¡æ¿ã€‘å¹¿ä¹‰åç¼€è‡ªåŠ¨æœºï¼ˆå¹¿ä¹‰ SAMï¼‰ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXn = 4e5;const int MAXlen = 1e6;const int MAXsumlen = 1e6;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn + MAXsumlen * 2;int head[MAXnd + 10], cntnex, nex[MAXnd + 10], to[MAXnd + 10];void connect(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int cntnd, root, last, son[MAXnd + 10][26 + 2], fail[MAXnd + 10], mxlen[MAXnd + 10];void init() &#123; cntnd = root = last = 1;&#125;void extend(int ch = -1) &#123; int a, b, c; a = c = last; b = last = ++cntnd; mxlen[b] = mxlen[a] + 1; if (ch == -1) &#123; fail[b] = root; return; &#125; for (; c &amp;&amp; son[c][ch] == 0; c = fail[c]) son[c][ch] = b; if (c == 0) &#123; fail[b] = root; &#125; else &#123; int d = son[c][ch]; if (mxlen[d] == mxlen[c] + 1) &#123; fail[b] = d; &#125; else &#123; int e = ++cntnd; copy(begin(son[d]), end(son[d]), begin(son[e])); fail[e] = fail[d]; mxlen[e] = mxlen[c] + 1; fail[b] = fail[d] = e; for (; c &amp;&amp; son[c][ch] == d; c = fail[c]) son[c][ch] = e; &#125; &#125;&#125;void buildfailtree() &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; connect(fail[i], i); &#125;&#125;int n;int len[MAXn + 10]; char str[MAXlen + 10];int suflen[MAXn + 10];signed main() &#123; init(); read(n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, str + 1); len[i] = strlen(str + 1); for (int j = 1; j &lt;= len[i]; ++j) &#123; extend(str[j] - &#x27;a&#x27;); &#125; extend(); &#125; buildfailtree(); ll ans = 0; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; ans += mxlen[i] - mxlen[fail[i]]; &#125; for (int i = n; i; --i) &#123; suflen[i] = suflen[i + 1] + (len[i] + 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; ans -= (ll)(len[i] + 1) * (suflen[i + 1] + 1); &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"å“ˆå¸Œ","slug":"TemLib/å“ˆå¸Œ","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å“ˆå¸Œ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%93%88%E5%B8%8C/","excerpt":"","text":"123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 2333;int ans = 0, num, mo;vector&lt;int&gt; hash[MOD + 10];void insert(int a) &#123; mo = a % MOD; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == a) return; ans++; hash[mo].push_back(a);&#125;int main() &#123; int n; int a; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a), insert(a); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å›æ–‡è‡ªåŠ¨æœº(PAM)","slug":"TemLib/å›æ–‡è‡ªåŠ¨æœº(PAM)","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/å›æ–‡è‡ªåŠ¨æœº(PAM)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA(PAM)/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š å‡½æ•° build ä¸­ i-len[]-1 å¯èƒ½ä¼šè¶…å‡ºå­—ç¬¦ä¸²çš„ä¸‹æ ‡èŒƒå›´ï¼Œåˆ°è¾¾ä¸‹æ ‡ 0ï¼Œéœ€è¦ç‰¹åˆ¤ã€‚ 123456789101112131415161718192021222324252627int cntnd, rootodd, rooteve;int son[MAXlenb + 10][26 + 2], fail[MAXlenb + 10], len[MAXlenb + 10];int cntep[MAXlenb + 10];void build(int lenb, char *b) &#123; cntnd = 2; rootodd = 1; len[rootodd] = -1; rooteve = 2; fail[rooteve] = rootodd; len[rooteve] = 0; int j = rootodd; for (int i = 1; i &lt;= lenb; ++i) &#123; while (i - len[j] - 1 == 0 || b[i - len[j] - 1] != b[i]) j = fail[j]; if (son[j][b[i]] == 0) &#123; int nwj = son[j][b[i]] = ++cntnd; len[nwj] = len[j] + 2; int k; if (j == rootodd) &#123; k = rooteve; &#125; else &#123; k = fail[j]; while (i - len[k] - 1 == 0 || b[i - len[k] - 1] != b[i]) k = fail[k]; k = son[k][b[i]]; &#125; fail[nwj] = k; &#125; j = son[j][b[i]]; ++cntep[j]; &#125;&#125; Luogu P3649 [APIO2014] å›æ–‡ä¸² ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXlenb = 3e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXlenb + 10], cntnex, nex[MAXlenb + 10], to[MAXlenb + 10];inline void connect(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int cntnd, rootodd, rooteve;int son[MAXlenb + 10][26 + 2], fail[MAXlenb + 10], len[MAXlenb + 10];int cntep[MAXlenb + 10];void build(int lenb, char *b) &#123; cntnd = 2; rootodd = 1; len[rootodd] = -1; rooteve = 2; fail[rooteve] = rootodd; len[rooteve] = 0; int j = rootodd; for (int i = 1; i &lt;= lenb; ++i) &#123; while (i - len[j] - 1 == 0 || b[i - len[j] - 1] != b[i]) j = fail[j]; if (son[j][b[i]] == 0) &#123; int nwj = son[j][b[i]] = ++cntnd; len[nwj] = len[j] + 2; int k; if (j == rootodd) &#123; k = rooteve; &#125; else &#123; k = fail[j]; while (i - len[k] - 1 == 0 || b[i - len[k] - 1] != b[i]) k = fail[k]; k = son[k][b[i]]; &#125; fail[nwj] = k; &#125; j = son[j][b[i]]; ++cntep[j]; &#125;&#125;void buildfailtree() &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == rootodd) continue; connect(fail[i], i); &#125;&#125;ll ans;void dfs(int cur) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; dfs(to[i]); cntep[cur] += cntep[to[i]]; &#125; ans = max(ans, (ll)len[cur] * cntep[cur]);&#125;int lenb; char b[MAXlenb + 10];signed main() &#123; scanf(&quot;%s&quot;, b + 1); lenb = strlen(b + 1); for (int i = 1; i &lt;= lenb; ++i) b[i] -= &#x27;a&#x27;; build(lenb, b); buildfailtree(); dfs(rootodd); printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"å›¾çš„ç›´å¾„ & å›¾çš„ç»å¯¹ä¸­å¿ƒ & æœ€å°ç›´å¾„ç”Ÿæˆæ ‘","slug":"TemLib/å›¾çš„ç›´å¾„ & å›¾çš„ç»å¯¹ä¸­å¿ƒ & æœ€å°ç›´å¾„ç”Ÿæˆæ ‘","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/å›¾çš„ç›´å¾„ & å›¾çš„ç»å¯¹ä¸­å¿ƒ & æœ€å°ç›´å¾„ç”Ÿæˆæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9B%BE%E7%9A%84%E7%9B%B4%E5%BE%84%20&%20%E5%9B%BE%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%B8%AD%E5%BF%83%20&%20%E6%9C%80%E5%B0%8F%E7%9B%B4%E5%BE%84%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"CF266D BerDonalds SP1479 PT07C - The GbAaY Kingdom SP735 MDST - Minimum Diameter Spanning Tree éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒEvaDiaCen å‡½æ•°ä¸­æœ‰æ•´å½¢é™¤ä»¥äºŒçš„æ“ä½œï¼Œæ‰€ä»¥éœ€è¦ä¿è¯åˆå§‹æ—¶æ‰€æœ‰è¾¹æƒä¸ºäºŒçš„å€æ•°ï¼Œéœ€è¦åœ¨è¯»å…¥æ—¶å°†è¾¹æƒä¹˜äºŒï¼Œè¾“å‡ºæ—¶é™¤å›å»å°±è¡Œäº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596int n, m;struct Edge &#123; int u, v, w;&#125; eg[MAXm + 10];int dis[MAXn + 10][MAXn + 10];void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;pair&lt;int, int&gt; tmp[MAXn + 10];int rk[MAXn + 10][MAXn + 10];void EvaRk() &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; tmp[j] = make_pair(dis[i][j], j); &#125; sort(tmp + 1, tmp + 1 + n); for (int j = 1; j &lt;= n; ++j) &#123; rk[i][j] = tmp[j].second; &#125; &#125;&#125;int dia;int cenu, cenv, cendisu, cendisv;void EvaDiaCen() &#123; dia = INF; for (int i = 1; i &lt;= m; ++i) &#123; int u = eg[i].u, v = eg[i].v, w = eg[i].w; int mxdisv = dis[v][rk[u][n]]; for (int j = n - 1; j; --j) &#123; if (mxdisv &lt;= dis[v][rk[u][j]]) &#123; if (dia &gt; dis[u][rk[u][j]] + mxdisv + w) &#123; dia = dis[u][rk[u][j]] + mxdisv + w; cenu = u; cenv = v; cendisu = dia / 2 - dis[u][rk[u][j]]; cendisv = dia / 2 - mxdisv; &#125; mxdisv = dis[v][rk[u][j]]; &#125; &#125; &#125;&#125;bool vis[MAXn + 10];int dist[MAXn + 10], from[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;void Dijkstra(int s) &#123; memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; pq.push(make_pair(0, s)); while (!pq.empty()) &#123; int cur = pq.top().second; pq.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; if (dist[to[i]] &gt; dist[cur] + wei[i]) &#123; dist[to[i]] = dist[cur] + wei[i]; from[to[i]] = cur; pq.push(make_pair(dist[to[i]], to[i])); &#125; &#125; &#125;&#125;int cntmdst; pair&lt;int, int&gt; mdst[MAXm + 10];void EvaMdst() &#123; for (int i = 1; i &lt;= m; ++i) &#123; if (eg[i].u == cenu &amp;&amp; eg[i].v == cenv) continue; Insert(eg[i].u, eg[i].v, eg[i].w); Insert(eg[i].v, eg[i].u, eg[i].w); &#125; Insert(n + 1, cenu, cendisu); Insert(cenu, n + 1, cendisu); Insert(n + 1, cenv, cendisv); Insert(cenv, n + 1, cendisv); Dijkstra(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (i == cenu || i == cenv) continue; mdst[++cntmdst] = make_pair(i, from[i]); &#125; mdst[++cntmdst] = make_pair(cenu, cenv);&#125;signed main() &#123; // ... Floyd(); EvaRk(); EvaDiaCen(); // æ±‚ç›´å¾„ä»¥åŠç»å¯¹ä¸­å¿ƒ EvaMdst(); // æ±‚æœ€å°ç›´å¾„ç”Ÿæˆæ ‘&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"åœ†æ–¹æ ‘è§£ä»™äººæŒ","slug":"TemLib/åœ†æ–¹æ ‘è§£ä»™äººæŒ","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/åœ†æ–¹æ ‘è§£ä»™äººæŒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9C%86%E6%96%B9%E6%A0%91%E8%A7%A3%E4%BB%99%E4%BA%BA%E6%8E%8C/","excerpt":"","text":"Luogu P5236 ã€æ¨¡æ¿ã€‘é™æ€ä»™äººæŒ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139int cntdfs1, dfs[MAXnd + 10], low[MAXnd + 10];int back[MAXnd + 10], throwback[MAXnd + 10], bottom[MAXnd + 10];int cntdcc; vector&lt;pair&lt;int, int&gt;&gt; dcc[MAXnd + 10];int topstk, stk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs1; if (!head1[cur]) &#123; dcc[++cntdcc].push_back(make_pair(cur, 0)); return; &#125; stk[++topstk] = cur; for (int i = head1[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; if (low[cur] &gt; dfs[to[i]]) &#123; low[cur] = dfs[to[i]]; throwback[cur] = wei[i]; &#125; &#125; else &#123; back[to[i]] = wei[i]; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt;= dfs[cur]) &#123; ++cntdcc; int x; x = stk[topstk--]; dcc[cntdcc].push_back(make_pair(cur, throwback[x])); dcc[cntdcc].push_back(make_pair(x, back[x])); while (x != to[i]) &#123; x = stk[topstk--]; dcc[cntdcc].push_back(make_pair(x, back[x])); &#125; &#125; &#125; &#125; bottom[cur] = cntdfs1;&#125;int tresum[MAXnd + 10];int fa[MAXnd + 10], dep[MAXnd + 10], siz[MAXnd + 10], hson[MAXnd + 10];void Dfs1(int cur, int f, int tsum) &#123; fa[cur] = f; tresum[cur] = tsum; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mxsonsiz = 0; for (int i = head2[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; Dfs1(to[i], cur, tresum[cur] + wei[i]); siz[cur] += siz[to[i]]; if (mxsonsiz &lt; siz[to[i]]) &#123; mxsonsiz = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs2, nddfs[MAXnd + 10], idxdfs[MAXnd + 10], top[MAXnd + 10];void Dfs2(int cur, int tp) &#123; nddfs[cur] = ++cntdfs2; idxdfs[cntdfs2] = cur; top[cur] = tp; if (hson[cur]) &#123; Dfs2(hson[cur], tp); &#125; for (int i = head2[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; Dfs2(to[i], to[i]); &#125;&#125;void Lca(int x, int y, int &amp;lca, int &amp;xnear, int &amp;ynear) &#123; lca = xnear = ynear = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; xnear = top[x]; x = fa[top[x]]; &#125; else &#123; ynear = top[y]; y = fa[top[y]]; &#125; &#125; if (dep[x] &gt; dep[y]) &#123; lca = y; xnear = idxdfs[nddfs[lca] + 1]; &#125; else if (dep[x] &lt; dep[y]) &#123; lca = x; ynear = idxdfs[nddfs[lca] + 1]; &#125; else &#123; lca = x; &#125;&#125;int cirsum[MAXnd + 10];int n, m, q;int N;signed main() &#123; read(n, m, q); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); Insert(head1, u, v, w); Insert(head1, v, u, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125; N = n; for (int i = 1, dccsiz; i &lt;= cntdcc; ++i) &#123; dccsiz = dcc[i].size(); if (dccsiz == 1) &#123; ; &#125; else if (dccsiz == 2) &#123; Insert(head2, dcc[i][0].first, dcc[i][1].first, dcc[i][0].second); &#125; else &#123; ++N; cirsum[dcc[i][dccsiz - 1].first] = dcc[i][dccsiz - 1].second; for (int j = dccsiz - 2; j; --j) &#123; cirsum[dcc[i][j].first] = cirsum[dcc[i][j + 1].first] + dcc[i][j].second; &#125; cirsum[N] = cirsum[dcc[i][1].first] + dcc[i][0].second; Insert(head2, dcc[i][0].first, N, 0); for (int j = 1; j &lt; dccsiz; ++j) &#123; Insert(head2, N, dcc[i][j].first, min(cirsum[dcc[i][j].first], cirsum[N] - cirsum[dcc[i][j].first])); &#125; &#125; &#125; Dfs1(1, 0, 0); Dfs2(1, 1); for (int i = 1, x, y, lca, xnear, ynear; i &lt;= q; ++i) &#123; read(x, y); Lca(x, y, lca, xnear, ynear); if (lca &lt;= n) &#123; printf(&quot;%d\\n&quot;, tresum[x] + tresum[y] - 2 * tresum[lca]); &#125; else &#123; int tmp = abs(cirsum[xnear] - cirsum[ynear]); printf(&quot;%d\\n&quot;, tresum[x] - tresum[xnear] + tresum[y] - tresum[ynear] + min(tmp, cirsum[lca] - tmp)); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"å—çŠ¶é“¾è¡¨","slug":"TemLib/å—çŠ¶é“¾è¡¨","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/å—çŠ¶é“¾è¡¨/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Poj 2887 BigString 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXtxtlen = 1e6;const int MAXsqrttxtlen = 1e3;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, sqrtn;struct Node &#123; int len; Node *pre, *nex; char txt[MAXsqrttxtlen * 2 + 10]; Node() &#123;len = 0, pre = nullptr, nex = nullptr, memset(txt, 0, sizeof(txt));&#125; inline void split(int p) &#123; Node *nw = new Node; nw-&gt;nex = nex; nex = nw; nw-&gt;pre = this; if (nw-&gt;nex != nullptr) nw-&gt;nex-&gt;pre = nw; copy(txt + p + 1, txt + len + 1, nw-&gt;txt + 1); nw-&gt;len = len - p; len = p; &#125; inline void insert(int p, char ch) &#123; for (int i = len; i &gt; p; --i) &#123; txt[i + 1] = txt[i]; &#125; txt[p + 1] = ch; ++len; if (len &gt; sqrtn) &#123; split(len &gt;&gt; 1); &#125; &#125;&#125;;Node *head;inline void Init(char *str) &#123; Node *last = nullptr; for (int l = 1, r = sqrtn; ; l += sqrtn, r += sqrtn) &#123; Node *nw = new Node; if (last != nullptr) &#123; nw-&gt;pre = last; last-&gt;nex = nw; &#125; else &#123; head = nw; &#125; nw-&gt;len = min(r, n) - l + 1; copy(str + l, str + l + nw-&gt;len, nw-&gt;txt + 1); last = nw; if (r &gt;= n) break; &#125;&#125;inline char Query(int p) &#123; --p; Node *cur = head; while (p &gt;= cur-&gt;len) &#123; p -= cur-&gt;len; cur = cur-&gt;nex; &#125; return cur-&gt;txt[1 + p];&#125;inline void Insert(int p, char ch) &#123; --p; Node *cur = head; if (p == -1) &#123; cur-&gt;insert(0, ch); return; &#125; while (p &gt;= cur-&gt;len) &#123; p -= cur-&gt;len; cur = cur-&gt;nex; &#125; cur-&gt;insert(1 + p, ch);&#125;int m;char str[MAXtxtlen + 10];signed main() &#123; scanf(&quot;%s&quot;, str + 1); n = strlen(str + 1); sqrtn = sqrt(n); Init(str); read(m); char opt, ch; for (int i = 1, p; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, &amp;opt); if (opt == &#x27;Q&#x27;) &#123; read(p); printf(&quot;%c\\n&quot;, Query(p)); &#125; else if (opt == &#x27;I&#x27;) &#123; scanf(&quot;%s&quot;, &amp;ch); read(p); Insert(p - 1, ch); &#125; else &#123; puts(&quot;Error!&quot;); exit(1); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŸƒæ°ç­›","slug":"TemLib/åŸƒæ°ç­›","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/åŸƒæ°ç­›/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9F%83%E6%B0%8F%E7%AD%9B/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š i * i ä¼šçˆ† intï¼Œæ‰€ä»¥åœ¨è¿›å…¥å¾ªç¯ for (int j = i * i; j &lt;= n; j += i) å‰è¦å…ˆæ»¡è¶³ if ((long long)i * i &lt;= m)ã€‚ ä»£ç ï¼š 1234567891011121314bool notpr[MAXn + 10]; int cntpr, pr[MAXn / 10 + 100];void evapr(int n) &#123; notpr[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; if ((long long)i * i &lt;= n) &#123; for (int j = i * i; j &lt;= n; j += i) &#123; notpr[j] = 1; &#125; &#125; &#125; &#125;&#125; Luogu P3383 ã€æ¨¡æ¿ã€‘çº¿æ€§ç­›ç´ æ•° ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e8;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;bool notpr[MAXn + 10]; int cntpr, pr[MAXn / 10 + 100];void evapr(int n) &#123; notpr[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; if ((long long)i * i &lt;= n) &#123; for (int j = i * i; j &lt;= n; j += i) &#123; notpr[j] = 1; &#125; &#125; &#125; &#125;&#125;int n, m;signed main() &#123; read(n, m); evapr(n); for (int i = 1, x; i &lt;= m; ++i) &#123; read(x); printf(&quot;%d\\n&quot;, pr[x]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åŸºç¯æ ‘","slug":"TemLib/åŸºç¯æ ‘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/åŸºç¯æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9F%BA%E7%8E%AF%E6%A0%91/","excerpt":"","text":"P1453 åŸå¸‚ç¯è·¯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;double k;int n, a[MAXn + 10], deg[MAXn + 10];queue&lt;int&gt; q;bool vis[MAXn + 10];int cntring, ring[MAXn + 10];void EvaRing() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 1) &#123; q.push(i); &#125; &#125; int cur; while (!q.empty()) &#123; cur = q.front(); q.pop(); vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!vis[to[i]]) &#123; --deg[to[i]]; if (deg[to[i]] == 1) &#123; q.push(to[i]); &#125; &#125; &#125; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 2) &#123; vis[i] = 1; ring[++cntring] = i; break; &#125; &#125; bool ok = 1; while (ok) &#123; ok = 0; for (re int i = head[ring[cntring]]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 1) continue; vis[to[i]] = 1; ring[++cntring] = to[i]; ok = 1; break; &#125; &#125;&#125;int d[MAXn + 10][2];void dp(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 2) continue; dp(to[i]); d[cur][0] += max(d[to[i]][1], d[to[i]][0]); d[cur][1] += d[to[i]][0]; &#125; d[cur][1] += a[cur];&#125;void Dp() &#123; memset(vis, 0, sizeof(vis)); for (re int i = 1; i &lt;= cntring; ++i) &#123; dp(ring[i]); &#125;&#125;int f[MAXn + 10][2][2];int Dp2() &#123; f[1][0][0] = d[ring[1]][0]; f[1][1][1] = d[ring[1]][1]; f[1][0][1] = f[1][1][0] = -INF; for (re int i = 2; i &lt;= cntring; ++i) &#123; f[i][0][0] = max(f[i - 1][0][0], f[i - 1][0][1]) + d[ring[i]][0]; f[i][0][1] = f[i - 1][0][0] + d[ring[i]][1]; f[i][1][0] = max(f[i - 1][1][0], f[i - 1][1][1]) + d[ring[i]][0]; f[i][1][1] = f[i - 1][1][0] + d[ring[i]][1]; &#125; return max(max(f[cntring][0][0], f[cntring][0][1]), f[cntring][1][0]);&#125;int main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (re int i = 1, u, v; i &lt;= n; ++i) &#123; read(u), read(v); ++u; ++v; ++deg[u]; ++deg[v]; Insert(u, v); Insert(v, u); &#125; scanf(&quot;%lf&quot;, &amp;k); EvaRing(); Dp(); printf(&quot;%.1lf\\n&quot;, (double)Dp2() * k);&#125; åŸºç¯æ ‘æ±‚ç¯é•¿åº¦å’Œç¯ä¸Šæ¯ä¸ªèŠ‚ç‚¹å‰çš„è¾¹çš„é•¿åº¦ï¼š123456789101112int cntinring, ring[MAXnd + 10], ringdis;int ndwei[MAXnd + 10];void EvaRing(int cur, int fromedge, int begin) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (iscut[i] || i == (fromedge ^ 1)) continue; ring[++cntinring] = to[i]; ringdis += wei[i]; ndwei[to[i]] = wei[i]; if (to[i] != begin) EvaRing(to[i], i, begin); if (cur == begin) break; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"å †æ’åº","slug":"TemLib/å †æ’åº","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å †æ’åº/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 ã€æ¨¡æ¿ã€‘å¿«é€Ÿæ’åºå¯ä»¥ç”¨å¿«æ’çš„æ¿æµ‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int heap[MAXn+10];int heapn;int n;void up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void insert(int x) &#123; heap[++heapn] = x; up(heapn);&#125;void pop(int p) &#123; heap[p] = heap[heapn--]; up(p); down(p);&#125;void pop_root() &#123; heap[1] = heap[heapn--]; down(1);&#125;int get_root() &#123; return heap[1];&#125;int main()&#123; n = read(); for(int i = 0; i &lt; n; i++) &#123; insert(read()); &#125; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, get_root()); pop_root(); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¤šé‡èƒŒåŒ…","slug":"TemLib/å¤šé‡èƒŒåŒ…","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¤šé‡èƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1776 å®ç‰©ç­›é€‰1. å•è°ƒé˜Ÿåˆ—ä¼˜åŒ–ç‰ˆ12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW = 4e4;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int le, ri; pair&lt;int, int&gt; q[MAXW + 10];inline void Init() &#123; le = 1; ri = 0;&#125;inline void Push_back(int x, int idx) &#123; while (le &lt;= ri &amp;&amp; q[ri].first &lt;= x) &#123; --ri; &#125; q[++ri] = make_pair(x, idx);&#125;inline int Front(int idx) &#123; while (le &lt;= ri &amp;&amp; q[le].second &lt; idx) &#123; ++le; &#125; return q[le].first;&#125;int n, W, d[MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, v, w, m; i &lt;= n; ++i) &#123; read(v, w, m); for (int j = 0; j &lt; w; ++j) &#123; Init(); for (int k = 0, l = j; l &lt;= W; ++k, l += w) &#123; Push_back(d[l] - k * v, k); d[l] = Front(k - m) + k * v; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, d[W]);&#125; 2. äºŒè¿›åˆ¶æ‹†åˆ†ç‰ˆ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 100;const int MAXW = 40000;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; &#125;&#125;void rec(int v[], int w[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; n = read(); W = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; v = read(); w = read(); num = read(); bin_divide(v, w, num, v_new, w_new, num_new); &#125; rec(v_new, w_new, W, num_new); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å­—ç¬¦ä¸²dp","slug":"TemLib/å­—ç¬¦ä¸²dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å­—ç¬¦ä¸²dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2dp/","excerpt":"","text":"P3082 [USACO13MAR]Necklace G1. Kmpä¸ŠDpï¼ˆä¼šTï¼‰12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::ios;using std::cin;using std::cout;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int INF = 0x3f3f3f3f;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10];int d[MAXltxt + 10][MAXlwrd + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; while (k &amp;&amp; (wrd[k + 1] != txt[i + 1] || k == lwrd)) k = fail[k]; if (wrd[k + 1] == txt[i + 1]) ++k; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; 2. Acè‡ªåŠ¨æœºä¸ŠDp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using std::ios;using std::cin;using std::cout;using std::queue;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int MAXnd = 1e3;const int INF = 0x3f3f3f3f;int cntnd, son[MAXnd + 10][26], fail[MAXnd + 10];int Insert(char *str) &#123; int len = strlen(str + 1); int cur = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (!son[cur][str[i] - &#x27;a&#x27;]) &#123; son[cur][str[i] - &#x27;a&#x27;] = ++cntnd; &#125; cur = son[cur][str[i] - &#x27;a&#x27;]; &#125; return cur;&#125;queue&lt;int&gt; q;void EvaFail() &#123; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int j = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) &#123; if (son[j][i]) &#123; fail[son[j][i]] = son[fail[j]][i]; q.push(son[j][i]); &#125; else &#123; son[j][i] = son[fail[j]][i]; &#125; &#125; &#125;&#125;char wrd[MAXlwrd + 10], txt[MAXltxt + 10];int n, lwrd, ltxt, d[MAXltxt + 10][MAXlwrd + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); Insert(wrd); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; k = son[k][txt[i + 1] - &#x27;a&#x27;]; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"å­—ç¬¦ä¸²å“ˆå¸Œ","slug":"TemLib/å­—ç¬¦ä¸²å“ˆå¸Œ","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å­—ç¬¦ä¸²å“ˆå¸Œ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"P3370 ã€æ¨¡æ¿ã€‘å­—ç¬¦ä¸²å“ˆå¸Œ1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1510;const int base = 261;const int MOD = 23333;int n, ans = 0;char s[MAXn];vector&lt;string&gt; hash[MOD + 2];inline void insert() &#123; int mo = 1; for (int i = 0; s[i]; i++) mo = (mo * 1ll * base + s[i]) % MOD; string s2 = s; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == s2) return; hash[mo].push_back(s2); ans++;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, &amp;s), insert(); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"å­—ç¬¦ä¸²å“ˆå¸Œè§£æœ€å°å¾ªç¯èŠ‚","slug":"TemLib/å­—ç¬¦ä¸²å“ˆå¸Œè§£æœ€å°å¾ªç¯èŠ‚","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/å­—ç¬¦ä¸²å“ˆå¸Œè§£æœ€å°å¾ªç¯èŠ‚/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E8%A7%A3%E6%9C%80%E5%B0%8F%E5%BE%AA%E7%8E%AF%E8%8A%82/","excerpt":"","text":"P3538 POI2012\\OKR-A Horrible Poem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e5;const int BASE = 107;const int MOD = 1e9 + 7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, cntp, p[MAXn + 10], minpf[MAXn + 10];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; minpf[i] = i; &#125; int up2 = up / i; for (int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; minpf[i * p[j]] = p[j]; if (!(i % p[j])) &#123; break; &#125; &#125; &#125;&#125;int hashpre[MAXn + 10], poww[MAXn + 10];inline int hash(int l, int r) &#123; return ((hashpre[r] - hashpre[l - 1] * poww[r - l + 1]) % MOD + MOD) % MOD;&#125;char str[MAXn + 10];signed main() &#123; read(n); LS(n); scanf(&quot;%s&quot;, str + 1); for (int i = 1; i &lt;= n; ++i) &#123; hashpre[i] = (hashpre[i - 1] * BASE + str[i] - &#x27;a&#x27;) % MOD; &#125; poww[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; poww[i] = (poww[i - 1] * BASE) % MOD; &#125; read(m); for (re int i = 1; i &lt;= m; ++i) &#123; int l, r, len, ans; read(l), read(r); ans = len = r - l + 1; if (hash(l + 1, r) == hash(l, r - 1)) &#123; printf(&quot;1\\n&quot;); &#125; else &#123; while (len &gt; 1) &#123; if (hash(l + ans / minpf[len], r) == hash(l, r - ans / minpf[len])) &#123; ans /= minpf[len]; //ans: å¾ªç¯èŠ‚é•¿åº¦ &#125; //minpf: æœ€å°è´¨å› æ•°ï¼Œå¾ªç¯æ¬¡æ•° len /= minpf[len]; //len: æ— å®é™…æ„ä¹‰ï¼Œç”¨äºæå–æ‰€æœ‰è´¨å› æ•° &#125; printf(&quot;%lld\\n&quot;, ans); &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"å­—ç¬¦ä¸²æœ€å°è¡¨ç¤ºæ³•","slug":"TemLib/å­—ç¬¦ä¸²æœ€å°è¡¨ç¤ºæ³•","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å­—ç¬¦ä¸²æœ€å°è¡¨ç¤ºæ³•/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"P1368 ã€æ¨¡æ¿ã€‘æœ€å°è¡¨ç¤ºæ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::min;const int MAXn = 3e5;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, a[MAXn * 2 + 10], begin;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); a[i + n] = a[i]; &#125; int i = 1, j = 2, k = 0; while (true) &#123; if (i &gt; n || j &gt; n) &#123; begin = min(i, j); break; &#125; k = 0; while (a[i + k] == a[j + k] &amp;&amp; k &lt; n) ++k; if (k == n) &#123; begin = i; break; &#125; if (a[i + k] &gt; a[j + k]) &#123; i = i + k + 1; if (i == j) ++i; &#125; else &#123; j = j + k + 1; if (i == j) ++j; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d &quot;, a[begin + i]); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"å®Œå…¨èƒŒåŒ…","slug":"TemLib/å®Œå…¨èƒŒåŒ…","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å®Œå…¨èƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1616 ç–¯ç‹‚çš„é‡‡è¯12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;LL n, W;LL d[MAXW + 10];int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = w; i &lt;= W; i++) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å®ç”¨å°é«˜ç²¾","slug":"TemLib/å®ç”¨å°é«˜ç²¾","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/å®ç”¨å°é«˜ç²¾/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%9E%E7%94%A8%E5%B0%8F%E9%AB%98%E7%B2%BE/","excerpt":"","text":"ä¸å®ç”¨çš„é«˜ç²¾ æ¨èä¸€ä¸ªå®ç”¨å°é«˜ç²¾ï¼š 1234567891011121314151617181920212223struct BigInt &#123; const static long long base = 1e13; long long s[2]; friend BigInt operator + (BigInt a, const BigInt b) &#123; a.s[0] += b.s[0]; a.s[1] += b.s[1]; if (a.s[0] &gt;= base) ++a.s[1], a.s[0] -= base; return a; &#125; friend int operator % (BigInt a, int b) &#123; return ((a.s[1] % b) * base + a.s[0]) % b; &#125; friend BigInt operator / (BigInt a, int b) &#123; BigInt c; c.s[1] = a.s[1] / b; c.s[0] = ((a.s[1] % b) * base + a.s[0]) / b; return c; &#125; void print() &#123; if (s[1]) printf(&quot;%lld%13lld&quot;, s[1], s[0]); else printf(&quot;%lld&quot;, s[0]); &#125;&#125;; ä¹˜æ³•ä¸ç”¨è€ƒè™‘ï¼Œç”¨ s[1] * s[1] å°±ç‚¸äº†ã€‚å‡æ³•è¿˜è¦è€ƒè™‘è´Ÿæ•°ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰ã€‚","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å®¹æ–¥åŸç†","slug":"TemLib/å®¹æ–¥åŸç†","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å®¹æ–¥åŸç†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"","text":"P1450 HAOI2008 ç¡¬å¸è´­ç‰©123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 4;const int MAXn2 = 16;const int MAXW = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int T, n = 4, W, w[MAXn + 10], cnt[MAXn + 10], d[MAXW + 10];signed main() &#123; read(w[1]), read(w[2]), read(w[3]), read(w[4]), read(T); d[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = w[i]; j &lt;= MAXW; ++j) &#123; d[j] += d[j - w[i]]; &#125; &#125; while (T--) &#123; read(cnt[1]), read(cnt[2]), read(cnt[3]), read(cnt[4]), read(W); int ans = 0; for (re int i = 0; i &lt; MAXn2; ++i) &#123; int p = W; for (re int j = 1; j &lt;= n; ++j) &#123; if ((i &gt;&gt; (j - 1)) &amp; 1) &#123; p -= w[j] * (cnt[j] + 1); &#125; &#125; if (p &lt; 0) &#123; continue; &#125; ans += __builtin_popcount(i) &amp; 1 ? -d[p] : d[p]; &#125; printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¯¹é¡¶æ ˆ","slug":"TemLib/å¯¹é¡¶æ ˆ","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¯¹é¡¶æ ˆ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AF%B9%E9%A1%B6%E6%A0%88/","excerpt":"","text":"P2201 æ•°åˆ—ç¼–è¾‘å™¨1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;struct Ele &#123; int val, sum, maxsum; Ele()&#123;&#125; Ele(int val_):val(val_)&#123;&#125;&#125;;struct Stack &#123; int top; Ele stk[MAXn + 10]; inline void Push(int x) &#123; stk[++top] = Ele(x); &#125; inline int Pop() &#123; return stk[top--].val; &#125;&#125;fro, beh;int n;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; char opt; for (re int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; opt; switch (opt) &#123; case &#x27;I&#x27;: cin &gt;&gt; x; fro.Push(x); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;D&#x27;: fro.Pop(); break; case &#x27;L&#x27;: beh.Push(fro.Pop()); break; case &#x27;R&#x27;: fro.Push(beh.Pop()); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;Q&#x27;: cin &gt;&gt; x; cout &lt;&lt; fro.stk[x].maxsum &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å·¦åå †","slug":"TemLib/å·¦åå †","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/å·¦åå †/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B7%A6%E5%81%8F%E5%A0%86/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 1234567891011121314151617181920int ls[MAXn + 10], rs[MAXn + 10];int hig[MAXn + 10], val[MAXn + 10];void init() &#123; hig[0] = -1;&#125;inline void pushup(int id) &#123; hig[id] = hig[rs[id]] + 1;&#125;int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (val[x] &gt; val[y]) swap(x, y); rs[x] = merge(rs[x], y); if (hig[ls[x]] &lt; hig[rs[x]]) swap(ls[x], rs[x]); pushup(x); return x;&#125;int pop(int x) &#123; isdel[x] = 1; return merge(ls[x], rs[x]);&#125; Luogu P3377 ã€æ¨¡æ¿ã€‘å·¦åæ ‘ï¼ˆå¯å¹¶å †ï¼‰ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;struct UniSet &#123; int fa[MAXn + 10]; void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; &#125; &#125; int anc(int x) &#123; return fa[x] = ((fa[x] == x) ? x : anc(fa[x])); &#125; void changeanc(int x, int y) &#123; fa[x] = y; fa[y] = y; &#125;&#125;;UniSet us;int ls[MAXn + 10], rs[MAXn + 10];int hig[MAXn + 10]; bool isdel[MAXn + 10]; pair&lt;int, int&gt; val[MAXn + 10];void init() &#123; hig[0] = -1;&#125;inline void pushup(int id) &#123; hig[id] = hig[rs[id]] + 1;&#125;int merge(int x, int y) &#123; if (x == 0 || y == 0) return x + y; if (val[x] &gt; val[y]) swap(x, y); rs[x] = merge(rs[x], y); if (hig[ls[x]] &lt; hig[rs[x]]) swap(ls[x], rs[x]); pushup(x); return x;&#125;int pop(int x) &#123; isdel[x] = 1; return merge(ls[x], rs[x]);&#125;int n, m;signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(val[i].first); val[i].second = i; &#125; us.init(n); for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt, x); if (opt == 1) &#123; read(y); if (isdel[x] || isdel[y]) continue; int ancx = us.anc(x), ancy = us.anc(y); if (ancx == ancy) continue; if (merge(ancx, ancy) == ancx) &#123; us.fa[ancy] = ancx; &#125; else &#123; us.fa[ancx] = ancy; &#125; &#125; else &#123; if (isdel[x]) &#123; puts(&quot;-1&quot;); continue; &#125; int ancx = us.anc(x); printf(&quot;%d\\n&quot;, val[ancx].first); us.changeanc(ancx, pop(ancx)); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¸¦æƒå¹¶æŸ¥é›†","slug":"TemLib/å¸¦æƒå¹¶æŸ¥é›†","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/å¸¦æƒå¹¶æŸ¥é›†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"å¸¦æƒå¹¶æŸ¥é›†çš„é€‚ç”¨å‰æï¼šç»´æŠ¤çš„å…³ç³»å…·æœ‰å¯ä¼ é€’æ€§ã€‚ å¸¦æƒå¹¶æŸ¥é›†æ“ä½œéœ€ä¿è¯çš„æ¡ä»¶ï¼šæ‰§è¡Œäº†å‡½æ•° anc æˆ–è¿›è¡Œåˆå¹¶çš„èŠ‚ç‚¹çš„æ‰€æœ‰ä¿¡æ¯ä¸€å®šä¼šè¢«æ›´æ–°ã€‚ æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ Luogu P2024 [NOI2001] é£Ÿç‰©é“¾ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline int addmod(int x) &#123; return (x &gt;= 3) ? x - 3 : x;&#125;inline int redmod(int x) &#123; return (x &lt; 0) ? x + 3 : x;&#125;int fa[MAXn + 10];int dis[MAXn + 10];void init(int n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; dis[i] = 0; &#125;&#125;int anc(int x) &#123; if (fa[x] == x) &#123; return x; &#125; else &#123; int ancc = anc(fa[x]); dis[x] = addmod(dis[fa[x]] + dis[x]); fa[x] = ancc; return ancc; &#125;&#125;int n, m;int ans;signed main() &#123; read(n, m); init(n); for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt, x, y); if (x &gt; n || y &gt; n) &#123; ++ans; continue; &#125; --opt; int ancx = anc(x), ancy = anc(y); if (ancx == ancy) &#123; if (redmod(dis[x] - dis[y]) != opt) ++ans; &#125; else &#123; fa[ancx] = ancy; dis[ancx] = addmod(redmod(opt - dis[x]) + dis[y]); &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¹¶æŸ¥é›†","slug":"TemLib/å¹¶æŸ¥é›†","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¹¶æŸ¥é›†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"P3367 ã€æ¨¡æ¿ã€‘å¹¶æŸ¥é›†123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 1e4;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;int n, m;int main() &#123; read(n), read(m); Init(n); for (re int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y); Merge(x, y); break; case 2: read(x), read(y); SameAnc(x, y) ? printf(&quot;Y\\n&quot;) : printf(&quot;N\\n&quot;); break; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"åº·æ‰˜å±•å¼€ & é€†åº·æ‰˜å±•å¼€","slug":"TemLib/åº·æ‰˜å±•å¼€ & é€†åº·æ‰˜å±•å¼€","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/åº·æ‰˜å±•å¼€ & é€†åº·æ‰˜å±•å¼€/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%20&%20%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","excerpt":"","text":"P3014 [USACO11FEB]Cow Line S 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 20;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : c ^ &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int t[MAXn + 10];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline void BuildUseSum(int *sum, int top) &#123; for (int i = 1; i &lt;= top; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;inline void Add(int p, int x, int top) &#123; while (p &lt;= top) &#123; t[p] += x; p += lowbit(p); &#125;&#125;inline int Sum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;inline int Div(int l, int r, int x) &#123; int mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (Sum(mid) &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int fac[MAXn + 10];void EvaFac(int top) &#123; fac[0] = 1; for (int i = 1; i &lt;= top; ++i) &#123; fac[i] = fac[i - 1] * i; &#125;&#125;int sum[MAXn + 10];void EvaSum(int top) &#123; for (int i = 1; i &lt;= top; ++i) &#123; sum[i] = i; &#125;&#125;int n, q;int x, a[MAXn + 10];int cnt[MAXn + 10], ans[MAXn + 10];void InvCantor() &#123; BuildUseSum(sum, n); int tmpx = x - 1; for (int i = n; i; --i) &#123; cnt[i] = tmpx / fac[i - 1]; tmpx %= fac[i - 1]; &#125; for (int i = n; i; --i) &#123; ans[i] = Div(1, n, cnt[i] + 1); Add(ans[i], -1, n); &#125;&#125;int Cantor() &#123; BuildUseSum(sum, n); int ans = 1; for (int i = n; i; --i) &#123; Add(a[i], -1, n); ans += fac[i - 1] * Sum(a[i]); &#125; return ans;&#125;signed main() &#123; read(n, q); EvaFac(n); EvaSum(n); char opt; for (int i = 1; i &lt;= q; ++i) &#123; cin &gt;&gt; opt; if (opt == &#x27;P&#x27;) &#123; read(x); InvCantor(); for (int i = n; i; --i) &#123; printf(&quot;%lld &quot;, ans[i]); &#125; puts(&quot;&quot;); &#125; else &#123; for (int i = n; i; --i) &#123; read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Cantor()); &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¼‚æˆ–é«˜æ–¯æ¶ˆå…ƒ","slug":"TemLib/å¼‚æˆ–é«˜æ–¯æ¶ˆå…ƒ","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/å¼‚æˆ–é«˜æ–¯æ¶ˆå…ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BC%82%E6%88%96%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839int n, m;bool a[MAXn + 10][MAXm + 10];int guass() &#123; int row = 1, mxchoser = 0; for (int col = 1; col &lt;= m &amp;&amp; row &lt;= n; ++col) &#123; int choser = -1; for (int i = row; i &lt;= n; ++i) &#123; if (a[i][col]) &#123; choser = i; break; &#125; &#125; if (choser == -1) continue; mxchoser = max(mxchoser, choser); if (choser != row) swap(a[row], a[choser]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (a[i][col]) &#123; for (int j = col; j &lt;= m + 1; ++j) &#123; a[i][j] ^= a[row][j]; &#125; &#125; &#125; ++row; &#125; bool noans = 0, moreans = 0; if (row &lt;= m) &#123; for (int i = row; i &lt;= n; ++i) &#123; if (a[i][m + 1]) &#123; noans = 1; break; &#125; &#125; if (noans == 0) moreans = 1; &#125; if (noans) return 0; else if (moreans) return -1; else return mxchoser;&#125; Luogu P2447 [SDOI2010] å¤–æ˜Ÿåƒè¶³è™« ä»£ç ï¼ˆæœ¬ä»£ç ä¸­ $n$ å’Œ $m$ å’Œé¢˜é¢ä¸­çš„æ˜¯åçš„ï¼Œä»£ç ä¸­ $n$ ä»£è¡¨çŸ©é˜µçš„è¡Œæ•°ï¼Œ$m$ ä»£è¡¨åˆ—æ•°ï¼‰ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 2e3;const int MAXm = 1e3;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, m;bool a[MAXn + 10][MAXm + 10];int guass() &#123; int row = 1, mxchoser = 0; for (int col = 1; col &lt;= m &amp;&amp; row &lt;= n; ++col) &#123; int choser = -1; for (int i = row; i &lt;= n; ++i) &#123; if (a[i][col]) &#123; choser = i; break; &#125; &#125; if (choser == -1) continue; mxchoser = max(mxchoser, choser); if (choser != row) swap(a[row], a[choser]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (a[i][col]) &#123; for (int j = col; j &lt;= m + 1; ++j) &#123; a[i][j] ^= a[row][j]; &#125; &#125; &#125; ++row; &#125; bool noans = 0, moreans = 0; if (row &lt;= m) &#123; for (int i = row; i &lt;= n; ++i) &#123; if (a[i][m + 1]) &#123; noans = 1; break; &#125; &#125; if (noans == 0) moreans = 1; &#125; if (noans) return 0; else if (moreans) return -1; else return mxchoser;&#125;char str[MAXm + 10];signed main() &#123; read(m, n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, str + 1); for (int j = 1; j &lt;= m; ++j) &#123; a[i][j] = str[j] - &#x27;0&#x27;; &#125; scanf(&quot;%d&quot;, &amp;a[i][m + 1]); &#125; int res = guass(); if (res == 0) &#123; puts(&quot;Error1&quot;); exit(1); &#125; else if (res == -1) &#123; puts(&quot;Cannot Determine&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, res); for (int i = 1; i &lt;= m; ++i) &#123; if (a[i][m + 1]) puts(&quot;?y7M#&quot;); else puts(&quot;Earth&quot;); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¼ºè¿é€šåˆ†é‡","slug":"TemLib/å¼ºè¿é€šåˆ†é‡","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¼ºè¿é€šåˆ†é‡/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"B3609 [å›¾è®ºä¸ä»£æ•°ç»“æ„ 701] å¼ºè¿é€šåˆ†é‡1234567891011121314151617181920212223242526272829303132int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntscc; vector&lt;int&gt; scc[MAXnd + 10];int top, stk[MAXnd + 10]; bool instk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]] &amp;&amp; instk[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; scc[cntscc].push_back(x); &#125; while (x != cur); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125; ç¼©ç‚¹ï¼š12345for (int i = 1; i &lt;= m; ++i) &#123; if (inscc[from1[i]] != inscc[to1[i]]) &#123; Insert2(inscc[from1[i]], inscc[to1[i]]); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"å½’å¹¶æ’åº","slug":"TemLib/å½’å¹¶æ’åº","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å½’å¹¶æ’åº/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 ã€æ¨¡æ¿ã€‘å¿«é€Ÿæ’åºå¯ä»¥ç”¨å¿«æ’çš„æ¿æµ‹1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x=x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];int tmp[MAXn + 10];void merge(int l, int r) &#123; if (r - l &lt;= 1) &#123; return; &#125; int mid = l + (r - l &gt;&gt; 1); merge(l, mid); merge(mid, r); int p = l, q = mid, s = l; while (s &lt; r) &#123; if (p &gt;= mid || (q &lt; r &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = l; i &lt; r; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å½’å¹¶æ³•æ±‚é€†åºå¯¹æ•°","slug":"TemLib/å½’å¹¶æ³•æ±‚é€†åºå¯¹æ•°","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å½’å¹¶æ³•æ±‚é€†åºå¯¹æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BD%92%E5%B9%B6%E6%B3%95%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/","excerpt":"","text":"P1908 é€†åºå¯¹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Inverted Sequence Numbers//different from only Merge Sort:&quot;//Diff&quot; #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn=500000;inline int read()&#123; register char c; while(c=getchar(),c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;); register int x(c-&#x27;0&#x27;); while(c=getchar(),c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123; x=x*10+c-&#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn+10];int tmp[MAXn+10];long long ans;//Diffvoid merge(int ll, int rr) &#123; if (rr - ll &lt;= 1) &#123; return; &#125; int mid = ll + (rr - ll &gt;&gt; 1); merge(ll, mid); merge(mid, rr); int p = ll, q = mid, s = ll; while (s &lt; rr) &#123; if (p &gt;= mid || (q &lt; rr &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; ans += mid - p;//Diff &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = ll; i &lt; rr; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); printf(&quot;%lld&quot;, ans);//Diff&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«è¯»","slug":"TemLib/å¿«è¯»","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/å¿«è¯»/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E8%AF%BB/","excerpt":"","text":"12345678template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«é€Ÿä¹˜","slug":"TemLib/å¿«é€Ÿä¹˜","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¿«é€Ÿä¹˜/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E4%B9%98/","excerpt":"","text":"é¾Ÿé€Ÿä¹˜ 12345678910111213template&lt;class T&gt;inline T mul(T x, T y, T mod) &#123; x %= mod; y %= mod; T ans = 0; while (y) &#123; if (y &amp; 1) &#123; ans = (ans + x) % mod; &#125; x = (x + x) % mod; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«é€Ÿå‚…é‡Œå¶å˜æ¢(fft)","slug":"TemLib/å¿«é€Ÿå‚…é‡Œå¶å˜æ¢(fft)","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/å¿«é€Ÿå‚…é‡Œå¶å˜æ¢(fft)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2(fft)/","excerpt":"","text":"Luogu P3803 ã€æ¨¡æ¿ã€‘å¤šé¡¹å¼ä¹˜æ³•ï¼ˆFFTï¼‰ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé¢˜ç›®ä¸­è¦å¼€å‡ åä¸‡ä¸ª Complexï¼Œè€Œä¸”å’ŒçŸ©é˜µä¹˜æ³•ä¸åŒçš„æ˜¯ä»£ç ä¸­æ²¡æœ‰å¼€éå…¨å±€å˜é‡çš„ Complex çš„éœ€æ±‚ï¼Œæ‰€ä»¥å¯ä»¥ä¸ç”¨å†™æ„é€ å‡½æ•°ï¼ŒèŠ‚çœä¸€äº›è¿è¡Œæ—¶é—´ã€‚ ä»£ç ä¸­çš„å˜é‡ n çš„æ„ä¹‰æ˜¯å¤šé¡¹å¼çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯åº¦æ•°åŠ ä¸€ï¼Œè€Œéåº¦æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const double twoPI = acos(-1) * 2;struct Complex &#123; double x, y; inline Complex operator+(const Complex sec) const &#123; return Complex&#123;x: x + sec.x, y: y + sec.y&#125;; &#125; inline Complex operator-(const Complex sec) const &#123; return Complex&#123;x: x - sec.x, y: y - sec.y&#125;; &#125; inline Complex operator*(const Complex sec) const &#123; return Complex&#123;x: x * sec.x - y * sec.y, y: x * sec.y + y * sec.x&#125;; &#125;&#125;;Complex Zero = Complex&#123;x: 0, y: 0&#125;, One = Complex&#123;x: 1, y: 0&#125;;int swp[MAXN + 10];void EvaSwp(int n) &#123; int mxdeg = n &gt;&gt; 1; for (int i = 1; i &lt; n; ++i) &#123; swp[i] = (swp[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) ? mxdeg : 0); &#125;&#125;void Swp(int n, Complex *a) &#123; for (int i = 0; i &lt; n; ++i) &#123; if (swp[i] &gt; i) &#123; swap(a[i], a[swp[i]]); &#125; &#125;&#125;void FFT(int n, Complex *a, int getinv) &#123; Swp(n, a); for (int len = 2, halflen = 1; len &lt;= n; len &lt;&lt;= 1, halflen &lt;&lt;= 1) &#123; Complex wlen = Complex&#123;x: cos(twoPI / len), y: sin(twoPI / len)&#125;; for (int l = 0, r = len - 1; r &lt; n; l += len, r += len) &#123; Complex w = One; for (int i = l, j = l + halflen; j &lt;= r; ++i, ++j, w = w * wlen) &#123; Complex u = a[i], v = a[j] * w; a[i] = u + v; a[j] = u - v; &#125; &#125; &#125; if (getinv == -1) &#123; reverse(a + 1, a + n); for (int i = 0; i &lt; n; ++i) &#123; a[i].x /= n; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«é€Ÿå¹‚","slug":"TemLib/å¿«é€Ÿå¹‚","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¿«é€Ÿå¹‚/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"P1226 ã€æ¨¡æ¿ã€‘å¿«é€Ÿå¹‚||å–ä½™è¿ç®—12345678910111213typedef long long LL;const int MOD = 1e7 + 7;inline int power(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ((LL)ans * x) % MOD; &#125; x = ((LL)x * x) % MOD; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«é€Ÿæ’åº","slug":"TemLib/å¿«é€Ÿæ’åº","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/å¿«é€Ÿæ’åº/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 ã€æ¨¡æ¿ã€‘å¿«é€Ÿæ’åº12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];void _QuickSort_(int* a, int l, int r) &#123; int i = l, j = r, f = a[(l + r) / 2]; do &#123; while (a[i] &lt; f) &#123; i++; &#125; while (a[j] &gt; f) &#123; j--; &#125; if (i &lt;= j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125; while (i &lt;= j); if (l &lt; j) &#123; _QuickSort_(a, l, j); &#125; if (i &lt; r) &#123; _QuickSort_(a, i, r); &#125;&#125;void QuickSort(int* a, int l, int r) &#123; _QuickSort_(a, l, r - 1);&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; QuickSort(a, 0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«é€Ÿæ•°è®ºå˜æ¢(ntt)","slug":"TemLib/å¿«é€Ÿæ•°è®ºå˜æ¢(ntt)","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/å¿«é€Ÿæ•°è®ºå˜æ¢(ntt)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2(ntt)/","excerpt":"","text":"Luogu P3803 ã€æ¨¡æ¿ã€‘å¤šé¡¹å¼ä¹˜æ³•ï¼ˆFFTï¼‰ ä»£ç ä¸­çš„å˜é‡ n çš„æ„ä¹‰æ˜¯å¤šé¡¹å¼çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯åº¦æ•°åŠ ä¸€ï¼Œè€Œéåº¦æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738const int MOD = 998244353, G = 3;int swp[MAXN + 10];void EvaSwp(int n) &#123; int mxdeg = n &gt;&gt; 1; for (int i = 1; i &lt; n; ++i) &#123; swp[i] = (swp[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) ? mxdeg : 0); &#125;&#125;void Swp(int n, int *a) &#123; for (int i = 0; i &lt; n; ++i) &#123; if (swp[i] &gt; i) &#123; swap(a[i], a[swp[i]]); &#125; &#125;&#125;void NTT(int n, int *a, int getinv) &#123; Swp(n, a); for (int len = 2, halflen = 1; len &lt;= n; len &lt;&lt;= 1, halflen &lt;&lt;= 1) &#123; int glen = power(G, (MOD - 1) / len); for (int l = 0, r = len - 1; r &lt; n; l += len, r += len) &#123; int g = 1; for (int i = l, j = l + halflen; j &lt;= r; ++i, ++j, g = g * glen % MOD) &#123; int u = a[i], v = a[j] * g % MOD; a[i] = addmod(u + v); a[j] = redmod(u - v); &#125; &#125; &#125; if (getinv == -1) &#123; reverse(a + 1, a + n); int invn = inv(n); for (int i = 0; i &lt; n; ++i) &#123; a[i] = a[i] * invn % MOD; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"å¿«é€Ÿè«æ¯”ä¹Œæ–¯å˜æ¢(fmt) & å¿«é€Ÿæ²ƒå°”ä»€-é˜¿è¾¾ç›å˜æ¢(fwt)","slug":"TemLib/å¿«é€Ÿè«æ¯”ä¹Œæ–¯å˜æ¢(fmt) & å¿«é€Ÿæ²ƒå°”ä»€-é˜¿è¾¾ç›å˜æ¢(fwt)","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/å¿«é€Ÿè«æ¯”ä¹Œæ–¯å˜æ¢(fmt) & å¿«é€Ÿæ²ƒå°”ä»€-é˜¿è¾¾ç›å˜æ¢(fwt)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2(fmt)%20&%20%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80-%E9%98%BF%E8%BE%BE%E7%8E%9B%E5%8F%98%E6%8D%A2(fwt)/","excerpt":"","text":"Luogu P4717 ã€æ¨¡æ¿ã€‘å¿«é€Ÿè«æ¯”ä¹Œæ–¯/æ²ƒå°”ä»€å˜æ¢ (FMT/FWT) ä»£ç ä¸­çš„å˜é‡ n çš„æ„ä¹‰æ˜¯å¤šé¡¹å¼çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯åº¦æ•°åŠ ä¸€ï¼Œè€Œéåº¦æ•°ã€‚ 1234567891011121314151617181920212223242526272829303132int inv2 = inv(2);inline void Or(int &amp;x, int &amp;y) &#123; y = addmod(y + x);&#125;inline void OrInv(int &amp;x, int &amp;y) &#123; y = redmod(y - x);&#125;inline void And(int &amp;x, int &amp;y) &#123; x = addmod(x + y);&#125;inline void AndInv(int &amp;x, int &amp;y) &#123; x = redmod(x - y);&#125;inline void Xor(int &amp;x, int &amp;y) &#123; int u = x, v = y; x = addmod(u + v); y = redmod(u - v);&#125;inline void XorInv(int &amp;x, int &amp;y) &#123; int u = x, v = y; x = addmod(u + v) * inv2 % MOD; y = redmod(u - v) * inv2 % MOD;&#125;void FMTFWT(int n, int *a, void (*oper)(int &amp;, int &amp;)) &#123; for (int len = 2, halflen = 1; len &lt;= n; len &lt;&lt;= 1, halflen &lt;&lt;= 1) &#123; for (int l = 0, r = len - 1; r &lt; n; l += len, r += len) &#123; for (int i = l, j = l + halflen; j &lt;= r; ++i, ++j) &#123; oper(a[i], a[j]); &#125; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ‰‹å†™å“ˆå¸Œè¡¨","slug":"TemLib/æ‰‹å†™å“ˆå¸Œè¡¨","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ‰‹å†™å“ˆå¸Œè¡¨/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%89%8B%E5%86%99%E5%93%88%E5%B8%8C%E8%A1%A8/","excerpt":"","text":"1234567891011121314151617181920212223242526const int MAXhx = 100237;const int B1 = 1007;const int B2 = 10009;struct Hx &#123; vector&lt;pair&lt;Ele, int&gt;&gt; a[MAXhx + 10]; void Init() &#123; for (int i = 0; i &lt; MAXhx; ++i) &#123; a[i].clear(); a[i].shrink_to_fit(); &#125; &#125; inline int&amp; operator[](Ele v) &#123; int hxidx = (v.x * B1 % MAXhx + v.y * B2 % MAXhx) % MAXhx; int i, topi = a[hxidx].size(); for (i = 0; i &lt; topi; ++i) &#123; if (a[hxidx][i].first == v) &#123; break; &#125; &#125; if (i &lt; topi) return a[hxidx][i].second; else &#123; a[hxidx].push_back(make_pair(v, 0)); return a[hxidx][topi].second; &#125; &#125;&#125;;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å°è£…","slug":"å°è£…","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"æ‰©å±•æ¬§å‡ é‡Œå¾—å®šç†(exgcd)","slug":"TemLib/æ‰©å±•æ¬§å‡ é‡Œå¾—å®šç†(exgcd)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ‰©å±•æ¬§å‡ é‡Œå¾—å®šç†(exgcd)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86(exgcd)/","excerpt":"","text":"P1082 [NOIP2012 æé«˜ç»„] åŒä½™æ–¹ç¨‹P5656 ã€æ¨¡æ¿ã€‘äºŒå…ƒä¸€æ¬¡ä¸å®šæ–¹ç¨‹ (exgcd)123456789101112131415161718192021#include&lt;cstdio&gt;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int a, b, d, x, y;int main() &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); d = exgcd(a, b, x, y); x *= d; x = (x % b + b) % b; printf(&quot;%d\\n&quot;, x);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æŠ˜åŠæœç´¢","slug":"TemLib/æŠ˜åŠæœç´¢","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/æŠ˜åŠæœç´¢/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/","excerpt":"","text":"P4799 [CEOI2015 Day2]ä¸–ç•Œå†°çƒé”¦æ ‡èµ› 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 40;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;map&lt;int, int&gt; map1, map2;int n, midn, W, w[MAXn + 10];signed main() &#123; read(n, W); midn = n &gt;&gt; 1; for (int i = 1; i &lt;= n; ++i) &#123; read(w[i]); &#125; map1[0] = map2[0] = 1; for (int i = 1; i &lt;= midn; ++i) &#123; auto j = end(map1), bottomj = begin(map1); for (--j; ; --j) &#123; map1[(*j).first + w[i]] += map1[(*j).first]; if (j == bottomj) break; &#125; &#125; for (int i = midn + 1; i &lt;= n; ++i) &#123; auto j = end(map2), bottomj = begin(map2); for (--j; ; --j) &#123; map2[(*j).first + w[i]] += map2[(*j).first]; if (j == bottomj) break; &#125; &#125; int sum = 0, ans = 0; auto j = begin(map2), topj = end(map2); auto i = end(map1), bottomi = begin(map1); for (--i; ; --i) &#123; int topmapj = W - (*i).first; while (j != topj &amp;&amp; (*j).first &lt;= topmapj) &#123; sum += (*j).second; ++j; &#125; ans += (*i).second * sum; if (i == bottomi) break; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"æœç´¢","slug":"æœç´¢","permalink":"http://rsdbkhusky.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"æ’å¤´dp","slug":"TemLib/æ’å¤´dp","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/æ’å¤´dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%8F%92%E5%A4%B4dp/","excerpt":"","text":"Luogu P5056ã€æ¨¡æ¿ã€‘æ’å¤´dp å…¶å®æˆ‘è§‰å¾—å«æ’å¤´ dpï¼Œä¸å¦‚å«æ‹¼å›¾ dp æ›´å½¢è±¡ã€‚ å¯ä»¥å°†ä»£ç ä¸­æ³¨é‡Šèµ·æ¥çš„æœ‰ exit(1) çš„è¡Œå–æ¶ˆæ³¨é‡Šï¼Œå¦‚æœä»£ç æ²¡æœ‰æ¼æ´ï¼Œåˆ™ä¸ä¼šè§¦å‘ exit(1)ï¼Œåä¹‹åˆ™å¯èƒ½è§¦å‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 12;const int MAXm = 12;const int MAXcntsta = 5e4;const int MOD = 1009;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;vector&lt;pair&lt;int, int&gt;&gt; hx[2][MOD + 10];inline void Clear(int idx) &#123; for (int i = 0; i &lt; MOD; ++i) &#123; hx[idx][i].clear(); &#125;&#125;inline void Add(int idx, int k, int v) &#123; int hxk = k % MOD; for (auto i = begin(hx[idx][hxk]), topi = end(hx[idx][hxk]); i != topi; ++i) &#123; if ((*i).first == k) &#123; (*i).second += v; return; &#125; &#125; hx[idx][hxk].push_back(make_pair(k, v));&#125;inline int deg(int num, int deg) &#123; return (num &gt;&gt; (deg &lt;&lt; 1)) &amp; 3;&#125;inline int assdeg(int num, int deg, int val) &#123; return (num &amp; ~(3 &lt;&lt; (deg &lt;&lt; 1))) | (val &lt;&lt; (deg &lt;&lt; 1));&#125;int n, m, ans; char a[MAXn + 10][MAXm + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, a[i] + 1); &#125; int begini, beginj, endi, endj; bool ok = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (a[i][j] == &#x27;.&#x27;) &#123; begini = i, beginj = j; ok = 1; break; &#125; &#125; if (ok) break; &#125; ok = 0; for (int i = n; i; --i) &#123; for (int j = m; j; --j) &#123; if (a[i][j] == &#x27;.&#x27;) &#123; endi = i, endj = j; ok = 1; break; &#125; &#125; if (ok) break; &#125; for (int i = begini; i &lt;= n; ++i) &#123; for (int j = (i == begini) ? beginj : 1; j &lt;= m; ++j) &#123; int now = ((i - 1) * m + j) &amp; 1, last = now ^ 1; int x = j - 1, y = j; if (i == begini &amp;&amp; j == beginj) Add(last, 0, 1); Clear(now); for (int k = 0; k &lt; MOD; ++k) &#123; if (hx[last][k].empty()) continue; for (auto l = begin(hx[last][k]), topl = end(hx[last][k]); l != topl; ++l) &#123; int sta = (*l).first, val = (*l).second; if (!val) continue; int degx = deg(sta, x), degy = deg(sta, y); if (a[i][j] == &#x27;*&#x27;) &#123; if (degx == 0 &amp;&amp; degy == 0) Add(now, sta, val); &#125; else &#123; if (degx == 0 &amp;&amp; degy == 0) &#123; if (i != n &amp;&amp; j != m) Add(now, assdeg(assdeg(sta, x, 1), y, 2), val); &#125; else if (degx &amp;&amp; degy == 0) &#123; if (i != n) Add(now, sta, val); if (j != m) Add(now, assdeg(assdeg(sta, x, 0), y, degx), val); &#125; else if (degx == 0 &amp;&amp; degy) &#123; if (i != n) Add(now, assdeg(assdeg(sta, x, degy), y, 0), val); if (j != m) Add(now, sta, val); &#125; else if (degx == 1 &amp;&amp; degy == 1) &#123; int tmpsta = sta; tmpsta = assdeg(assdeg(tmpsta, x, 0), y, 0); for (int o = y + 1, cnt = 1; ; ++o) &#123; int dego = deg(tmpsta, o); if (dego == 1) ++cnt; else if (dego == 2) --cnt; if (!cnt) &#123; tmpsta = assdeg(tmpsta, o, 1); break; &#125; &#125; Add(now, tmpsta, val); &#125; else if (degx == 2 &amp;&amp; degy == 2) &#123; // if (i == n) exit(1); int tmpsta = sta; tmpsta = assdeg(assdeg(tmpsta, x, 0), y, 0); for (int o = x - 1, cnt = 1; ; --o) &#123; int dego = deg(tmpsta, o); if (dego == 1) --cnt; else if (dego == 2) ++cnt; if (!cnt) &#123; tmpsta = assdeg(tmpsta, o, 2); break; &#125; &#125; Add(now, tmpsta, val); &#125; else if (degx == 2 &amp;&amp; degy == 1) &#123; // if (i == n) exit(1); Add(now, assdeg(assdeg(sta, x, 0), y, 0), val); &#125; else if (i == endi &amp;&amp; j == endj) &#123; if (!assdeg(assdeg(sta, x, 0), y, 0)) ans += val; &#125; &#125; &#125; &#125; if (j == m) &#123; for (int k = 0; k &lt; MOD; ++k) &#123; if (hx[now][k].empty()) continue; for (auto l = begin(hx[now][k]), topl = end(hx[now][k]); l != topl; ++l) &#123; // if (deg((*l).first, m)) exit(1); (*l).first &lt;&lt;= 2; &#125; &#125; &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ•´ä½“äºŒåˆ†è§£é™æ€åŒºé—´ç¬¬kå°","slug":"TemLib/æ•´ä½“äºŒåˆ†è§£é™æ€åŒºé—´ç¬¬kå°","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ•´ä½“äºŒåˆ†è§£é™æ€åŒºé—´ç¬¬kå°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E8%A7%A3%E9%9D%99%E6%80%81%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š å‡½æ•° totdiv å†…çš„å˜é‡ cntelel å’Œ cnteler è¦ç”¨å±€éƒ¨å˜é‡ï¼Œä¸èƒ½ç”¨å…¨å±€å˜é‡ã€‚ ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int cntquery;struct Ele &#123; int opt; int p, v, w; int l, r, rk, idx;&#125;;int cntele; Ele ele[MAXcntele + 10];Ele elel[MAXcntele + 10];Ele eler[MAXcntele + 10];int ans[MAXm + 10];void totdiv(int l, int r, int L, int R) &#123; if (l &gt; r) return; if (L == R) &#123; for (int i = l; i &lt;= r; ++i) &#123; if (ele[i].opt == 2) &#123; ans[ele[i].idx] = L; &#125; &#125; return; &#125; int M = (L + R) &gt;&gt; 1; int cntelel = 0, cnteler = 0; for (int i = l; i &lt;= r; ++i) &#123; if (ele[i].opt == 1) &#123; if (ele[i].v &lt;= M) &#123; modify(ele[i].p, ele[i].w, n); elel[++cntelel] = ele[i]; &#125; else &#123; eler[++cnteler] = ele[i]; &#125; &#125; else &#123; int tmp = querysec(ele[i].l, ele[i].r); if (ele[i].rk &lt;= tmp) &#123; elel[++cntelel] = ele[i]; &#125; else &#123; eler[++cnteler] = ele[i]; eler[cnteler].rk -= tmp; &#125; &#125; &#125; copy(elel + 1, elel + 1 + cntelel, ele + l); copy(eler + 1, eler + 1 + cnteler, ele + l + cntelel); totdiv(l, l + cntelel - 1, L, M); totdiv(l + cntelel, r, M + 1, R);&#125; Luogu P2617 Dynamic Rankings ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = 1e5;const int MAXcntele = MAXn * 2 + MAXm * 2;const int MAXa = 1e9;const int NINF = 0xc0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int t[MAXn + 10];inline int lowbit(int x) &#123; return x &amp; -x;&#125;inline void modify(int p, int v, int n) &#123; while (p &lt;= n) &#123; t[p] += v; p += lowbit(p); &#125;&#125;inline int querysum(int p) &#123; if (p == 0) return 0; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;inline int querysec(int l, int r) &#123; return querysum(r) - querysum(l - 1);&#125;int n, m;int a[MAXn + 10];struct MQ &#123; int opt, x, y, z;&#125;;MQ mq[MAXm + 10];int cntquery;struct Ele &#123; int opt; int p, v, w; int l, r, rk, idx;&#125;;int cntele; Ele ele[MAXcntele + 10];Ele elel[MAXcntele + 10];Ele eler[MAXcntele + 10];int ans[MAXm + 10];void totdiv(int l, int r, int L, int R) &#123; if (l &gt; r) return; if (L == R) &#123; for (int i = l; i &lt;= r; ++i) &#123; if (ele[i].opt == 2) &#123; ans[ele[i].idx] = L; &#125; &#125; return; &#125; int M = (L + R) &gt;&gt; 1; int cntelel = 0, cnteler = 0; for (int i = l; i &lt;= r; ++i) &#123; if (ele[i].opt == 1) &#123; if (ele[i].v &lt;= M) &#123; modify(ele[i].p, ele[i].w, n); elel[++cntelel] = ele[i]; &#125; else &#123; eler[++cnteler] = ele[i]; &#125; &#125; else &#123; int tmp = querysec(ele[i].l, ele[i].r); if (ele[i].rk &lt;= tmp) &#123; elel[++cntelel] = ele[i]; &#125; else &#123; eler[++cnteler] = ele[i]; eler[cnteler].rk -= tmp; &#125; &#125; &#125; copy(elel + 1, elel + 1 + cntelel, ele + l); copy(eler + 1, eler + 1 + cnteler, ele + l + cntelel); totdiv(l, l + cntelel - 1, L, M); totdiv(l + cntelel, r, M + 1, R);&#125;signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); ele[++cntele] = Ele&#123;opt: 1, p: i, v: a[i], w: 1, l: NINF, r: NINF, rk: NINF, idx: NINF&#125;; &#125; char opt[10]; for (int i = 1, x, y, z; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, opt); if (*opt == &#x27;Q&#x27;) &#123; read(x, y, z); ele[++cntele] = Ele&#123;opt: 2, p: NINF, v: NINF, w: NINF, l: x, r: y, rk: z, idx: ++cntquery&#125;; &#125; else &#123; read(x, y); ele[++cntele] = Ele&#123;opt: 1, p: x, v: a[x], w: -1, l: NINF, r: NINF, rk: NINF, idx: NINF&#125;; a[x] = y; ele[++cntele] = Ele&#123;opt: 1, p: x, v: a[x], w: 1, l: NINF, r: NINF, rk: NINF, idx: NINF&#125;; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; ele[++cntele] = Ele&#123;opt: 1, p: i, v: a[i], w: -1, l: NINF, r: NINF, rk: NINF, idx: NINF&#125;; &#125; totdiv(1, cntele, 0, MAXa); for (int i = 1; i &lt;= cntquery; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ–œç‡ä¼˜åŒ–dp & Luogu P3195 [HNOI2008]ç©å…·è£…ç®±","slug":"TemLib/æ–œç‡ä¼˜åŒ–dp & Luogu P3195 [HNOI2008]ç©å…·è£…ç®±","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ–œç‡ä¼˜åŒ–dp & Luogu P3195 [HNOI2008]ç©å…·è£…ç®±/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P3195%20[HNOI2008]%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1/","excerpt":"","text":"é¢˜ç›®ä¼ é€é—¨ æœ¬é¢˜çŠ¶è½¬æ–¹ç¨‹ï¼š \\begin{aligned} d_i&=\\min_{j","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"æ—‹è½¬å¡å£³ & æœ€å°çŸ©å½¢è¦†ç›–","slug":"TemLib/æ—‹è½¬å¡å£³ & æœ€å°çŸ©å½¢è¦†ç›–","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/æ—‹è½¬å¡å£³ & æœ€å°çŸ©å½¢è¦†ç›–/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%20&%20%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/","excerpt":"","text":"æ—‹è½¬å¡å£³Luogu P1452 USACO03FALL Beauty Contest G /ã€æ¨¡æ¿ã€‘æ—‹è½¬å¡å£³ æ³¨æ„ stk æ•°ç»„è¦å¼€äºŒå€ã€‚ 123456789101112131415// ...void EvaConv(Point p[], int n) &#123;/* ... */&#125;double Rotate(Point p[], int n) &#123; EvaConv(p, n); if (top &lt;= 2) &#123; return dist(p[stk[1]], p[stk[top]]); &#125; double ans = 0; copy(stk + 1, stk + top + 1, stk + top + 1); for (int i = 1, j = 3; i &lt;= top; ++i) &#123; while (j &lt; top * 2 &amp;&amp; area(p[stk[i]], p[stk[i + 1]], p[stk[j]]) &lt;= area(p[stk[i]], p[stk[i + 1]], p[stk[j + 1]])) ++j; ans = max(ans, max(dist(p[stk[i]], p[stk[j]]), dist(p[stk[i + 1]], p[stk[j]]))); &#125; return ans;&#125; æœ€å°çŸ©å½¢è¦†ç›–Luogu P3187 HNOI2007 æœ€å°çŸ©å½¢è¦†ç›– 12345678910111213141516171819202122232425// ...void EvaConv(Point p[], int n) &#123;/* ... */&#125;void Rotate(Point p[], int n) &#123; EvaConv(p, n); if (top &lt;= 2) &#123; puts(&quot;Error!&quot;); exit(1); &#125; copy(stk + 1, stk + top + 1, stk + top + 1); for (int i = 1, j = 3, k = 2, l, topidx = top * 2; i &lt;= top; ++i) &#123; while (j &lt; topidx &amp;&amp; area(p[stk[i]], p[stk[i + 1]], p[stk[j]]) &lt;= area(p[stk[i]], p[stk[i + 1]], p[stk[j + 1]])) ++j; while (k &lt; topidx &amp;&amp; proj(p[stk[i]], p[stk[i + 1]], p[stk[k]]) &lt;= proj(p[stk[i]], p[stk[i + 1]], p[stk[k + 1]])) ++k; if (i == 1) l = j; while (l &lt; topidx &amp;&amp; proj(p[stk[i]], p[stk[i + 1]], p[stk[l]]) &gt;= proj(p[stk[i]], p[stk[i + 1]], p[stk[l + 1]])) ++l; double h = poi_dist_str(p[stk[i]], p[stk[i + 1]], p[stk[j]]); Point kproji = poi_proj_str(p[stk[i]], p[stk[i + 1]], p[stk[k]]), lproji = poi_proj_str(p[stk[i]], p[stk[i + 1]], p[stk[l]]); double w = length(kproji - lproji); if (ans &gt; h * w) &#123; Point jprojk = poi_proj_str(kproji + rotate(lproji - kproji, -PI / 2), kproji, p[stk[j]]), jprojl = poi_proj_str(lproji + rotate(kproji - lproji, PI / 2), lproji, p[stk[j]]); ans = h * w; ansp[0] = lproji; ansp[1] = kproji; ansp[2] = jprojk; ansp[3] = jprojl; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"æ— æ—‹Treap","slug":"TemLib/æ— æ—‹Treap","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/æ— æ—‹Treap/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%97%A0%E6%97%8BTreap/","excerpt":"","text":"æ— æ—‹Treapï¼Œåˆå« FHQ-Treapã€‚ å’Œ Splay ä¸€æ ·ï¼Œæ— æ—‹Treap ä¹Ÿæ˜¯ç”¨ä¸­åºéå†ç»´æŠ¤åºåˆ—çš„ï¼Œè¦ç»´æŠ¤çš„è¿™ä¸ªåºåˆ—æ˜¯æœ‰æŸç§é¡ºåºçš„ï¼Œå¯¹äºä¸åŒçš„é¢˜ç›®ï¼Œè¿™ä¸ªã€Œé¡ºåºã€çš„å®šä¹‰æ˜¯ä¸åŒçš„ã€‚æ¯”å¦‚ï¼Œå¯¹äºæ™®é€šå¹³è¡¡æ ‘ï¼Œã€Œé¡ºåºã€æ˜¯æŒ‡æŒ‰æƒå€¼é€’å¢çš„é¡ºåºï¼›å¯¹äºæ–‡è‰ºå¹³è¡¡æ ‘ï¼Œã€Œé¡ºåºã€æ˜¯æŒ‡æŒ‰åœ¨æ•°ç»„ä¸­ä¸‹æ ‡é€’å¢çš„é¡ºåºï¼Œæˆ‘ä»¬ç®¡æŒ‰ XXX é€’å¢çš„é¡ºåºçš„è¿™ä¸ª XXX å«é¡ºåºå€¼ã€‚ æ— æ—‹Treap å³æ˜¯é¡ºåºå€¼æ»¡è¶³ BST çš„æ€§è´¨ï¼Œæ¯ä¸ªç‚¹çš„éšæœºå€¼ï¼ˆè¿™ä¸ªéšæœºå€¼ä¼šåœ¨æ¯ä¸ªç‚¹è¢«åˆ›å»ºçš„æ—¶å€™éšæœºç”Ÿæˆï¼Œä¸”æ°¸è¿œä¸ä¼šæ”¹å˜ï¼‰æ»¡è¶³å¤§æ ¹å †çš„æ€§è´¨çš„äºŒå‰æŸ¥æ‰¾æ ‘ã€‚ æ ¸å¿ƒæ“ä½œæœ‰ä¸¤ä¸ªï¼š$\\text{Split}(id, v)$ å’Œ $\\text{Merge}(id_1,id_2)$ã€‚ ${lrt,rrt}\\text{Split}(id, v)$ï¼šå°† $\\text{subtree}{id}$ åˆ†æˆä¸¤æ£µæ ‘ï¼Œä¸€é¢—æ ¹ä¸º $lrt$ï¼Œæ»¡è¶³ $\\forall i\\in\\text{subtree}{lrt},vali\\le v$ï¼ˆ$val_i$ ä¸ºç‚¹ $i$ çš„é¡ºåºå€¼ï¼‰ï¼›å¦ä¸€é¢—æ ¹ä¸º $rrt$ï¼Œæ»¡è¶³ $\\forall i\\in\\text{subtree}{rrt},val_i&gt;v$ã€‚ ${rt}\\text{Merge}(id1,id_2)$ï¼šä¿è¯å¯¹äº $\\forall i\\in\\text{subtree}{id1},j\\in\\text{subtree}{id2}$ æœ‰ $val_i&lt;val_j$ï¼Œåˆå¹¶ $\\text{subtree}{id1}$ å’Œ $\\text{subtree}{id_2}$ï¼Œæœ€åæ ¹ä¸º $rt$ã€‚ Luogu P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109mt19937 rd(time(0));int root;int cntnd;int son[MAXn + 10][2];int val[MAXn + 10], pval[MAXn + 10], cnt[MAXn + 10], siz[MAXn + 10];inline void pushup(int id) &#123; siz[id] = siz[son[id][0]] + siz[son[id][1]] + cnt[id];&#125;inline void initnode(int id, int v, int ct) &#123; val[id] = v; pval[id] = rd(); cnt[id] = ct; siz[id] = ct;&#125;pair&lt;int, int&gt; Split(int id, int v) &#123; if (id == 0) return make_pair(0, 0); int lrt, rrt; if (val[id] &lt;= v) &#123; tie(lrt, rrt) = Split(son[id][1], v); son[id][1] = lrt; pushup(id); return make_pair(id, rrt); &#125; else &#123; tie(lrt, rrt) = Split(son[id][0], v); son[id][0] = rrt; pushup(id); return make_pair(lrt, id); &#125;&#125;int Merge(int id1, int id2) &#123; if (id1 == 0 || id2 == 0) return id1 + id2; if (pval[id1] &gt;= pval[id2]) &#123; son[id1][1] = Merge(son[id1][1], id2); pushup(id1); return id1; &#125; else &#123; son[id2][0] = Merge(id1, son[id2][0]); pushup(id2); return id2; &#125;&#125;void Insert(int v) &#123; int lrt, mrt, rrt; tie(lrt, rrt) = Split(root, v - 1); tie(mrt, rrt) = Split(rrt, v); if (mrt) &#123; ++cnt[mrt]; pushup(mrt); &#125; else &#123; mrt = ++cntnd; initnode(mrt, v, 1); &#125; root = Merge(Merge(lrt, mrt), rrt);&#125;void Delete(int v) &#123; int lrt, mrt, rrt; tie(lrt, rrt) = Split(root, v - 1); tie(mrt, rrt) = Split(rrt, v); if (mrt) &#123; --cnt[mrt]; pushup(mrt); if (cnt[mrt]) lrt = Merge(lrt, mrt); &#125; root = Merge(lrt, rrt);&#125;int ValtoRank(int v) &#123; int lrt, rrt; tie(lrt, rrt) = Split(root, v - 1); int ans = siz[lrt] + 1; root = Merge(lrt, rrt); return ans;&#125;int RanktoId(int rk) &#123; int id = root; while (true) &#123; if (rk &lt;= siz[son[id][0]]) &#123; id = son[id][0]; &#125; else if (rk &lt;= siz[son[id][0]] + cnt[id]) &#123; return id; &#125; else &#123; rk -= siz[son[id][0]] + cnt[id]; id = son[id][1]; &#125; &#125; return id;&#125;int PreId(int v) &#123; int lrt, rrt; tie(lrt, rrt) = Split(root, v - 1); int lrtmx = lrt; while (true) &#123; if (son[lrtmx][1]) lrtmx = son[lrtmx][1]; else break; &#125; root = Merge(lrt, rrt); return lrtmx;&#125;int NexId(int v) &#123; int lrt, rrt; tie(lrt, rrt) = Split(root, v); int rrtmn = rrt; while (true) &#123; if (son[rrtmn][0]) rrtmn = son[rrtmn][0]; else break; &#125; root = Merge(lrt, rrt); return rrtmn;&#125; Luogu P3391 ã€æ¨¡æ¿ã€‘æ–‡è‰ºå¹³è¡¡æ ‘ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283mt19937 rd(time(0));int root;int cntnd;int son[MAXn + 10][2];int val[MAXn + 10], pval[MAXn + 10], siz[MAXn + 10];int lzrev[MAXn + 10];inline void putrev(int id) &#123; swap(son[id][0], son[id][1]); lzrev[id] ^= 1;&#125;inline void pushdown(int id) &#123; if (lzrev[id]) &#123; putrev(son[id][0]); putrev(son[id][1]); lzrev[id] = 0; &#125;&#125;inline void pushup(int id) &#123; siz[id] = siz[son[id][0]] + siz[son[id][1]] + 1;&#125;inline void initnode(int id, int v) &#123; val[id] = v; pval[id] = rd(); siz[id] = 1;&#125;pair&lt;int, int&gt; Split(int id, int p) &#123; if (p == 0) return make_pair(0, id); if (id == 0) return make_pair(0, 0); pushdown(id); int lrt, rrt; if (p &lt;= siz[son[id][0]]) &#123; tie(lrt, rrt) = Split(son[id][0], p); son[id][0] = rrt; pushup(id); return make_pair(lrt, id); &#125; else if (p &lt;= siz[son[id][0]] + 1) &#123; lrt = id; rrt = son[id][1]; son[id][1] = 0; pushup(id); return make_pair(lrt, rrt); &#125; else &#123; tie(lrt, rrt) = Split(son[id][1], p - (siz[son[id][0]] + 1)); son[id][1] = lrt; pushup(id); return make_pair(id, rrt); &#125;&#125;int Merge(int id1, int id2) &#123; if (id1 == 0 || id2 == 0) return id1 + id2; pushdown(id1); pushdown(id2); if (pval[id1] &gt;= pval[id2]) &#123; son[id1][1] = Merge(son[id1][1], id2); pushup(id1); return id1; &#125; else &#123; son[id2][0] = Merge(id1, son[id2][0]); pushup(id2); return id2; &#125;&#125;void Build(int n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; initnode(++cntnd, i); root = Merge(root, cntnd); &#125;&#125;void Traversal(int id) &#123; if (id == 0) return; pushdown(id); Traversal(son[id][0]); printf(&quot;%d &quot;, val[id]); Traversal(son[id][1]);&#125;void Reverse(int l, int r) &#123; int lrt, mrt, rrt; tie(lrt, rrt) = Split(root, l - 1); tie(mrt, rrt) = Split(rrt, r - (l - 1)); putrev(mrt); root = Merge(Merge(lrt, mrt), rrt);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ›¿ç½ªç¾Šæ ‘","slug":"TemLib/æ›¿ç½ªç¾Šæ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ›¿ç½ªç¾Šæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š å‡½æ•° precid å’Œ nexid ä¸èƒ½ä½¿ç”¨ splay çš„ï¼Œå› ä¸ºæ›¿ç½ªç¾Šæ ‘æœ‰ç©ºç‚¹ã€‚ Luogu P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;double thr = 0.75;int cntnd, root, ls[MAXn + 10], rs[MAXn + 10];int val[MAXn + 10], cnt[MAXn + 10], sizcnt[MAXn + 10], siznd[MAXn + 10], sizdel[MAXn + 10];inline void pushup(int id) &#123; sizcnt[id] = cnt[id] + sizcnt[ls[id]] + sizcnt[rs[id]]; siznd[id] = 1 + siznd[ls[id]] + siznd[rs[id]]; sizdel[id] = (cnt[id] == 0) + sizdel[ls[id]] + sizdel[rs[id]];&#125;inline int needrb(int id) &#123; return max(siznd[ls[id]], siznd[rs[id]]) &gt;= thr * siznd[id] || sizdel[id] &gt;= thr * siznd[id];&#125;int cntino, ino[MAXn + 10];void traversal(int id) &#123; if (id == 0) return; traversal(ls[id]); if (cnt[id]) ino[++cntino] = id; traversal(rs[id]);&#125;int build(int le, int ri) &#123; if (le &gt; ri) return 0; int mid = (le + ri) &gt;&gt; 1, id = ino[mid]; ls[id] = build(le, mid - 1); rs[id] = build(mid + 1, ri); pushup(id); return id;&#125;int rebuild(int id) &#123; cntino = 0; traversal(id); return build(1, cntino);&#125;int cntpa, pa[MAXn + 10];int find(int v) &#123; cntpa = 0; int id = root; while (id) &#123; pa[++cntpa] = id; if (v == val[id]) break; else if (v &lt; val[id]) id = ls[id]; else id = rs[id]; &#125; if (id == 0) pa[++cntpa] = id; return id;&#125;void pushuppa() &#123; for (int i = cntpa; i; --i) &#123; pushup(pa[i]); &#125;&#125;void rebuildpa() &#123; for (int i = 1; i &lt;= cntpa; ++i) &#123; if (needrb(pa[i])) &#123; if (i == 1) root = rebuild(pa[i]); else if (pa[i] == ls[pa[i - 1]]) ls[pa[i - 1]] = rebuild(pa[i]); else rs[pa[i - 1]] = rebuild(pa[i]); break; &#125; &#125;&#125;void insert(int v) &#123; int id = find(v); if (id == 0) &#123; pa[cntpa] = id = ++cntnd; val[id] = v; if (pa[cntpa - 1] == 0) root = id; else if (v &lt; val[pa[cntpa - 1]]) ls[pa[cntpa - 1]] = id; else rs[pa[cntpa - 1]] = id; &#125; ++cnt[id]; pushuppa(); rebuildpa();&#125;void delet(int v) &#123; int id = find(v); if (cnt[id]) &#123; --cnt[id]; pushuppa(); rebuildpa(); &#125;&#125;int valtorank(int v) &#123; int ans = 1, id = root; while (id) &#123; if (v &lt; val[id]) &#123; id = ls[id]; &#125; else if (v == val[id]) &#123; ans += sizcnt[ls[id]]; break; &#125; else &#123; ans += sizcnt[ls[id]] + cnt[id]; id = rs[id]; &#125; &#125; return ans;&#125;int ranktoid(int rk) &#123; int id = root; while (true) &#123; if (rk &lt;= sizcnt[ls[id]]) &#123; id = ls[id]; &#125; else if (rk &lt;= sizcnt[ls[id]] + cnt[id]) &#123; break; &#125; else &#123; rk -= sizcnt[ls[id]] + cnt[id]; id = rs[id]; &#125; &#125; return id;&#125;int precid(int v) &#123; return ranktoid(valtorank(v) - 1);&#125;int nexid(int v) &#123; return ranktoid(valtorank(v + 1));&#125;int n;signed main() &#123; read(n); for (int i = 1, opt, x; i &lt;= n; ++i) &#123; read(opt, x); if (opt == 1) &#123; insert(x); &#125; else if (opt == 2) &#123; delet(x); &#125; else if (opt == 3) &#123; printf(&quot;%d\\n&quot;, valtorank(x)); &#125; else if (opt == 4) &#123; printf(&quot;%d\\n&quot;, val[ranktoid(x)]); &#125; else if (opt == 5) &#123; printf(&quot;%d\\n&quot;, val[precid(x)]); &#125; else &#123; printf(&quot;%d\\n&quot;, val[nexid(x)]); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æœ€å¤§æµ","slug":"TemLib/æœ€å¤§æµ","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æœ€å¤§æµ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š å˜é‡ cntnex åˆå€¼è¦è®¾ä¸ºå¥‡æ•°ã€‚ Ek ç®—æ³•ä»£ç ï¼› 12345678910111213141516171819202122232425262728293031323334int l, r, que[MAXn + 10];bool vis[MAXn + 10]; int prec[MAXn + 10], lim[MAXn + 10];bool bfs(int s, int t) &#123; l = 1, r = 0; memset(vis, 0, sizeof(vis)); que[++r] = s; vis[s] = 1; prec[s] = 0; lim[s] = INF; while (l &lt;= r) &#123; int cur = que[l++]; for (int i = head[cur]; i; i = nex[i]) &#123; if (cap[i] == 0 || vis[to[i]]) continue; que[++r] = to[i]; vis[to[i]] = 1; prec[to[i]] = i; lim[to[i]] = min(lim[cur], cap[i]); if (to[i] == t) return 1; &#125; &#125; return 0;&#125;void ek(int s, int t, int &amp;ansf) &#123; ansf = 0; while (bfs(s, t)) &#123; ansf += lim[t]; int cur = t; while (cur != s) &#123; cap[prec[cur]] -= lim[t]; cap[prec[cur] ^ 1] += lim[t]; cur = to[prec[cur] ^ 1]; &#125; &#125;&#125; Dinic ç®—æ³•ä»£ç ï¼› 123456789101112131415161718192021222324252627282930313233343536373839int arc[MAXn + 10], lay[MAXn + 10];int l, r, que[MAXn + 10];bool bfs(int s, int t) &#123; l = 1, r = 0; memset(lay, -1, sizeof(lay)); arc[s] = head[s]; lay[s] = 0; que[++r] = s; while (l &lt;= r) &#123; int cur = que[l++]; for (int i = head[cur]; i; i = nex[i]) &#123; if (cap[i] == 0 || lay[to[i]] != -1) continue; arc[to[i]] = head[to[i]]; lay[to[i]] = lay[cur] + 1; if (to[i] == t) return 1; que[++r] = to[i]; &#125; &#125; return 0;&#125;int dfs(int cur, int t, int lim) &#123; if (cur == t) return lim; int ans = 0; for (int i = arc[cur]; i &amp;&amp; ans &lt; lim; i = nex[i]) &#123; arc[cur] = i; if (cap[i] == 0 || lay[to[i]] != lay[cur] + 1) continue; int f = dfs(to[i], t, min(lim - ans, cap[i])); if (f == 0) lay[to[i]] = -1; else &#123; ans += f; cap[i] -= f; cap[i ^ 1] += f; &#125; &#125; return ans;&#125;void dinic(int s, int t, int &amp;ansf) &#123; ansf = 0; while (bfs(s, t)) ansf += dfs(s, t, INF);&#125; é¢˜ç›®Luogu P3376 ã€æ¨¡æ¿ã€‘ç½‘ç»œæœ€å¤§æµ ä»£ç ï¼ˆä»¥ Dinic ä¸ºä¾‹ï¼‰ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e2;const int MAXm = 5e3;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex = 1, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], cap[MAXm * 2 + 10];inline void connect(int u, int v, int c) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; cap[cntnex] = c;&#125;int arc[MAXn + 10], lay[MAXn + 10];int l, r, que[MAXn + 10];bool bfs(int s, int t) &#123; l = 1, r = 0; memset(lay, -1, sizeof(lay)); arc[s] = head[s]; lay[s] = 0; que[++r] = s; while (l &lt;= r) &#123; int cur = que[l++]; for (int i = head[cur]; i; i = nex[i]) &#123; if (cap[i] == 0 || lay[to[i]] != -1) continue; arc[to[i]] = head[to[i]]; lay[to[i]] = lay[cur] + 1; if (to[i] == t) return 1; que[++r] = to[i]; &#125; &#125; return 0;&#125;int dfs(int cur, int t, int lim) &#123; if (cur == t) return lim; int ans = 0; for (int i = arc[cur]; i &amp;&amp; ans &lt; lim; i = nex[i]) &#123; arc[cur] = i; if (cap[i] == 0 || lay[to[i]] != lay[cur] + 1) continue; int f = dfs(to[i], t, min(lim - ans, cap[i])); if (f == 0) lay[to[i]] = -1; else &#123; ans += f; cap[i] -= f; cap[i ^ 1] += f; &#125; &#125; return ans;&#125;void dinic(int s, int t, int &amp;ansf) &#123; ansf = 0; while (bfs(s, t)) ansf += dfs(s, t, INF);&#125;int n, m, s, t;signed main() &#123; read(n, m, s, t); for (int i = 1, u, v, c; i &lt;= m; ++i) &#123; read(u, v, c); connect(u, v, c); connect(v, u, 0); &#125; int ansf; dinic(s, t, ansf); printf(&quot;%lld\\n&quot;, ansf); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æœ€å°æ ‘å½¢å›¾","slug":"TemLib/æœ€å°æ ‘å½¢å›¾","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æœ€å°æ ‘å½¢å›¾/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/","excerpt":"","text":"P4716 ã€æ¨¡æ¿ã€‘æœ€å°æ ‘å½¢å›¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e2;const int MAXm = 1e4;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, eg[MAXn + 10][MAXn + 10], tmpeg[MAXn + 10][MAXn + 10];int pre[MAXn + 10];bool vis[MAXn + 10];int CheckCon(int cur) &#123; vis[cur] = 1; int ans = 1; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (eg[cur][i] == INF || vis[i]) continue; ans += CheckCon(i); &#125; return ans;&#125;int cntdfs, dfs[MAXn + 10], low[MAXn + 10];int cntscc, inscc[MAXn + 10];int top, stk[MAXn + 10]; bool instk[MAXn + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; if (pre[cur]) &#123; if (!dfs[pre[cur]]) &#123; Tarjan(pre[cur]); low[cur] = min(low[cur], low[pre[cur]]); &#125; else if (instk[pre[cur]]) &#123; low[cur] = min(low[cur], dfs[pre[cur]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; inscc[x] = cntscc; &#125; while (x != cur); &#125;&#125;int n, m, root, ans;signed main() &#123; read(n, m, root); cntnd = n; memset(eg, 0x3f, sizeof(eg)); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); if (u == v) continue; eg[u][v] = min(eg[u][v], w); &#125; if (CheckCon(root) != cntnd) &#123; puts(&quot;-1&quot;); return 0; &#125; while (true) &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; pre[i] = i; if (i == root) continue; for (int j = 1; j &lt;= cntnd; ++j) &#123; if (eg[j][i] &lt; eg[pre[i]][i]) &#123; pre[i] = j; &#125; &#125; &#125; memset(dfs, 0, sizeof(dfs)); cntdfs = cntscc = 0; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (!dfs[i]) Tarjan(i); &#125; if (cntscc == cntnd) &#123; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; ans += eg[pre[i]][i]; &#125; break; &#125; for (int i = 1; i &lt;= cntnd; ++i) &#123; if (i == root) continue; if (inscc[pre[i]] == inscc[i]) ans += eg[pre[i]][i]; &#125; memset(tmpeg, 0x3f, sizeof(tmpeg)); for (int i = 1, x = inscc[i]; i &lt;= cntnd; ++i, x = inscc[i]) &#123; for (int j = 1, y = inscc[j]; j &lt;= cntnd; ++j, y = inscc[j]) &#123; if (eg[i][j] == INF || eg[pre[j]][j] == INF || x == y) continue; if (inscc[pre[j]] != y) &#123; tmpeg[x][y] = min(tmpeg[x][y], eg[i][j]); &#125; else &#123; tmpeg[x][y] = min(tmpeg[x][y], eg[i][j] - eg[pre[j]][j]); &#125; &#125; &#125; memcpy(eg, tmpeg, sizeof(eg)); cntnd = cntscc; root = inscc[root]; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æœ€å°ç”Ÿæˆæ ‘","slug":"TemLib/æœ€å°ç”Ÿæˆæ ‘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœ€å°ç”Ÿæˆæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P3366 ã€æ¨¡æ¿ã€‘æœ€å°ç”Ÿæˆæ ‘Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e3;const int MAXm = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); &#125; &#125; return ans;&#125;int ans;signed main() &#123; read(n), read(m); for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); edge[i] = Edge(u, v, w); &#125; ans = Kruskal(); for (re int i = 1; i &lt; n; ++i) &#123; if (!SameAnc(i, i + 1)) &#123; printf(&quot;orz\\n&quot;); return 0; &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æœ€å°è´¹ç”¨æœ€å¤§æµ","slug":"TemLib/æœ€å°è´¹ç”¨æœ€å¤§æµ","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æœ€å°è´¹ç”¨æœ€å¤§æµ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"","text":"1. æ— è´Ÿç¯æœ€å°è´¹ç”¨æœ€å¤§æµP3381 ã€æ¨¡æ¿ã€‘æœ€å°è´¹ç”¨æœ€å¤§æµ 1234567891011121314151617181920212223242526272829303132333435int inque[MAXnd + 10], dis[MAXnd + 10], lim[MAXnd + 10], pre[MAXnd + 10];queue&lt;int&gt; que;void Spfa(int s) &#123; memset(inque, 0, sizeof(inque)); memset(dis, 0x3f, sizeof(dis)); memset(lim, 0x3f, sizeof(lim)); memset(pre, 0, sizeof(pre)); dis[s] = 0; que.push(s); inque[s] = 1; while (!que.empty()) &#123; int cur = que.front(); que.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (!cap[i]) continue; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; lim[to[i]] = min(lim[cur], cap[i]); pre[to[i]] = i; if (!inque[to[i]]) &#123; que.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;void Ek(int s, int t, int &amp;ansf, int &amp;anscos) &#123; ansf = 0, anscos = 0; while (Spfa(s), dis[t] != INF) &#123; ansf += lim[t]; anscos += lim[t] * dis[t]; for (int eg = pre[t]; eg; eg = pre[to[eg ^ 1]]) &#123; cap[eg] -= lim[t]; cap[eg ^ 1] += lim[t]; &#125; &#125;&#125; 2. æœ‰è´Ÿç¯æœ€å°è´¹ç”¨æœ€å¤§æµP7173 ã€æ¨¡æ¿ã€‘æœ‰è´Ÿåœˆçš„è´¹ç”¨æµ 123456789101112131415161718192021222324252627282930313233int n, m, s1, t1, s2, t2, ans1, ans2;int startf[MAXnd + 10];int ansf, anscos;signed main() &#123; cntnex = 1; read(n, m, s1, t1); s2 = n + 1, t2 = n + 2; for (int i = 1, u, v, c, w; i &lt;= m; ++i) &#123; read(u, v, c, w); if (w &gt;= 0) &#123; Insert(u, v, c, w); Insert(v, u, 0, -w); &#125; else if (w &lt; 0) &#123; startf[u] -= c, startf[v] += c; ans2 += w * c; Insert(u, v, 0, w); Insert(v, u, c, -w); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (startf[i] &gt; 0) &#123; Insert(s2, i, startf[i], 0); Insert(i, s2, 0, 0); &#125; else if (startf[i] &lt; 0) &#123; Insert(i, t2, -startf[i], 0); Insert(t2, i, 0, 0); &#125; &#125; Insert(t1, s1, INF, 0); Insert(s1, t1, 0, 0); Ek(s2, t2, ansf, anscos); ans1 += cap[cntnex]; ans2 += anscos; head[s1] = nex[head[s1]]; head[t1] = nex[head[t1]]; cntnex -= 2; Ek(s1, t1, ansf, anscos); ans1 += ansf; ans2 += anscos; printf(&quot;%d %d\\n&quot;, ans1, ans2); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æœ€çŸ­è·¯","slug":"TemLib/æœ€çŸ­è·¯","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœ€çŸ­è·¯/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P3371 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆå¼±åŒ–ç‰ˆï¼‰P4779 ã€æ¨¡æ¿ã€‘å•æºæœ€çŸ­è·¯å¾„ï¼ˆæ ‡å‡†ç‰ˆï¼‰1. Dijkstra1234567891011121314151617181920bool vis[MAXn + 10]; int dis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;Dijkstra(root); 2. SPFA1234567891011121314151617181920bool inque[MAXn + 10]; int dis[MAXn + 10];queue&lt;int&gt; q;void SPFA(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(root); inque[root] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;SPFA(root); 3. Floyd12345678for (re int k = 1; k &lt;= n; ++k) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); //ä¼ é€’é—­åŒ…ï¼šcon[i][j] |= con[i][k] &amp; con[k][j]; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æœ€é•¿ä¸Šå‡å­åºåˆ—(lis)","slug":"TemLib/æœ€é•¿ä¸Šå‡å­åºåˆ—(lis)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœ€é•¿ä¸Šå‡å­åºåˆ—(lis)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(lis)/","excerpt":"","text":"æœ¬è§£æ³•æ—¶é—´å¤æ‚åº¦$O(nlogn)$ï¼Œè¿˜æœ‰ä¸€ç§ DP çš„ $O(n^2)$ çš„æ±‚æ³•ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ä¸Šç½‘äº†è§£ä¸€ä¸‹ 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, s[MAXn + 10], cnt;int main() &#123; read(n); for (re int i = 1, a; i &lt;= n; ++i) &#123; read(a); if (a &gt; s[cnt]) &#123; s[++cnt] = a; &#125; else &#123; *lower_bound(s + 1, s + 1 + cnt, a) = a; &#125; &#125; printf(&quot;%d\\n&quot;, cnt);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æœ€è¿‘å…¬å…±ç¥–å…ˆ(lca)","slug":"TemLib/æœ€è¿‘å…¬å…±ç¥–å…ˆ(lca)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœ€è¿‘å…¬å…±ç¥–å…ˆ(lca)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(lca)/","excerpt":"","text":"P3379 ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰1. å€å¢123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 500000;const int MAXlogdep = 19;const int MAXm = MAXn - 1;int anc[MAXn + 10][MAXlogdep + 10], dep[MAXn + 10], n, q, s;int head[MAXn + 10], next[MAXm * 2 + 10], toid[MAXm * 2 + 10], nown;int lg2[MAXn + 10];void Insert(int from, int to) &#123; next[++nown] = head[from]; head[from] = nown; toid[nown] = to;&#125;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;; &#125; return x;&#125;void Dfs(int nodeid, int fa) &#123; anc[nodeid][0] = fa; for (int i = 1; i &lt;= MAXlogdep; ++i) &#123; anc[nodeid][i] = anc[anc[nodeid][i - 1]][i - 1]; &#125; dep[nodeid] = dep[fa] + 1; for (int i = head[nodeid]; i; i = next[i]) &#123; if (toid[i] != fa) &#123; Dfs(toid[i], nodeid); &#125; &#125;&#125;void Init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; lg2[i] = lg2[i - 1] + (1 &lt;&lt; lg2[i - 1] == i); &#125; for (int i = 0; i &lt;= n; ++i) &#123; lg2[i]--; &#125;&#125;int Lca(int x, int y) &#123; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; while (dep[x] &lt; dep[y]) &#123; y = anc[y][lg2[dep[y] - dep[x]]]; &#125; if (x == y) &#123; return y; &#125; for (int i = lg2[dep[y]]; i &gt;= 0; --i) &#123; if (anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main() &#123; n = read(); q = read(); s = read(); Init(); int x, y; for (int i = 1; i &lt; n; ++i) &#123; x = read(); y = read(); Insert(x, y); Insert(y, x); &#125; Dfs(s, 0); for (int i = 0; i &lt; q; ++i) &#123; x = read(); y = read(); printf(&quot;%d\\n&quot;, Lca(x, y)); &#125; return 0;&#125; 2. æ ‘å‰–12345678910int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; x = fa[top[x]]; &#125; else &#123; y = fa[top[y]]; &#125; &#125; return dep[x] &gt; dep[y] ? y : x;&#125; 3. ç¦»çº¿Tarjan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e5;const int MAXm = MAXn;const int MAXq = 5e5;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int headq[MAXn + 10], cntnexq, nexq[MAXq + 10], q[MAXq + 10];void Insertq(int u, int v) &#123; nexq[++cntnexq] = headq[u]; headq[u] = cntnexq; q[cntnexq] = v;&#125;int fa[MAXn + 10]; bool vis[MAXn + 10];void Dfs1(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; fa[to[i]] = cur; Dfs1(to[i]); &#125;&#125;int times[MAXn + 10], ans[MAXq + 10];void Dfs2(int cur) &#123; ++times[cur]; for (re int i = headq[cur]; i; i = nexq[i]) &#123; int id = q[i]; while (times[id] != 1) &#123; id = fa[id]; &#125; ans[i] = id; &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (times[to[i]]) continue; Dfs2(to[i]); &#125; ++times[cur];&#125;int n, Q, root, qid_nexq[MAXq + 10];int main() &#123; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;Q, &amp;root); for (re int i = 1, u, v; i &lt; n; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); for (re int i = 1, u, v; i &lt;= Q; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insertq(u, v); qid_nexq[i] = cntnexq; &#125; Dfs2(root); for (re int i = 1; i &lt;= Q; ++i) &#123; printf(&quot;%d\\n&quot;, ans[qid_nexq[i]]); &#125;&#125; 4. æ¬§æ‹‰åºè¯·è§ ä¸€ä½dalaoçš„åšå®¢ã€‚ï¼ˆæˆ‘æ‡’å¾—å†™äº†ï¼‰","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æœ€é•¿å…¬å…±å­åºåˆ—(lcs)","slug":"TemLib/æœ€é•¿å…¬å…±å­åºåˆ—(lcs)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœ€é•¿å…¬å…±å­åºåˆ—(lcs)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(lcs)/","excerpt":"","text":"P1439 ã€æ¨¡æ¿ã€‘æœ€é•¿å…¬å…±å­åºåˆ—æœ¬è§£æ³•æ—¶é—´å¤æ‚åº¦$O(nlogn)$ï¼Œè¿˜æœ‰ä¸€ç§ DP çš„ $O(n^2)$ çš„æ±‚æ³•ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ä¸Šç½‘äº†è§£ä¸€ä¸‹ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;const int INF = 0x3f3f3f3f;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;int id[MAXn + 10];int mapping[MAXn + 10];int d[MAXn + 10];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) id[read()] = i; for (int i = 1; i &lt;= n; i++) mapping[i] = id[read()]; memset(d, 0x3f, sizeof(d)); int len = 0; d[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int l = 0, r = len, mid; if (mapping[i] &gt; d[len]) d[++len] = mapping[i]; else &#123; while (l &lt; r) &#123; mid = (l + r) / 2; if (d[mid] &gt; mapping[i]) r = mid; else l = mid + 1; &#125; d[l] = min(mapping[i], d[l]); &#125; &#125; cout &lt;&lt; len; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æœ‰ç†æ•°å–ä½™","slug":"TemLib/æœ‰ç†æ•°å–ä½™","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœ‰ç†æ•°å–ä½™/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%89%E7%90%86%E6%95%B0%E5%8F%96%E4%BD%99/","excerpt":"","text":"P2613 ã€æ¨¡æ¿ã€‘æœ‰ç†æ•°å–ä½™ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#define re register#define int long longconst int MOD = 19260817;inline void read(int &amp;a) &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x * 10 + c - &#x27;0&#x27;) % MOD; &#125; a = x;&#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int inv, k; exgcd(n, mod, inv, k); return (inv % mod + mod) % mod;&#125;int frac(int a, int b, int mod) &#123; return (a * inv(b, mod)) % mod;&#125;int a, b;signed main() &#123; read(a), read(b); if (!(b % MOD)) &#123; printf(&quot;Angry!\\n&quot;); return 0; &#125; printf(&quot;%lld\\n&quot;, frac(a, b, MOD));&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æè¶…çº¿æ®µæ ‘","slug":"TemLib/æè¶…çº¿æ®µæ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æè¶…çº¿æ®µæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"è®¾ä¸€ä¸ªæ¡ä»¶å¯¹äºèŠ‚ç‚¹ id ä¸ºã€Œæ˜¯ä¸€æ¡å®Œå…¨åŒ…å«èŠ‚ç‚¹ id çš„ä¸” stra[id].calc(mid[id])ï¼ˆä¸ç›´çº¿ $x=mid[\\text{id}]$ çš„äº¤ç‚¹ï¼‰æœ€å¤§çš„çº¿æ®µã€ã€‚åˆ™ stra[id] ç»´æŠ¤çš„æ˜¯ä¸è¢« id çš„ç¥–å…ˆæ»¡è¶³è¯¥æ¡ä»¶ä¸”è¢« id æ»¡è¶³è¯¥æ¡ä»¶çš„çº¿æ®µã€‚ è€Œä¸ç›´çº¿ $x=p$ äº¤ç‚¹æœ€å¤§çš„çº¿æ®µå°±æ˜¯æè¶…çº¿æ®µæ ‘æ‰€æœ‰åŒ…å«æ¨ªåæ ‡ $p$ çš„èŠ‚ç‚¹çš„ stra ä¸ç›´çº¿ $x=p$ äº¤ç‚¹çš„æœ€å¤§çš„çº¿æ®µã€‚ æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162inline int sig(double x) &#123; if (x &lt; -EPS) return -1; else if (x &gt; EPS) return 1; else return 0;&#125;struct Point &#123; double v; int idx; inline bool operator&lt;(const Point sec) const &#123; if (sig(v - sec.v)) return v &lt; sec.v; else return idx &gt; sec.idx; &#125;&#125;;inline Point max(Point fir, Point sec) &#123; return (fir &lt; sec) ? sec : fir;&#125;struct Stra &#123; double b, k; int idx; inline Point calc(int p) &#123; if (idx == 0) return Point&#123;NINF, 0&#125;; else return Point&#123;b + k * p, idx&#125;; &#125;&#125;;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)const int MAXnd = MAXx * 4;int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10];Stra stra[MAXnd + 10];void build(int id, int l, int r) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; if (le[id] != ri[id]) &#123; build(ls, le[id], mid[id]); build(rs, mid[id] + 1, ri[id]); &#125;&#125;void modify(int id, int l, int r, Stra s) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; if (stra[id].calc(mid[id]) &lt; s.calc(mid[id])) &#123; swap(stra[id], s); &#125; if (le[id] != ri[id]) &#123; if (stra[id].k &lt; s.k) modify(rs, l, r, s); else if (stra[id].k &gt; s.k) modify(ls, l, r, s); &#125; &#125; else &#123; if (l &lt;= mid[id]) modify(ls, l, r, s); if (r &gt; mid[id]) modify(rs, l, r, s); &#125;&#125;Point query(int id, int p) &#123; Point ans = stra[id].calc(p); if (le[id] != ri[id]) &#123; if (p &lt;= mid[id]) ans = max(ans, query(ls, p)); else ans = max(ans, query(rs, p)); &#125; return ans;&#125;#undef ls#undef rs Luogu P4097 [HEOI2013]Segment ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXx = 39989;const int MAXy = 1e9;const int MAXm = 1e5;const double NINF = -2e9;const double EPS = 1e-8;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline int sig(double x) &#123; if (x &lt; -EPS) return -1; else if (x &gt; EPS) return 1; else return 0;&#125;struct Point &#123; double v; int idx; inline bool operator&lt;(const Point sec) const &#123; if (sig(v - sec.v)) return v &lt; sec.v; else return idx &gt; sec.idx; &#125;&#125;;inline Point max(Point fir, Point sec) &#123; return (fir &lt; sec) ? sec : fir;&#125;struct Stra &#123; double b, k; int idx; inline Point calc(int p) &#123; if (idx == 0) return Point&#123;NINF, 0&#125;; else return Point&#123;b + k * p, idx&#125;; &#125;&#125;;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)const int MAXnd = MAXx * 4;int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10];Stra stra[MAXnd + 10];void build(int id, int l, int r) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; if (le[id] != ri[id]) &#123; build(ls, le[id], mid[id]); build(rs, mid[id] + 1, ri[id]); &#125;&#125;void modify(int id, int l, int r, Stra s) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; if (stra[id].calc(mid[id]) &lt; s.calc(mid[id])) &#123; swap(stra[id], s); &#125; if (le[id] != ri[id]) &#123; if (stra[id].k &lt; s.k) modify(rs, l, r, s); else if (stra[id].k &gt; s.k) modify(ls, l, r, s); &#125; &#125; else &#123; if (l &lt;= mid[id]) modify(ls, l, r, s); if (r &gt; mid[id]) modify(rs, l, r, s); &#125;&#125;Point query(int id, int p) &#123; Point ans = stra[id].calc(p); if (le[id] != ri[id]) &#123; if (p &lt;= mid[id]) ans = max(ans, query(ls, p)); else ans = max(ans, query(rs, p)); &#125; return ans;&#125;#undef ls#undef rsint m;int cnts;int lastans;signed main() &#123; build(1, 1, MAXx); read(m); for (int i = 1, opt, p, xa, ya, xb, yb; i &lt;= m; ++i) &#123; read(opt); if (opt == 0) &#123; read(p); p = (p + lastans - 1) % MAXx + 1; printf(&quot;%d\\n&quot;, lastans = query(1, p).idx); &#125; else &#123; read(xa, ya, xb, yb); xa = (xa + lastans - 1) % MAXx + 1; ya = (ya + lastans - 1) % MAXy + 1; xb = (xb + lastans - 1) % MAXx + 1; yb = (yb + lastans - 1) % MAXy + 1; Stra s; if (xa &gt; xb) &#123; swap(xa, xb); swap(ya, yb); &#125; if (xa != xb) &#123; double k = (double)(yb - ya) / (double)(xb - xa); s = Stra&#123;ya - k * xa, k, ++cnts&#125;; &#125; else &#123; s = Stra&#123;(double)max(ya, yb), 0, ++cnts&#125;; &#125; modify(1, xa, xb, s); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æœæ•™ç­›","slug":"TemLib/æœæ•™ç­›","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æœæ•™ç­›/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9D%9C%E6%95%99%E7%AD%9B/","excerpt":"","text":"Luogu P4213 ã€æ¨¡æ¿ã€‘æœæ•™ç­›ï¼ˆSumï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142struct Ele &#123; int key, val1, val2;&#125;;vector&lt;Ele&gt; hx[MOD + 10]; // Find å‡½æ•°å’Œ Insert å‡½æ•°æ˜¯ hash è¡¨çš„å‡½æ•°ï¼Œä¸æ˜¯æ–‡ç« é‡ç‚¹inline Ele Find(int k) &#123; int kmod = k % MOD; for (auto i: hx[kmod]) &#123; if (i.key == k) &#123; return i; &#125; &#125; return Ele&#123;key: INF, val1: INF, val2: INF&#125;;&#125;inline void Insert(Ele ele) &#123; hx[ele.key % MOD].push_back(ele);&#125;inline int SumId(int n) &#123; return n * (n + 1) / 2;&#125;Ele EvaSum(int n) &#123; if (n &lt;= MAXn2div3) return Ele&#123;key: n, val1: ola[n], val2: mob[n]&#125;; Ele ans = Find(n); if (ans.key != INF) return ans; ans = Ele&#123;key: n, val1: SumId(n), val2: 1&#125;; for (int il = 2, ir = min(n, (n / (n / il))); ; il = ir + 1, ir = min(n, (n / (n / il)))) &#123; Ele query = EvaSum(n / il); ans.val1 -= (ir - il + 1) * query.val1; ans.val2 -= (ir - il + 1) * query.val2; if (ir == n) break; &#125; Insert(ans); return ans;&#125;signed main() &#123; EvaOlaMob(MAXn2div3); GetSum(MAXn2div3, ola); GetSum(MAXn2div3, mob); Ele ans = EvaSum(n); printf(&quot;%lld %lld\\n&quot;, ans.val1, ans.val2);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ ‘ä¸Šå…³é”®ç‚¹","slug":"TemLib/æ ‘ä¸Šå…³é”®ç‚¹","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ ‘ä¸Šå…³é”®ç‚¹/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E4%B8%8A%E5%85%B3%E9%94%AE%E7%82%B9/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template&lt;class T&gt;inline void read(T &amp;a) &#123; re char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());re bool f = c == &#x27;-&#x27;;re T x = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n, k, ans, root = 1;bool vis[MAXn + 10];pair&lt;int, bool&gt; Dfs(int cur) &#123; // 0: hav, 1: ned vis[cur] = 1; int ned = -INF, hav = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; pair&lt;int, bool&gt; tmp = Dfs(to[i]); if (tmp.second) &#123; ned = max(ned, tmp.first); &#125; else &#123; hav = max(hav, tmp.first); &#125; &#125; if (cur == root) &#123; if (ned == -INF &amp;&amp; hav == -INF) &#123; ++ans; &#125; else if (ned == -INF) &#123; ; &#125; else if (hav == -INF) &#123; ++ans; &#125; else &#123; if (ned &gt; hav) &#123; ++ans; &#125; else &#123; ; &#125; &#125; return make_pair(-1, -1); &#125; if (ned == -INF &amp;&amp; hav == -INF) &#123; return make_pair(1, 1); &#125; else if (ned == -INF) &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; else if (hav == -INF) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (ned &gt; hav) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; &#125;&#125;int main() &#123; read(n); read(k); if (k == 0) &#123; printf(&quot;%d\\n&quot;, n); return 0; &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs(root); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ‘ä¸Šå¯å‘å¼åˆå¹¶","slug":"TemLib/æ ‘ä¸Šå¯å‘å¼åˆå¹¶","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/æ ‘ä¸Šå¯å‘å¼åˆå¹¶/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","excerpt":"","text":"U41492 æ ‘ä¸Šæ•°é¢œè‰² 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int fa[MAXn + 10], hson[MAXn + 10], siz[MAXn + 10];void Dfs1(int cur, int f) &#123; fa[cur] = f; siz[cur] = 1; int mx = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; Dfs1(to[i], cur); siz[cur] += siz[to[i]]; if (mx &lt; siz[to[i]]) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int color[MAXn + 10], ans[MAXn + 10];int cntbuc, buc[MAXn + 10];void Dfs3(int cur, int hson) &#123; if (!buc[color[cur]]) ++cntbuc; ++buc[color[cur]]; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson) continue; Dfs3(to[i], hson); &#125;&#125;void Dfs2(int cur) &#123; if (!hson[cur]) &#123; ans[cur] = 1; buc[color[cur]] = 1; cntbuc = 1; &#125; else &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; Dfs2(to[i]); memset(buc, 0, sizeof(buc)); cntbuc = 0; &#125; Dfs2(hson[cur]); Dfs3(cur, hson[cur]); ans[cur] = cntbuc; &#125;&#125;int n, q;signed main() &#123; read(n); for (int i = 1, u, v; i &lt; n; ++i) &#123; read(u, v); Insert(u, v); Insert(v, u); &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(color[i]); &#125; Dfs1(1, 0); Dfs2(1); read(q); for (int i = 1, cur; i &lt;= q; ++i) &#123; read(cur); printf(&quot;%d\\n&quot;, ans[cur]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ‘åˆ†å—","slug":"TemLib/æ ‘åˆ†å—","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ ‘åˆ†å—/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%88%86%E5%9D%97/","excerpt":"","text":"æ‹¬å·åºåˆ†å—ç•¥ã€‚ ç‹å®¤è”é‚¦åˆ†å—Luogu P2325 SCOI2005 ç‹å®¤è”é‚¦ $\\text{sizbl}$ ä¸ºä¸€é¢„å®šå¥½çš„å€¼ï¼Œåˆ†å¾—çš„å—çš„å¤§å°èŒƒå›´ $[\\text{sizbl},3\\text{sizbl})$ï¼Œä¸” $\\ge 2\\text{sizbl}$ çš„å—æœ€å¤šåªæœ‰ä¸€ä¸ªã€‚ 123456789101112131415161718192021222324int sizbl = 100, cntbl, root[MAXn + 10];int inbl[MAXn + 10];int top, stk[MAXn + 10];void EvaBl(int cur, int f) &#123; int bottom = top; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == f) continue; EvaBl(to[i], cur); if (top - bottom &gt;= sizbl) &#123; root[++cntbl] = cur; while (top &gt; bottom) &#123; inbl[stk[top--]] = cntbl; &#125; &#125; &#125; stk[++top] = cur;&#125;signed main() &#123; // ... EvaBl(1, 0); if (cntbl == 0) root[++cntbl] = 1; while (top) inbl[stk[top--]] = cntbl;&#125; æ ‘ä¸Šæ’’ç‚¹æŒ‰æ·±åº¦ä»å¤§å¾€å°éå†æ¯ä¸ªç‚¹ï¼Œå¦‚æœå…¶ $0\\sim\\text{sizbl}$ çº§ç¥–å…ˆä¸­æ²¡æœ‰å…³é”®ç‚¹ï¼Œåˆ™å°†å…¶ $\\text{sizbl}$ çº§ç¥–å…ˆä½œä¸ºå…³é”®ç‚¹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int cntkey, idxkey[MAXn + 10];int top[MAXn + 10];bitset&lt;MAXn + 10&gt; info[MAXsqrtn + 10];int tpstk, stk[MAXn + 10];void PutKey(int root) &#123; while (!pq.empty()) &#123; pair&lt;int, int&gt; pr = pq.top(); pq.pop(); int cur = pr.second; for (int i = 0; i &lt;= sizbl &amp;&amp; cur &amp;&amp; idxkey[cur] == 0; ++i, cur = fa[cur]); if (idxkey[cur] == 0) &#123; idxkey[cur] = ++cntkey; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (i == root) continue; pq.push(make_pair(dep[i], i)); &#125; while (!pq.empty()) &#123; pair&lt;int, int&gt; pr = pq.top(); pq.pop(); int cur = pr.second; if (top[cur]) continue; if (idxkey[cur]) &#123; info[idxkey[pr.second]].set(a[cur], 1); stk[++tpstk] = cur; for (cur = fa[cur]; cur &amp;&amp; idxkey[cur] == 0; cur = fa[cur]) &#123; info[idxkey[pr.second]].set(a[cur], 1); stk[++tpstk] = cur; &#125; while (tpstk) &#123; top[stk[tpstk--]] = cur; &#125; &#125; else &#123; stk[++tpstk] = cur; for (cur = fa[cur]; cur &amp;&amp; idxkey[cur] == 0; cur = fa[cur]) &#123; stk[++tpstk] = cur; &#125; while (tpstk) &#123; top[stk[tpstk--]] = cur; &#125; &#125; &#125;&#125;int Query(int x, int y) &#123; bitset&lt;MAXn + 10&gt; ans; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); if (idxkey[y]) &#123; ans = ans | info[idxkey[y]]; y = top[y]; &#125; else &#123; ans.set(a[y], 1); y = fa[y]; &#125; &#125; while (x != y) &#123; if (dep[x] &gt; dep[y]) swap(x, y); ans.set(a[y], 1); y = fa[y]; &#125; ans.set(a[x], 1); return ans.count();&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ‘å¥—æ ‘","slug":"TemLib/æ ‘å¥—æ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ ‘å¥—æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%A5%97%E6%A0%91/","excerpt":"","text":"æœ¬æ–‡ã€Œçº¿æ®µæ ‘å¥—çº¿æ®µæ ‘ã€æ¿å—ä¸ºæ–°å†…å®¹ï¼Œã€Œçº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘ã€æ¿å—ä¸ºæ—§å†…å®¹ çº¿æ®µæ ‘å¥—çº¿æ®µæ ‘æ³¨æ„äº‹é¡¹ï¼š ä»£ç ä¸­çš„å‡½æ•°å’Œå˜é‡æœ‰çš„å¸¦åç¼€ bï¼Œæœ‰çš„å¸¦åç¼€ aï¼Œå¦‚ modifyaã€‚å¸¦åç¼€ b çš„ä»£è¡¨ bigï¼Œè¡¨ç¤ºè¾ƒå¤§çš„ä¸€å±‚ï¼Œä¹Ÿå°±æ˜¯å¤–å±‚ï¼Œè¿™ä¸åˆ†å—çš„å˜é‡çš„åç¼€ç›¸åŒã€‚ä½†æ˜¯å†…å±‚ç”¨çš„åç¼€ä¸æ˜¯ sï¼Œè€Œæ˜¯ aï¼Œè¿™æ˜¯å› ä¸ºåç¼€ s ä¼šå¯¼è‡´æ­§ä¹‰ï¼Œæ¯”å¦‚å˜é‡ r å¸¦åç¼€ s ä¼šå˜æˆ rsï¼Œè€Œ rs æœ¬æ¥å°±æ˜¯å˜é‡åã€‚ éœ€è¦æ³¨æ„å†…å±‚çº¿æ®µæ ‘å¼€çš„æ•°ç»„å¤§å°ï¼Œæ˜¯ MAXm * MAXcovn * MAXlayaï¼Œå…¶ä¸­ m è¡¨ç¤ºæ“ä½œæ•°ï¼Œn è¡¨ç¤ºå¤–å±‚çº¿æ®µæ ‘æ‰€åœ¨åŒºé—´çš„å¤§å°ï¼Œa è¡¨ç¤ºå†…å±‚çº¿æ®µæ ‘æ‰€åœ¨åŒºé—´çš„å¤§å°ï¼Œè€Œ cov è¡¨ç¤ºçº¿æ®µæ ‘åŒºé—´æ“ä½œä¸­è¢«å®Œå…¨è¦†ç›–ä¸”ç¥–å…ˆæ²¡æœ‰è¢«å®Œå…¨è¦†ç›–çš„èŠ‚ç‚¹æ•°é‡ï¼Œ$\\text{maxcov}n=(\\lceil\\log n\\rceil-1)\\times 2$ã€‚ ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const int MAXnda = MAXm * MAXcovn * MAXlaya;int cntnd, ls[MAXnda + 10], rs[MAXnda + 10];int sum[MAXnda + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;void modifya(int &amp;id, int p, int v, int le, int ri) &#123; if (id == 0) id = ++cntnd; if (le == ri) &#123; sum[id] += v; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) modifya(ls[id], p, v, le, mid); else modifya(rs[id], p, v, mid + 1, ri); pushup(id); &#125;&#125;int querya(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += querya(ls[id], l, r, le, mid); if (r &gt; mid) ans += querya(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)const int MAXndb = MAXn * 4;int le[MAXndb + 10], ri[MAXndb + 10], mid[MAXndb + 10];int root[MAXndb + 10];void buildb(int id, int *a, int l, int r) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; for (int i = le[id]; i &lt;= ri[id]; ++i) &#123; modifya(root[id], a[i], 1, 0, MAXa); &#125; if (le[id] != ri[id]) &#123; buildb(ls, a, le[id], mid[id]); buildb(rs, a, mid[id] + 1, ri[id]); &#125;&#125;void modifyb(int id, int pb, int pa, int v) &#123; modifya(root[id], pa, v, 0, MAXa); if (le[id] != ri[id]) &#123; if (pb &lt;= mid[id]) modifyb(ls, pb, pa, v); else modifyb(rs, pb, pa, v); &#125;&#125;int queryb(int id, int lb, int rb, int la, int ra) &#123; if (le[id] &gt;= lb &amp;&amp; ri[id] &lt;= rb) &#123; return querya(root[id], la, ra, 0, MAXa); &#125; else &#123; int ans = 0; if (lb &lt;= mid[id]) ans += queryb(ls, lb, rb, la, ra); if (rb &gt; mid[id]) ans += queryb(rs, lb, rb, la, ra); return ans; &#125;&#125;#undef ls#undef rs Luogu P3380 ã€æ¨¡æ¿ã€‘äºŒé€¼å¹³è¡¡æ ‘ï¼ˆæ ‘å¥—æ ‘ï¼‰ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;const int MAXcovn = 30;const int MAXm = 5e4;const int MAXa = 1e8;const int MAXlaya = 28;const int INF = 0x3f3f3f3f;const int NINF = 0xc0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnda = MAXm * MAXcovn * MAXlaya;int cntnd, ls[MAXnda + 10], rs[MAXnda + 10];int sum[MAXnda + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;void modifya(int &amp;id, int p, int v, int le, int ri) &#123; if (id == 0) id = ++cntnd; if (le == ri) &#123; sum[id] += v; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) modifya(ls[id], p, v, le, mid); else modifya(rs[id], p, v, mid + 1, ri); pushup(id); &#125;&#125;int querya(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += querya(ls[id], l, r, le, mid); if (r &gt; mid) ans += querya(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)const int MAXndb = MAXn * 4;int le[MAXndb + 10], ri[MAXndb + 10], mid[MAXndb + 10];int root[MAXndb + 10];void buildb(int id, int *a, int l, int r) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; for (int i = le[id]; i &lt;= ri[id]; ++i) &#123; modifya(root[id], a[i], 1, 0, MAXa); &#125; if (le[id] != ri[id]) &#123; buildb(ls, a, le[id], mid[id]); buildb(rs, a, mid[id] + 1, ri[id]); &#125;&#125;void modifyb(int id, int pb, int pa, int v) &#123; modifya(root[id], pa, v, 0, MAXa); if (le[id] != ri[id]) &#123; if (pb &lt;= mid[id]) modifyb(ls, pb, pa, v); else modifyb(rs, pb, pa, v); &#125;&#125;int queryb(int id, int lb, int rb, int la, int ra) &#123; if (le[id] &gt;= lb &amp;&amp; ri[id] &lt;= rb) &#123; return querya(root[id], la, ra, 0, MAXa); &#125; else &#123; int ans = 0; if (lb &lt;= mid[id]) ans += queryb(ls, lb, rb, la, ra); if (rb &gt; mid[id]) ans += queryb(rs, lb, rb, la, ra); return ans; &#125;&#125;int cntidx, idx[MAXcovn + 10];void findidx(int id, int lb, int rb) &#123; if (le[id] &gt;= lb &amp;&amp; ri[id] &lt;= rb) &#123; idx[++cntidx] = root[id]; &#125; else &#123; if (lb &lt;= mid[id]) findidx(ls, lb, rb); if (rb &gt; mid[id]) findidx(rs, lb, rb); &#125;&#125;#undef ls#undef rsint Valtorank(int l, int r, int v) &#123; if (v == 0) return 1; else return 1 + queryb(1, l, r, 0, v - 1);&#125;int Ranktoval(int l, int r, int rk) &#123; if (rk == 0) return -2147483647; cntidx = 0; findidx(1, l, r); int sumall = 0; for (int i = 1; i &lt;= cntidx; ++i) &#123; sumall += sum[idx[i]]; &#125; if (rk &gt; sumall) return 2147483647; int lea = 0, ria = MAXa, mida; while (lea != ria) &#123; mida = (lea + ria) &gt;&gt; 1; int sumls = 0; for (int i = 1; i &lt;= cntidx; ++i) &#123; sumls += sum[ls[idx[i]]]; &#125; if (rk &lt;= sumls) &#123; for (int i = 1; i &lt;= cntidx; ++i) &#123; idx[i] = ls[idx[i]]; &#125; ria = mida; &#125; else &#123; rk -= sumls; for (int i = 1; i &lt;= cntidx; ++i) &#123; idx[i] = rs[idx[i]]; &#125; lea = mida + 1; &#125; &#125; return lea;&#125;int Precval(int l, int r, int v) &#123; return Ranktoval(l, r, Valtorank(l, r, v) - 1);&#125;int Nexval(int l, int r, int v) &#123; return Ranktoval(l, r, Valtorank(l, r, v + 1));&#125;int n, m;int a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; buildb(1, a, 1, n); for (int i = 1, opt, x, l, r, p; i &lt;= m; ++i) &#123; read(opt); if (opt == 1) &#123; read(l, r, x); printf(&quot;%d\\n&quot;, Valtorank(l, r, x)); &#125; else if (opt == 2) &#123; read(l, r, x); printf(&quot;%d\\n&quot;, Ranktoval(l, r, x)); &#125; else if (opt == 3) &#123; read(p, x); modifyb(1, p, a[p], -1); a[p] = x; modifyb(1, p, a[p], 1); &#125; else if (opt == 4) &#123; read(l, r, x); printf(&quot;%d\\n&quot;, Precval(l, r, x)); &#125; else &#123; read(l, r, x); printf(&quot;%d\\n&quot;, Nexval(l, r, x)); &#125; &#125; return 0;&#125; çº¿æ®µæ ‘å¥—å¹³è¡¡æ ‘Luogu P3380 ã€æ¨¡æ¿ã€‘äºŒé€¼å¹³è¡¡æ ‘ï¼ˆæ ‘å¥—æ ‘ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;const int MAXm = 5e4;const int MAXlogn = 16;const int MAXnd1 = MAXn * 4;const int MAXnd2 = MAXnd1 * 3 + MAXn * MAXlogn + MAXm * MAXlogn;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int idxinf, idxninf;int cntnd, son[MAXnd2 + 10][2], fa[MAXnd2 + 10], siz[MAXnd2 + 10], cnt[MAXnd2 + 10], val[MAXnd2 + 10];inline void pushup(int cur) &#123; siz[cur] = cnt[cur] + siz[son[cur][0]] + siz[son[cur][1]];&#125;inline int side(int cur) &#123; return cur == son[fa[cur]][1];&#125;inline void rotate(int cur) &#123; int y = fa[cur], z = fa[y], sidecur = side(cur), s = son[cur][sidecur ^ 1]; if (z) &#123;son[z][side(y)] = cur;&#125; fa[cur] = z; son[y][sidecur] = s; if (s) &#123;fa[s] = y;&#125; son[cur][sidecur ^ 1] = y; fa[y] = cur; pushup(y); pushup(cur);&#125;inline void splay(int &amp;root, int cur, int goal = 0) &#123; int y, z; while (fa[cur] != goal) &#123; y = fa[cur], z = fa[y]; if (z != goal) &#123; if (side(cur) == side(y)) rotate(y); else rotate(cur); &#125; rotate(cur); &#125; if (!goal) root = cur;&#125;inline int V2R(int &amp;root, int v) &#123; int ans = 0, cur = root; while (true) &#123; if (val[cur] &lt; v) &#123; ans += siz[son[cur][0]] + cnt[cur]; if (son[cur][1]) cur = son[cur][1]; else break; &#125; else if (val[cur] == v) &#123; ans += siz[son[cur][0]]; break; &#125; else &#123; if (son[cur][0]) cur = son[cur][0]; else break; &#125; &#125; splay(root, cur); return ans - 1;&#125;inline int PI(int &amp;root, int v) &#123; int ans = idxninf, cur = root; while (true) &#123; if (val[cur] &gt;= v) &#123; if (son[cur][0]) cur = son[cur][0]; else break; &#125; else &#123; ans = val[ans] &gt; val[cur] ? ans : cur; if (son[cur][1]) cur = son[cur][1]; else break; &#125; &#125; splay(root, cur); return ans;&#125;inline int NI(int &amp;root, int v) &#123; int ans = idxinf, cur = root; while (true) &#123; if (val[cur] &lt;= v) &#123; if (son[cur][1]) cur = son[cur][1]; else break; &#125; else &#123; ans = val[ans] &lt; val[cur] ? ans : cur; if (son[cur][0]) cur = son[cur][0]; else break; &#125; &#125; splay(root, cur); return ans;&#125;inline void I(int &amp;root, int v) &#123; int cur = root, f = 0; while (cur &amp;&amp; v != val[cur]) &#123; f = cur; cur = son[cur][v &gt; val[cur]]; &#125; if (cur) &#123; ++cnt[cur]; &#125; else &#123; cur = ++cntnd; cnt[cur] = 1; val[cur] = v; fa[cur] = f; if (f) son[f][v &gt; val[f]] = cur; &#125; splay(root, cur);&#125;inline void D(int &amp;root, int v) &#123; int pre = PI(root, v), nex = NI(root, v); splay(root, pre); splay(root, nex, pre); int del = son[nex][0]; if (del) &#123; --cnt[del]; if (cnt[del]) &#123; splay(root, del); &#125; else &#123; son[nex][0] = 0; &#125; &#125;&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd1 + 10], ri[MAXnd1 + 10], root[MAXnd1 + 10];void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; I(root[id], INF); I(root[id], -INF); for (int i = l; i &lt;= r; ++i) I(root[id], a[i]); if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); &#125;&#125;void Insert(int id, int p, int a) &#123; I(root[id], a); if (le[id] == ri[id]) &#123; ; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) Insert(ls, p, a); else Insert(rs, p, a); &#125;&#125;void Delete(int id, int p, int a) &#123; D(root[id], a); if (le[id] == ri[id]) &#123; ; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) Delete(ls, p, a); else Delete(rs, p, a); &#125;&#125;int ValtoRank(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return V2R(root[id], v); &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += ValtoRank(ls, l, r, v); if (r &gt; mid) ans += ValtoRank(rs, l, r, v); return ans; &#125;&#125;int RanktoVal(int l, int r, int rk) &#123; --rk; int L = -INF + 1, R = INF - 1, M; while (L &lt; R) &#123; M = (L + R + 1) &gt;&gt; 1; if (ValtoRank(1, l, r, M) &lt;= rk) &#123; L = M; &#125; else &#123; R = M - 1; &#125; &#125; return L;&#125;int Pre(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return val[PI(root[id], v)]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = -INF; if (l &lt;= mid) ans = max(ans, Pre(ls, l, r, v)); if (r &gt; mid) ans = max(ans, Pre(rs, l, r, v)); return ans; &#125;&#125;int Nex(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return val[NI(root[id], v)]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = INF; if (l &lt;= mid) ans = min(ans, Nex(ls, l, r, v)); if (r &gt; mid) ans = min(ans, Nex(rs, l, r, v)); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; val[idxinf = ++cntnd] = INF; val[idxninf = ++cntnd] = -INF; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, l, r, p, k, tmp; i &lt;= m; ++i) &#123; read(opt); if (opt == 1) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, ValtoRank(1, l, r, k) + 1); &#125; else if (opt == 2) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, RanktoVal(l, r, k)); &#125; else if (opt == 3) &#123; read(p, k); Delete(1, p, a[p]); a[p] = k; Insert(1, p, k); &#125; else if (opt == 4) &#123; read(l, r, k); tmp = Pre(1, l, r, k); if (tmp == -INF) puts(&quot;-2147483647&quot;); else printf(&quot;%d\\n&quot;, tmp); &#125; else if (opt == 5) &#123; read(l, r, k); tmp = Nex(1, l, r, k); if (tmp == INF) puts(&quot;2147483647&quot;); else printf(&quot;%d\\n&quot;, tmp); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ ‘å½¢dp","slug":"TemLib/æ ‘å½¢dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ ‘å½¢dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%BD%A2dp/","excerpt":"","text":"P1352 æ²¡æœ‰ä¸Šå¸çš„èˆä¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 6000;const int NEGINF = 0xc0c0c0c0;int n;int d[MAXn + 10][2];int v[MAXn + 10];int edgenum;int head[MAXn + 10];int next[MAXn + 10];int to[MAXn + 10];inline int read()&#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void first()&#123; memset(d, 0xc0c0, sizeof(d));&#125;void insert_edge(int from, int too)&#123; next[++edgenum] = head[from]; head[from] = edgenum; to[edgenum] = too;&#125;void put_in()&#123; n = read(); for (int i = 1; i &lt;= n; i++) v[i] = read(); for (int i = 1; i &lt; n; i++)&#123; int to = read(); int from = read(); insert_edge(from, to); &#125;&#125;int dp(int nodeid, bool have_root)&#123; if (d[nodeid][have_root] != NEGINF) return d[nodeid][have_root]; int&amp; ans = d[nodeid][have_root] = 0; if (!have_root) for (int i = head[nodeid]; i; i = next[i]) ans += max(dp(to[i], 0), dp(to[i], 1)); else&#123; ans += v[nodeid]; for (int i = head[nodeid]; i; i = next[i]) ans += dp(to[i], 0); &#125; return ans;&#125;int find_root()&#123; bool have_in_deg[MAXn + 10] = &#123; 0 &#125;; for (int i = 1; i &lt;= edgenum; i++) have_in_deg[to[i]] = 1; for (int i = 1; i &lt;= n; i++) if (!have_in_deg[i]) return i;&#125;int main()&#123; first(); put_in(); int rootid = find_root(); cout &lt;&lt; max(dp(rootid, 0), dp(rootid, 1)) &lt;&lt; endl;&#125; P2015 äºŒå‰è‹¹æœæ ‘12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100;const int MAXq = 100;const int INF = 0x3f3f3f3f;int n, q;int d[MAXn + 10][MAXq + 10];int to[MAXn + 10][2];//ÃÃ‚Â±Ãª1ÃÂªfromÂµÃ„idint edgew[MAXn + 10][2];//ÃÃ‚Â±Ãª1ÃÂªfromÂµÃ„idinline int read()&#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;void Init()&#123; memset(d, -1, sizeof(d));&#125;void insert_edge(int nodeid1, int nodeid2, int edge_w)&#123; if (!to[nodeid1][0])&#123; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; &#125;else&#123; to[nodeid1][1] = nodeid2; edgew[nodeid1][1] = edge_w; &#125;&#125;int dp(int nodeid, int keepnum)&#123; if (d[nodeid][keepnum] != -1) return d[nodeid][keepnum]; int&amp; ans = d[nodeid][keepnum] = 0; if (!keepnum) return ans = 0; if (!to[nodeid][0]) return ans = -INF; for (int knuml = 0; knuml &lt;= keepnum; knuml++)&#123; int knumr = keepnum - knuml; int tmp_ans = 0; if (knuml) tmp_ans += edgew[nodeid][0] + dp(to[nodeid][0], knuml - 1); if (knumr) tmp_ans += edgew[nodeid][1] + dp(to[nodeid][1], knumr - 1); ans = max(ans, tmp_ans); &#125; return ans;&#125;int main()&#123; Init(); n = read(); q = read(); for (int i = 1; i &lt; n; i++)&#123; int nodeid1 = read(); int nodeid2 = read(); int edgew = read(); insert_edge(nodeid1, nodeid2, edgew); &#125; cout &lt;&lt; dp(1, q);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ‘å½¢èƒŒåŒ…","slug":"TemLib/æ ‘å½¢èƒŒåŒ…","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ ‘å½¢èƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/","excerpt":"","text":"1. sizeä¼˜åŒ–è§£æ ‘å½¢èƒŒåŒ…æ³¨æ„ï¼šè¯¥æ–¹æ³•æ— æ³•è§£å†³å¸¦æƒæ ‘å½¢èƒŒåŒ…ã€‚ P3177 HAOI2015 æ ‘ä¸ŠæŸ“è‰² 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e3;const int MAXm = MAXn;const int MAXk = 2e3;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXm + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, fa[MAXn + 10], siz[MAXn + 10], d[MAXn + 10][MAXk + 10];void Dfs(int cur) &#123; siz[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs(to[i]); siz[cur] += siz[to[i]]; &#125;&#125;void DfsDp(int cur) &#123; d[cur][0] = d[cur][1] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; DfsDp(to[i]); for (int j = min(m, siz[cur]); ~j; --j) &#123; for (int k = 0; k &lt;= min(j, siz[to[i]]); ++k) &#123; d[cur][j] = max(d[cur][j], d[cur][j - k] + d[to[i]][k] + wei[i] * (k * (m - k) + (siz[to[i]] - k) * (n - siz[to[i]] - (m - k)))); &#125; &#125; &#125;&#125;signed main() &#123; memset(d, 0xc0, sizeof(d)); read(n, m); if (n &lt; m * 2) &#123; m = n - m; &#125; for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1); DfsDp(1); printf(&quot;%lld\\n&quot;, d[1][m]);&#125; 2. dfsåºä¼˜åŒ–è§£æ ‘å½¢èƒŒåŒ…U189430 å¸¦æƒæ ‘å½¢èƒŒåŒ… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e3;const int MAXW = 1e4;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm + 10], from[MAXm + 10], to[MAXm + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; from[cntnex] = u; to[cntnex] = v;&#125;int n, W, ndw[MAXn + 10], ndv[MAXn + 10];int cntdfs, idxdfs[MAXn + 10], bottom[MAXn + 10];void Dfs(int cur) &#123; idxdfs[++cntdfs] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; Dfs(to[i]); &#125; bottom[cur] = cntdfs;&#125;int d[MAXn * 2 + 10][MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, f; i &lt;= n; ++i) &#123; read(ndw[i], f, ndv[i]); if (f == i) &#123; Insert(n + 1, i); &#125; else &#123; Insert(f, i); &#125; &#125; Dfs(n + 1); // ä¸»å¹²éƒ¨åˆ† for (int i = cntdfs; i; --i) &#123; int cur = idxdfs[i]; for (int j = W; j &gt;= ndw[cur]; --j) &#123; d[i][j] = max(d[bottom[cur] + 1][j], d[i + 1][j - ndw[cur]] + ndv[cur]); &#125; for (int j = ndw[cur] - 1; ~j; --j) &#123; d[i][j] = d[bottom[cur] + 1][j]; &#125; &#125; // ä¸»å¹²éƒ¨åˆ† int ans = 0; for (int j = 0; j &lt;= W; ++j) &#123; ans = max(ans, d[1][j]); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ‘çŠ¶æ•°ç»„","slug":"TemLib/æ ‘çŠ¶æ•°ç»„","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ ‘çŠ¶æ•°ç»„/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"P3374 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 1P3368 ã€æ¨¡æ¿ã€‘æ ‘çŠ¶æ•°ç»„ 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 5e5;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int n, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= n) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int a[MAXn + 10], m;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseSum(a); for (re int i = 1, opt, x, y, k; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(k); Add(x, k); Add(y + 1, -k); break; case 2: read(x); printf(&quot;%lld\\n&quot;, EvaSum(x)); break; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ ‘çš„ç›´å¾„","slug":"TemLib/æ ‘çš„ç›´å¾„","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/æ ‘çš„ç›´å¾„/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","excerpt":"","text":"U81904 ã€æ¨¡æ¿ã€‘æ ‘çš„ç›´å¾„ 1. ä¸¤æ¬¡Dfsæ³¨æ„ï¼šè¯¥æ–¹æ³•æ— æ³•è§£å†³è´Ÿæƒæ ‘ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerusing namespace std;const int MAXn = 5e5;const int MAXm = MAXn;const int FINF = 0xc0c0c0c0;int n;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10];void Dfs(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; dis[to[i]] = dis[cur] + wei[i]; Dfs(to[i]); &#125;&#125;int EvaFar(int root) &#123; memset(dis, 0xc0, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[root] = 0; Dfs(root); int mx = FINF, maxer = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mx &lt; dis[i]) &#123; mx = dis[i]; maxer = i; &#125; &#125; return maxer;&#125;int side1, side2;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1, u, v, w; i &lt; n; ++i) &#123; scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); Insert(u, v, w); Insert(v, u, w); &#125; side1 = EvaFar(1); side2 = EvaFar(side1); printf(&quot;%d %d\\n&quot;, side1, side2); printf(&quot;%d\\n&quot;, dis[side2]);&#125; 2. æ ‘å½¢Dp12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e5;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int ans, d[MAXn + 10];void Dfs(int cur, int fath) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fath) continue; Dfs(to[i], cur); ans = max(ans, d[cur] + d[to[i]] + wei[i]); d[cur] = max(d[cur], d[to[i]] + wei[i]); &#125;&#125;int n;signed main() &#123; read(n); for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1, 0); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ‘çš„é‡å¿ƒ","slug":"TemLib/æ ‘çš„é‡å¿ƒ","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/æ ‘çš„é‡å¿ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/","excerpt":"","text":"P1395 ä¼šè®® 1234567891011121314151617181920212223242526int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n;bool vis[MAXn + 10]; int siz[MAXn + 10], w[MAXn + 10], cen[2];void EvaCen(int cur) &#123; vis[cur] = 1; siz[cur] = 1; w[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; EvaCen(to[i]); siz[cur] += siz[to[i]]; w[cur] = max(w[cur], siz[to[i]]); &#125; w[cur] = max(w[cur], n - siz[cur]); if (w[cur] &lt;= n / 2) &#123; cen[cen[0] != 0] = cur; &#125;&#125;EvaCen(1);","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"è½»é‡é“¾å‰–åˆ†","slug":"TemLib/æ ‘é“¾å‰–åˆ†","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ ‘é“¾å‰–åˆ†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void dfs1(int cur, int f) &#123; fa[cur] = f; dep[cur] = dep[f] + 1; siz[cur] = 1; int mxsonsiz = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; dfs1(to[i], cur); siz[cur] += siz[to[i]]; if (mxsonsiz &lt; siz[to[i]]) &#123; mxsonsiz = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int top[MAXn + 10], cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], bottom[MAXn + 10];void dfs2(int cur, int tp) &#123; top[cur] = tp; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; dfs2(hson[cur], top[cur]); &#125; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; dfs2(to[i], to[i]); &#125; bottom[cur] = cntdfs;&#125;int lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); return x;&#125;void pathmodify(int x, int y, int v) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); modify(1, nddfs[top[y]], nddfs[y], v); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); modify(1, nddfs[x], nddfs[y], v);&#125;int pathquery(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); ans += query(1, nddfs[top[y]], nddfs[y]); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); ans += query(1, nddfs[x], nddfs[y]); return ans;&#125;void subtmodify(int x, int v) &#123; modify(1, nddfs[x], bottom[x], v);&#125;int subtquery(int x) &#123; return query(1, nddfs[x], bottom[x]);&#125; Luogu ã€æ¨¡æ¿ã€‘è½»é‡é“¾å‰–åˆ†/æ ‘é“¾å‰–åˆ† ä»£ç ï¼ˆè¯¥ä»£ç ä¸å¸¦å–æ¨¡ï¼Œä¸èƒ½ ACï¼‰ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int mod;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)const int MAXnd = MAXn * 4;int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int sum[MAXnd + 10];int lzadd[MAXnd + 10];inline void putadd(int id, int v) &#123; sum[id] += len[id] * v; lzadd[id] += v;&#125;inline void pushdown(int id) &#123; if (lzadd[id]) &#123; putadd(ls, lzadd[id]); putadd(rs, lzadd[id]); lzadd[id] = 0; &#125;&#125;inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;void build(int id, int *a, int l, int r) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; if (le[id] == ri[id]) &#123; sum[id] = a[le[id]]; &#125; else &#123; build(ls, a, le[id], mid[id]); build(rs, a, mid[id] + 1, ri[id]); pushup(id); &#125;&#125;void modify(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putadd(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modify(ls, l, r, v); if (r &gt; mid[id]) modify(rs, l, r, v); pushup(id); &#125;&#125;int query(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += query(ls, l, r); if (r &gt; mid[id]) ans += query(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint head[MAXn + 10], cntnex, nex[MAXn * 2 + 10], to[MAXn * 2 + 10];inline void connect(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void dfs1(int cur, int f) &#123; fa[cur] = f; dep[cur] = dep[f] + 1; siz[cur] = 1; int mxsonsiz = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; dfs1(to[i], cur); siz[cur] += siz[to[i]]; if (mxsonsiz &lt; siz[to[i]]) &#123; mxsonsiz = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int top[MAXn + 10], cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], bottom[MAXn + 10];void dfs2(int cur, int tp) &#123; top[cur] = tp; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; dfs2(hson[cur], top[cur]); &#125; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; dfs2(to[i], to[i]); &#125; bottom[cur] = cntdfs;&#125;int lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); return x;&#125;void pathmodify(int x, int y, int v) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); modify(1, nddfs[top[y]], nddfs[y], v); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); modify(1, nddfs[x], nddfs[y], v);&#125;int pathquery(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); ans += query(1, nddfs[top[y]], nddfs[y]); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); ans += query(1, nddfs[x], nddfs[y]); return ans;&#125;void subtmodify(int x, int v) &#123; modify(1, nddfs[x], bottom[x], v);&#125;int subtquery(int x) &#123; return query(1, nddfs[x], bottom[x]);&#125;int n, m, root;int a[MAXn + 10], aidxdfs[MAXn + 10];signed main() &#123; read(n, m, root, mod); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (int i = 1, u, v; i &lt; n; ++i) &#123; read(u, v); connect(u, v); connect(v, u); &#125; dfs1(root, 0); dfs2(root, root); for (int i = 1; i &lt;= n; ++i) &#123; aidxdfs[i] = a[idxdfs[i]]; &#125; build(1, aidxdfs, 1, n); for (int i = 1, opt, x, y, v; i &lt;= m; ++i) &#123; read(opt); if (opt == 1) &#123; read(x, y, v); pathmodify(x, y, v); &#125; else if (opt == 2) &#123; read(x, y); printf(&quot;%lld\\n&quot;, pathquery(x, y)); &#125; else if (opt == 3) &#123; read(x, v); subtmodify(x, v); &#125; else &#123; read(x); printf(&quot;%lld\\n&quot;, subtquery(x)); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ ¹å·åˆ†æ²»","slug":"TemLib/æ ¹å·åˆ†æ²»","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/æ ¹å·åˆ†æ²»/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/","excerpt":"","text":"P3396 å“ˆå¸Œå†²çª 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5 + 5e4;const int MAXsqrtn = 387;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, sqrtn, m, a[MAXn + 10];int small[MAXsqrtn + 10][MAXsqrtn + 10];signed main() &#123; read(n, m); sqrtn = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); for (int j = 1; j &lt;= sqrtn; ++j) &#123; small[j][i % j] += a[i]; &#125; &#125; char opt; for (int i = 1; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, &amp;opt); if (opt == &#x27;A&#x27;) &#123; int mod, yu; read(mod, yu); if (mod &lt;= sqrtn) &#123; printf(&quot;%d\\n&quot;, small[mod][yu]); &#125; else &#123; int ans = 0; for (int i = (yu ? yu : mod); i &lt;= n; i += mod) &#123; ans += a[i]; &#125; printf(&quot;%d\\n&quot;, ans); &#125; &#125; else &#123; int idx, val; read(idx, val); for (int i = 1; i &lt;= sqrtn; ++i) &#123; small[i][idx % i] += -a[idx] + val; &#125; a[idx] = val; &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ ¼è·¯è®¡æ•°","slug":"TemLib/æ ¼è·¯è®¡æ•°","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ ¼è·¯è®¡æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%BC%E8%B7%AF%E8%AE%A1%E6%95%B0/","excerpt":"","text":"$[x,y]_{a_1,a_2\\cdots}^{b_1,b_2\\cdots}$ï¼šæ¯ä¸€æ­¥å¯ä»¥ä¸º $(1,1)$ æˆ– $(1,-1)$ï¼Œä» $(0,0)$ èµ°åˆ° $(x,y)$ï¼Œå¿…é¡»ä¸ $y=a_1,y=a_2\\cdots$ ç›¸äº¤ï¼Œä¸èƒ½ä¸ $y=b_1,y=b_2\\cdots$ ç›¸äº¤çš„è·¯å¾„æ•°ã€‚ è§„å®š $x\\ge 0,y\\ge 0$ï¼Œ$a_1\\le a_2\\le\\cdots,b_1\\le b_2\\le\\cdots$ã€‚ æ— é™åˆ¶è·¯å¾„æ•° [x,y]=\\begin{cases} 0&(x","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ¨¡æ‹Ÿé€€ç«","slug":"TemLib/æ¨¡æ‹Ÿé€€ç«","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/æ¨¡æ‹Ÿé€€ç«/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/","excerpt":"","text":"Luogu P1337 [JSOI2004]å¹³è¡¡ç‚¹ / åŠæ‰“XXX 123456789101112131415161718192021222324252627282930313233inline double calc(double x, double y) &#123;/* ... */&#125;double ansval = INF, ansx, ansy;void SA() &#123; double tem = MAXx; double nowx = rdom(-MAXx, MAXx), nowy = rdom(-MAXx, MAXx); double nowval = calc(nowx, nowy); double nexval, nexx, nexy; while (tem &gt; 1e-10) &#123; nexx = nowx + rdom(-tem, tem); nexy = nowy + rdom(-tem, tem); nexval = calc(nexx, nexy); if (nowval &gt; nexval || exp((nowval - nexval) / tem) &gt; rdom()) &#123; nowval = nexval; nowx = nexx; nowy = nexy; if (ansval &gt; nowval) &#123; ansval = nowval; ansx = nowx; ansy = nowy; &#125; &#125; tem *= 0.999; &#125;&#125;signed main() &#123; int bg1 = clock(); srand(time(0)); // ... int bg2 = clock(); SA(); int times = clock() - bg2; while (CLOCKS_PER_SEC - clock() + bg1 &gt; times + 20000) &#123; SA(); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ¬¡çŸ­è·¯","slug":"TemLib/æ¬¡çŸ­è·¯","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/æ¬¡çŸ­è·¯/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%AC%A1%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P2865 [USACO06NOV]Roadblocks G 1. Dijkstra123456789101112131415161718192021222324252627int dis[MAXn + 10], secdis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); memset(secdis, 0x3f, sizeof(secdis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second, d = -q.top().first; q.pop(); if (secdis[cur] &lt; d) continue; for (re int i = head[cur]; i; i = nex[i]) &#123; int dist = d + wei[i]; if (dis[to[i]] &gt; dist) &#123; swap(dis[to[i]], dist); q.push(make_pair(-dis[to[i]], to[i])); &#125; if (secdis[to[i]] &gt; dist) &#123; secdis[tod[i]] = dist; q.push(make_pair(-secdis[to[i]], to[i])); &#125; &#125; &#125;&#125;// mainå‡½æ•°ä¸­Dijkstra(root);printf(&quot;%d\\n&quot;, secdis[cur]); 2. Spfa1234567891011121314151617181920212223242526272829303132333435int secdis[MAXn + 10], dis[MAXn + 10];bool inque[MAXn + 10];queue&lt;int&gt; q;int tmp[4];bool update(int &amp;dis1, int &amp;secdis1, int dis2, int secdis2) &#123; tmp[0] = dis1, tmp[1] = secdis1, tmp[2] = dis2, tmp[3] = secdis2; sort(tmp, tmp + 4); unique(tmp, tmp + 4); if (dis1 != tmp[0] || secdis1 != tmp[1]) &#123; dis1 = tmp[0], secdis1 = tmp[1]; return 1; &#125; else &#123; return 0; &#125;&#125;void Spfa(int sour) &#123; memset(secdis, 0x3f, sizeof(secdis)); memset(dis, 0x3f, sizeof(dis)); dis[sour] = 0; q.push(sour); inque[sour] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (update(dis[to[i]], secdis[to[i]], dis[cur] + wei[i], secdis[cur] + wei[i])) &#123; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;// mainå‡½æ•°ä¸­Spfa(root);printf(&quot;%d\\n&quot;, secdis[cur]);","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ¬§æ‹‰è·¯å¾„","slug":"TemLib/æ¬§æ‹‰è·¯å¾„","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/æ¬§æ‹‰è·¯å¾„/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. æ— å‘å›¾æ¬§æ‹‰è·¯å¾„P2731 [USACO3.3]éª‘é©¬ä¿®æ …æ  Riding the Fences ä¹‹æ‰€ä»¥è¦ç”¨é‚»æ¥çŸ©é˜µæ˜¯å› ä¸ºä¸€æ¡è¾¹åªèƒ½èµ°ä¸€æ¬¡ï¼Œèµ°è¿‡ä¸€æ¡è¾¹è¿™æ¡è¾¹çš„å¦ä¸€ä¸ªæ–¹å‘ä¹Ÿä¸èƒ½èµ°äº†ï¼Œé‚»æ¥çŸ©é˜µä¾¿äºåˆ é™¤èµ°è¿‡çš„è¾¹çš„å¦ä¸€ä¸ªæ–¹å‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e2;const int MAXm = 1024;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, m, source = 1, edge[MAXn + 10][MAXn + 10], deg[MAXn + 10];int top, stk[MAXm * 2 + 10];void Dfs(int cur) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (edge[cur][i]) &#123; --edge[cur][i]; --edge[i][cur]; Dfs(i); &#125; &#125; stk[++top] = cur;&#125;signed main() &#123; read(m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); ++edge[u][v]; ++edge[v][u]; ++deg[u]; ++deg[v]; n = max(n, max(u, v)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (deg[i] &amp; 1) &#123; source = i; break; &#125; &#125; Dfs(source); for (int i = top; i; --i) &#123; printf(&quot;%d\\n&quot;, stk[i]); &#125;&#125; ç©ºé—´å¼€ä¸ä¸‹ $O(n^2)$ æ€ä¹ˆåŠï¼Œå¬åˆ«äººè¯´è¦ç”¨ä»€ä¹ˆå½“å‰å¼§ä¼˜åŒ–ï¼Œç•™å‘å¾…è¡¥â€¦â€¦ 2. æœ‰å‘å›¾æ¬§æ‹‰è·¯å¾„P7771 ã€æ¨¡æ¿ã€‘æ¬§æ‹‰è·¯å¾„ æœ‰å‘å›¾æ±‚æ¬§æ‹‰è·¯å¾„ï¼Œå› ä¸ºè¾¹æ²¡æœ‰å¦ä¸€ä¸ªæ–¹å‘ï¼Œæ‰€ä»¥ä¸ç”¨åˆ å¦ä¸€ä¸ªæ–¹å‘ã€‚ç›´æ¥ç”¨é‚»æ¥è¡¨å³å¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = 2e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : c ^ &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;inline bool cmp(int a, int b) &#123; return a &gt; b;&#125;vector&lt;int&gt; edge[MAXn + 10];int top, stk[MAXm + 10];void Dfs(int cur) &#123; while (!edge[cur].empty()) &#123; int to = edge[cur].back(); edge[cur].pop_back(); Dfs(to); &#125; stk[++top] = cur;&#125; int n, m;int indeg[MAXn + 10], outdeg[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); edge[u].push_back(v); ++outdeg[u]; ++indeg[v]; &#125; int cnt1 = 0, cnt2 = 0, bg = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (indeg[i] == outdeg[i] + 1) &#123; ++cnt1; &#125; else if (indeg[i] == outdeg[i] - 1) &#123; ++cnt2; bg = i; &#125; else if (indeg[i] != outdeg[i]) &#123; puts(&quot;No&quot;); return 0; &#125; &#125; if (!((cnt1 == 1 &amp;&amp; cnt2 == 1) || (cnt1 == 0 &amp;&amp; cnt2 == 0))) &#123; puts(&quot;No&quot;); return 0; &#125; if (bg == 0) &#123; bg = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; sort(begin(edge[i]), end(edge[i]), cmp); &#125; Dfs(bg); for (int i = top; i; --i) &#123; printf(&quot;%d &quot;, stk[i]); &#125; puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"æ±‚çº¦æ•°","slug":"TemLib/æ±‚çº¦æ•°","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/æ±‚çº¦æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%B1%82%E7%BA%A6%E6%95%B0/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 1234567891011121314int cntap, ap[MAXsqrtx + 10];void evaap(int x) &#123; cntap = 0; int sqrtx = ceil(sqrt(x)); for (int i = 1; i &lt; sqrtx; ++i) &#123; if (x % i == 0) &#123; ap[++cntap] = i; ap[++cntap] = x / i; &#125; &#125; if (sqrtx * sqrtx == x) &#123; ap[++cntap] = sqrtx; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"æ··åˆèƒŒåŒ…","slug":"TemLib/æ··åˆèƒŒåŒ…","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/æ··åˆèƒŒåŒ…/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1833 æ¨±èŠ±1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 10000;const int MAXW = 1000;const int INF = 0x3f3f3f3f;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];bool is_limit[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new, bool is_limit[]) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; is_limit[num_new] = 1; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; is_limit[num_new] = 1; &#125;&#125;void put_in() &#123; W = read(); n = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; w = read(); v = read(); num = read(); if (num) bin_divide(v, w, num, v_new, w_new, num_new, is_limit); else &#123; v_new[++num_new] = v; w_new[num_new] = w; is_limit[num_new] = 0; &#125; &#125;&#125;void rec(int v[], int w[], bool is_limit[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; if (is_limit[i]) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; else &#123; for (int j = w[i]; j &lt;= W; j++) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; &#125;&#125;int eva_maxV(int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v_new, w_new, is_limit, W, num_new); cout &lt;&lt; eva_maxV(W);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"ç‚¹åˆ†æ²»","slug":"TemLib/ç‚¹åˆ†æ²»","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/ç‚¹åˆ†æ²»/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%82%B9%E5%88%86%E6%B2%BB/","excerpt":"","text":"Luogu P4178 Tree ä¸å»ºè®®ä½¿ç”¨ Luogu 3806 ä½œä¸ºæ¨¡æ¿ï¼Œè¯¥é¢˜æƒ…å½¢è¿‡äºç‰¹æ®Šï¼Œåªéœ€æ‰¾åˆ°ä¸€ç»„è§£å³å¯åˆ¤æ–­ä¸º trueï¼Œå¯¼è‡´åªéå†æ ‘çš„ä¸€éƒ¨åˆ†ä¹Ÿå¯é€šè¿‡æ­¤é¢˜ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445bool vis[MAXn + 10];int cen, siz[MAXn + 10];void EvaCen(int cur, int f, int totsiz) &#123;/* ... */&#125;int cntd, d[MAXn + 10];void Dfs(int cur, int f, int dis, int tar) &#123; if (dis &gt; tar) return; d[++cntd] = dis; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == f || vis[to[i]]) continue; Dfs(to[i], cur, dis + wei[i], tar); &#125;&#125;int ans;int top, stk[MAXn + 10];void Div(int bg, int totsiz, int tar) &#123; EvaCen(bg, 0, totsiz); int c = cen; vis[c] = 1; while (top) Add(stk[top--], -1, tar); for (int i = head[c]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; cntd = 0; Dfs(to[i], c, wei[i], tar); for (int i = 1; i &lt;= cntd; ++i) &#123; ans += Sum(tar - d[i]); &#125; for (int i = 1; i &lt;= cntd; ++i) &#123; Add(d[i], 1, tar); stk[++top] = d[i]; &#125; &#125; for (int i = head[c]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; if (siz[to[i]] &lt; siz[c]) Div(to[i], siz[to[i]], tar); else Div(to[i], totsiz - siz[c], tar); &#125;&#125;signed main() &#123; // ... Add(0, 1, tar); Div(1, n, tar);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"ç‚æœµè‰æ ‘","slug":"TemLib/ç‚æœµè‰æ ‘","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/ç‚æœµè‰æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/","excerpt":"","text":"CF896C Willem, Chtholly and Seniorious 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374struct Ele &#123; int l, r; mutable int v; inline bool operator&lt;(const Ele sec) const &#123; return l &lt; sec.l; &#125;&#125;;inline bool cmpv(Ele fir, Ele sec) &#123; return fir.v &lt; sec.v;&#125;set&lt;Ele&gt; odt;inline auto Split(int p) &#123; if (p &gt; n) return end(odt); auto pit = --odt.upper_bound(Ele&#123;l: p, r: -1, v: -1&#125;); int l = pit-&gt;l, r = pit-&gt;r, v = pit-&gt;v; odt.erase(pit); if (l &lt; p) odt.insert(Ele&#123;l: l, r: p - 1, v: v&#125;); return odt.insert(Ele&#123;l: p, r: r, v: v&#125;).first;&#125;void modifySecAdd(int l, int r, int v) &#123; auto rit = Split(r + 1), lit = Split(l); for (auto i = lit; i != rit; ++i) &#123; i-&gt;v += v; &#125;&#125;void modifySecAss(int l, int r, int v) &#123; auto rit = Split(r + 1), lit = Split(l); odt.erase(lit, rit); odt.insert(Ele&#123;l: l, r: r, v: v&#125;);&#125;int cntinsec; Ele insec[MAXn + 10];int RanktoVal(int l, int r, int rk) &#123; auto rit = Split(r + 1), lit = Split(l); cntinsec = 0; for (auto i = lit; i != rit; ++i) &#123; insec[++cntinsec] = *i; &#125; sort(insec + 1, insec + 1 + cntinsec, cmpv); for (int i = 1; i &lt;= cntinsec; ++i) &#123; int len = insec[i].r - insec[i].l + 1; if (rk &lt;= len) return insec[i].v; else rk -= len; &#125; return -1;&#125;int queryPowersum(int l, int r, int y, int mod) &#123; auto rit = Split(r + 1), lit = Split(l); int ans = 0; for (auto i = lit; i != rit; ++i) &#123; ans = addmod(ans + (i-&gt;r - i-&gt;l + 1) * power(i-&gt;v % mod, y, mod) % mod, mod); &#125; return ans;&#125;signed main() &#123; // ... for (int i = 1; i &lt;= n; ++i) &#123; // ... odt.insert(Ele&#123;l: i, r: i, v: a[i]&#125;); &#125; for (int i = 1, opt, l, r, x, y; i &lt;= m; ++i) &#123; // ... if (opt == 1) &#123; modifySecAdd(l, r, x); &#125; else if (opt == 2) &#123; modifySecAss(l, r, x); &#125; else if (opt == 3) &#123; printf(&quot;%lld\\n&quot;, RanktoVal(l, r, x)); &#125; else &#123; printf(&quot;%lld\\n&quot;, queryPowersum(l, r, x, y)); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çŸ©é˜µæ±‚é€†","slug":"TemLib/çŸ©é˜µæ±‚é€†","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/çŸ©é˜µæ±‚é€†/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86/","excerpt":"","text":"Luogu P4783 ã€æ¨¡æ¿ã€‘çŸ©é˜µæ±‚é€† 1234567891011121314151617181920212223242526272829303132333435int n, n2; // n2 = n * 2int a[MAXn + 10][MAXn * 2 + 10];bool EvaInv() &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i][i + n] = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int chose = 0; for (int j = i; j &lt;= n; ++j) &#123; if (a[j][i]) &#123; chose = j; break; &#125; &#125; if (chose == 0) return 0; if (chose != i) &#123; for (int j = 1; j &lt;= n2; ++j) &#123; swap(a[i][j], a[chose][j]); &#125; &#125; int invaii = inv(a[i][i]); for (int j = i; j &lt;= n2; ++j) &#123; a[i][j] = a[i][j] * invaii % MOD; &#125; for (int j = 1; j &lt;= n; ++j) &#123; if (j == i) continue; int mul = a[j][i]; for (int k = i; k &lt;= n2; ++k) &#123; a[j][k] -= a[i][k] * mul % MOD; redmod(a[j][k]); &#125; &#125; &#125; return 1;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çŸ©é˜µè¡Œåˆ—å¼","slug":"TemLib/çŸ©é˜µè¡Œåˆ—å¼","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/çŸ©é˜µè¡Œåˆ—å¼/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F/","excerpt":"","text":"çŸ©é˜µè¡Œåˆ—å¼çš„æ€§è´¨ï¼› éæ–¹é˜µæ²¡æœ‰è¡Œåˆ—å¼ã€‚ åŸçŸ©é˜µè½¬ç½®çš„è¡Œåˆ—å¼ä¸åŸçŸ©é˜µè¡Œåˆ—å¼ç›¸åŒã€‚ åŸçŸ©é˜µæŸä¸€è¡Œï¼ˆåˆ—ï¼‰åŠ ä¸Šå¦ä¸€è¡Œï¼ˆåˆ—ï¼‰ä¹˜ä¸ŠæŸä¸€ç³»æ•° $k$ å¾—åˆ°çš„çŸ©é˜µçš„è¡Œåˆ—å¼ä¸åŸçŸ©é˜µè¡Œåˆ—å¼ç›¸ç­‰ã€‚ åŸçŸ©é˜µäº¤æ¢ä¸¤è¡Œï¼ˆåˆ—ï¼‰å¾—åˆ°çš„çŸ©é˜µçš„è¡Œåˆ—å¼ä¸åŸçŸ©é˜µè¡Œåˆ—å¼äº’ä¸ºç›¸åæ•°ã€‚ åŸçŸ©é˜µæŸä¸€è¡Œï¼ˆåˆ—ï¼‰ä¹˜ä¸Šç³»æ•° $k$ å¾—åˆ°çš„çŸ©é˜µçš„è¡Œåˆ—å¼æ˜¯åŸçŸ©é˜µè¡Œåˆ—å¼çš„ $k$ å€ã€‚ çŸ©é˜µè¡Œåˆ—å¼æœ‰ä¸¤ç§æ±‚æ³•ï¼šé€‚ç”¨äºè´¨æ•°æ¨¡æ•°çš„æ±‚æ³•ã€é€‚ç”¨äºä»»æ„æ¨¡æ•°çš„æ±‚æ³•ã€‚ æ³¨æ„äº‹é¡¹: å»ºè®®å…ˆå°è£…ä¸Šå‡ ç§è¡Œçš„æ“ä½œå‡½æ•°ï¼ˆswaprowã€redrowâ€¦â€¦ï¼‰ï¼Œå¦‚æœéœ€è¦ä¼˜åŒ–å¸¸æ•°ï¼Œè¿˜å¯ä»¥ä¼ å…¥å‚æ•° bottomj ï¼Œå˜é‡ j ä»çš„å–å€¼ä» bottomj åˆ° nï¼ˆå¦‚æœä¸ä¼ åˆ™ä» 1 å¼€å§‹ï¼‰ã€‚ è´¨æ•°æ¨¡æ•°çš„æ±‚æ³•å« bottomj ä¼˜åŒ–çš„å†™æ³•çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int n;int a[MAXn + 10][MAXn + 10];bool neg; int mul;inline void swaprow(int x, int y, int bottomj) &#123; for (int j = bottomj; j &lt;= n; ++j) &#123; swap(a[x][j], a[y][j]); &#125; neg ^= 1;&#125;inline void mulrow(int x, int v, int bottomj) &#123; for (int j = bottomj; j &lt;= n; ++j) &#123; a[x][j] = a[x][j] * v % mod; &#125; mul = mul * v % mod;&#125;inline void redrow(int x, int y, int bottomj) &#123; // x -= y for (int j = bottomj; j &lt;= n; ++j) &#123; a[x][j] = redmod(a[x][j] - a[y][j]); &#125;&#125;int det() &#123; neg = 0; mul = 1; for (int rc = 1; rc &lt;= n; ++rc) &#123; int choser = -1; for (int i = rc; i &lt;= n; ++i) &#123; if (a[i][rc]) &#123; choser = i; break; &#125; &#125; if (choser == -1) return 0; if (choser != rc) swaprow(rc, choser, rc); for (int i = rc + 1; i &lt;= n; ++i) &#123; if (a[i][rc]) &#123; mulrow(i, a[rc][rc] * inv(a[i][rc]) % mod, rc); redrow(i, rc, rc); &#125; &#125; &#125; int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans = ans * a[i][i] % mod; &#125; if (neg) ans = redmod(-ans); ans = ans * inv(mul) % mod; return ans;&#125; ä»»æ„æ¨¡æ•°çš„æ±‚æ³•å« bottomj ä¼˜åŒ–çš„å†™æ³•çš„ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243int n;int a[MAXn + 10][MAXn + 10];bool neg;inline void swaprow(int x, int y, int bottomj) &#123; for (int j = bottomj; j &lt;= n; ++j) &#123; swap(a[x][j], a[y][j]); &#125; neg ^= 1;&#125;inline void redrow(int x, int y, int v, int bottomj) &#123; // x -= y * v for (int j = bottomj; j &lt;= n; ++j) &#123; a[x][j] = redmod(a[x][j] - a[y][j] * v % mod); &#125;&#125;int det() &#123; neg = 0; for (int rc = 1; rc &lt;= n; ++rc) &#123; int choser = -1; for (int i = rc; i &lt;= n; ++i) &#123; if (a[i][rc]) &#123; choser = i; break; &#125; &#125; if (choser == -1) return 0; if (choser != rc) swaprow(rc, choser, rc); for (int i = rc + 1; i &lt;= n; ++i) &#123; if (a[i][rc]) &#123; if (a[i][rc] &gt; a[rc][rc]) swaprow(rc, i, rc); while (a[i][rc]) &#123; redrow(rc, i, a[rc][rc] / a[i][rc], rc); swaprow(rc, i, rc); &#125; &#125; &#125; &#125; int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans = ans * a[i][i] % mod; &#125; if (neg) ans = redmod(-ans); return ans;&#125; é¢˜ç›®Luogu P7112 ã€æ¨¡æ¿ã€‘è¡Œåˆ—å¼æ±‚å€¼ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 6e2;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int mod;inline int redmod(int x) &#123; return (x &lt; 0) ? x + mod : x;&#125;inline int power(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) ans = ans * x % mod; x = x * x % mod; y &gt;&gt;= 1; &#125; return ans;&#125;inline int inv(int x) &#123; return power(x, mod - 2);&#125;int n;int a[MAXn + 10][MAXn + 10];bool neg;inline void swaprow(int x, int y, int bottomj) &#123; for (int j = bottomj; j &lt;= n; ++j) &#123; swap(a[x][j], a[y][j]); &#125; neg ^= 1;&#125;inline void redrow(int x, int y, int v, int bottomj) &#123; // x -= y * v for (int j = bottomj; j &lt;= n; ++j) &#123; a[x][j] = redmod(a[x][j] - a[y][j] * v % mod); &#125;&#125;int det() &#123; neg = 0; for (int rc = 1; rc &lt;= n; ++rc) &#123; int choser = -1; for (int i = rc; i &lt;= n; ++i) &#123; if (a[i][rc]) &#123; choser = i; break; &#125; &#125; if (choser == -1) return 0; if (choser != rc) swaprow(rc, choser, rc); for (int i = rc + 1; i &lt;= n; ++i) &#123; if (a[i][rc]) &#123; if (a[i][rc] &gt; a[rc][rc]) swaprow(rc, i, rc); while (a[i][rc]) &#123; redrow(rc, i, a[rc][rc] / a[i][rc], rc); swaprow(rc, i, rc); &#125; &#125; &#125; &#125; int ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans = ans * a[i][i] % mod; &#125; if (neg) ans = redmod(-ans); return ans;&#125;signed main() &#123; read(n, mod); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; read(a[i][j]); a[i][j] %= mod; &#125; &#125; printf(&quot;%lld\\n&quot;, det()); return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çŸ©é˜µè¿ç®—","slug":"TemLib/çŸ©é˜µè¿ç®—","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/çŸ©é˜µè¿ç®—/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/","excerpt":"","text":"P3390 ã€æ¨¡æ¿ã€‘çŸ©é˜µå¿«é€Ÿå¹‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Mat &#123; int mat[MAXmat][MAXmat]; Mat() &#123; memset(mat, 0, sizeof(mat)); &#125; Mat(int a[MAXmat][MAXmat]) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = a[i][j]; &#125; &#125; &#125; inline void operator=(Mat x) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = x.mat[i][j]; &#125; &#125; &#125; inline Mat operator+(Mat x) &#123; Mat ans; for (int i = 0; i &lt; MAXmat; ++i) &#123; for (int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (mat[i][j] + x.mat[i][j]) % MOD; &#125; &#125; return ans; &#125; inline Mat operator*(Mat x) &#123; Mat ans; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int k = 0; k &lt; MAXmat; ++k) &#123; int a = mat[i][k]; for (re int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (a * x.mat[k][j] + ans.mat[i][j]) % MOD; &#125; &#125; &#125; return ans; &#125; inline Mat operator^(int x) &#123; Mat ans, base; for (re int i = 0; i &lt; MAXmat; ++i) &#123; ans.mat[i][i] = 1; &#125; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; base.mat[i][j] = mat[i][j]; &#125; &#125; while (x) &#123; if (x &amp; 1) &#123; ans = ans * base; &#125; base = base * base; x &gt;&gt;= 1; &#125; return ans; &#125;&#125;;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"ç¬›å¡å°”æ ‘","slug":"TemLib/ç¬›å¡å°”æ ‘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/ç¬›å¡å°”æ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/","excerpt":"","text":"P5854 ã€æ¨¡æ¿ã€‘ç¬›å¡å°”æ ‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 1e7;struct Node &#123; LL p; LL ls; LL rs;&#125;;Node node[MAXn + 10];LL n;LL nowid;LL stk[MAXn + 10];LL top;inline LL read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register LL s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void insert(LL p) &#123; nowid++; node[nowid].p = p; LL newtop = top; while (newtop &amp;&amp; node[stk[newtop]].p &gt; node[nowid].p) newtop--; if (newtop) node[stk[newtop]].rs = nowid; if (newtop &lt; top) node[nowid].ls = stk[newtop + 1]; stk[++newtop] = nowid; top = newtop;&#125;int main() &#123; n = read(); LL p; for (LL i = 0; i &lt; n; i++) &#123; p = read(); insert(p);/*è¿™é‡Œ insert çš„æ•°å­—çš„å€¼(p)æ²¡æœ‰å•è°ƒçš„è¦æ±‚ï¼Œ ä½†æ•°å­—çš„æ ‡å·(id)è¦æ±‚å•å¢ï¼Œè‹¥ä¸å•å¢è¦å…ˆæ’åº*/ &#125; for (LL i = 1; i &lt;= n; i++) &#123; printf(&quot;%lld %lld %lld\\n&quot;, node[i].p, node[i].ls, node[i].rs); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ€§åŸº","slug":"TemLib/çº¿æ€§åŸº","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/çº¿æ€§åŸº/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E5%9F%BA/","excerpt":"","text":"Acwing 3164. çº¿æ€§åŸº è¿™é‡Œæ¨è Acwing ä¸Šçš„çº¿æ€§åŸºæ¨¡æ¿ã€‚luogu ä¸Šçš„æ¨¡æ¿æ•°æ®èŒƒå›´å¤ªå°äº†ã€‚ è¿™é‡Œçš„æ±‚çº¿æ€§åŸºæ˜¯æ±‚ä¸€ç§ç‰¹æ®Šçš„çº¿æ€§åŸºï¼šæŠŠæ¯ä¸ªæ•°åœ¨äºŒè¿›åˆ¶ä¸‹çš„æ¯ä¸€ä½çœ‹åšä¸€ä¸ª $0/1$ åˆ†å‘é‡ï¼Œæ¯ä¸ªæ•°è¡¨ç¤ºä¸€ä¸ªå‘é‡ï¼Œä¸€ä¸ªæ•°ç»„å°±æ˜¯ä¸€ä¸ªå‘é‡ç»„ã€‚æ±‚è¿™ä¸ªå‘é‡ç»„çš„çº¿æ€§åŸºã€‚ 1. é«˜æ¶ˆæ³•ç”Ÿæˆçš„çº¿æ€§åŸºæ‹¥æœ‰çš„æ€§è´¨ï¼š æ˜¯åŸå‘é‡ç»„çš„çº¿æ€§åŸºåºŸè¯ çº¿æ€§åŸºå†…æ‰€æœ‰æ•°åœ¨äºŒè¿›åˆ¶ä¸‹ä¼šæ„æˆä¸Šä¸‰è§’ç»“æ„ï¼ˆé‡è¦æ€§è´¨ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXm = 64;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline bool deg(int num, int deg) &#123; return num &amp; (1ll &lt;&lt; deg);&#125;int n;int a[MAXn + 10];signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; int row = 1; for (int col = MAXm - 1; ~col &amp;&amp; row &lt;= n; --col) &#123; for (int i = row; i &lt;= n; ++i) &#123; if (deg(a[i], col)) &#123; swap(a[row], a[i]); break; &#125; &#125; if (!deg(a[row], col)) continue; for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (deg(a[i], col)) &#123; a[i] ^= a[row]; &#125; &#125; ++row; &#125; int ans = 0; for (int i = 1; i &lt; row; ++i) &#123; ans ^= a[i]; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; æä¾›ä¸€ç»„æ ·ä¾‹ï¼š 1210681519689123291 153992348230057 352917520953222 379410980430607 333284887124912 596782649548897 1004880543767517 258503666829624 353486948696275 244563245470691 äºŒè¿›åˆ¶è¡¨ç¤ºï¼š 1234567891010011010111101011010101010111110100100010111011011001000110000001110001000110011011011100001101010010101000000111110100000001101111000101011111000011001010110010001001010000000101101100110001100001111010010111100011110111011110100111001011011101100001000011110110001010100100111010101101000000110000111100100011110111011111011110110100101101111011101001110101100011011100100110011110000001001001110000101000001011111101001100000000010100000001101001100110111100110110111010001010111110001001111100011 ç”Ÿæˆçš„çº¿æ€§åŸºï¼š 1234567891010000001000011001001000110110011001011000111101101010000000000111010000111011110111011000111000100000010000100010110101100000011010000011010101111100100010000000110010110100001010011001111111101100001000010010001101111100111011001000111001010111101010000010000001110001111101101010010011010001000110000000010000101010011100011111001101000101101010000000000001000111110101010000111011101100101101001110000000001001000010010010010100000101110001010001000000000001010010110111111110110101001011111110111 å¯ä»¥çœ‹åˆ°ç¡®å®æ˜¯ä¸Šä¸‰è§’ç»“æ„ã€‚ 2. è´ªå¿ƒæ³•ç”Ÿæˆçš„çº¿æ€§åŸºä¸å…·æœ‰æ€§è´¨ 2ã€‚ æ‰€ä»¥è¿™ç§æ–¹æ³•ç”Ÿæˆçš„çº¿æ€§åŸºä¸èƒ½å¤„ç†ä¸€äº›é—®é¢˜ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;const int MAXm = 64;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline int degll(int num, int deg) &#123; return num &amp; (1ll &lt;&lt; deg);&#125;inline int maxdegll(int num) &#123; return 63 - __builtin_clzl(num);&#125;int n;int num[MAXm + 10];signed main() &#123; read(n); for (int i = 1, a, mxdeg; i &lt;= n; ++i) &#123; read(a); while (a) &#123; mxdeg = maxdegll(a); if (num[mxdeg]) &#123; a ^= num[mxdeg]; &#125; else &#123; num[mxdeg] = a; break; &#125; &#125; &#125; int ans = 0; for (int i = MAXm - 1; ~i; --i) &#123; if (!degll(ans, i)) &#123; ans ^= num[i]; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; ç”Ÿæˆçš„çº¿æ€§åŸºï¼š 1234567891010011010111101011010101010111110100100010111011011010100000011111010000000110111100010101111100001100010001100000011100010001100110110111000011010100100011011111110010011101100001101101111010000110110000011011011001100011100010110111001010000001010010000011001111010001000001111001110110011001000100100000010001111000101011100001111000001110010100111000000001100011111100011001101011111011101000001010000000001100001001001101101111010001011110101010100000000001010010110111111110110101001011111110111 è€Œä¸”æ³¨æ„è¿™ç§æ–¹æ³•ç”Ÿæˆçš„çº¿æ€§åŸºå­˜åœ¨ num æ•°ç»„é‡Œçš„æ—¶å€™ä¸æ˜¯è¿ç»­çš„ï¼Œå¦‚æœåˆ å» 41 è¡Œ if (!degll(ans, i)) çš„è¯è¾“å‡ºçš„æ˜¯ï¼š 12345678910111001101011110101101010101011111010010001011101101101010000001111101000000011011110001010111110000110001000110000001110001000110011011011100001101010010001101111111001001110110000110110111101000011011000001101101100110001110001011011100101000000101001000001100111101000100000111100111011001100100010010000001000111100010101110000111100000111001010011100000000000000000000000000000000000000000000000000000000001100011111100011001101011111011101000001010000000001100001001001101101111010001011110101010100000000001010010110111111110110101001011111110111","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ€§æ±‚åŒºé—´æ¬§æ‹‰å‡½æ•°","slug":"TemLib/çº¿æ€§æ±‚åŒºé—´æ¬§æ‹‰å‡½æ•°","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/çº¿æ€§æ±‚åŒºé—´æ¬§æ‹‰å‡½æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 123456789101112131415161718192021bool notpr[MAXn + 10]; int cntpr, pr[MAXn / 10 + 100];int ola[MAXn + 10];void evaola(int n) &#123; notpr[1] = 1; ola[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; ola[i] = i - 1; &#125; for (int j = 1, topprj = n / i; j &lt;= cntpr &amp;&amp; pr[j] &lt;= topprj; ++j) &#123; notpr[i * pr[j]] = 1; if (i % pr[j]) &#123; ola[i * pr[j]] = ola[i] * (pr[j] - 1); &#125; else &#123; ola[i * pr[j]] = ola[i] * pr[j]; break; &#125; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ€§æ±‚åŒºé—´è«æ¯”ä¹Œæ–¯å‡½æ•°","slug":"TemLib/çº¿æ€§æ±‚åŒºé—´è«æ¯”ä¹Œæ–¯å‡½æ•°","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/çº¿æ€§æ±‚åŒºé—´è«æ¯”ä¹Œæ–¯å‡½æ•°/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 123456789101112131415161718192021bool notpr[MAXn + 10]; int cntpr, pr[MAXn + 10];int mob[MAXn + 10];void evamob(int n) &#123; notpr[1] = 1; mob[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; mob[i] = -1; &#125; for (int j = 1, topprj = n / i; j &lt;= cntpr &amp;&amp; pr[j] &lt;= topprj; ++j) &#123; notpr[i * pr[j]] = 1; if (i % pr[j]) &#123; mob[i * pr[j]] = -mob[i]; &#125; else &#123; mob[i * pr[j]] = 0; break; &#125; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ€§æ±‚åŒºé—´é€†å…ƒ","slug":"TemLib/çº¿æ€§æ±‚åŒºé—´é€†å…ƒ","date":"un44fin44","updated":"un33fin33","comments":true,"path":"1970/01/01/TemLib/çº¿æ€§æ±‚åŒºé—´é€†å…ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E9%80%86%E5%85%83/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 1234567int inv[MAXn + 10];void evainv(int n) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; ++i)&#123; inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD; &#125;&#125; Luogu P3811 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 3e6;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int mod;int inv[MAXn + 10];void evainv(int n) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; ++i)&#123; inv[i] = (mod - mod / i) * inv[mod % i] % mod; &#125;&#125;int n;signed main() &#123; read(n, mod); evainv(n); for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%lld\\n&quot;, inv[i]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ€§ç­›","slug":"TemLib/çº¿æ€§ç­›","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/çº¿æ€§ç­›/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E7%AD%9B/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 12345678910111213bool notpr[MAXn + 10]; int cntpr, pr[MAXn / 10 + 100];void evapr(int n) &#123; notpr[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; &#125; for (int j = 1, toppj = n / i; j &lt;= cntpr &amp;&amp; pr[j] &lt;= toppj; ++j) &#123; notpr[i * pr[j]] = 1; if (i % pr[j] == 0) break; &#125; &#125;&#125; Luogu P3383 ã€æ¨¡æ¿ã€‘çº¿æ€§ç­›ç´ æ•° ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e8;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;bool notpr[MAXn + 10]; int cntpr, pr[MAXn / 10 + 100];void evapr(int n) &#123; notpr[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (notpr[i] == 0) &#123; pr[++cntpr] = i; &#125; for (int j = 1, toppj = n / i; j &lt;= cntpr &amp;&amp; pr[j] &lt;= toppj; ++j) &#123; notpr[i * pr[j]] = 1; if (i % pr[j] == 0) break; &#125; &#125;&#125;int n, m;signed main() &#123; read(n, m); evapr(n); for (int i = 1, x; i &lt;= m; ++i) &#123; read(x); printf(&quot;%d\\n&quot;, pr[x]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ®µæ ‘","slug":"TemLib/çº¿æ®µæ ‘","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/çº¿æ®µæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 11. æ— æ‡’æ ‡è®° Update 2022-01-06: è‰ï¼Œä»Šå¤©æ¥ç¿»çœ‹æˆ‘çš„è€æ–‡ç« ï¼Œçªç„¶å‘ç°æˆ‘è¿˜å†™è¿‡ä¸€ä¸ªæ— æ‡’æ ‡è®°çš„çº¿æ®µæ ‘ã€‚å°±ä¸åˆ äº†ï¼Œç•™ä¸ªçºªå¿µã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] = sum[id] + k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125; 2. æœ‰æ‡’æ ‡è®°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], add[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;inline void pushdown(int id) &#123; sum[ls] = sum[ls] + add[id] * (ri[ls] - le[ls] + 1); sum[rs] = sum[rs] + add[id] * (ri[rs] - le[rs] + 1); add[ls] = add[ls] + add[id]; add[rs] = add[rs] + add[id]; add[id] = 0;&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] = sum[id] + k * (ri[id] - le[id] + 1); add[id] = add[id] + k; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾","slug":"TemLib/çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/çº¿æ®µæ ‘ä¼˜åŒ–å»ºå›¾/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define re registerconst int MAXn = 5e5;const int MAXm = 1e5;const int MAXedge = 3e7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn * 11 + 10], cntnex, nex[MAXedge + 10], to[MAXedge + 10]; bool wei[MAXedge + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, root;struct Node&#123; int l, r, idx;&#125;out[MAXn * 4 + 10], in[MAXn * 4 + 10];int cntnd;void BuildOut(int id, int l, int r) &#123; out[id].idx = ++cntnd; out[id].l = l; out[id].r = r; if (l == r) &#123; Insert(l, out[id].idx, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildOut(id &lt;&lt; 1, l, mid); BuildOut((id &lt;&lt; 1) + 1, mid + 1, r); Insert(out[id &lt;&lt; 1].idx, out[id].idx, 0); Insert(out[(id &lt;&lt; 1) + 1].idx, out[id].idx, 0);&#125;void BuildIn(int id, int l, int r) &#123; in[id].idx = ++cntnd; in[id].l = l; in[id].r = r; if (l == r) &#123; Insert(in[id].idx, 10 * n + l, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildIn(id &lt;&lt; 1, l, mid); BuildIn((id &lt;&lt; 1) + 1, mid + 1, r); Insert(in[id].idx, in[id &lt;&lt; 1].idx, 0); Insert(in[id].idx, in[(id &lt;&lt; 1) + 1].idx, 0);&#125;int cntqin, qin[MAXn + 10], cntqout, qout[MAXn + 10];void GetSecIn(int id, int l, int r) &#123; if (in[id].l &gt;= l &amp;&amp; in[id].r &lt;= r) &#123; qin[++cntqin] = in[id].idx; return; &#125; int mid = (in[id].l + in[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecIn(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecIn((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void GetSecOut(int id, int l, int r) &#123; if (out[id].l &gt;= l &amp;&amp; out[id].r &lt;= r) &#123; qout[++cntqout] = out[id].idx; return; &#125; int mid = (out[id].l + out[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecOut(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecOut((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void InsertSec(int l1, int r1, int l2, int r2) &#123; cntqin = cntqout = 0; GetSecOut(1, l2, r2); GetSecIn(1, l1, r1); for (re int i = 1; i &lt;= cntqout; ++i) &#123; for (re int j = 1; j &lt;= cntqin; ++j) &#123; Insert(qout[i], qin[j], 1); &#125; &#125;&#125;bool vis[MAXn * 11 + 10]; int dis[MAXn * 11 + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int main() &#123; read(n), read(m), read(root); cntnd = n; BuildOut(1, 1, n); BuildIn(1, 1, n); for (re int i = 1, l1, r1, l2, r2; i &lt;= m; ++i) &#123; read(l1), read(r1), read(l2), read(r2); InsertSec(l1, r1, l2, r2); InsertSec(l2, r2, l1, r1); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; Insert(i, 10 * n + i, 0); Insert(10 * n + i, i, 0); &#125; Dijkstra(root); for (re int i = 10 * n + 1; i &lt;= 11 * n; ++i) &#123; printf(&quot;%d\\n&quot;, dis[i]); &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"çº¿æ®µæ ‘åˆ†è£‚","slug":"TemLib/çº¿æ®µæ ‘åˆ†è£‚","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/çº¿æ®µæ ‘åˆ†è£‚/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E8%A3%82/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š å»ºè®®å°†çº¿æ®µæ ‘åˆ†è£‚çš„å‡½æ•° int split(id, p, le, ri) å®ç°ä¸ºåˆ†è£‚æˆ $[1,p]$ å’Œ $(p,n]$ ä¸¤æ£µçº¿æ®µæ ‘ï¼Œä¸” $[1,p]$ è¿™ä¸€æ£µçš„æ ¹ä»ä¸º idï¼Œ$(p,n]$ è¿™ä¸€æ£µçš„æ ¹ä¸ºè¿”å›å€¼ã€‚ ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031int split(int id, int p, int le, int ri) &#123; if (id == 0) return 0; int nwid = ++cntnd; if (le == ri) &#123; ; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) &#123; rs[nwid] = rs[id]; rs[id] = 0; ls[nwid] = split(ls[id], p, le, mid); &#125; else &#123; rs[nwid] = split(rs[id], p, mid + 1, ri); &#125; pushup(id); pushup(nwid); &#125; return nwid;&#125;int Split(int &amp;rootid, int l, int r) &#123; int lid, mdid, rid; rid = split(rootid, r, 1, n); if (l == 1) &#123; mdid = rootid; lid = 0; &#125; else &#123; mdid = split(rootid, l - 1, 1, n); lid = rootid; &#125; rootid = merge(lid, rid, 1, n); return mdid;&#125; Luogu P5494 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘åˆ†è£‚ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e5;const int MAXlayn = 19;const int MAXm = 2e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;const int MAXnd = MAXn * 4 + MAXm * MAXlayn * 2;int cntroot, root[MAXm + 10];int cntnd, ls[MAXnd + 10], rs[MAXnd + 10];int sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int build(int *a, int le, int ri) &#123; int id = ++cntnd; if (le == ri) &#123; sum[id] = a[le]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id] = build(a, le, mid); rs[id] = build(a, mid + 1, ri); pushup(id); &#125; return id;&#125;void modify(int &amp;id, int p, int v, int le, int ri) &#123; if (id == 0) id = ++cntnd; if (le == ri) &#123; sum[id] += v; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) modify(ls[id], p, v, le, mid); else modify(rs[id], p, v, mid + 1, ri); pushup(id); &#125;&#125;int query1(int id, int l, int r, int le, int ri) &#123; if (id == 0) return 0; if (le &gt;= l &amp;&amp; ri &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += query1(ls[id], l, r, le, mid); if (r &gt; mid) ans += query1(rs[id], l, r, mid + 1, ri); return ans; &#125;&#125;int query2(int id, int rk, int le, int ri) &#123; if (le == ri) &#123; return le; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (rk &lt;= sum[ls[id]]) &#123; return query2(ls[id], rk, le, mid); &#125; else &#123; return query2(rs[id], rk - sum[ls[id]], mid + 1, ri); &#125; &#125;&#125;int merge(int id1, int id2, int le, int ri) &#123; if (id1 == 0 || id2 == 0) return id1 + id2; if (le == ri) &#123; sum[id1] += sum[id2]; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id1] = merge(ls[id1], ls[id2], le, mid); rs[id1] = merge(rs[id1], rs[id2], mid + 1, ri); pushup(id1); &#125; return id1;&#125;int split(int id, int p, int le, int ri) &#123; if (id == 0) return 0; int nwid = ++cntnd; if (le == ri) &#123; ; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) &#123; rs[nwid] = rs[id]; rs[id] = 0; ls[nwid] = split(ls[id], p, le, mid); &#125; else &#123; rs[nwid] = split(rs[id], p, mid + 1, ri); &#125; pushup(id); pushup(nwid); &#125; return nwid;&#125;int n, m;int a[MAXn + 10];int Query2(int rootid, int rk) &#123; if (rk &gt; sum[rootid]) return -1; return query2(rootid, rk, 1, n);&#125;int Split(int &amp;rootid, int l, int r) &#123; int lid, mdid, rid; rid = split(rootid, r, 1, n); if (l == 1) &#123; mdid = rootid; lid = 0; &#125; else &#123; mdid = split(rootid, l - 1, 1, n); lid = rootid; &#125; rootid = merge(lid, rid, 1, n); return mdid;&#125;signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; root[++cntroot] = build(a, 1, n); for (int i = 1, opt, ver, x, y; i &lt;= m; ++i) &#123; read(opt, ver); if (opt == 0) &#123; read(x, y); root[++cntroot] = Split(root[ver], x, y); &#125; else if (opt == 1) &#123; read(x); root[ver] = merge(root[ver], root[x], 1, n); &#125; else if (opt == 2) &#123; read(x, y); modify(root[ver], y, x, 1, n); &#125; else if (opt == 3) &#123; read(x, y); printf(&quot;%lld\\n&quot;, query1(root[ver], x, y, 1, n)); &#125; else &#123; read(x); printf(&quot;%lld\\n&quot;, Query2(root[ver], x)); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"çº¿æ®µæ ‘åˆå¹¶","slug":"TemLib/çº¿æ®µæ ‘åˆå¹¶","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/çº¿æ®µæ ‘åˆå¹¶/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼šæ— ã€‚ ä»£ç ï¼š 123456789101112int merge(int id1, int id2, int le, int ri) &#123; if (id1 == 0 || id2 == 0) return id1 + id2; if (le == ri) &#123; // ...ï¼ˆåˆå¹¶æ ¹èŠ‚ç‚¹ï¼‰ &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id1] = merge(ls[id1], ls[id2], le, mid); rs[id1] = merge(rs[id1], rs[id2], mid + 1, ri); pushup(id1); &#125; return id1;&#125; Luogu P4556 [Vaniæœ‰çº¦ä¼š]é›¨å¤©çš„å°¾å·´ /ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘åˆå¹¶ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = 1e5;const int MAXz = 1e5;const int MAXlayz = 18;const int NINF = 0xc0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXn * 2 + 10], to[MAXn * 2 + 10];inline void connect(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void dfs1(int cur, int f) &#123; fa[cur] = f; dep[cur] = dep[f] + 1; siz[cur] = 1; int mxsonsiz = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; dfs1(to[i], cur); siz[cur] += siz[to[i]]; if (mxsonsiz &lt; siz[to[i]]) &#123; mxsonsiz = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10];void dfs2(int cur, int tp) &#123; top[cur] = tp; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; dfs2(hson[cur], top[cur]); &#125; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; dfs2(to[i], to[i]); &#125;&#125;int lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) swap(x, y); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); return x;&#125;struct Ele &#123; int z, opt;&#125;;vector&lt;Ele&gt; ndele[MAXn + 10];struct Info &#123; int cnt, idx; inline bool operator&gt;(const Info sec) const &#123; if (cnt != sec.cnt) return cnt &gt; sec.cnt; else return idx &lt; sec.idx; &#125; inline Info operator+(const Info sec) const &#123; return Info&#123;cnt + sec.cnt, idx&#125;; &#125;&#125;;inline Info max(Info fir, Info sec) &#123; return (fir &gt; sec) ? fir : sec;&#125;const int MAXnd = MAXm * 4 * MAXlayz;int root[MAXn + 10];int cntnd, ls[MAXnd + 10], rs[MAXnd + 10];Info info[MAXnd + 10];inline void pushup(int id) &#123; info[id] = max(info[ls[id]], info[rs[id]]);&#125;void modify(int &amp;id, int p, int v, int le, int ri) &#123; if (id == 0) id = ++cntnd; if (le == ri) &#123; info[id].idx = le; info[id].cnt += v; if (info[id].cnt == 0) info[id] = Info&#123;0, 0&#125;; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; if (p &lt;= mid) modify(ls[id], p, v, le, mid); else modify(rs[id], p, v, mid + 1, ri); pushup(id); &#125;&#125;int merge(int id1, int id2, int le, int ri) &#123; if (id1 == 0 || id2 == 0) return id1 + id2; if (le == ri) &#123; info[id1] = info[id1] + info[id2]; if (info[id1].cnt == 0) info[id1] = Info&#123;0, 0&#125;; &#125; else &#123; int mid = (le + ri) &gt;&gt; 1; ls[id1] = merge(ls[id1], ls[id2], le, mid); rs[id1] = merge(rs[id1], rs[id2], mid + 1, ri); pushup(id1); &#125; return id1;&#125;int mxz;int ans[MAXn + 10];void dfs3(int cur) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; dfs3(to[i]); root[cur] = merge(root[cur], root[to[i]], 1, mxz); &#125; for (auto i: ndele[cur]) &#123; modify(root[cur], i.z, i.opt, 1, mxz); &#125; ans[cur] = info[root[cur]].idx;&#125;int n, m;signed main() &#123; read(n, m); for (int i = 1, u, v; i &lt; n; ++i) &#123; read(u, v); connect(u, v); connect(v, u); &#125; dfs1(1, 0); dfs2(1, 1); for (int i = 1, x, y, z; i &lt;= m; ++i) &#123; read(x, y, z); mxz = max(mxz, z); int lcaa = lca(x, y); ndele[x].push_back(Ele&#123;z, 1&#125;); ndele[y].push_back(Ele&#123;z, 1&#125;); ndele[lcaa].push_back(Ele&#123;z, -1&#125;); if (fa[lcaa]) ndele[fa[lcaa]].push_back(Ele&#123;z, -1&#125;); &#125; dfs3(1); for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"è«é˜Ÿ","slug":"TemLib/è«é˜Ÿ","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/è«é˜Ÿ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%8E%AB%E9%98%9F/","excerpt":"","text":"å¤æ‚åº¦åˆ†æ$a$ï¼šå—é•¿ï¼Œ$n$ï¼šæ•°ç»„é•¿åº¦ï¼Œ$m$ï¼šè¯¢é—®ä¸ªæ•°ï¼Œ$t$ï¼šä¿®æ”¹ä¸ªæ•°ã€‚ æ™®é€šè«é˜ŸLuogu P1494 [å›½å®¶é›†è®­é˜Ÿ]å°Zçš„è¢œå­ å„æŒ‡é’ˆå¤æ‚åº¦ï¼ˆä»ä¸Šå¾€ä¸‹ä¾æ¬¡ä»£è¡¨å·¦ç«¯ç‚¹ï¼Œå³ç«¯ç‚¹ï¼Œæ—¶é—´ç‚¹çš„ç§»åŠ¨æ¬¡æ•°ï¼‰ am+n\\\\ ~~~~~~~~~~~~~~~~~~~n\\times\\dfrac{n}{a}\\\\ æœ€ä¼˜å—é•¿ï¼ˆ$n$ï¼Œ$m$ï¼Œ$t$ åŒé˜¶æƒ…å†µä¸‹ï¼‰ \\dfrac{n}{\\sqrt{m}}\\\\ å¸¦ä¿®è«é˜ŸLuogu P1903 [å›½å®¶é›†è®­é˜Ÿ]æ•°é¢œè‰² / ç»´æŠ¤é˜Ÿåˆ— å„æŒ‡é’ˆå¤æ‚åº¦ am+n\\\\ ~~~~~~~~~am+n\\times\\dfrac{n}{a}\\\\ ~~~~~~~~~~~~~~~~~~~~~~~~~~t\\times\\left(\\dfrac{n}{a}\\right)^2 æœ€ä¼˜å—é•¿ n^{\\frac{2}{3}}\\\\ å›æ»šè«é˜ŸAT1219 æ­´å²ã®ç ”ç©¶ å„æŒ‡é’ˆå¤æ‚åº¦ am\\\\ ~~~~~~~~~~~~~~~~~~~~~n\\times\\dfrac{n}{a}\\\\ æœ€ä¼˜å—é•¿ \\dfrac{n}{\\sqrt{m}}\\\\ æ ‘ä¸Šè«é˜ŸSP10707 COT2 - Count on a tree II å¤æ‚åº¦ä¸ç›¸å½“äºæ™®é€šè«é˜Ÿã€‚ äºŒæ¬¡ç¦»çº¿è«é˜ŸLuogu P4887 ã€æ¨¡æ¿ã€‘è«é˜ŸäºŒæ¬¡ç¦»çº¿ï¼ˆç¬¬åå››åˆ†å—(å‰ä½“)ï¼‰ å¤æ‚åº¦ä¸ç›¸å½“äºæ™®é€šè«é˜Ÿçš„å¤æ‚åº¦åŠ ä¸ŠäºŒæ¬¡ç¦»çº¿çš„å¤æ‚åº¦ã€‚ ä»£ç æ™®é€šè«é˜Ÿ12345678910111213141516171819202122232425262728293031int lenpart, inpart[MAXn + 10];void EvaInpart(int n, int m) &#123; lenpart = ceil((double)n / sqrt(ceil((double)m))); for (int i = 1; i &lt;= n; ++i) &#123; inpart[i] = i / lenpart; &#125;&#125;struct Query &#123; int l, r, id; inline bool operator&lt;(const Query sec) const &#123; if (inpart[l] == inpart[sec.l]) &#123; return inpart[l] &amp; 1 ? r &lt; sec.r : sec.r &lt; r; &#125; return l &lt; sec.l; &#125;&#125; que[MAXm + 10];int n, m, a[MAXn + 10];int sum, buc[MAXc + 10], ans[MAXm + 10];inline void add(int v) &#123;/* ... */&#125;inline void del(int v) &#123;/* ... */&#125;void Mocap() &#123; for (int i = 1, l = 1, r = 0; i &lt;= m; ++i) &#123; while (l &gt; que[i].l) add(a[--l]); while (r &lt; que[i].r) add(a[++r]); while (l &lt; que[i].l) del(a[l++]); while (r &gt; que[i].r) del(a[r--]); // è®°å½•ç­”æ¡ˆ &#125;&#125; å¸¦ä¿®è«é˜Ÿ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int lenpart, inpart[MAXn + 10];void EvaInpart(int n) &#123; lenpart = ceil((double)cbrt((double)n) * cbrt((double)n)); for (int i = 1; i &lt;= n; ++i) &#123; inpart[i] = i / lenpart; &#125;&#125;struct Query &#123; int l, r, t, idx; inline bool operator&lt;(const Query sec) const &#123; if (inpart[l] == inpart[sec.l]) &#123; if (inpart[r] == inpart[sec.r]) &#123; return t &lt; sec.t; &#125; return inpart[l] &amp; 1 ? r &lt; sec.r : sec.r &lt; r; &#125; return l &lt; sec.l; &#125;&#125; que[MAXquery + 10]; int cntque;struct Change &#123; int p, v;&#125; cha[MAXchange + 10]; int cntcha;int n, m, a[MAXn + 10];int buc[MAXcolor + 10], res;int ans[MAXn + 10];inline void add(int v) &#123;/* ... */&#125;inline void del(int v) &#123;/* ... */&#125;void Mocap() &#123; for (int i = 1, l = 1, r = 0, t = 0; i &lt;= cntque; ++i) &#123; while (que[i].l &lt; l) add(a[--l]); while (que[i].r &gt; r) add(a[++r]); while (que[i].l &gt; l) del(a[l++]); while (que[i].r &lt; r) del(a[r--]); while (que[i].t &gt; t) &#123; if (cha[t + 1].p &gt;= l &amp;&amp; cha[t + 1].p &lt;= r) &#123; del(a[cha[t + 1].p]); add(cha[t + 1].v); &#125; swap(a[cha[t + 1].p], cha[t + 1].v); ++t; &#125; while (que[i].t &lt; t) &#123; if (cha[t].p &gt;= l &amp;&amp; cha[t].p &lt;= r) &#123; del(a[cha[t].p]); add(cha[t].v); &#125; swap(a[cha[t].p], cha[t].v); --t; &#125; ans[que[i].idx] = res; &#125;&#125; å›æ»šè«é˜Ÿ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int lenpart, inpart[MAXn + 10];void EvaInpart(int n, int m) &#123; lenpart = ceil((double)n / sqrt((double)m)); for (int i = 1; i &lt;= n; ++i) &#123; inpart[i] = i / lenpart; &#125;&#125;int n, m, a[MAXn + 10];int cntmap, mapup[MAXn + 10]; map&lt;int, int&gt; mapdown;struct Query &#123; int l, r, idx; inline bool operator&lt;(const Query sec) const &#123; if (inpart[l] == inpart[sec.l]) &#123; return r &lt; sec.r; &#125; return l &lt; sec.l; &#125;&#125; que[MAXm + 10];int buc[MAXn + 10], res, ans[MAXm + 10];inline void add(int v) &#123;/* ... */&#125;void Mocap() &#123; for (int i = 1, j = 1; i &lt;= m; i = j) &#123; while (j &lt;= m &amp;&amp; inpart[que[i].l] == inpart[que[j].l]) ++j; int k = i; for (; k &lt; j; ++k) &#123; if (inpart[que[k].l] == inpart[que[k].r]) &#123; for (int p = que[k].l; p &lt;= que[k].r; ++p) add(a[p]); ans[que[k].idx] = res; for (int p = que[k].l; p &lt;= que[k].r; ++p) --buc[a[p]]; res = 0; &#125; else break; &#125; for (int r = inpart[que[i].l] * lenpart + lenpart - 1; k &lt; j; ++k) &#123; if (inpart[que[k].l] != inpart[que[k].r]) &#123; while (r &lt; que[k].r) add(a[++r]); int backup = res; for (int l = inpart[que[i].l] * lenpart + lenpart - 1; l &gt;= que[k].l; --l) add(a[l]); ans[que[k].idx] = res; for (int l = inpart[que[i].l] * lenpart + lenpart - 1; l &gt;= que[k].l; --l) --buc[a[l]]; res = backup; &#125; &#125; memset(buc, 0, sizeof(buc)); res = 0; &#125;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"è™šæ ‘","slug":"TemLib/è™šæ ‘","date":"un44fin44","updated":"un11fin11","comments":true,"path":"1970/01/01/TemLib/è™šæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%99%9A%E6%A0%91/","excerpt":"","text":"Luogu P2495 [SDOI2011]æ¶ˆè€—æˆ˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243inline bool cmp(int a, int b) &#123; return nddfs[a] &lt; nddfs[b];&#125;int cntkey, key[MAXn + 10];int cntuse, use[MAXn + 10];int top, stk[MAXn + 10];void InitAdj() &#123; while (cntuse) &#123; l2.head[use[cntuse--]] = 0; &#125; l2.cntnex = 0;&#125;void EvaVirTree() &#123; InitAdj(); sort(key + 1, key + 1 + cntkey, cmp); stk[++top] = 1; use[++cntuse] = 1; for (int i = 1; i &lt;= cntkey; ++i) &#123; int lca = Lca(key[i], stk[top]); for (int j = top; j; --j) &#123; if (nddfs[stk[j]] &lt;= nddfs[lca]) &#123; for (; top &gt; j + 1; --top) &#123; Insert(stk[top - 1], stk[top]); &#125; if (top == j + 1) &#123; Insert(lca, stk[top]); --top; &#125; if (stk[j] != lca) &#123; stk[++top] = lca; use[++cntuse] = lca; &#125; stk[++top] = key[i]; use[++cntuse] = key[i]; break; &#125; &#125; &#125; for (; top &gt; 1; --top) &#123; Insert(stk[top - 1], stk[top]); &#125; --top;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"è´¹é©¬å°å®šç†æ±‚é€†å…ƒ","slug":"TemLib/è´¹é©¬å°å®šç†æ±‚é€†å…ƒ","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/è´¹é©¬å°å®šç†æ±‚é€†å…ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒæ­¤é¢˜ä¸æ˜¯æ±‚å•ä¸ªé€†å…ƒçš„æ¨¡æ¿é¢˜ï¼Œä½†å¯ä»¥ç”¨è¿™é“æ¨¡æ¿é¢˜æ£€éªŒè¿™ç§æ±‚é€†æ–¹æ³•çš„æ­£ç¡®æ€§ï¼ˆæ²¡æœ‰WAï¼‰ 123456789101112131415inline int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = (1LL * ans * x) % mod; &#125; y &gt;&gt;= 1; x = (1LL * x * x) % mod; &#125; return ans;&#125;int inv(int n, int mod) &#123; return power(n, mod - 2, mod);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"é‚»æ¥è¡¨","slug":"TemLib/é‚»æ¥è¡¨","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/é‚»æ¥è¡¨/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%82%BB%E6%8E%A5%E8%A1%A8/","excerpt":"","text":"12345678910#include&lt;cstdio&gt;const int MAXn = 1e4;const int MAXm = 1e4 * 2;//æ— å‘å›¾MAXMåº”å¼€è¾¹æ•°äºŒå€int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"é”™æ’é—®é¢˜","slug":"TemLib/é”™æ’é—®é¢˜","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/é”™æ’é—®é¢˜/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"P1595 ä¿¡å°é—®é¢˜1234567891011121314#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 20;int n, a[MAXn + 10];signed main() &#123; a[1] = 0; a[2] = 1; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 3; i &lt;= n; ++i) &#123; a[i] = (i - 1) * (a[i - 2] + a[i - 1]); &#125; printf(&quot;%lld\\n&quot;, a[n]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"éè´¨æ•°æ¨¡æ•°é€†å…ƒè¿ç®—","slug":"TemLib/éè´¨æ•°æ¨¡æ•°é€†å…ƒè¿ç®—","date":"un44fin44","updated":"un44fin44","comments":true,"path":"1970/01/01/TemLib/éè´¨æ•°æ¨¡æ•°é€†å…ƒè¿ç®—/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%9D%9E%E8%B4%A8%E6%95%B0%E6%A8%A1%E6%95%B0%E9%80%86%E5%85%83%E8%BF%90%E7%AE%97/","excerpt":"","text":"åŸç†ï¼šå°†æ¨¡æ•° $\\bmod$ åˆ†è§£è´¨å› æ•° $p_1^{c_1}p_2^{c_2}p_3^{c_3}\\cdots$ï¼Œå†å°†æ‰€æœ‰å‚ä¸è¿ç®—çš„æ•°æŒ‰ç…§ $\\bmod$ çš„è´¨å› æ•°åˆ†è§£ä¸º $v\\times p_1^{câ€™_1}p_2^{câ€™_2}p_3^{câ€™_3}$ï¼Œå…¶ä¸­ $v$ ä¸ºä¸å±äº $\\bmod$ è´¨å› æ•°çš„éƒ¨åˆ†ï¼Œå¯ä»¥ç›´æ¥ç”¨ exgcd æ±‚é€†å…ƒï¼Œå…¶ä½™éƒ¨åˆ†åœ¨è¿›è¡Œä¹˜é™¤è¿ç®—æ—¶ç›´æ¥æŒ‡æ•°ç›¸åŠ å‡ï¼Œæœ€åä¹˜åœ¨ä¸€èµ·å°±æ˜¯ç»“æœï¼Œå¦‚æœè¿ç®—å®Œæœ‰æŒ‡æ•°ä¸ºè´Ÿåˆ™æ²¡æœ‰é€†å…ƒï¼Œä¸€èˆ¬ä½¿ç”¨ä¸‹ï¼ˆæ¯”å¦‚æ±‚ç»„åˆæ•°ï¼‰æ˜¯ä¸ä¼šå‡ºç°æŒ‡æ•°ä¸ºè´Ÿçš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int mod = 15;// ...int cntp, p[MAXcntp * 2 + 10];void Dis(int x) &#123; cntp = 0; for (int i = 2, topi = sqrt(x); i &lt;= topi; ++i) &#123; if (!(x % i)) &#123; p[++cntp] = i; while (!(x % i)) &#123; x /= i; &#125; &#125; &#125; if (x &gt; 1) p[++cntp] = x;&#125;struct Number &#123; int v, c[MAXcntp * 2 + 10]; inline Number()&#123;&#125; inline Number(int x) &#123; for (int i = 1; i &lt;= cntp; ++i) &#123; c[i] = 0; if (!x) continue; while (!(x % p[i])) &#123; ++c[i]; x /= p[i]; &#125; &#125; v = x; &#125; inline void operator=(int x) &#123; memset(c, 0, sizeof(c)); for (int i = 1; i &lt;= cntp; ++i) &#123; c[i] = 0; if (!x) continue; while (!(x % p[i])) &#123; ++c[i]; x /= p[i]; &#125; &#125; v = x; &#125; inline Number operator*(Number sec) &#123; Number ans; ans.v = v * sec.v % mod; for (int i = 1; i &lt;= cntp; ++i) &#123; ans.c[i] = c[i] + sec.c[i]; &#125; return ans; &#125; inline Number operator/(Number sec) &#123; Number ans; ans.v = v * inv(sec.v) % mod; for (int i = 1; i &lt;= cntp; ++i) &#123; ans.c[i] = c[i] - sec.c[i]; &#125; return ans; &#125; inline int real() &#123; int ans = v; for (int i = 1; i &lt;= cntp; ++i) &#123; ans *= power(p[i], c[i]); ans %= mod; &#125; return ans; &#125;&#125;;signed main() &#123; Dis(mod); Number a(36), b(14); Number c = a / b; printf(&quot;%lld\\n&quot;, c.real());&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å°è£…","slug":"å°è£…","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"é«˜æ–¯æ¶ˆå…ƒ","slug":"TemLib/é«˜æ–¯æ¶ˆå…ƒ","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/é«˜æ–¯æ¶ˆå…ƒ/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"æ³¨æ„äº‹é¡¹ï¼š é«˜æ–¯æ¶ˆå…ƒä»£ç çš„ 14 è¡Œå’Œ 17~20 è¡Œä¹Ÿå¯å‘çŸ©é˜µè¡Œåˆ—å¼é‚£æ ·åŒ…è£…æˆä¸€ä¸ªå‡½æ•°å¹¶ä½¿ç”¨ bottomj ä¼˜åŒ–å¸¸æ•°ã€‚ä½†å› ä¸ºåœ¨ Luogu P2455 [SDOI2006]çº¿æ€§æ–¹ç¨‹ç»„ çš„æµ‹è¯•ä¸­å¯¹å¸¸æ•°çš„ä¼˜åŒ–ä¸æ˜æ˜¾ï¼Œåˆå› ä¸º swap(a[row], a[maxer]) åœ¨é«˜æ¶ˆä¸­åªå‡ºç°ä¸€æ¬¡ï¼Œè¿™æ ·åšä¹Ÿä¸ä¼šæ˜¯ä»£ç ç»“æ„æ›´æ¸…æ™°ï¼Œæ‰€ä»¥ä¸æ¨èè¿™ç§å†™æ³•ã€‚ è¯¥é«˜æ–¯æ¶ˆå…ƒä»£ç åªé€‚ç”¨äºçŸ©é˜µè¡Œåˆ—é•¿åº¦ç›¸ç­‰ï¼Œé€‚ç”¨äºè¡Œåˆ—é•¿åº¦ä¸ç›¸ç­‰çš„ç‰ˆæœ¬è¯·è§å¼‚æˆ–é«˜æ–¯æ¶ˆå…ƒã€‚ ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243int n;double a[MAXn + 10][MAXn + 10];int guass() &#123; int row = 1; for (int col = 1; col &lt;= n; ++col) &#123; double mx = 0; int maxer = -1; for (int i = row; i &lt;= n; ++i) &#123; if (mx &lt; abs(a[i][col])) &#123; mx = abs(a[i][col]); maxer = i; &#125; &#125; if (sig(mx) == 0) continue; if (maxer != row) swap(a[row], a[maxer]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; double k = a[i][col] / a[row][col]; for (int j = col; j &lt;= n + 1; ++j) &#123; a[i][j] -= a[row][j] * k; &#125; &#125; ++row; &#125; bool noans = 0, infans = 0; if (row &lt;= n) &#123; for (int i = row; i &lt;= n; ++i) &#123; if (sig(a[i][n + 1])) &#123; noans = 1; break; &#125; &#125; if (noans == 0) infans = 1; &#125; if (noans) return 0; else if (infans) return -1; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i][n + 1] /= a[i][i]; a[i][i] = 1; &#125; return 1; &#125;&#125; Luogu P2455 [SDOI2006]çº¿æ€§æ–¹ç¨‹ç»„ ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 50;const double EPS = 1e-8;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline int sig(double x) &#123; if (x &lt; -EPS) return -1; else if (x &gt; EPS) return 1; else return 0;&#125;int n;double a[MAXn + 10][MAXn + 10];int guass() &#123; int row = 1; for (int col = 1; col &lt;= n; ++col) &#123; double mx = 0; int maxer = -1; for (int i = row; i &lt;= n; ++i) &#123; if (mx &lt; abs(a[i][col])) &#123; mx = abs(a[i][col]); maxer = i; &#125; &#125; if (sig(mx) == 0) continue; if (maxer != row) swap(a[row], a[maxer]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; double k = a[i][col] / a[row][col]; for (int j = col; j &lt;= n + 1; ++j) &#123; a[i][j] -= a[row][j] * k; &#125; &#125; ++row; &#125; bool noans = 0, infans = 0; if (row &lt;= n) &#123; for (int i = row; i &lt;= n; ++i) &#123; if (sig(a[i][n + 1])) &#123; noans = 1; break; &#125; &#125; if (noans == 0) infans = 1; &#125; if (noans) return 0; else if (infans) return -1; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i][n + 1] /= a[i][i]; a[i][i] = 1; &#125; return 1; &#125;&#125;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n + 1; ++j) &#123; scanf(&quot;%lf&quot;, &amp;a[i][j]); &#125; &#125; int res = guass(); if (res == 0) puts(&quot;-1&quot;); else if (res == -1) puts(&quot;0&quot;); else &#123; for (int i = 1; i &lt;= n; ++i) &#123; printf(&quot;x%d=%.2lf\\n&quot;, i, a[i][n + 1]); &#125; &#125; return 0;&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"é«˜æ–¯æ¶ˆå…ƒè§£æœ‰åæ•ˆæ€§çš„dp","slug":"TemLib/é«˜æ–¯æ¶ˆå…ƒè§£æœ‰åæ•ˆæ€§çš„dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/é«˜æ–¯æ¶ˆå…ƒè§£æœ‰åæ•ˆæ€§çš„dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E6%9C%89%E5%90%8E%E6%95%88%E6%80%A7%E7%9A%84dp/","excerpt":"","text":"CF24D Broken robot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e3;const int MAXm = 1e3;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, x, y;double mat[MAXm + 10][MAXm + 10], d[MAXn + 10][MAXm + 10];signed main() &#123; read(n), read(m); read(x), read(y); if (m == 1) &#123; printf(&quot;%d\\n&quot;, 2 * (n - x)); return 0; &#125; for (re int i = n - 1; i &gt;= x; --i) &#123; memset(mat, 0, sizeof(mat)); mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = d[i + 1][1] + 3; for (re int j = 2; j &lt; m; ++j) &#123; mat[j][j - 1] = mat[j][j + 1] = -1; mat[j][j] = 3; mat[j][m + 1] = d[i + 1][j] + 4; &#125; mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = d[i + 1][m] + 3; // ------- é«˜æ–¯æ¶ˆå…ƒ begin ------- for (re int i = 1; i &lt; m; ++i) &#123; double solve = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] -= mat[i][i] * solve; if (i != m) &#123; mat[i + 1][i + 1] -= mat[i][i + 1] * solve; &#125; mat[i + 1][m + 1] -= mat[i][m + 1] * solve; &#125; for (re int i = m; i &gt; 1; --i) &#123; double solve = mat[i - 1][i] / mat[i][i]; mat[i - 1][i] -= mat[i][i] * solve; mat[i - 1][m + 1] -= mat[i][m + 1] * solve; &#125; // ------- é«˜æ–¯æ¶ˆå…ƒ end ------- for (re int j = 1; j &lt;= m; ++j) &#123; d[i][j] = mat[j][m + 1] / mat[j][j]; &#125; &#125; printf(&quot;%.4f\\n&quot;, d[x][y]);&#125;","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"é«˜ç²¾è¿ç®—","slug":"TemLib/é«˜ç²¾è¿ç®—","date":"un44fin44","updated":"un55fin55","comments":true,"path":"1970/01/01/TemLib/é«˜ç²¾è¿ç®—/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E7%B2%BE%E8%BF%90%E7%AE%97/","excerpt":"","text":"å®ç”¨å°é«˜ç²¾ï¼ˆæ¨èï¼‰P1601 A+B Problemï¼ˆé«˜ç²¾ï¼‰P1303 A*B ProblemP1480 A/B Problem(è½¬è½½çš„) æ”¯æŒè´Ÿæ•°ï¼Œå‹ä½ï¼Œé‡è½½è¿ç®—ç¬¦ ä¸è¿‡èµ›åœºä¸Šåº”è¯¥æ²¡äººå†™ä¸€éè¿™ä¸ª 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 10000;const int BIT = 4;const int MOD = 1e4;struct bign &#123; int num[maxn], len; bool flag; friend bign abs(const bign &amp;x) &#123; bign k = x; k.flag = true; return k; &#125; friend void remove(bign &amp;x) &#123; while (x.num[x.len] == 0 &amp;&amp; x.len &gt; 1)x.len--; &#125; bign() &#123; memset(num, 0, sizeof(num)); flag = true; len = 1; &#125; bign(const int &amp;x) &#123; *this = bign(); if (x) &#123; int k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const ll &amp;x) &#123; *this = bign(); if (x) &#123; ll k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const char *x) &#123; int l = strlen(x), s, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == 4) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign(const string x) &#123; int l = x.length(), s = 0, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == BIT) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign operator=(const int &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const ll &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const char *x) &#123; return *this = bign(x); &#125; bign operator=(const string &amp;x) &#123; return *this = bign(x); &#125; bool operator&lt;(const bign &amp;x) const &#123; if (flag != x.flag)return flag &lt; x.flag; if (len != x.len)return (len &lt; x.len) ^ flag ^ 1; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return (num[i] &lt; x.num[i]) ^ flag ^ 1; &#125; &#125; return false; &#125; bool operator&lt;(const int &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&lt;(const ll &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&gt;(const bign &amp;x) const &#123; return x &lt; *this; &#125; bool operator&gt;(const int &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&gt;(const ll &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&lt;=(const bign &amp;x) const &#123; return !(*this &gt; x); &#125; bool operator&lt;=(const int &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&lt;=(const ll &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&gt;=(const bign &amp;x) const &#123; return !(*this &lt; x); &#125; bool operator&gt;=(const int &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator&gt;=(const ll &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator==(const bign &amp;x) const &#123; if (flag != x.flag)return false; if (len != x.len)return false; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return false; &#125; &#125; return true; &#125; bool operator==(const int &amp;x) const &#123; return *this == bign(x); &#125; bool operator==(const ll &amp;x) const &#123; return *this == bign(x); &#125; bool operator!=(const bign &amp;x) const &#123; return !(*this == x); &#125; bool operator!=(const int &amp;x) const &#123; return *this != bign(x); &#125; bool operator!=(const ll &amp;x) const &#123; return *this != bign(x); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;x) &#123; string s; in &gt;&gt; s; x = s; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const bign &amp;x) &#123; if (x.flag == false &amp;&amp; x != 0)out &lt;&lt; &quot;-&quot;; out &lt;&lt; x.num[x.len]; for (int i = x.len - 1; i &gt;= 1; i--)printf(&quot;%0*d&quot;, BIT, x.num[i]); return out; &#125; bign operator-() const &#123; bign k = *this; k.flag ^= 1; return k; &#125; bign operator+(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len || i &lt;= x.len; i++) &#123; int p = num[i] + x.num[i] + g; k.num[++k.len] = p % MOD; g = p / MOD; &#125; return k; &#125; if (flag &amp;&amp; !x.flag)return *this - (-x); if (!flag &amp;&amp; x.flag)return x - (-*this); return -((-x) + (-*this)); &#125; bign operator+(const int &amp;x) const &#123; return *this + bign(x); &#125; bign operator+=(const bign &amp;x) &#123; return *this = *this + x; &#125; bign operator+=(const int &amp;x) &#123; return *this += bign(x); &#125; bign operator+=(const ll &amp;x) &#123; return *this += bign(x); &#125; bign operator++() &#123; return *this += 1; &#125; bign operator++(int) &#123; bign k = *this; *this += 1; return k; &#125; bign operator-(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag &amp;&amp; *this &gt;= x) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len; i++) &#123; int p = num[i] - x.num[i] + g; if (p &lt; 0)g = -1; else g = 0; k.num[++k.len] = (p % MOD + MOD) % MOD; &#125; remove(k); return k; &#125; if (flag &amp;&amp; x.flag)return -(x - *this); if (flag &amp;&amp; !x.flag)return *this + (-x); if (!flag &amp;&amp; x.flag)return -((-*this) + x); return (-x) - (-*this); &#125; bign operator-=(const bign &amp;x) &#123; *this = *this - x; return *this; &#125; bign operator-=(const int &amp;x) &#123; return *this -= bign(x); &#125; bign operator-=(const ll &amp;x) &#123; return *this -= bign(x); &#125; bign operator--() &#123; return *this -= 1; &#125; bign operator--(int) &#123; bign k = *this; *this -= 1; return k; &#125; bign operator*(const bign &amp;x) const &#123; bign k; k.flag = (flag == x.flag); k.len = len + x.len + 1; for (int i = 1; i &lt;= len; i++) &#123; for (int j = 1; j &lt;= x.len; j++) &#123; k.num[i + j - 1] += num[i] * x.num[j]; k.num[i + j] += k.num[i + j - 1] / MOD; k.num[i + j - 1] %= MOD; &#125; &#125; remove(k); return k; &#125; bign operator*(const int &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*(const ll &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*=(const bign &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const int &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const ll &amp;x) &#123; return *this = *this * x; &#125; bign operator/(const bign &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(), a = bign(); k.flag = (flag == x.flag); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x)) &#123; a -= abs(x); k.num[i]++; &#125; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //ÃˆÂ¡Ã„Â£ remove(k); return k; &#125; bign operator/(const int &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //ÃˆÂ¡Ã„Â£ remove(k); return k; &#125; bign operator/(const ll &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //ÃˆÂ¡Ã„Â£ remove(k); return k; &#125; bign operator/=(const bign &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const int &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const ll &amp;x) &#123; return *this = *this / x; &#125; bign operator%(const bign &amp;x) const &#123; if (x == 0)return bign(); bign a = bign(); for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x))a -= abs(x); &#125;// if (a == 0)return a;// if (flag &amp;&amp; x.flag)return a;// if (flag &amp;&amp; !x.flag)return a + x;// if (!flag &amp;&amp; x.flag)return x - a;// return -a;//ÃˆÂ¡Ã„Â£ if (flag)return a; return -a; &#125; bign operator%(const int &amp;x) const &#123; return *this % bign(x); &#125; bign operator%(const ll &amp;x) const &#123; return *this % bign(x); &#125; bign operator%=(const bign &amp;x) &#123; return *this = *this % x; &#125; bign operator%=(const int &amp;x) &#123; return *this %= bign(x); &#125; bign operator%=(const ll &amp;x) &#123; return *this %= bign(x); &#125; friend bign pow(const bign &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const int &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const bign &amp;x, const int &amp;y) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans *= cnt; cnt *= cnt; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign max(const bign &amp;x, const bign &amp;y) &#123; return x &gt; y ? x : y; &#125; friend bign min(const bign &amp;x, const bign &amp;y) &#123; return x &lt; y ? x : y; &#125;&#125;;int main() &#123; bign a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; a - b &lt;&lt; endl; cout &lt;&lt; a * b &lt;&lt; endl; cout &lt;&lt; a / b &lt;&lt; endl; cout &lt;&lt; a % b &lt;&lt; endl; return 0;&#125; ä½ ç«Ÿç„¶çœ‹å®Œäº†ï¼","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"å°è£…","slug":"å°è£…","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]},{"title":"å‰è€å¸ˆçº¿æ®µæ ‘","slug":"TemLib/å‰è€å¸ˆçº¿æ®µæ ‘","date":"un44fin44","updated":"un22fin22","comments":true,"path":"1970/01/01/TemLib/å‰è€å¸ˆçº¿æ®µæ ‘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%89%E8%80%81%E5%B8%88%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"æœ¬æ–‡ã€Œã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 3ã€çš„ä»£ç ä¸ºæ–°å†…å®¹ï¼Œå…¶ä»–ä¸ºæ—§å†…å®¹ æ ¸å¿ƒæ€æƒ³ï¼š è®¾å½“å‰æ“ä½œä¸ºå°†åŒºé—´å†…å€¼ä¸ $v$ å– $\\min$ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹å®Œå…¨è¢«æ“ä½œåŒºé—´åŒ…å«ï¼ˆæ—¢æ»¡è¶³æ™®é€šçº¿æ®µæ ‘åœæ­¢é€’å½’çš„æ¡ä»¶ï¼‰ï¼Œåˆ†ç±»è®¨è®ºï¼š $\\max\\le v$ $\\mathrm{secmax}&lt;v&lt;\\max$ $v\\le\\mathrm{secmax}$ å¯¹äºæœ‰å¤šç§æ‡’æ ‡è®°çš„æƒ…å†µï¼Œè¦ä¹ˆé’¦å®šä»–ä»¬çš„é¡ºåºï¼Œè¦ä¹ˆå°†ä»–ä»¬è½¬åŒ–æˆå‡ ç§æ²¡æœ‰é¡ºåºå…³ç³»ï¼ˆæˆ–è€…è¯´æ˜¯é¡ºåºä¸Šä¸å†²çªï¼‰çš„æ‡’æ ‡è®°ï¼ˆæ¯”å¦‚å‡ ç§åŠ å‡æ ‡è®°ï¼‰ã€‚ å¯¹äºç»´æŠ¤å†å²æœ€å€¼çš„è¦æ±‚ï¼Œè€ƒè™‘æ ‡è®°çš„ç”Ÿå‘½å‘¨æœŸã€‚ Luogu P6242 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 3 ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 5e5;const int NINF = 0xc0c0c0c0c0c0c0c0;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)const int MAXnd = MAXn * 4;int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int sum[MAXnd + 10], mx[MAXnd + 10], cntmx[MAXnd + 10], secmx[MAXnd + 10], hismx[MAXnd + 10];int lz1[MAXnd + 10], lz2[MAXnd + 10], lz3[MAXnd + 10], lz4[MAXnd + 10];/*lz1: æœ€å¤§å€¼çš„å¢å‡å€¼lz2: æœ€å¤§å€¼çš„å¢å‡å€¼ç”Ÿå‘½å‘¨æœŸä¸­çš„æœ€å¤§å€¼lz3: éæœ€å¤§å€¼çš„å¢å‡å€¼lz4: éæœ€å¤§å€¼å†å²çš„å¢å‡å€¼ç”Ÿå‘½å‘¨æœŸä¸­çš„æœ€å¤§å€¼*/inline void put(int id, int v1, int v2, int v3, int v4) &#123; sum[id] += v1 * cntmx[id] + v3 * (len[id] - cntmx[id]); hismx[id] = max(hismx[id], mx[id] + v2); mx[id] += v1; if (secmx[id] != NINF) secmx[id] += v3; lz2[id] = max(lz2[id], lz1[id] + v2); lz1[id] += v1; lz4[id] = max(lz4[id], lz3[id] + v4); lz3[id] += v3;&#125;inline void putadd(int id, int v) &#123; put(id, v, v, v, v);&#125;inline void putmin(int id, int v) &#123; put(id, v - mx[id], v - mx[id], 0, 0);&#125;inline void pushdown(int id) &#123; int maxx = max(mx[ls], mx[rs]); if (mx[ls] == maxx) put(ls, lz1[id], lz2[id], lz3[id], lz4[id]); else put(ls, lz3[id], lz4[id], lz3[id], lz4[id]); if (mx[rs] == maxx) put(rs, lz1[id], lz2[id], lz3[id], lz4[id]); else put(rs, lz3[id], lz4[id], lz3[id], lz4[id]); lz1[id] = lz2[id] = lz3[id] = lz4[id] = 0;&#125;inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs]; mx[id] = max(mx[ls], mx[rs]); cntmx[id] = ((mx[ls] == mx[id]) ? cntmx[ls] : 0) + ((mx[rs] == mx[id]) ? cntmx[rs] : 0); secmx[id] = max((mx[ls] == mx[id]) ? secmx[ls] : mx[ls], (mx[rs] == mx[id]) ? secmx[rs] : mx[rs]); hismx[id] = max(hismx[ls], hismx[rs]);&#125;void build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; if (le[id] == ri[id]) &#123; sum[id] = a[le[id]]; mx[id] = a[le[id]]; cntmx[id] = 1; secmx[id] = NINF; hismx[id] = a[le[id]]; &#125; else &#123; build(ls, le[id], mid[id], a); build(rs, mid[id] + 1, ri[id], a); pushup(id); &#125;&#125;void modifyadd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putadd(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyadd(ls, l, r, v); if (r &gt; mid[id]) modifyadd(rs, l, r, v); pushup(id); &#125;&#125;void modifymin(int id, int l, int r, int v) &#123; if (v &gt;= mx[id]) &#123; ; &#125; else if (v &gt; secmx[id] &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putmin(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifymin(ls, l, r, v); if (r &gt; mid[id]) modifymin(rs, l, r, v); pushup(id); &#125;&#125;int querysum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += querysum(ls, l, r); if (r &gt; mid[id]) ans += querysum(rs, l, r); return ans; &#125;&#125;int querymax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = NINF; if (l &lt;= mid[id]) ans = max(ans, querymax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, querymax(rs, l, r)); return ans; &#125;&#125;int queryhismax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return hismx[id]; &#125; else &#123; pushdown(id); int ans = NINF; if (l &lt;= mid[id]) ans = max(ans, queryhismax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryhismax(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rsint n, m;int a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; build(1, 1, n, a); for (int i = 1, opt, l, r, x; i &lt;= m; ++i) &#123; read(opt, l, r); if (opt == 1) &#123; read(x); modifyadd(1, l, r, x); &#125; else if (opt == 2) &#123; read(x); modifymin(1, l, r, x); &#125; else if (opt == 3) &#123; printf(&quot;%lld\\n&quot;, querysum(1, l, r)); &#125; else if (opt == 4) &#123; printf(&quot;%lld\\n&quot;, querymax(1, l, r)); &#125; else &#123; printf(&quot;%lld\\n&quot;, queryhismax(1, l, r)); &#125; &#125; return 0;&#125; DarkBzoj #4695. æœ€å‡å¥³é€‰æ‰‹ è§£æ³•ä¸€ç”¨çš„æ˜¯é’¦å®šæ‡’æ ‡è®°é¡ºåºçš„æ–¹æ³•ï¼Œè§£æ³•äºŒç”¨çš„æ˜¯è½¬åŒ–æˆæ²¡æœ‰é¡ºåºå…³ç³»çš„æ‡’æ ‡è®°çš„æ–¹æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10];int mx[MAXnd + 10], cntmx[MAXnd + 10], secmx[MAXnd + 10], mn[MAXnd + 10], cntmn[MAXnd + 10], secmn[MAXnd + 10];int sum[MAXnd + 10];int lzadd[MAXnd + 10], lzmx[MAXnd + 10], lzmn[MAXnd + 10];/*é’¦å®šé¡ºåº: lzadd &gt; lzmx = lzmn*/inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs]; if (mx[ls] &gt; mx[rs]) &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls]; secmx[id] = max(secmx[ls], mx[rs]); &#125; else if (mx[ls] &lt; mx[rs]) &#123; mx[id] = mx[rs]; cntmx[id] = cntmx[rs]; secmx[id] = max(mx[ls], secmx[rs]); &#125; else &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls] + cntmx[rs]; secmx[id] = max(secmx[ls], secmx[rs]); &#125; if (mn[ls] &lt; mn[rs]) &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls]; secmn[id] = min(secmn[ls], mn[rs]); &#125; else if (mn[ls] &gt; mn[rs]) &#123; mn[id] = mn[rs]; cntmn[id] = cntmn[rs]; secmn[id] = min(mn[ls], secmn[rs]); &#125; else &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls] + cntmn[rs]; secmn[id] = min(secmn[ls], secmn[rs]); &#125;&#125;inline void putadd(int id, int padd) &#123; sum[id] += padd * (ri[id] - le[id] + 1); mx[id] += padd; mn[id] += padd; if (secmx[id] != -INF) secmx[id] += padd; if (secmn[id] != INF) secmn[id] += padd; if (lzmx[id] != -INF) lzmx[id] += padd; if (lzmn[id] != INF) lzmn[id] += padd; lzadd[id] += padd;&#125;inline void putmx(int id, int pmx) &#123; if (mn[id] &gt;= pmx) return; sum[id] += (pmx - mn[id]) * cntmn[id]; if (secmx[id] == mn[id]) secmx[id] = pmx; if (mx[id] == mn[id]) mx[id] = pmx; if (lzmn[id] &lt; pmx) lzmn[id] = pmx; mn[id] = lzmx[id] = pmx;&#125;inline void putmn(int id, int pmn) &#123; if (mx[id] &lt;= pmn) return; sum[id] -= (mx[id] - pmn) * cntmx[id]; if (secmn[id] == mx[id]) secmn[id] = pmn; if (mn[id] == mx[id]) mn[id] = pmn; if (lzmx[id] &gt; pmn) lzmx[id] = pmn; mx[id] = lzmn[id] = pmn;&#125;inline void pushdown(int id) &#123; if (lzadd[id]) &#123; // æ³¨æ„é¡ºåºlzaddä¸å…¶ä»–æ‡’æ ‡è®°çš„é¡ºåº putadd(ls, lzadd[id]); putadd(rs, lzadd[id]); lzadd[id] = 0; &#125; if (lzmx[id] != -INF) &#123; putmx(ls, lzmx[id]); putmx(rs, lzmx[id]); lzmx[id] = -INF; &#125; if (lzmn[id] != INF) &#123; putmn(ls, lzmn[id]); putmn(rs, lzmn[id]); lzmn[id] = INF; &#125;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; lzmx[id] = -INF; lzmn[id] = INF; if (l == r) &#123; mx[id] = mn[id] = sum[id] = a[l]; cntmx[id] = cntmn[id] = 1; secmx[id] = -INF; secmn[id] = INF; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putadd(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyMax(int id, int l, int r, int v) &#123; if (mn[id] &gt;= v) return; if (secmn[id] &gt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putmx(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMax(ls, l, r, v); if (r &gt; mid[id]) modifyMax(rs, l, r, v); pushup(id); &#125;&#125;void modifyMin(int id, int l, int r, int v) &#123; if (mx[id] &lt;= v) return; if (secmx[id] &lt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; putmn(id, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMin(ls, l, r, v); if (r &gt; mid[id]) modifyMin(rs, l, r, v); pushup(id); &#125;&#125;int querySum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += querySum(ls, l, r); if (r &gt; mid[id]) ans += querySum(rs, l, r); return ans; &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;int queryMin(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mn[id]; &#125; else &#123; pushdown(id); int ans = INF; if (l &lt;= mid[id]) ans = min(ans, queryMin(ls, l, r)); if (r &gt; mid[id]) ans = min(ans, queryMin(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int mx[MAXnd + 10], cntmx[MAXnd + 10], secmx[MAXnd + 10], mn[MAXnd + 10], cntmn[MAXnd + 10], secmn[MAXnd + 10];int sum[MAXnd + 10];int lz1[MAXnd + 10], lz2[MAXnd + 10], lz3[MAXnd + 10];/*lz1: æœ€å¤§å€¼çš„å¢å‡å€¼lz2: æœ€å°å€¼çš„å¢å‡å€¼lz3: éæœ€å°æœ€å¤§å€¼çš„å¢å‡å€¼*/inline void pushup(int id) &#123; if (mx[ls] &gt; mx[rs]) &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls]; secmx[id] = max(secmx[ls], mx[rs]); &#125; else if (mx[ls] &lt; mx[rs]) &#123; mx[id] = mx[rs]; cntmx[id] = cntmx[rs]; secmx[id] = max(mx[ls], secmx[rs]); &#125; else &#123; mx[id] = mx[ls]; cntmx[id] = cntmx[ls] + cntmx[rs]; secmx[id] = max(secmx[ls], secmx[rs]); &#125; if (mn[ls] &lt; mn[rs]) &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls]; secmn[id] = min(secmn[ls], mn[rs]); &#125; else if (mn[ls] &gt; mn[rs]) &#123; mn[id] = mn[rs]; cntmn[id] = cntmn[rs]; secmn[id] = min(mn[ls], secmn[rs]); &#125; else &#123; mn[id] = mn[ls]; cntmn[id] = cntmn[ls] + cntmn[rs]; secmn[id] = min(secmn[ls], secmn[rs]); &#125; sum[id] = sum[ls] + sum[rs];&#125;inline void update(int id, int v1, int v2, int v3) &#123; if (mx[id] == secmn[id]) &#123; sum[id] += v1 * cntmx[id] + v2 * cntmn[id]; mx[id] += v1; mn[id] += v2; secmx[id] += v2; secmn[id] += v1; lz1[id] += v1; lz2[id] += v2; &#125; else if (mx[id] == mn[id]) &#123; if (v1) &#123; sum[id] += v1 * cntmx[id]; mx[id] += v1; mn[id] += v1; lz1[id] += v1; lz2[id] += v1; &#125; else if (v2) &#123; sum[id] += v2 * cntmx[id]; mx[id] += v2; mn[id] += v2; lz1[id] += v2; lz2[id] += v2; &#125; else &#123; sum[id] += v3 * cntmx[id]; mx[id] += v3; mn[id] += v3; lz1[id] += v3; lz2[id] += v3; &#125; &#125; else &#123; sum[id] += v1 * cntmx[id] + v2 * cntmn[id] + v3 * (len[id] - cntmx[id] - cntmn[id]); mx[id] += v1; mn[id] += v2; secmx[id] += v3; secmn[id] += v3; lz1[id] += v1; lz2[id] += v2; lz3[id] += v3; &#125;&#125;inline void pushdown(int id) &#123; int maxx = max(mx[ls], mx[rs]), minn = min(mn[ls], mn[rs]); if (mx[ls] == mn[ls]) update(ls, mx[ls] == maxx ? lz1[id] : 0, mn[ls] == minn ? lz2[id] : 0, lz3[id]); else update(ls, mx[ls] == maxx ? lz1[id] : lz3[id], mn[ls] == minn ? lz2[id] : lz3[id], lz3[id]); if (mx[rs] == mn[rs]) update(rs, mx[rs] == maxx ? lz1[id] : 0, mn[rs] == minn ? lz2[id] : 0, lz3[id]); else update(rs, mx[rs] == maxx ? lz1[id] : lz3[id], mn[rs] == minn ? lz2[id] : lz3[id], lz3[id]); lz1[id] = lz2[id] = lz3[id] = 0;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; if (l == r) &#123; mn[id] = mx[id] = sum[id] = a[l]; cntmn[id] = cntmx[id] = 1; secmn[id] = INF; secmx[id] = -INF; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v, v, v); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyMin(int id, int l, int r, int v) &#123; if (mx[id] &lt;= v) return; if (secmx[id] &lt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v - mx[id], 0, 0); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMin(ls, l, r, v); if (r &gt; mid[id]) modifyMin(rs, l, r, v); pushup(id); &#125;&#125;void modifyMax(int id, int l, int r, int v) &#123; if (mn[id] &gt;= v) return; if (secmn[id] &gt; v &amp;&amp; le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, 0, v - mn[id], 0); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyMax(ls, l, r, v); if (r &gt; mid[id]) modifyMax(rs, l, r, v); pushup(id); &#125;&#125;int querySum(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int ans = 0; if (l &lt;= mid[id]) ans += querySum(ls, l, r); if (r &gt; mid[id]) ans += querySum(rs, l, r); return ans; &#125;&#125;int queryMin(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mn[id]; &#125; else &#123; pushdown(id); int ans = INF; if (l &lt;= mid[id]) ans = min(ans, queryMin(ls, l, r)); if (r &gt; mid[id]) ans = min(ans, queryMin(rs, l, r)); return ans; &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs Luogu P4314 CPU ç›‘æ§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXnd + 10], ri[MAXnd + 10], mid[MAXnd + 10], len[MAXnd + 10];int mx[MAXnd + 10], hismx[MAXnd + 10];int lz1[MAXnd + 10], lz2[MAXnd + 10], lz3[MAXnd + 10], lz4[MAXnd + 10], lz5[MAXnd + 10];/*lz1: æœ«æ®µå¢å‡å€¼lz2: æœ«æ®µå¢å‡å€¼çš„å†å²æœ€å¤§å€¼lz3: é¦–æ®µå¢å‡å€¼çš„å†å²æœ€å¤§å€¼lz4: (å¦‚æœæœ‰)æœ«ç«¯è¦†ç›–å€¼lz5: (å¦‚æœæœ‰)ä¸­é—´æ®µçš„æœ€å¤§å€¼*/inline void pushup(int id) &#123; mx[id] = max(mx[ls], mx[rs]); hismx[id] = max(hismx[ls], hismx[rs]);&#125;inline void update(int id, int v1, int v2, int v3, int v4, int v5) &#123; if (v4 == INF) &#123; if (lz4[id] == INF) &#123; hismx[id] = max(hismx[id], mx[id] + v3); mx[id] = mx[id] + v1; lz2[id] = lz3[id] = max(lz2[id], lz1[id] + v3); lz1[id] = lz1[id] + v1; &#125; else &#123; hismx[id] = max(hismx[id], mx[id] + v3); mx[id] = mx[id] + v1; lz2[id] = max(lz2[id], lz1[id] + v3); lz1[id] = lz1[id] + v1; &#125; &#125; else &#123; if (lz4[id] == INF) &#123; hismx[id] = max(max(max(hismx[id], mx[id] + v3), v5), v4 + v2); mx[id] = v4 + v1; lz3[id] = max(lz3[id], lz1[id] + v3); lz1[id] = v1; lz2[id] = v2; lz4[id] = v4; lz5[id] = v5; &#125; else &#123; hismx[id] = max(max(max(hismx[id], mx[id] + v3), v5), v4 + v2); mx[id] = v4 + v1; lz5[id] = max(max(max(lz5[id], v5), lz4[id] + lz2[id]), lz4[id] + lz1[id] + v3); lz1[id] = v1; lz2[id] = v2; lz4[id] = v4; &#125; &#125;&#125;inline void pushdown(int id) &#123; update(ls, lz1[id], lz2[id], lz3[id], lz4[id], lz5[id]); update(rs, lz1[id], lz2[id], lz3[id], lz4[id], lz5[id]); lz1[id] = lz2[id] = lz3[id] = 0; lz4[id] = INF; lz5[id] = -INF;&#125;void Build(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; mid[id] = (l + r) &gt;&gt; 1; len[id] = r - l + 1; lz4[id] = INF; lz5[id] = -INF; if (l == r) &#123; mx[id] = hismx[id] = a[l]; &#125; else &#123; Build(ls, l, mid[id], a); Build(rs, mid[id] + 1, r, a); pushup(id); &#125;&#125;void modifyAdd(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; update(id, v, v, v, INF, -INF); &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyAdd(ls, l, r, v); if (r &gt; mid[id]) modifyAdd(rs, l, r, v); pushup(id); &#125;&#125;void modifyRep(int id, int l, int r, int v) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; mx[id] = v; hismx[id] = max(hismx[id], v); if (lz4[id] != INF) lz5[id] = max(lz5[id], lz4[id] + lz2[id]); lz1[id] = lz2[id] = 0; lz4[id] = v; &#125; else &#123; pushdown(id); if (l &lt;= mid[id]) modifyRep(ls, l, r, v); if (r &gt; mid[id]) modifyRep(rs, l, r, v); pushup(id); &#125;&#125;int queryMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return mx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryMax(rs, l, r)); return ans; &#125;&#125;int queryHisMax(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return hismx[id]; &#125; else &#123; pushdown(id); int ans = -INF; if (l &lt;= mid[id]) ans = max(ans, queryHisMax(ls, l, r)); if (r &gt; mid[id]) ans = max(ans, queryHisMax(rs, l, r)); return ans; &#125;&#125;#undef ls#undef rs","categories":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]}],"categories":[{"name":"ç¼–ç¨‹ï¼ˆ8 æœˆ ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹ï¼ˆ8-æœˆ-ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B%EF%BC%888-%E6%9C%88-%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ç¼–ç¨‹/ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"æ‚è°ˆ","slug":"æ‚è°ˆ","permalink":"http://rsdbkhusky.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"ç¼–ç¨‹","slug":"ç¼–ç¨‹","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"ä»£ç ","slug":"ä»£ç ","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"ä¿¡æ¯ç«èµ›","slug":"ä¿¡æ¯ç«èµ›","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"æ¨¡æ¿","slug":"æ¨¡æ¿","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"å‡ ä½•","slug":"å‡ ä½•","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"è½¯ä»¶","slug":"è½¯ä»¶","permalink":"http://rsdbkhusky.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"å›¾è®º","slug":"å›¾è®º","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"æœç´¢","slug":"æœç´¢","permalink":"http://rsdbkhusky.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"å°è£…","slug":"å°è£…","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]}