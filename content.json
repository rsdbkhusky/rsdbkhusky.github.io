{"meta":{"title":"燃烧的冰块_husky's blog","subtitle":"Thank for your visiting","description":"这是一个个人博客","author":"rsdbk_husky","url":"http://rsdbkhusky.github.io","root":"/"},"pages":[{"title":"友链","date":"un55fin55","updated":"un55fin55","comments":true,"path":"link/index.html","permalink":"http://rsdbkhusky.github.io/link/index.html","excerpt":"","text":""},{"title":"分类","date":"un55fin55","updated":"un55fin55","comments":true,"path":"categories/index.html","permalink":"http://rsdbkhusky.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"un55fin55","updated":"un55fin55","comments":true,"path":"tags/index.html","permalink":"http://rsdbkhusky.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VisualStudio常用设置","slug":"VisualStudio常用设置","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/12/12/VisualStudio常用设置/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/12/VisualStudio%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"文章中的的设置纯属个性化设置，依据自身喜好而定。 “选项”菜单从“顶部栏/调试/选项”即可打开“选项”菜单，也有其他打开“选项”菜单的方法。 接下来的 6 条操作都是在“选项”菜单中完成的。 主题：（“环境/视觉体验/颜色主题/”） 深色字体：（“环境/字体与颜色/”） consolas 粗体键盘：（“环境/键盘/ -&gt; 搜索‘编辑.切换行注释’”） 快捷键设为”ctrl+/“代码格式设置：（“文本编辑器/「你要设置的语言」/代码样式/格式设置/”） 看着改改（根据个人口味） 如果是大括号不换行的选手，发现编辑代码的时候大括号自动换行，检查一下这里是不是勾选“在}后自动格式化程序块”了，如果是的话取消勾选。底部状态栏：（“环境/常规/显示状态栏/”） 取消勾选引用和作者更改项：（“文本编辑器/所有语言/CodeLens/启用CodeLens/”） 取消勾选 “属性”菜单此条面向 c++ 选手。 在编译 c++ 代码时，如果你的代码中有 scanf 等编译器认为不安全的函数，可能无法成功编译。如果你想使用这些函数，你需要看一看这一条。 从“顶部栏/调试/调试属性”即可打开“属性”菜单，或从“顶部栏/项目/属性”打开。 打开“属性”菜单后，进入“配置属性/C、C++/预处理器/预处理器定义/编辑/”，加入“_CRT_SECURE_NO_WARNINGS”即可。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"软件","slug":"软件","permalink":"http://rsdbkhusky.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Gdb中输出格式优化","slug":"Gdb中print的各种参数对效果的影响","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2021/12/12/Gdb中print的各种参数对效果的影响/","link":"","permalink":"http://rsdbkhusky.github.io/2021/12/12/Gdb%E4%B8%ADprint%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E5%AF%B9%E6%95%88%E6%9E%9C%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"gdb 打开 / 关闭输出格式优化的命令 1set p [options] on/off 常用的 options 参数 array array-index pretty 在输出不同种类变量时各种格式优化参数的效果 array array-indexes pretty 关联式容器：set，map…… $-$ $-$ $\\surd$ 序列式容器：vector…… $\\surd$ $\\surd$ $-$ 容器适配器：stack，priority_queue…… $\\surd$ $\\surd$ $-$ 普通数组 $\\surd$ $\\surd$ $-$ 结构体数组 $\\surd$ $\\surd$ $\\times$ $\\surd$：添加会提升效果。 $\\times$：添加会降低效果。 $-$：添不添加对效果不影响。 （这里的效果纯属个人观点） 图片示例：","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"双指针优化dp & Luogu P1973 [NOI2011] NOI 嘉年华","slug":"双指针优化dp & Luogu P1973 [NOI2011] NOI 嘉年华","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/10/13/双指针优化dp & Luogu P1973 [NOI2011] NOI 嘉年华/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/13/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P1973%20[NOI2011]%20NOI%20%E5%98%89%E5%B9%B4%E5%8D%8E/","excerpt":"","text":"题目传送门 一. 思路首先进行离散化，将所有区间左右端点离散化，离散成 $m$ 个“离散点”，只有这些地方才可能设置为断点，不然一定是不优的。 首先考虑朴素 DP，设 $sec_{l,r}$ 为完全被包含在离散点 $l\\sim r$ 内的区间总数，直接 $O(n^3)$ 暴力求就好了。 $pre_{i,j}$：离散点 $1\\sim i$ 内包含的区间，一个组分到 $j$ 个区间时，另一组能分到的最大值。我们的方程应该写成这样： pre_{i,j}=\\max\\limits_{k=1}^{k","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogu U182676 完全图切割","slug":"Luogu U182676 完全图切割","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/10/06/Luogu U182676 完全图切割/","link":"","permalink":"http://rsdbkhusky.github.io/2021/10/06/Luogu%20U182676%20%E5%AE%8C%E5%85%A8%E5%9B%BE%E5%88%87%E5%89%B2/","excerpt":"","text":"题目传送门 （题目非原创） 一. 思路没有连通性限制的情况$f_{i, j}$：$i$ 个点所有连边情况的简单无向图（无重边自环，不要求连通），每种情况边数 $j$ 次方的和。 考虑 $f$ 的递推式，因为没有连通性要求，边随便连，可以考虑每加入一个点，他和其他所有点的连边情况，显然，如果原来有 $i - 1$ 个点，加入一个点，新连边的所有情况 $\\begin{cases}\\operatorname{C}{i-1}^{0}\\times\\text{新连0边}\\\\operatorname{C}{i-1}^{1}\\times\\text{新连1边}\\\\cdots\\\\operatorname{C}{i-1}^{i-1}\\times\\text{新连i-1边}\\\\end{cases}$，设集合 $T_i=\\begin{cases}\\operatorname{C}{i-1}^{0}\\text{个0}\\\\operatorname{C}{i-1}^{1}\\text{个1}\\\\cdots\\\\operatorname{C}{i-1}^{i-1}\\text{个i-1}\\\\end{cases}$，集合 $F_i$ 表示 $i$ 个点所有连边情况的简单无向图的边数构成的集合。那么： \\begin{gather} \\because F_i=\\left\\{z\\mid z=x+y,x\\in F_{i-1},y\\in T_i\\right\\}\\\\ \\And f_{i,j}=\\sum\\limits_{z\\in F_i}z^j\\\\ \\therefore f_{i,j}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^j\\\\ \\end{gather}$f_{i,j}$ 对于不同的 $j$ 继续拆解这个式子： \\begin{gather} f_{i,0}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^0\\\\ =\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}1\\\\ =\\left|F_{i-1}\\right|\\left|T_{i}\\right|\\\\ =f_{i-1,0}\\times2^{i-1}\\\\ \\end{gather} \\begin{gather} f_{i,1}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^1\\\\ =\\sum\\limits_{y\\in T_{i}}\\sum\\limits_{x\\in F_{i-1}}x+\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}y\\\\ =\\left|T_{i}\\right|\\sum\\limits_{x\\in F_{i-1}}x+\\left|F_{i-1}\\right|\\sum\\limits_{y\\in T_{i}}y\\\\ =2^{i-1}\\times f_{i-1}+f_{i-1,0}\\times\\sum\\limits_{y\\in T_{i}}y\\\\ \\end{gather} \\begin{gather} f_{i,2}=\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x+y)^2\\\\ =\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}(x^2+y^2+2xy)\\\\ =\\sum\\limits_{y\\in T_{i}}\\sum\\limits_{x\\in F_{i-1}}x^2+\\sum\\limits_{x\\in F_{i-1}}\\sum\\limits_{y\\in T_{i}}y^2+2\\sum\\limits_{x\\in F_{i-1}}x\\sum\\limits_{y\\in T_{i}}y\\\\ =2^{i-1}\\times f_{i-1,2}+f_{i-1,0}\\times \\sum\\limits_{y\\in T_{i}}y^2+2\\times f_{i-1,1}\\times \\sum\\limits_{y\\in T_{i}}y \\end{gather}可以预处理出 $2^i$、$\\sum\\limits{y\\in T{i}}y$ 和 $\\sum\\limits{y\\in T{i}}y^2$。 有连通性限制的情况$d_{i, j}$：$i$ 个点所有保证连通的连边情况的简单无向图，每种情况边数 $j$ 次方的和。 $D_i$：$i$ 个点所有保证连通的连边情况的简单无向图的边数构成的集合。 正难则反，不方便直接推出符合条件的情况，可以用总的情况减去不符合的情况。随意选一个点作为基准，枚举这个点所在连通块的大小，显然这个点所在连通块一定连通（废话），剩余点连通性随意，如果节点总数 $i$ 基准节点所在连通块大小为 $k$，除去那个基准节点一定被选，剩余点中要选 $k-1$ 个作为连通块中的其他节点，方案数 $\\operatorname{C}_{i-1}^{k-1}$。 \\begin{gather} d_{i,j}=f_{i,j}-\\sum\\limits_{k=1}^{k","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogu P2518 [HAOI2010]计数","slug":"计数","date":"un44fin44","updated":"un66fin66","comments":true,"path":"2021/09/02/计数/","link":"","permalink":"http://rsdbkhusky.github.io/2021/09/02/%E8%AE%A1%E6%95%B0/","excerpt":"","text":"题目传送门 一. 思路1. 拆分原数（数位DP思想）求某个区间的数中满足某个条件的数的个数，这是典型的数位 DP 题的套路。于是我们可以试着拆分这个数，把 [0, 原数) 这个区间按位拆成一些区间： 我们只需计算出所有整块区间中满足条件的数并求和就好了。 2. 处理每个区间（多重集排列）所谓符合要求，就是由原数中的每一位上的非零数和任意个零按位拼凑而成。看似这个要求不好处理，实则完全可以通过多重集排列得出。 多重集排列，将一个可以有重复元素的集合中的元素进行排列的方案数，如：{1, 3, 3}，多重集排列：[1, 3, 3]，[3, 1, 3]，[3, 3, 1]，共三种。这篇文章中设多重集排列的符号为 $\\operatorname{Pmult}(cnt_1, cnt_2 \\ldots cnt_n)$，如 {1, 3, 3} 的排列是 $\\operatorname{Pmult}(1, 2)$。 应用到这题上来就是例如 [0, 1000) 这个区间，首位是 “0”，除了首位外还有 3 位，有两个非零数字 “1”，”2”。答案就是 一个 “1”，一个 “2”，一个 “0”（”0” 的个数为除首位外的位数 - 非零位数），即 $\\operatorname{Pmult}(1, 1, 1)$。 多重集排列的计算公式就是： \\operatorname{Pmult}(cnt_1, cnt_2 \\ldots cnt_n) = \\operatorname{C}_{sumcnt}^{cnt_1} \\times \\operatorname{C}_{sumcnt - cnt_1}^{cnt_2} \\times \\ldots \\times \\operatorname{C}_{sumcnt - cnt_1 - cnt_2 - \\ldots - cnt_{n - 1}}^{cnt_n}~~~~(sumcnt = \\sum\\limits_{i = 1}^n cnt_i)简略证明就是你有 $sumcnt$ 个空，先将 $cnt1$ 个相同物品放进去，就是 $\\operatorname{C}{sumcnt}^{cnt_1}$ 种，空的数量变为 $sumcnt - cnt_1$ 个，以此类推。 3. 代码实现中的细节： 拆分原数是从高位往低位。每一次处理完一位处理下一位之前，如果这一位非零，将 cnt 数组中这一位数字的数量减一，因为之后处理的更低位中，高位是确定的，也就是说无法在使用高位的这个数字了。如 “1020” 处理完 [0, 1000) 后，之后所有区间的千位都是 “1”， “1” 无法再参与排列，所以直接 --cnt[1]。 处理某个非零位时，先枚举该位，将还剩下的数（还剩下 “x”，即 cnt[x] &gt; 0）中小于改位原数的依次填到该位，再用多重集排列算出剩下的位的排列数。（具体见代码） 遇到为零的位如 “1020” 中个位和百位，他们拆分出的区间没有数，直接跳过就好，不浪费程序运行时间。 二. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans; // cnt[x]: &quot;x&quot;数还可参与排列的数量，也就是&quot;x&quot;在当前位和比当前位低的位中的数量。 // cnt[10]: 在当前位和比当前位低的位中&quot;0&quot;的数量。 // sumcnt: Sum&#123;cnt[1] ~ cnt[9]&#125;，用于计算&quot;0&quot;的个数。signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P3225 [HNOI2012]矿场搭建","slug":"矿场搭建","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/08/18/矿场搭建/","link":"","permalink":"http://rsdbkhusky.github.io/2021/08/18/%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/","excerpt":"","text":"一. 思路0. 前置知识：割点，v-dcc（再说一遍，无向图有的是双连通分量，没有强连通分量一说！）。​ 这里推荐几道模板题，学习 Tarjan 建议把他们都 A 了： dcc 割边：Luogu Std。 dcc 割点：Luogu Std。 e-dcc：Luogu Std。 v-dcc：Luogu Std。 scc：Luogu Std。 scc 缩点：Luogu。 （没有找到双连通分量的缩点模板，知道的小伙伴欢迎在评论中补充） 蓝书上这部分讲的很详细。 那么接下来我们以这个图为例讲解此题： 命名三个双连通分量为：A，B，C。红色的为割点。 1. 一个包含一个割点的双连通分量（A，C） 非割点坍塌： 没有关系，比如 A 中 1 号点坍塌，3 号点中的人可以来到割点（2 号点），然后去往其他双连通分量中的出口逃生。 割点坍塌： 比如 2 号塌了，1 号和 3 号中就必须有一个出口。 综上，对于包含一个割点的双连通分量，需要建 $1$ 个出口，方案数为 $\\operatorname{size} - 1$。（$\\operatorname{size}$：该 dcc 大小）。 2. 一个包含两个及以上个割点的双连通分量（B） 非割点坍塌：（同 1 - 1） 割点坍塌： 这次情况不同了，塌了一个割点，还有至少一个割点可以供里面的工人离开这个 dcc。 综上，对于包含两个及以上个割点的双连通分量，根本无需建出口。 看到这里，很多人有 问题 了：如果全是包含两个及以上个割点的 dcc，所有人总想着往其他 dcc 跑，其他 dcc 却也没出口怎么办。那么恭喜你，这种情况根本不可能成立。比如有一圈像 B 一样的 dcc 拼在一起： 但再仔细看，一当形成环，割点就直接没有了，也就是说上图 4 个红色点都应该是白色的，这就是第三种情况（待会要讲）。 而如果环不合拢，两端必然存在包含一个割点的 dcc，也就自然能成功逃离： 3. 环如果是一个环，看上去建一个出口就行了，但还要考虑出口坍塌的情况！所以需要建 $2$ 个出口。方案数为 $\\operatorname{C}^2_{\\operatorname{size}} = \\dfrac{\\operatorname{size} \\times (\\operatorname{size} - 1)}{2}$。 4. 最终结果 出口数：将所有 dcc 建的出口数相加。 方案数：将所有 dcc 的方案数相乘。（乘法原理） 二. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e4;const int MAXm = 3e5;template &lt;class T&gt;inline void read(T&amp; a) &#123; re char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); re T x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125;a = x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int top, stk[MAXn + 10], cntdcc;vector&lt;int&gt; dcc[MAXn + 10];bool is[MAXn + 10];int root, cntdfs, dfs[MAXn + 10], low[MAXn + 10];void Init() &#123; cntnex = top = root = cntdfs = 0; memset(head, 0, sizeof(head)); memset(nex, 0, sizeof(nex)); memset(to, 0, sizeof(to)); memset(stk, 0, sizeof(stk)); memset(is, 0, sizeof(is)); memset(dfs, 0, sizeof(dfs)); memset(low, 0, sizeof(low)); for (re int i = 1; i &lt;= cntdcc; ++i) &#123; dcc[i].clear(); &#125; cntdcc = 0;&#125;void Tarjan(int cur) &#123; int times = 0; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; ++cntdcc; dcc[cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (dfs[cur] &lt;= low[to[i]]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; is[cur] = 1; &#125; ++cntdcc; int instk; do &#123; instk = stk[top--]; dcc[cntdcc].push_back(instk); &#125; while (instk != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; else &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; &#125;&#125;int n, m;signed main() &#123; int T = 0; while (~scanf(&quot;%lld&quot;, &amp;m)) &#123; if (m == 0) &#123; break; &#125; ++T; n = 0; Init(); for (re int i = 1, u, v; i &lt;= m; ++i) &#123; read(u), read(v); n = max(n, u); n = max(n, v); if (u == v) &#123; continue; &#125; Insert(u, v); Insert(v, u); &#125; for (re int i = n; i; --i) &#123; if (!dfs[i]) &#123; root = i; Tarjan(i); &#125; &#125;// 除核心以外的都是纯板子// ---------------核心--------------- int ans1 = 0, ans2 = 1; for (re int i = 1; i &lt;= cntdcc; ++i) &#123; int cnt = 0; for (re vector&lt;int&gt;::iterator j = dcc[i].begin(); j != dcc[i].end(); ++j) &#123; if (is[*j]) &#123; ++cnt; &#125; &#125; if (cnt == 1) &#123; ++ans1; ans2 *= dcc[i].size() - 1; &#125; else if (cnt == 0) &#123; ans1 += 2; ans2 *= dcc[i].size() * (dcc[i].size() - 1) / 2; &#125; &#125;// ---------------核心--------------- printf(&quot;Case %lld: %lld %lld\\n&quot;, T, ans1, ans2); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Luogu CF679A Bear and Prime 100","slug":"Bear and Prime 100","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Bear and Prime 100/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Bear%20and%20Prime%20100/","excerpt":"","text":"CF679A Bear and Prime 100一. 审题：1. 前提条件： 无 2. 询问 &amp; 输入： 询问：（最多 $20$ 次） 输出一个数 $x$，代表询问 $x$ 是否是被猜数的约数。 输入： 读入一个字符 yes 或 no 代表这个数是否是被猜数的约数。 3. 输出： 该数是否是素数。 二. 思路 我们知道质数的因数有且只有 $1$ 和自己，也就是 $1$ 和一个质数。所以第一感觉是把 $1-100$ 的质数问一遍。但很快发现询问次数不够。而且也用不着，因为，如果只问 1-50 内的质数： 如果有2个及以上的 $yes$ 回答，直接判断为合数。 如果有一个 $yes$ 回答，$51-100$ 不可能有因数，那样所猜数就超100了。 如果无 $yes$ 回答，$51-100$ 必有且只有一个因数，就是他本身呀。所以问 $51-100$ 的质数是无意义的。 问完质数还不够，例如 4 就判断不出来，因为本交互程序只判断有没有这个因数，不能说出该因数个数。所以还得判断质数的平方数（$100$ 以内的） 三. 代码因为每个输出后都跟了endl，所以不需要加fflush(stdout)。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int primes[20] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47&#125;; //1-50内质数，共15个int sq_nums[10] = &#123;4, 9, 25, 49&#125;; //质数的平方数(100以内的) string feedback; //交互返回的字符串bool once; //是否已经返回过一次yes了int main() &#123; for (int i = 0; i &lt; 15; ++i) &#123; cout &lt;&lt; primes[i] &lt;&lt; endl; cin &gt;&gt; feedback; if (feedback == &quot;yes&quot;) &#123; if (!once) &#123; once = 1; &#125; else &#123; cout &lt;&lt; &quot;composite&quot; &lt;&lt; endl; return 0; &#125; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; cout &lt;&lt; sq_nums[i] &lt;&lt; endl; cin &gt;&gt; feedback; if (feedback == &quot;yes&quot;) &#123;//这些平方数本来就是合数，所以只要返回1次yes就可以判断了 cout &lt;&lt; &quot;composite&quot; &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; &quot;prime&quot; &lt;&lt; endl; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogu P4544 [USACO10NOV]Buying Feed G","slug":"Buying Feed G","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Buying Feed G/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Buying%20Feed%20G/","excerpt":"","text":"P4544 USACO10NOV Buying Feed G放在前面：本方法时间复杂度为 $O(nW)$ ，单调队列优化 DP。本题还有一道弱化版，欢迎大佬切完这题顺便把那题也切了，并欢迎大家来该题题解看我的另一篇博客。 一. 变量声明： $W$：代替题目中的 $K$，到家时应带的饲料吨数，相当于背包中的背包最大承重（weight）。 $n$：代替题目中的 $N$，商店数量，相当于背包问题中的物品数。 $x_i$：同题目中的 $x_i$。 $w_i$：代替题目中的 $f_i$，商店 $i$ 食物数量。 $v_i$：代替题目中的 $c_i$，商店 $i$ 食物单价。 二. 思路1. 思考解法 路线上后面的商店不会影响路线前半部分的最优解，符合无后效性。 有最大容量 $W$，有可选择的物品，每个物品有重量和价值，明显是背包类问题。 所以考虑背包 DP。 2. 初始状态$d_{i,j}=\\begin{cases} 0&amp;(i=0~\\land~j=0)\\ \\infty&amp;(else) \\end{cases}$ 3. 结束状态$d_{\\operatorname{home},W}$ （$\\operatorname{home}$：见代码和代码中的注释） 4. 确定状态转移方程$d_{i,j}$：已经经过前 $i$ 个商店（已到 $i$ 号商店买了东西但还没有往 $i+1$ 号走）且恰好一共买了 $j$ 份食物时最少花费的费用。 本题就是一道改装版的多重背包问题，就加了一个转移花费，转移花费怎么求呢？$i$ 店与上一家店距离差为 $xi-x{i-1}$，若在 $i$ 号店之前买的食物份数一共为 $k$ ，在 $i$ 店购物后车上的食物份数为 $j$，则这段路上车辆运送的食物数为 $k$。转移花费就是 $(xi-x{i-1})\\times k^2$。 综上所述，朴素状转方程：$d{i,j}=\\min{k=0}^{k\\leqslant j}\\left{d{i-1,k}+(x_i-x{i-1})\\times k^2+v_i\\times (j-k)\\right}$ 5. 单调队列优化（重点）枚举 $i$ 复杂度为 $O(n)$，枚举 $j$ 复杂度为 $O(W)$，枚举 $k$ 最坏情况下复杂度也是 $O(W)$。总复杂度 $O(nW^2)$ 显然会超。那么让我们观察一下状转方程： ~~~~~~~~d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2+v_i\\times (j-k)\\right\\}\\Longrightarrow d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times k+v_i\\times j\\right\\}重点一 ：观察上面这个拆了个括号的方程，左边是我们要去求的状态，在该状态下，$i$ 和 $j$ 是已知的，因为该状态就是由 $i$ 和 $j$ 定义的，$i$ 和 $j$ 在一个具体的状态下为常量（或者换一种解释：$i$ 和 $j$ 是用 for 循环枚举出来的，所以我们当然知道他的值）。所以我们可以将 $v_i\\times j$ 提出括号。可得： \\Longrightarrow d_{i,j}=\\min_{k=0}^{k\\leqslant j}\\left\\{d_{i-1,k}+(x_i-x_{i-1})\\times k^2-v_i\\times k\\right\\}+v_i\\times j重点二：这个方程中的变量只有 $k$，而又有 $k\\leqslant j$，因为在 $i$ 店购物后的食物数不可能低于购物前。那么我们就可以使用单调队列优化。单调队列中存放的就是 $\\min$ 内的部分 $d{i-1,k}+(x_i-x{i-1})\\times k^2-vi\\times k$ （在这里我们把它称作 $calc{i,k}$），对于每一个 $i$ ，将 $j$ 从 $0$ 到 $W$ 枚举一遍，对于每个 $j$ 先将它作为 $k$ 计算 $calc{i,k}$ 并放到单调队列中，再先计算状态 $d{i.j}$。 三. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define re register#define int long longconst int MAXn = 500;const int MAXW = 10000;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;template &lt;class T&gt;inline T min(T a, T b) &#123; return a &lt; b ? a : b;&#125;struct Shop &#123; int x; int w; int v; Shop(): x(0), w(0), v(0)&#123;&#125; Shop(int x_, int w_, int v_): x(x_), w(w_), v(v_) &#123;&#125; inline bool operator &lt; (Shop &amp;a) &#123; return this-&gt;x &lt; a.x; &#125;&#125;;Shop shop[MAXn + 10];int W, n, d[MAXn + 10][MAXW + 10];int head, tail, que[MAXW + 10];inline int calc(int i, int k) &#123; return d[i - 1][k] + (shop[i].x - shop[i - 1].x) * k * k - shop[i].v * k;&#125;signed main() &#123; int E; read(W), read(E), read(n); shop[0] = Shop(0, 0, 0); //本人将起点和终点（家）时当做食物数为 0 的商店，这样能避免特判，所以“home”就是n+1 for (re int i = 1, x, w, v; i &lt;= n; ++i) &#123; read(x), read(w), read(v); shop[i] = Shop(x, w, v); &#125; shop[n + 1] = Shop(E, 0, 0); //同上 sort(shop, shop + n + 2); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (re int i = 1; i &lt;= n + 1; ++i) &#123; //i：当前阶段是在哪个店 head = 1; tail = 0; for (re int j = 0; j &lt;= W; ++j) &#123; //j：当前状态要求在此处商店购买后车上有多少饲料 while (calc(i, que[tail]) &gt; calc(i, j) &amp;&amp; head &lt;= tail) --tail; if (j - que[head] &gt; shop[i].w &amp;&amp; head &lt;= tail) ++head; que[++tail] = j; d[i][j] = calc(i, que[head]) + shop[i].v * j; &#125; &#125; printf(&quot;%lld&quot;, d[n + 1][W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogo P2616 [USACO10JAN]Buying Feed, II S","slug":"Buying Feed, II S","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Buying Feed, II S/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Buying%20Feed,%20II%20S/","excerpt":"","text":"P2616 USACO10 JANBuying Feed, II S放在前面：为对应“普及-”的难度，本文讲解的是 $O(nW^2)$ 复杂度的朴素 DP，如想挑战更高难度请进 Here，并欢迎大家来该题题解看我的另一篇博客上的 $O(nW)$ 解法。 一. 变量声明： $W$：代替题目中的 $K$，到家时应带的饲料吨数，相当于背包中的背包最大承重（weight）。 $n$：代替题目中的 $N$，商店数量，相当于背包问题中的物品数。 $x_i$：同题目中的 $x_i$。 $w_i$：代替题目中的 $f_i$，商店 $i$ 食物数量。 $v_i$：代替题目中的 $c_i$，商店 $i$ 食物单价。 二. 思路1. 思考解法 路线上后面的商店不会影响路线前半部分的最优解，符合无后效性。 有最大容量 $W$，有可选择的物品，每个物品有重量和价值，明显是背包类问题。 所以考虑背包 DP。 2. 初始状态$d_{i,j}=\\begin{cases} 0&amp;(i=0~\\land~j=0)\\ \\infty&amp;(else) \\end{cases}$ 3. 结束状态$d_{\\operatorname{home},W}$ （$\\operatorname{home}$：见代码和代码中的注释） 4. 确定状态转移方程$d_{i,j}$：已经经过前 $i$ 个商店（已到 $i$ 号商店买了东西但还没有往 $i+1$ 号走）且恰好一共买了 $j$ 份食物时最少花费的费用。 本题就是一道改装版的多重背包问题，就加了一个转移花费，转移花费怎么求呢？$i$ 店与上一家店距离差为 $xi-x{i-1}$，若在 $i$ 号店买的食物份数为 $k$ ，在 $i$ 店购物后车上的食物份数为 $j$（$j$ 和 $k$ 这两个量都是 for 循环枚举出来的），则这段路上车辆运送的食物数为 $j-k$。转移花费就是 $(xi-x{i-1})\\times (j-k)$。 综上所述，状转方程：$d{i,j}=\\min{k=0}^{k\\leqslant wi}\\left{d{i-1,j-k}+(xi-x{i-1})\\times (j-k)+v_i\\times k\\right}$ 三. 代码代码中有一些例如构造函数和重载运算符一样的技巧，这些暂时不会也不妨碍理解算法，只需看 main 函数中的内容就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define re registerconst int MAXn = 500;const int MAXW = 10000;template &lt;class T&gt; //模板函数inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;inline int min(int a, int b) &#123; return a &lt; b ? a : b;&#125;struct Shop &#123; int x; int w; int v; Shop(): x(0), w(0), v(0)&#123;&#125; //构造函数 Shop(int x_, int w_, int v_): x(x_), w(w_), v(v_) &#123;&#125; //同上 inline bool operator &lt; (Shop &amp;a) &#123; //重载运算符 return this-&gt;x &lt; a.x; &#125;&#125;;Shop shop[MAXn + 10];int W, n, d[MAXn + 10][MAXW + 10];int main() &#123; int E; read(W), read(E), read(n); shop[0] = Shop(0, 0, 0); //本人将起点和终点（家）时当做食物数为 0 的商店，这样能避免特判，所以“home”就是n+1 for (re int i = 1, x, w, v; i &lt;= n; ++i) &#123; read(x), read(w), read(v); shop[i] = Shop(x, w, v); &#125; shop[n + 1] = Shop(E, 0, 0); //同上 sort(shop, shop + n + 2); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (re int i = 1; i &lt;= n + 1; ++i) &#123; //i：当前阶段是在哪个店 for (re int j = W; j &gt;= 0; --j) &#123; //j：当前状态要求车上有多少饲料 for (re int k = 0; k &lt;= shop[i].w; ++k) &#123; //k：当前转移中要从本店买多少饲料 if (j &lt; k) continue; d[i][j] = min(d[i][j], d[i - 1][j - k] + (shop[i].x - shop[i - 1].x) * (j - k) + k * shop[i].v); &#125; &#125; &#125; printf(&quot;%d&quot;, d[n + 1][W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogu CF727C Guess the Array","slug":"Guess the Array","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/Guess the Array/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/Guess%20the%20Array/","excerpt":"","text":"CF727C Guess the Array注：本文含交互题 endl 与 fflush 不同种类的配合使用效果的 测试（见 “四”） 一. 审题：1. 前提条件： 一个数 $n$ 代表数组中数的个数。 2. 询问 &amp; 输入： 询问： 输出两个数 $x$，$y$ 。代表询问 $a_x$ 和 $a_y$ 的和。 格式：? x y 输入： 读入一个数代表这两个数的和。 3. 输出： 数组中所有数的值。格式：! a[1] a[2] a[3] ... a[n] 二. 思路1. 思考解法我们可以不一口气把 $n$ 次都询问完（当然最后肯定是都要询问完的），既然 $n$ 个数询问 $n$ 次一定有解，那么我们可以先询问 $a_1+a_2$ ， $a_2+a_3$ 以及 $a_3+a_1$ 。这样就能先计算出 $a_1$，$a_2$ 以及 $a_3$。 只要有了一个数的具体值，我们每询问一次就可以算出一个数的具体值，这样一气呵成，避免了一口气询问完后堆积过多条件无从下手的情况。 2. 具体实现 前三个数： 解法有很多，如 \\ \\ \\ \\ \\begin{cases}x+y=a\\\\y+z=b\\\\z+x=c\\end{cases}\\Longrightarrow 2x+2y+2z=a+b+c\\Longrightarrow x+y+z=\\dfrac{a+b+c}{2}\\Longrightarrow x=\\dfrac{a+b+c}{2}-b $y$，$z$ 同理。 剩下的数： 接下来询问$a_1+a_4$，$a_1+a_5$ . . . $a_1+a_n$。 三. 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5000;int n;int add12,add13,add23; //addxy:第x个和第y个数的和int add[MAXn + 10]; //add[x]:第1个和第x个数的和int first; //第一个数的值int main() &#123; scanf(&quot;%d&quot;, &amp;n); cout &lt;&lt; &quot;? 1 2&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add12); cout &lt;&lt; &quot;? 2 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add23); cout &lt;&lt; &quot;? 1 3&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add13);//这里用了endl就不需要fflush(stdout)了 first = (add13 - add23 + add12) &gt;&gt; 1;//读入前三个数间两两值得和，并计算第一个数 for (int i = 4 ; i &lt;= n; ++i) &#123; cout &lt;&lt; &quot;? 1 &quot; &lt;&lt; i &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;add[i]); &#125;//读入第1个数和第4-n个数间两两的值 cout &lt;&lt; &quot;! &quot; &lt;&lt; first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add12 - first; fflush(stdout); cout &lt;&lt; &#x27; &#x27; &lt;&lt; add23 - add12 + first; fflush(stdout); for(int i = 4; i &lt;= n; ++i) &#123; cout &lt;&lt; &#x27; &#x27; &lt;&lt; add[i] - first; &#125;&#125; 四. endl 与 fflush对交互题来说，弄清楚 endl 和 fflush 怎么用格外重要。不多废话了，直接摆上测试结果： 结论：endl 后面 不用跟 fflush，但如果没有 endl （或是用 printf）要加上 fflush(stdout)。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Luogu P1654 OSU!","slug":"OSU!","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/07/21/OSU!/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/OSU!/","excerpt":"","text":"P1654 OSU!放在前面：这是一道期望dp大水题，属于那种看题解一看就会，自己写一写就废的那种。 一. 思路（不想看我前面唠叨就直接看代码吧） 1. 确定状态转移方程$d_i$：$i$ 次操作后得的分数。则 $E(d_i)$：$i$ 次操作后期望的的分数。 第 $i$ 轮后，得分发生了怎样的变化了呢？我们先只看从最近一次失败后算起的成功的一段，$i$ 轮前得分是 $x^3$，如果低 $i$ 次成功，$i$ 轮后是 $(x+1)^3=x^3+3x^2+3x+1$，反之是 $0$。变化了 $3x^2+3x+1$。再加上之前的得分 $d_{i-1}$。 综上所述，已知成败情况的状转方程： $xi=\\begin{cases}0&amp;(fail)\\x{i-1}+1&amp;(success)\\end{cases}$ ${x^2}i=\\begin{cases}0&amp;(fail)\\{x^2}{i-1}+2x_{i-1}+1&amp;(success)\\end{cases}$ $di=d{i-1}+\\begin{cases}0&amp;(fail)\\3{x^2}{i-1}+3x{i-1}+1&amp;(success)\\end{cases}$ 设第 $i$ 次成功的几率为 $prob_i$。 综上所述，期望状转方程： \\begin{aligned} E(x)_i&=prob_i\\times (E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &=prob_i\\times (E(x)_{i-1}+1) \\\\ E({x^2})_i&=prob_i\\times(E({x^2})_{i-1}+2E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &=prob_i\\times(E({x^2})_{i-1}+2E(x)_{i-1}+1) \\\\ E(d)_i&=E(d)_{i-1}+prob_i\\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1)+(1-prob_i)\\times 0 \\\\ &=E(d)_{i-1}+prob_i\\times(3E({x^2})_{i-1}+3E(x)_{i-1}+1) \\\\ \\end{aligned}2. 坑点 $E(a^2)\\ne E(a)^2$ 也就是说，不能将状转方程中的 $E(x^2)$ 用 $E(x)$ 表示。 $d\\ne x^3$ $d$ 比 $x^3$ 还额外需要考虑之前的累计得分，也就是 $di$ 要加上 $d{i-1}$。 $E(d)$、$E(x^2)$ 和 $E(x)$ 更新的顺序 如果你不开数组，就要格外注意这一点。$d$ 的期望状转方程中用到 $E(d)$、 $E(x^2)$ 和 $E(x)$；$x^2$ 的用到 $E(x^2)$ 和 $E(x)$；$x$ 的只用到自己，并且用的都是上一阶段的。所以先刷新 $E(d)$，再刷新 $E(x^2)$，最后 $E(x)$。 二. 代码123456789101112#include&lt;cstdio&gt;int n; double prob, d, x2, x;int main() &#123; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; scanf(&quot;%lf&quot;, &amp;prob); d = d + prob * (3 * x2 + 3 * x + 1); x2 = prob * (x2 + 2 * x + 1); x = prob * (x + 1); &#125; printf(&quot;%.1lf&quot;, d);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"OI中的数论","slug":"OI中的数论","date":"un33fin33","updated":"un00fin00","comments":true,"path":"2021/07/21/OI中的数论/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E8%AE%BA/","excerpt":"","text":"一. 质数概念 概念：$\\varphi(n)$：$1\\sim n$ 中与 $n$ 互质的数的个数。 如果当 $a, b$ 互质时, 有 $f(a b)=f(a) * f(b)$, 那么称函数 $f$ 为积性函数。 性质 区间质数个数：前 $n$ 个：$\\dfrac{n}{\\ln n}$。 欧拉函数 $\\forall n&gt;1,1 \\sim n$ 中与 $n$ 互质的数的和为 $n \\times \\varphi(n) / 2$。 若 $a, b$ 互质, 则 $\\varphi(a b)=\\varphi(a) \\varphi(b)$。 若 $f$ 是积性函数, 且在算术基本定理中 $n=\\prod{i=1}^{m} p{i}^{c{i}}$, 则 $f(n)=\\prod{i=1}^{m} f\\left(p{i}^{c{i}}\\right)$。 设 $p$ 为质数, 若 $p \\mid n$ 且 $p^{2} \\mid n$, 则 $\\varphi(n)=\\varphi(n / p) * p$。 设 $p$ 为质数, 若 $p \\mid n$ 但 $p^{2} \\nmid n$, 则 $\\varphi(n)=\\varphi(n / p) *(p-1)$。 $\\sum_{d \\mid n} \\varphi(d)=n$。 公式 $\\varphi(n)=n \\times \\dfrac{p{1}-1}{p{1}} \\times \\dfrac{p{2}-1}{p{2}} \\times \\cdots \\times \\dfrac{p{m}-1}{p{m}}=n \\times \\prod_{\\text {质数 } p \\mid n}\\left(1-\\dfrac{1}{p}\\right)$。 $\\varphi(p\\times i)=\\varphi(i)\\times\\begin{cases}p&amp;(p\\mid i)\\p-1&amp;(p\\nmid i)\\end{cases}$。 代码 单点质数筛 试除法 区间质数筛 埃氏筛 线性筛 自由区间质数筛 双筛法（筛小素数再筛区间素数） 单点质因数分解 试除法 单点欧拉函数——质因数分解（求值公式） 区间欧拉函数——线性法（积性性质） 自由区间欧拉函数——倍数法（求值公式） 二. 约数性质 单点约数个数：$2 \\sqrt{n}$。 区间约数个数：$n \\log n$。 公式 正约数个数：$\\left(c{1}+1\\right) \\times\\left(c{2}+1\\right) \\times \\cdots \\times\\left(c{m}+1\\right)=\\prod{i=1}^{m}\\left(c_{i}+1\\right)$。 正约数和：$\\left(1+p{1}+p{1}^{2}+\\cdots+p{1}^{c{1}}\\right) \\times\\cdots \\times\\left(1+p{m}+p{m}^{2}+\\cdots+p{m}^{c{m}}\\right)=\\prod{i=1}^{m}\\left(\\sum{j=0}^{c{i}}\\left(p{i}\\right)^{j}\\right)$。 代码 $gcd~lcm$ 单点约数筛 试除法 区间约数筛 倍数法（埃氏） 三. 余数概念 对于 $\\forall a \\in[0, m-1]$, 集合 ${a+k m}(k \\in \\mathbb{Z})$ 的所有数模 $m$ 同余, 余数都是 $a_{0}$ 该集合称为一个模 $m$ 的同余类, 简记为 $\\bar{a}$ 。 模 $m$ 的同余类一共有 $m$ 个, 分别为 $\\overline{0}, \\overline{1}, \\overline{2}, \\cdots, \\overline{m-1}$ 。它们构成 $m$ 的完全剩余系。 $1 \\sim m$ 中与 $m$ 互质的数代表的同余类共有 $\\varphi(m)$ 个, 它们构成 $m$ 的简化剩余系。 例如, 模 10 的简化剩余系为 ${\\overline{1}, \\overline{3}, \\overline{7}, \\overline{9}}$ 。 若整数 $b, m$ 互质, 并且 $b \\mid a$, 则存在一个整数 $x$, 使得 $a / b \\equiv a \\times x(\\bmod m)$ 。 称 $x$ 为 $b$ 的模 $m$ 乘法逆元, 记为 $b^{-1}(\\bmod m)$。因为 $a / b \\equiv a \\times b^{-1} \\equiv a / b \\times b \\times b^{-1}(\\bmod m)$, 所以 $b \\times b^{-1} \\equiv 1(\\bmod m)$ 。 定理 / 公式 费马小定理：若 $p$ 是质数, 则对于任意整数 $a$, 有 $a^{p} \\equiv a(\\bmod p)$ 。 欧拉定理：若正整数 $a, n$ 互质, 则 $a^{\\varphi(n)} \\equiv 1(\\bmod n)$, 其中 $\\varphi(n)$ 为欧拉函数。 欧拉定理推论1：若正整数 $a, n$ 互质, 则对于任意正整数 $b$, 有 $a^{b} \\equiv a^{b \\bmod \\varphi(n)}(\\bmod n)$。 欧拉定理推论2：当 $a, n$ 不一定互质且 $b&gt;\\varphi(n)$ 时, 有 $a^{b} \\equiv a^{b \\bmod \\varphi(n)+\\varphi(n)}(\\bmod n)$。 裴蜀定理：对于任意整数 $a, b$, 存在一对整数 $x, y$, 满足 $a x+b y=\\operatorname{gcd}(a, b)$。 方程 $a x+b y=c$ 的通解：$x=\\frac{c}{d} x{0}+k \\frac{b}{d}, \\quad y=\\frac{c}{d} y{0}-k \\frac{a}{d}(k \\in \\mathbb{Z})$。 代码 $exgcd$ 求逆元 单点——$exgcd$、费马小定理 区间——线性求逆元 任意 $n$ 数——前缀积 $crt$","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Luogu P2432 zxbsmk爱查错","slug":"zxbsmk爱查错","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/zxbsmk爱查错/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/zxbsmk%E7%88%B1%E6%9F%A5%E9%94%99/","excerpt":"","text":"P2432 zxbsmk爱查错一. 审题：1.已知&amp;输入： 给出一个长度为 $L$ 的文本串。 给出 $W$ 个单词串。 2.目标&amp;输出： 在文本串中删除尽量少的字母使得文本串只有由词串构成，输出这个最少删除的字母数。 二. 思路1. 思考解法 文本串后面的内容不会影响文本串前半部分的最优解，符合无后效性。 若把文本串右端位置作为状态，文本串右端位置较靠右的状态需要通过文本串右端位置较靠左的状态得到（如 $di$ 需要通过 $d_0 \\dots d{i-1}$ 的其中之一得到），符合子问题重叠性。 所以考虑DP。 2. 确定状态转移方程$d_i$：前 $i$ 个子母的文本串中最少删除的字母数。 $txtidx$：用该第 $j$ 个单词串匹配前 $i$ 个子母的文本串，匹配完时文本串的下标。（3. 中有详解） $delcnt$：用该第 $j$ 个单词串匹配前 $i$ 个子母的文本串，匹配过程中失配的次数。（3. 中有详解） $seccessmatch$：用该第 $j$ 个单词串匹配前 $i$ 个子母的文本串，是否匹配成功。（3. 中有详解） 综上所述，状转方程：$di=\\min{j=1}^{W}\\begin{cases}d{i-1}+1&amp;(seccessmatch=false)\\d{txtidx}+delcnt&amp;(seccessmatch=true)\\end{cases}$ 3.细节&amp;详解反正跟字符串有关题的题解，没图我是看不懂。 比如文本串是 cabbcxyz ，我们现在正在求 $d_5$ （$i=5$） 用其中一个单词串 abc 匹配，用某个单词匹配时不用管其他单词。 初始时把 $txtidx$ 设为 $i$ （也就是 $5$），$wordidx$ 设为单词长度， $delcnt$ 设为 $0$ 。（注意 $delnum$ 不是整个文本串删去的字母个数，而是当前情况下匹配过部分的文本串的删去字母个数。3. 中有详解） 初始时： 第一次匹配后： 第二次匹配后： 第三次匹配后： 第四次匹配后： 三. 代码代码中有比较详细的注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXwordcnt = 600;//单词数量最大值 const int MAXwordlen = 25;//单词长度最大值 const int MAXtxtlen = 300;//文本长度最大值 int wordcnt/*单词数量*/, txtlen/*文本长度*/;char word[MAXwordcnt + 10][MAXwordlen + 10]/*单词*/, txt[MAXtxtlen + 10]/*文本*/;int d[MAXtxtlen];//DP数组 int main() &#123; scanf(&quot;%d %d&quot;, &amp;wordcnt, &amp;txtlen); scanf(&quot;%s&quot;, txt + 1); for (int i = 1; i &lt;= wordcnt; ++i) &#123; scanf(&quot;%s&quot;, word[i] + 1); &#125; d[0] = 0; for (int i = 1; i &lt;= txtlen; ++i) &#123; d[i] = d[i - 1] + 1;//如果没有单次得以再次位置匹配，需要删除的单词数++ for (int j = 1; j &lt;= wordcnt; ++j) &#123; int wordidx = strlen(word[j] + 1);//此时单词串的下标 int txtidx;//此时文本串的下标 int delcnt = 0;//当前情况下匹配过部分的文本串的删去字母个数 bool seccessmatch = 0;//是否匹配成功 for (txtidx = i; txtidx &gt;= 1; --txtidx) &#123; if (wordidx == 0) &#123;//wordidx == 0代表单词已经匹配完了 seccessmatch = 1; break; &#125; if (txt[txtidx] == word[j][wordidx]) &#123;//如果单词串与文本串在该位置相同... --wordidx; //那么匹配下一位 &#125; else &#123; //否则... ++delcnt; //需要删的个数++ &#125; &#125; if (wordidx == 0) &#123;//wordidx == 0代表单词已经匹配完了 seccessmatch = 1; &#125; if (seccessmatch) &#123; //如果成功匹配... d[i] = min(d[i], d[txtidx] + delcnt);//转移状态 &#125; &#125; &#125; printf(&quot;%d&quot;, d[txtlen]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"UVA 1025 城市里的间谍 A Spy in the Metro","slug":"城市里的间谍","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/城市里的间谍/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%9F%8E%E5%B8%82%E9%87%8C%E7%9A%84%E9%97%B4%E8%B0%8D/","excerpt":"","text":"UVA1025 城市里的间谍 A Spy in the Metro（本题有多倍经验哦） 一. 思路1. 思考解法 时间 是个好的 DP 阶段，时间轴上靠后发生的不会影响前面的事，反映到本题上就是 Maria 之后怎么走不会影响现在的最优解，符合无后效性。 Maria 既可以乘向东的地铁，又可以乘向西的地铁，还可以呆着不动。那么一种情况可以由多种情况而来，多种情况也可以发展成一种情况，各种情况互相交织，符合子问题重叠性。 所以考虑 DP。 2. 前缀和初始化 题目给出了站的时间间距和每列地铁发车时的时间（只会从首末两站发车），事实上，地铁在前进中到达每站的时间就是个前缀和 （偷偷点开标签我们也可以看到前缀和），到达某站的时间就是前面所有站时间间距之和，当然还要加上发车时间。 3. DP我采用的是 刷表法，当然，填表法 也可以。 所需条件： $stabet_i$：站 $i-1$ 与站 $i$ 间相隔的时间。 $canright{i,j}(canleft{i,j})$：$i$ 时刻 $j$ 站是否有开向末站（首站）的火车。 $d_{i,j}$：得到 $i$ 时刻在 $j$ 站这种状态最少的停留时间。 通过前缀和我们已经得到 $canright$ 以及$canleft$ 数组。接下来就是状态转移了。 初始状态： 易得，应初始化为： $d_{i,j}=\\begin{cases}0&amp;(i=0~\\land~j=1)\\\\infty&amp;(else)\\end{cases}$ 其中 $\\infty$ 代表无法到达。 状态转移： 因为本题的阶段之间不像普通的0/1背包那样只会由上一阶段转移到，而是也会由很多个单位时间之前的阶段转移到（站与站之间的时间不止1），所以我选择多维数组而非滚动数组。 首先，无论此刻此站有没有地铁，都可以在本站等待，这是普遍的转移；另外，如果此刻此站恰好有地铁，可以做特殊的转移。 综上所述，状转方程：（因为是刷表法，状转方程不方便写在一个括号里，蒟蒻就这么写了 qwq） （$\\operatorname{self}$ 代表自己） \\begin{aligned} &d_{i,j}=\\min(\\operatorname{self},~d_{i-1,j}+1)&(i>0) \\\\ &d_{i+stabet_{j+1},j+1}=\\min(\\operatorname{self},~d_{i,j})&(canright_{i,j}=true) \\\\ &d_{i+stabet_j,j-1}=\\min(\\operatorname{self},~d_{i,j})&(canleft_{i,j}=true) \\\\ \\end{aligned} 结果状态： $d_{T,n}$ 二. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 50;const int MAXT = 2000;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, T, stabet[MAXn + 10], rightcnt, leftcnt; bool canright[MAXT + 10][MAXn + 10], canleft[MAXT + 10][MAXn + 10]; int d[MAXT + 10][MAXn + 10]; int main() &#123; int k = 0; read(n); while (n) &#123; ++k; memset(canright, 0, sizeof(canright)); // memset(canleft, 0, sizeof(canleft)); //多组数据要初始化 memset(d, 0x3f, sizeof(d)); // read(T); for (int i = 2; i &lt;= n; ++i) &#123; read(stabet[i]); &#125; int time; // read(rightcnt); // for (int i = 1; i &lt;= rightcnt; ++i) &#123; // read(time); // canright[time][1] = 1; // for (int j = 2; j &lt;= n; ++j) &#123; // time += stabet[j]; // canright[time][j] = 1; // &#125; // &#125; //边读入边用前缀和计算canright和canleft数组 read(leftcnt); // for (int i = 1; i &lt;= leftcnt; ++i) &#123; // read(time); // canleft[time][n] = 1; // for (int j = n - 1; j &gt;= 1; --j) &#123; // time += stabet[j + 1]; // canleft[time][j] = 1; // &#125; // &#125; // d[0][1] = 0; for (int i = 0; i &lt;= T; ++i) &#123; // for (int j = 1; j &lt;= n; ++j) &#123; // if (i) // d[i][j] = min(d[i][j], // d[i - 1][j] + 1); // if (canright[i][j]) // d[i + stabet[j + 1]][j + 1] = min(d[i + stabet[j + 1]][j + 1], //动态规划 d[i][j] );// if (canleft[i][j]) // d[i + stabet[j]][j - 1] = min(d[i + stabet[j]][j - 1], // d[i][j] ); // &#125; // &#125; // if (d[T][n] == INF) &#123; printf(&quot;Case Number %d: impossible\\n&quot;, k); &#125; else &#123; printf(&quot;Case Number %d: %d\\n&quot;, k, d[T][n]); &#125; read(n); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"}]},{"title":"Luogu P3868 [TJOI2009]猜数字","slug":"猜数字","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/猜数字/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%8C%9C%E6%95%B0%E5%AD%97/","excerpt":"","text":"P3868 [TJOI2009]猜数字一. 思路首先拿道题看到条件给出两组数，其中一组互素，让猜一个数字。自然而然往 crt 上想。但为什么是 crt 呢？ $\\forall i \\in [1,k]$，有 $b_i \\mid (n - a_i)$，这句话可以化为一组同余方程，再移项可得标准的 crt 格式： ~~~~~~~~~~~~~~\\begin{cases} n - a_1 \\equiv 0 &(\\operatorname{mod}~b_1) \\\\ n - a_2 \\equiv 0 &(\\operatorname{mod}~b_2) \\\\ \\cdots \\\\ n - a_k \\equiv 0 &(\\operatorname{mod}~b_k) \\\\ \\end{cases} \\\\ ~\\\\ \\Longrightarrow\\begin{cases} n \\equiv a_1 &(\\operatorname{mod}~b_1) \\\\ n \\equiv a_2 &(\\operatorname{mod}~b_2) \\\\ \\cdots \\\\ n \\equiv a_k &(\\operatorname{mod}~b_k) \\\\ \\end{cases}然后 crt 求解就好了。crt ——中国剩余定理就是提供了一个解同余方程组 $\\begin{cases}x \\equiv a1 &amp;(\\operatorname{mod}~m_1) \\ x \\equiv a_2 &amp;(\\operatorname{mod}~m_2) \\ \\cdots \\ x \\equiv a_n &amp;(\\operatorname{mod}~m_n) \\ \\end{cases}$ 的公式，即 $x = \\sum\\limits{i = 1}^{n} { ai \\times M_i \\times t_i }$，其中 $M_i = \\dfrac{\\prod\\limits{j = 1}^{n}m_j}{m_i}$， $t_i = \\operatorname{inv}(M_i)$。公式的推导详见 OI-Wiki。 二. 坑点交代码上去一看，为什么只有 90 分？最后一个点 WA 掉了，并且显示第一行第一列输出了减号。看来是爆 long long 了。所以需要龟速快速乘防止爆 long long。（本蒟蒻不会long double） 三. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 10;template &lt;typename T&gt;inline T qmul(T x, T y, T mod) &#123; if (x == 0 || y == 0) return 0; T ret = 0; while (y) &#123; if (y &amp; 1) ret = ((ret % mod) + (x % mod)) % mod; y &gt;&gt;= 1; x = ((x % mod) + (x % mod)) % mod; &#125; return ret;&#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int a, int m) &#123; int k, inv; exgcd(a, m, inv, k); return (inv % m + m) % m;&#125;int crt(int cnta, int *a, int *m) &#123; int prod = 1, ans = 0; for (re int i = 1; i &lt;= cnta; ++i) &#123; prod *= m[i]; &#125; for (re int i = 1, M; i &lt;= cnta; ++i) &#123; M = prod / m[i]; ans = (ans + qmul(qmul(a[i], M, prod), inv(M, m[i]), prod)) % prod; &#125; return ans;&#125;int n, a[MAXn + 10], m[MAXn + 10];signed main() &#123; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;m[i]); &#125; printf(&quot;%lld\\n&quot;, crt(n, a, m));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"对拍","slug":"对拍","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/对拍/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E5%AF%B9%E6%8B%8D/","excerpt":"","text":"在 OI 赛制 中，代码只能交一次，这是比赛与 OJ 最大的不同。我们如果不能保证代码是正确的，就需要对拍： code1/2.cpp：暴力及正解代码。 random.cpp：随机数据生成器。 match.cpp：对拍程序： 一. 对拍程序12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstdlib&gt;int T = 100;signed main() &#123; while (T--) &#123; system(&quot;./random &gt; in.txt&quot;); system(&quot;./1 &lt; in.txt &gt; 1.txt&quot;); system(&quot;./2 &lt; in.txt &gt; 2.txt&quot;); if (system(&quot;diff -b 1.txt 2.txt&quot;)) &#123; printf(&quot;Error!!!\\n&quot;); exit(1); &#125; else &#123; printf(&quot;Ok\\n&quot;); &#125; &#125;&#125; 注意头文件。 二. 随机数程序主推 mt19937 （需要 c++11）。随机数范围到 $2^{19937}-1$。完全不用担心不够用，具体实例： 1234567#include&lt;random&gt;#include&lt;ctime&gt;using namespace std;mt19937 rd(time(0));int random(int l, int r) &#123; return rd() % (r - l + 1) + l;&#125; 三. 图像示例 Your browser does not support the video tag.","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"Luogu P3601 签到题","slug":"签到题","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/签到题/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E7%AD%BE%E5%88%B0%E9%A2%98/","excerpt":"","text":"P3601 签到题一. 思路$1 \\le l \\le r \\le 10^{12}$，$r-l \\le 10^6$。很显然，传统的用欧拉函数是积性函数这条性质的从 $1$ 扫到区间右端的方法肯定不行。虽然传统的方法不行。但欧拉函数还有一条有用的公式：$\\varphi(n)=n \\times \\prod\\limits_{i=1}^{n}\\dfrac{p_i-1}{p_i}$ 。也就是说，我们只要知道 $l \\sim r$ 中所有数的质因数分解就好了。不难发现一个数 $n$ 的质因数中有一个或零个大于 $\\sqrt{n}$ 。那么我们把小于等于 $\\sqrt{r}$ 的质数姑且称为“小质数”；大于 $\\sqrt{r}$ 的叫“大质数”。 先预处理出所有小质数（也就是 $1 \\sim 10^6$ 内的）开一个数组 $inv$ 每个位置预处理为下标的值（就是 $\\varphi(n)=n \\times \\prod\\limits{i=1}^{n}\\dfrac{p_i-1}{p_i}$ 中的等式右边的 $n$），然后用倍数法枚举所有小质数在 $l \\sim r$ 区间中的倍数，将相应的 $inv_i$ 乘上 $\\prod\\limits{i=1}^{n}\\dfrac{p_i-1}{p_i}$。 当然，不要忘了大质数，因为每个数至多有一个大质数，所以大质数也很好处理。开一个数组 $bidprime$ 全初始化为下标。用倍数法枚举 $prime_i$ 的倍数枚举到相应的 $inv_j$ 时，顺便把 $bigprime_j$ 中所有的的因数 $prime_i$ 剔除。最后就得到了每个数的大质数。 二. 细节最重要的细节就是枚举小指数的倍数时从几枚举了。设该小质数为 $p$，区间左端点为 $l$ 。答案是 $\\max{ p^2, \\left\\lceil\\dfrac{l}{p}\\right\\rceil \\times p }$。 为什么呢？首先小于 $p^2$ 的 $p$ 的倍数在枚举 $2$，$3$ 等比它更小的质数时就已经枚举过了。而 $\\left\\lceil\\dfrac{l}{p}\\right\\rceil \\times p $ 是大于等于 $l$ 的第一个 $p$ 的倍数。 三. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register #define int long longconst int MAXprime = 1e6;const int MAXn = 1e6;const int MOD = 666623333;template &lt;class T&gt;inline T max(T a, T b) &#123; return a &gt; b ? a : b;&#125;int cntp, prime[MAXprime / 5 + 100];bool notp[MAXprime + 10];void PrimeSieve(int up) &#123; //线性筛不解释 notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) prime[++cntp] = i; int upj = up / i; for (re int j = 1; j &lt;= cntp &amp;&amp; prime[j] &lt;= upj; ++j) &#123; notp[i * prime[j]] = 1; if (!(i % prime[j])) break; &#125; &#125;&#125;int ans, l, r, phi[MAXn + 10], bigprime[MAXn + 10];signed main() &#123; PrimeSieve(MAXprime); scanf(&quot;%lld %lld&quot;, &amp;l, &amp;r); for (re int i = l; i &lt;= r; ++i) &#123; //初始化 phi[i - l] = bigprime[i - l] = i; &#125; for (re int i = 1; i &lt;= cntp; ++i) &#123; //倍数法：枚举所有小质数的倍数 for (re int j = max(prime[i] * prime[i], (int)ceil((double)l / prime[i]) * prime[i]); j &lt;= r; j += prime[i]) &#123; phi[j - l] = phi[j - l] / prime[i] * (prime[i] - 1); while (!(bigprime[j - l] % prime[i])) &#123; bigprime[j - l] /= prime[i]; &#125; &#125; &#125; for (re int i = l; i &lt;= r; ++i) &#123; //处理大质数 if (bigprime[i - l] &gt; 1) &#123; phi[i - l] = phi[i - l] / bigprime[i - l] * (bigprime[i - l] - 1); &#125; &#125; for (re int i = l; i &lt;= r; ++i) &#123; //求和 ans = (ans + i - phi[i - l]) % MOD; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"记一只小傻蜂","slug":"记一只小傻蜂","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/记一只小傻蜂/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E8%AE%B0%E4%B8%80%E5%8F%AA%E5%B0%8F%E5%82%BB%E8%9C%82/","excerpt":"","text":"今天，2021 年 6 月 28 日。 笃行楼 5 楼 第三机房，不足 40 cm 的狭窄门缝中，钻进了一只蜂。 这只蜂比较肥大，巨身修尾，青项金翅。 进来就盘旋在天花板上面，半天赶不下来。 傻死了，她要么一直撞灯管，要么一直盘旋着飞，给她掰了些饼干也不吃。 稍晚些的时候，杰从机房的外面进来了，但是杰哥要怎么把她从高度 4m 的高高天花板中再赶出去啊！ 天啊，她怎么一直在飞，真的不累吗。 放张照片： 又过了一会 她不知什么时候又飞到灯泡管上面了，半天一直没动静。 我好怕啊。 被杰哥一扫帚打下来，估计是没了。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://rsdbkhusky.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"锁机","slug":"锁机","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/锁机/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%94%81%E6%9C%BA/","excerpt":"","text":"作为一名 $OIer$，我们时时刻刻都有被 $jc$ 的风险。这事我们需要一款简单的锁机程序来锁死保护我们的电脑： 12345678910#include&lt;windows.h&gt; #include&lt;winable.h&gt; #include&lt;time.h&gt;int main() &#123; FreeConsole(); while(1) &#123; if (clock() &gt; 10000) break; BlockInput(1); &#125; &#125; 比如这就是一个 $10$ 秒钟的锁机 ，clock() 函数的单位是 $ms$。 如果无效试试用管理员身份运行。 小心别多数了个 $0$。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"}]},{"title":"Luogu P3833 [SHOI2012]魔法树","slug":"魔法树","date":"un33fin33","updated":"un66fin66","comments":true,"path":"2021/07/21/魔法树/","link":"","permalink":"http://rsdbkhusky.github.io/2021/07/21/%E9%AD%94%E6%B3%95%E6%A0%91/","excerpt":"","text":"P3833 [SHOI2012]魔法树放在前面的前面：本文有树剖图解放在前面：一道树剖板子题，关于树剖的教程网上数不胜数，我就只 概述 一下，就不造轮子了，具体细节请见 OI WIKI。 一. 过程概述0. 基础：邻接表，线段树。1. 第一次 dfs：求出该有根树（如果题目没明确根就任选一个）所有节点的父节点，深度，（以他为根的）子树的大小， 重儿子。 2. 第二次 dfs：求出该有根树所有节点的 dfs 序—— $dfs$，每个 dfs 对应的节点编号—— $dfsidx$（$i=dfsidx_{dfs_i}$），所在重链的链顶—— $top$，其子树中节点中 dfs 序最大的一个—— $bottom$。用途： $dfs$：若这棵树上本来就有权值需要用它辅助给线段树建树。本题中无用。 $dfsidx$：用他将线段树上节点的编号转化为线段树上节点的编号。 $top$：进行树链上操作时需要。（详见我的代码和 OI WIKI） $bottom$：进行子树上操作时需要。（详见我的代码和 OI WIKI） 3. 权值增减与查询：详解见 OI WIKI，这里只放两张图： 树和dfs序： （madeby：大佬 EternalAlexander 的 OI Painter） 另一张dfs图： 有点先序遍历内味了，只不过不是根左右，而是根重轻。由此也可发现：树上一条重链或一棵子树都是线段树上连续的一部分，这正是树剖的核心。 二. 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include&lt;bits/stdc++.h&gt;using namespace std;#define re registertypedef long long LL;const int MAXn = 1e5;const int MAXm = MAXn - 1;template &lt;class T&gt;inline void read(T &amp;x) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T s(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;x = s;&#125;int cntnext, head[MAXn + 10], nex[MAXm + 10], to[MAXm + 10];//////inline void Insert(int from, int too) &#123; // nex[++cntnext] = head[from]; //邻接表 head[from] = cntnext; // to[cntnext] = too; //////&#125; struct Node &#123; //////线段树 LL sum; // int l; // int r; // LL add; //&#125;; //Node stt[MAXn * 4 + 10]; //void _BuildUseArray_(int nodeid, int l, int r, LL *array) &#123; // stt[nodeid].l = l; // stt[nodeid].r = r; // if (l == r) &#123; // stt[nodeid].sum = array[l]; // return; // &#125; // int mid = (l + r) &gt;&gt; 1; // _BuildUseArray_((nodeid &lt;&lt; 1), l, mid, array); // _BuildUseArray_((nodeid &lt;&lt; 1) + 1, mid + 1, r, array); // stt[nodeid].sum = (stt[(nodeid &lt;&lt; 1)].sum + stt[(nodeid &lt;&lt; 1) + 1].sum);&#125; //void _Build0_(int nodeid, int l, int r) &#123; // stt[nodeid].l = l; // stt[nodeid].r = r; // if (l == r) &#123; // return; // &#125; // int mid = (l + r) &gt;&gt; 1; // _Build0_((nodeid &lt;&lt; 1), l, mid); // _Build0_((nodeid &lt;&lt; 1) + 1, mid + 1, r); //&#125; //void _Spread_(int nodeid) &#123; // stt[(nodeid &lt;&lt; 1)].sum = ( stt[(nodeid &lt;&lt; 1)].sum + ((stt[(nodeid &lt;&lt; 1)].r - stt[(nodeid &lt;&lt; 1)].l + 1) * stt[nodeid].add) ); stt[(nodeid &lt;&lt; 1) + 1].sum = ( stt[(nodeid &lt;&lt; 1) + 1].sum + (stt[nodeid].add * (stt[(nodeid &lt;&lt; 1) + 1].r - stt[(nodeid &lt;&lt; 1) + 1].l + 1)) ); // stt[(nodeid &lt;&lt; 1)].add = (stt[(nodeid &lt;&lt; 1)].add + stt[nodeid].add); stt[(nodeid &lt;&lt; 1) + 1].add = (stt[(nodeid &lt;&lt; 1) + 1].add + stt[nodeid].add); // stt[nodeid].add = 0; /// &#125; ////////// 线段树 void _Add_(int nodeid, int l, int r, LL k) &#123; /// if (stt[nodeid].l &gt;= l &amp;&amp; stt[nodeid].r &lt;= r) &#123; // stt[nodeid].add = (stt[nodeid].add + k); // stt[nodeid].sum = (stt[nodeid].sum + k * (stt[nodeid].r - stt[nodeid].l + 1)); return; // &#125; // _Spread_(nodeid); // int mid = (stt[nodeid].l + stt[nodeid].r) &gt;&gt; 1; // if (l &lt;= mid) _Add_((nodeid &lt;&lt; 1), l, r, k); // if (mid &lt; r) _Add_((nodeid &lt;&lt; 1) + 1, l, r, k); // stt[nodeid].sum = (stt[(nodeid &lt;&lt; 1)].sum + stt[(nodeid &lt;&lt; 1) + 1].sum);&#125; //LL _Eva_(int nodeid, int l, int r) &#123; // if (stt[nodeid].l &gt;= l &amp;&amp; stt[nodeid].r &lt;= r) // return stt[nodeid].sum; // _Spread_(nodeid); // LL val = 0; // int mid = (stt[nodeid].l + stt[nodeid].r) &gt;&gt; 1; // if (l &lt;= mid) val = (val + _Eva_((nodeid &lt;&lt; 1), l, r)); // if (mid &lt; r) val = (val + _Eva_((nodeid &lt;&lt; 1) + 1, l, r)); return val; //&#125; //void BuildUseArray(int l, int r, LL *array) &#123; // _BuildUseArray_(1, l, r, array); //&#125; //void Build0(int l, int r) &#123; // memset(stt, 0, sizeof(stt)); // _Build0_(1, l, r); //&#125; //void Add(int l, int r, LL k) &#123; // _Add_(1, l, r, k); //&#125; //LL Eva(int l, int r) &#123; // return _Eva_(1, l, r); //&#125; //////线段树 int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];//树剖 int Dfs1(int nodeid, int fat, int deep) &#123; //// int size = 1; /// int maxsiz = 0; // int maxer = 0; // int eachsiz; // fa[nodeid] = fat; // dep[nodeid] = deep; // for (re int i = head[nodeid]; i; i = nex[i]) &#123; // eachsiz = Dfs1(to[i], nodeid, deep + 1); // size += eachsiz; // if (eachsiz &gt; maxsiz) &#123; // maxsiz = eachsiz; // maxer = to[i]; // &#125; // &#125; // siz[nodeid] = size; // hson[nodeid] = maxer; // return size; //&#125; // //int cntdfs, dfs[MAXn + 10], dfsidx[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10]; void Dfs2(int nodeid, int topp) &#123; // dfs[++cntdfs] = nodeid; // dfsidx[nodeid] = cntdfs; // top[nodeid] = topp; // if (hson[nodeid]) &#123; // Dfs2(hson[nodeid], topp); // for (int i = head[nodeid]; i; i = nex[i]) &#123; // if (to[i] != fa[nodeid] &amp;&amp; to[i] != hson[nodeid]) &#123; // Dfs2(to[i], to[i]); // &#125; // &#125; // &#125; // bottom[nodeid] = dfs[cntdfs]; //&#125; /// ////////// 树剖 void TreePathAdd(int x, int y, int k) &#123; /// while (top[x] != top[y]) &#123; // if (dep[top[x]] &gt; dep[top[y]]) &#123; // swap(x, y); // &#125; // Add(dfsidx[top[y]], dfsidx[y], k); // y = fa[top[y]]; // &#125; // if (dep[x] &gt; dep[y]) &#123; // swap(x, y); // &#125; // Add(dfsidx[x], dfsidx[y], k); //&#125; // //LL TreePathEva(int x, int y) &#123; // LL sum = 0; // while (top[x] != top[y]) &#123; // if (dep[top[x]] &gt; dep[top[y]]) &#123; // swap(x, y); // &#125; // sum += Eva(dfsidx[top[y]], dfsidx[y]); // y = fa[top[y]]; // &#125; // if (dep[x] &gt; dep[y]) &#123; // swap(x, y); // &#125; // sum += Eva(dfsidx[x], dfsidx[y]); // return sum; //&#125; // //void SonTreeAdd(int rootid, int k) &#123; // Add(dfsidx[rootid], dfsidx[bottom[rootid]], k); //&#125; // //LL SonTreeEva(int rootid) &#123; // return Eva(dfsidx[rootid], dfsidx[bottom[rootid]]); //&#125; //////树剖 int n, q;int main() &#123; read(n); Build0(1, n); for (re int i = 1, from, to; i &lt; n; ++i) &#123; read(from), read(to); Insert(from + 1, to + 1); &#125; Dfs1(1, 0, 1); Dfs2(1, 1); read(q); for (re int i = 1, from, to, val, opt, root; i &lt;= q; ++i) &#123; getchar(); opt = getchar(); switch (opt) &#123; case &#x27;A&#x27;: read(from), read(to), read(val); TreePathAdd(from + 1, to + 1, val); break; case &#x27;Q&#x27;: read(root); printf(&quot;%lld\\n&quot;, SonTreeEva(root + 1)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"卡时","slug":"卡时","date":"un22fin22","updated":"un66fin66","comments":true,"path":"2021/06/08/卡时/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/08/%E5%8D%A1%E6%97%B6/","excerpt":"","text":"众所周知，在各大计算机竞赛的赛场上，总会有那么一样东西令人头疼，令暴力爆零，令搜索欲哭无泪；在各大在线评测系统上，总会有那么三个字母教 $n^2$ 失败，教 $2^n$ 无奈，教 $n!$ 一个点都拿不到。没错，那就是 T-L-E。 今天就来分享分享怎么避免这三个大字的出现。 正文卡时，顾名思义，就是卡时间，用尽时间限制中的每一微秒，搜索的话就算没搜完，把局部最小值输出至少有可能 A，当然如果你的算法太差也顶多只能把 $TLE$ 变成 $WA$ 那么开始吧！ 1.代码直接放代码：（递归同理我就不再放一遍了） 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;#include&lt;ctime&gt;using namespace std;#define re registerint main() &#123; for (re int i = 0; ; ++i)&#123; if (i &gt;= 500000000 &amp;&amp; i % 1000000 == 0 &amp;&amp; clock() &gt;= 990) &#123; printf(&quot;How many done: %d\\n&quot;, i); printf(&quot;Time used: %.6lf\\n&quot;, (double) clock() / CLOCKS_PER_SEC); /*在这里输出“正解”*/ exit(EXIT_SUCCESS); &#125; /*在这里放程序的主体*/ &#125;&#125; 2.讲解 #include&lt;cmath&gt; 头文件记得加上 &quot;if (i &gt;= 500000000 &amp;&amp; i % 1000000 == 0 &amp;&amp; clock() &gt;= 990)&quot; 重点！ i &gt;= 500000000 ​ $500000000$ 是你估计的该循环体能在规定时间能执行的次数，往小估计一点！不然程序来不及判断 clock() &gt;= 990 就超时了。 i % 1000000 == 0 ​ 因为 clock 函数的常数很大，尽量少是执行他， 所以加这个来减少 clock() 的执行次数， $1000000$ 这个数别设太大，不然也容易没卡住而超时。 clock() &gt;= 990 ​ 整个卡时中最重要的部分，注意两点：一、990 这个数字取决于操作系统，因为 $Windows$ 的 CLOCKS_PER_SEC 是 $1000$ , $Linux$ 下是 $1000000$ ，也就是 $Window$ 的 clock() 返回值单位为毫秒， $Linux$ 是微秒，也就是说这个卡时程序要是在 $Linux$ 上测 $990$ 应该为 $990000$。二、不要太贪了， $1$ 秒的题开个 $980000$ 就行了，可别真开到开 $1000000$。 关于三者的顺序 ​ 我们知道，几个 &amp;&amp; 或 || 隔开的语句顺序不一样可能会有不同的结果，因为如果计算机通过靠前的语句能判断整个语句的布尔值就不会执行后面的，（如 &amp;&amp; 之间出现 false , || 之间出现 true ），所以，我们应该将耗时少的判定放在前面，耗时 &gt;= $&lt;$ % $&lt;$ clock()，所以我们按这个顺序放置。否则，卡时的耗时甚至要比搜索本身耗时高，得不偿失。 exit(EXIT_SUCCESS) “相当于 return 0 ，与 return 0 不同的是，无论他在哪执行（包括除 main 以外的函数），整个程序立即结束。依靠递归的搜索不能用 return 0 来停止，需要用它。 3.结果","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"运行时间测试","slug":"运行时间测试","date":"un22fin22","updated":"un66fin66","comments":true,"path":"2021/06/08/运行时间测试/","link":"","permalink":"http://rsdbkhusky.github.io/2021/06/08/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%B5%8B%E8%AF%95/","excerpt":"","text":"有一天，我在网上看到有人说重载 max() 函数是一种有用的卡常技巧，今天就来测一下重载 max() 到底是有用还是帮了倒忙。 正文1.代码直接放代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt;using namespace std;#define re registertypedef long long LL;LL numof = 100000000;/*在这里做初始化和准备工作*/inline int Max(int a, int b) &#123; return a &gt; b ? a : b;&#125;/*在这里做初始化和准备工作*/int main() &#123; printf(&quot;Time to do %lld is &quot;, numof) ; clock_t emptystart = clock(); for (re LL i = 0; i &lt; numof; ++i) &#123; &#125; clock_t emptyend = clock(); clock_t teststart = clock(); for (re LL i = 0; i &lt; numof; ++i) &#123; /*在这里放测试代码*/ max(13, 12); //Max(13, 12); /*在这里放测试代码*/ &#125; clock_t testend = clock(); printf(&quot;%.6lf\\n&quot;, (double) ((testend - teststart) - (emptyend - emptystart)) / CLOCKS_PER_SEC); &#125; 2.讲解 如果 numof 设得比较大最好加上 emptystart 和 emptyend 来排除循环本身的耗时。 123printf(&quot;%.6lf\\n&quot;, (double) ((testend - teststart) - (emptyend - emptystart)) / CLOCKS_PER_SEC); 很简单。 3.结果 C 自带的 max： 自制的 Max： 是有优化的，但效果并不明显 . . .","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"}]},{"title":"01分数规划","slug":"TemLib/01分数规划","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/01分数规划/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","excerpt":"","text":"P4377 USACO18OPEN Talent Show G12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 250;const int MAXW = 1e3;const double MAXfrac = 1e6;const double EPS = 1e-8;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, W, w[MAXn + 10], t[MAXn + 10]; double v[MAXn + 10];double d[MAXW + 10];double calc(double x) &#123; for (int i = 1; i &lt;= n; ++i) &#123; v[i] = (double)t[i] - (double)w[i] * x; &#125; memset(d, 0xc2, sizeof(d)); d[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = W; ~j; --j) &#123; int k = min(j + w[i], W); d[k] = max(d[k], d[j] + v[i]); &#125; &#125; return d[W];&#125;signed main() &#123; read(n, W); for (int i = 1; i &lt;= n; ++i) &#123; read(w[i], t[i]); &#125; double L = 0, R = MAXfrac; while (R - L &gt; EPS) &#123; double mid = (L + R) / 2; if (calc(mid) &gt; 0) &#123; L = mid; &#125; else &#123; R = mid; &#125; &#125; printf(&quot;%d\\n&quot;, int(L * 1000));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"01背包","slug":"TemLib/01背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/01背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/01%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1048 [NOIP2005 普及组] 采药123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;LL n, W;LL d[MAXW + 10];inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = W; i &gt;= w; i--) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Cdq解三维偏序","slug":"TemLib/Cdq解三维偏序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Cdq解三维偏序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Cdq%E8%A7%A3%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F/","excerpt":"","text":"P3810 【模板】三维偏序（陌上花开）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXk = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int top, t[MAXk + 10];#define lowbit(x) (x &amp; (-x))void Add(int p, int v) &#123; while (p &lt;= top) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int n, k;struct Ele &#123; int a, b, c, cnt, ans;&#125;eletmp[MAXn + 10], ele[MAXn + 10];inline bool cmpc(Ele x, Ele y) &#123; if (x.c == y.c) &#123; if (x.b == y.b) &#123; return x.a &lt; y.a; &#125; return x.b &lt; y.b; &#125; return x.c &lt; y.c;&#125;inline bool cmpb(Ele x, Ele y) &#123; if (x.b == y.b) &#123; return x.a &lt; y.a; &#125; return x.b &lt; y.b;&#125;void cdq(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; cdq(l, mid); cdq(mid + 1, r); int j = l; for (int i = mid + 1; i &lt;= r; ++i) &#123; while (j &lt;= mid &amp;&amp; ele[i].b &gt;= ele[j].b) &#123; Add(ele[j].a, ele[j].cnt); ++j; &#125; ele[i].ans += EvaSum(ele[i].a); &#125; for (int i = l; i &lt; j; ++i) &#123; Add(ele[i].a, -ele[i].cnt); &#125; inplace_merge(ele + l, ele + 1 + mid, ele + 1 + r, cmpb);&#125;int ans[MAXn + 10], m;int main() &#123; read(n), read(k); top = k; for (int i = 1; i &lt;= n; ++i) &#123; read(eletmp[i].a), read(eletmp[i].b), read(eletmp[i].c); &#125; sort(eletmp + 1, eletmp + 1 + n, cmpc); for (int i = 1, j = 0; i &lt;= n; ++i) &#123; ++j; if (eletmp[i].a != eletmp[i + 1].a || eletmp[i].b != eletmp[i + 1].b || eletmp[i].c != eletmp[i + 1].c) &#123; ++m; ele[m].a = eletmp[i].a; ele[m].b = eletmp[i].b; ele[m].c = eletmp[i].c; ele[m].cnt = j; j = 0; &#125; &#125; cdq(1, m); for (int i = 1; i &lt;= m; ++i) &#123; ans[ele[i].ans + ele[i].cnt - 1] += ele[i].cnt; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Ac自动机","slug":"TemLib/Ac自动机","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Ac自动机/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Ac%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"P3808 【模板】AC自动机（简单版）P3796 【模板】AC自动机（加强版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXtxtlen = 1e6;const int MAXwrdlen = 70;const int MAXwrdcnt = 150;const int MAXnd = 1e6;int cntnd, son[MAXnd + 10][26], mat[MAXnd + 10];char txt[MAXtxtlen + 10], wrd[MAXwrdcnt + 10][MAXwrdlen + 10];int ltxt, lwrd;int fail[MAXnd + 10], ndidx[MAXwrdcnt + 10];int n;queue&lt;int&gt; q;void clear(queue&lt;int&gt; &amp;q) &#123; queue&lt;int&gt; empty; swap(q, empty);&#125;void Init() &#123; cntnd = ltxt = lwrd = n = 0; memset(son, 0, sizeof(son)); memset(mat, 0, sizeof(mat)); memset(txt, 0, sizeof(txt)); memset(wrd, 0, sizeof(wrd)); memset(fail, 0, sizeof(fail)); memset(ndidx, 0, sizeof(ndidx)); memset(mat, 0, sizeof(mat)); clear(q);&#125;void Insert(char *wrd, int wrdidx) &#123; int cur = 0; for (re int i = 1; i &lt;= lwrd; ++i) &#123; if (son[cur][wrd[i] - 97]) &#123; cur = son[cur][wrd[i] - 97]; &#125; else &#123; cur = son[cur][wrd[i] - 97] = ++cntnd; &#125; &#125; ndidx[wrdidx] = cur;&#125;void GetFail() &#123; for (re int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int cur = q.front(); q.pop(); for (re int i = 0; i &lt; 26; ++i) &#123; if (son[cur][i]) &#123; fail[son[cur][i]] = son[fail[cur]][i]; q.push(son[cur][i]); &#125; else &#123; son[cur][i] = son[fail[cur]][i]; &#125; &#125; &#125;&#125;void Work() &#123; int cur = 0; for (re int i = 1; i &lt;= ltxt; ++i) &#123; cur = son[cur][txt[i] - 97]; int x = cur; while (x) &#123; ++mat[x]; x = fail[x]; &#125; &#125;&#125;int main() &#123; while (true) &#123; Init(); scanf(&quot;%d&quot;, &amp;n); if (!n) break; for (re int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%s&quot;, wrd[i] + 1); lwrd = strlen(wrd[i] + 1); Insert(wrd[i], i); &#125; GetFail(); scanf(&quot;%s&quot;, txt + 1); ltxt = strlen(txt + 1); Work(); int mx = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mat[ndidx[i]] &gt; mx) &#123; mx = mat[ndidx[i]]; &#125; &#125; printf(&quot;%d\\n&quot;, mx); for (re int i = 1; i &lt;= n; ++i) &#123; if (mat[ndidx[i]] == mx) &#123; printf(&quot;%s\\n&quot;, wrd[i] + 1); &#125; &#125; &#125; &#125; 每个字符串只算一次的 Work 函数。12345678910111213int Work() &#123; int j = 0, ans = 0; for (re int i = 1; i &lt;= ltxt; ++i) &#123; j = son[j][txt[i] - 97]; int k = j; while (cnt[k] &amp;&amp; k) &#123; ans += cnt[k]; cnt[k] = 0; k = fail[k]; &#125; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Exgcd求逆元","slug":"TemLib/Exgcd求逆元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Exgcd求逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Exgcd%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 【模板】乘法逆元此题不是求单个逆元的模板题，但可以用这道模板题检验这种求逆方法的正确性（没有WA） 123456789101112131415int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Floyd解最小环","slug":"TemLib/Floyd解最小环","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Floyd解最小环/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Floyd%E8%A7%A3%E6%9C%80%E5%B0%8F%E7%8E%AF/","excerpt":"","text":"P6175 无向图的最小环问题#include&lt;bits/stdc++.h&gt; using namespace std; const int MAXn = 1e2; const int INF = 0x20202020; template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#39;0&#39; || c &gt; &#39;9&#39;);register T x(c - &#39;0&#39;);while (c = getchar(), c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125; template &lt;typename T, typename ...Argv&gt; inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...); &#125; int n, m, ans = INF; int wei[MAXn + 10][MAXn + 10], dis[MAXn + 10][MAXn + 10]; signed main() &#123; read(n, m); memset(wei, 0x20, sizeof(wei)); memset(dis, 0x20, sizeof(dis)); for (int i = 1; i &lt;= n; ++i) &#123; wei[i][i] = dis[i][i] = 0; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); wei[u][v] = wei[v][u] = dis[u][v] = dis[v][u] = min(dis[u][v], w); &#125; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j || j == k || k == i) continue; ans = min(ans, wei[i][k] + wei[k][j] + dis[j][i]); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125; if (ans == INF) &#123; printf(&quot;No solution.\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, ans); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Gcd Lcm","slug":"TemLib/Gcd Lcm","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Gcd Lcm/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Gcd%20Lcm/","excerpt":"","text":"P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题1. 最大公约数(gcd) 辗转相除法 123int gcd(int a, int b) return b ? gcd(b, a % b) : a;&#125; 更相减损术 带取模的 123456789101112131415int gcd(int a, int b) &#123; int twice = 1; while (a % 2 == 0 &amp;&amp; b % 2 == 0) &#123; a /= 2, b /= 2; twice *= 2; &#125; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return twice * a;&#125; 不带取模的 12345678910int gcd(int a, int b) &#123; while(a != b) &#123; if(a &gt; b) &#123; a -= b; &#125; else &#123; b -= a; &#125; &#125; return a;&#125; 2. 最小公倍数123int lcm(int a, int b) &#123; return a / gcd(a, b) * b; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Johnson全源最短路","slug":"TemLib/Johnson全源最短路","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Johnson全源最短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Johnson%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P5905 【模板】Johnson 全源最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 3e3;const int MAXm = 6e3;const int INF = 1e9;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;inline void clear(priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; &amp;pq) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pqempty; pq = pqempty;&#125;int head[MAXn + 10], cntnex, nex[MAXm + MAXn + 10], from[MAXm + MAXn + 10], to[MAXm + MAXn + 10], wei[MAXm + MAXn + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; from[cntnex] = u; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m;int h[MAXn + 10], cntinque[MAXn + 10]; bool inque[MAXn + 10]; queue&lt;int&gt; q;bool Spfa(int sour) &#123; fill(begin(h), end(h), INF); h[sour] = 0; q.push(sour); inque[sour] = 1; ++cntinque[sour]; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (h[to[i]] &gt; h[cur] + wei[i]) &#123; h[to[i]] = h[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; ++cntinque[to[i]]; if (cntinque[to[i]] &gt; n + 1) &#123; return 0; &#125; &#125; &#125; &#125; &#125; return 1;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10]; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;void Dijkstra(int sour) &#123; memset(vis, 0, sizeof(vis)); fill(begin(dis), end(dis), INF); dis[sour] = 0; pq.push(make_pair(0, sour)); while (!pq.empty()) &#123; int cur = pq.top().second; pq.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; pq.push(make_pair(dis[to[i]], to[i])); &#125; &#125; &#125;&#125;signed main() &#123; read(n, m); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u, v, w); Insert(u, v, w); &#125; for (int i = 1; i &lt;= n; ++i) &#123; Insert(n + 1, i, 0); &#125; if (!Spfa(n + 1)) &#123; puts(&quot;-1&quot;); return 0; &#125; for (int i = 1; i &lt;= cntnex; ++i) &#123; wei[i] = wei[i] + h[from[i]] - h[to[i]]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int ans = 0; Dijkstra(i); for (int j = 1; j &lt;= n; ++j) &#123; if (dis[j] == INF) &#123; ans += j * INF; &#125; else &#123; ans += j * (dis[j] - h[i] + h[j]); &#125; &#125; printf(&quot;%lld\\n&quot;, ans); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Kmp","slug":"TemLib/Kmp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/Kmp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Kmp/","excerpt":"","text":"P3375 【模板】KMP字符串匹配wrd：txt：从 1 开始。 lwrd：ltxt：闭区间，[1, l]。 sec_i：以 i 为左端点的子串是单词串。 fail_j = k：文本串 [1, k] 的的后缀和整个文本串前缀最长公共部分的长度。如果单词串上遍历到 j + 1 时（还未确定单词串位置 j + 1 是否能匹配成功），fail_j = k 代表保证单词串 [1, k]。一定是已匹配成功的。也就是说应该判断 word_{j + 1} 与 txt_i 是否相等，而非 word_j，因为word_j 之前已经匹配成功了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;using std::ios;using std::cin;using std::cout;const int MAXlwrd = 1e6;const int MAXltxt = 1e6;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10]; bool isbegin[MAXltxt + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;void Solve() &#123; int j = 0; for (int i = 1; i &lt;= ltxt; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != txt[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == txt[i]) ++j; if (j == lwrd) isbegin[i - lwrd + 1] = 1; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); Solve(); for (int i = 1; i &lt;= ltxt; ++i) &#123; if (isbegin[i]) &#123; cout &lt;&lt; i &lt;&lt; &#x27;\\n&#x27;; &#125; &#125; for (int i = 1; i &lt;= lwrd; ++i) &#123; cout &lt;&lt; fail[i] &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Manacher","slug":"TemLib/Manacher","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Manacher/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Manacher/","excerpt":"","text":"P3805 【模板】manacher 算法1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e7 + 1e6;char str[MAXn * 2 + 10];int rad[MAXn * 2 + 10];void EvaRad(int len) &#123; for (int i = 1, l = 1, r = 0; i &lt;= len; ++i) &#123; if (i &gt; r) rad[i] = 0; else rad[i] = min(r - i, rad[r + l - i]); while (i + rad[i] &lt; len &amp;&amp; i - rad[i] &gt; 1 &amp;&amp; str[i + rad[i] + 1] == str[i - rad[i] - 1]) ++rad[i]; if (i + rad[i] &gt; r) &#123; r = i + rad[i]; l = i - rad[i]; &#125; &#125;&#125;char strfirst[MAXn + 10];int len1, len2, ans;signed main() &#123; scanf(&quot;%s&quot;, (strfirst + 1)); len1 = strlen(strfirst + 1); str[++len2] = &#x27;#&#x27;; for (int i = 1; i &lt;= len1; ++i) &#123; str[++len2] = strfirst[i]; str[++len2] = &#x27;#&#x27;; &#125; EvaRad(len2); for (int i = 1; i &lt;= len2; ++i) &#123; ans = max(ans, i &amp; 1 ? (rad[i] &amp; (~1)) : (rad[i] &amp; (~1)) + 1); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Splay","slug":"TemLib/Splay","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Splay/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Splay/","excerpt":"","text":"维护递增的中序遍历 P3369 【模板】普通平衡树 按题目要求维护的中序遍历（中序遍历维护序列） P3391 【模板】文艺平衡树 操作合集+Splay建树：P2042 [NOI2005] 维护数列 Splay 合并 P3224 [HNOI2012]永无乡 函数汇总： 辅助操作 $check(id)$ $pushup(id)$ $rotate(id)$ $splay(id, goal)$ $find(v)$ 主操作 $EvaPre(v)$ $EvaNex(v)$ $Insert(v)$ $Delete(v)$ $ValtoRank(v)$ $RanktoVal(rank)$ $pushdown(id)$ $Reverser(rank, rank)$ $Add(rank, cnt, a_1 a_2 \\cdots) Del(rank, cnt) \\cdots$ $Build(cnt, a_1, a_2 \\cdots)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXinque = 5e5;const int MAXnd = MAXinque;const int INF = 0x003f3f3f3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int root;int son[MAXnd + 10][2], fa[MAXnd + 10], siz[MAXnd + 10], val[MAXnd + 10], sum[MAXnd + 10], pref[MAXnd + 10], suf[MAXnd + 10], seg[MAXnd + 10], rev[MAXnd + 10], same[MAXnd + 10];inline bool check(int cur) &#123; return !rev[cur] || (same[cur] == INF);&#125;inline void pushdown(int cur) &#123; if (!cur) return; if (same[cur] != INF) &#123; val[cur] = same[cur]; sum[cur] = val[cur] * siz[cur]; pref[cur] = suf[cur] = max(0ll, sum[cur]); seg[cur] = (val[cur] &gt; 0 ? sum[cur] : val[cur]); if (son[cur][0]) same[son[cur][0]] = same[cur]; if (son[cur][1]) same[son[cur][1]] = same[cur]; same[cur] = INF; rev[cur] = 0; &#125; if (rev[cur]) &#123; swap(pref[cur], suf[cur]); swap(son[cur][0], son[cur][1]); if (son[cur][0]) rev[son[cur][0]] ^= 1; if (son[cur][1]) rev[son[cur][1]] ^= 1; rev[cur] = 0; &#125;&#125;inline void pushup(int cur) &#123; if (!cur) return; int ls = son[cur][0], rs = son[cur][1]; pushdown(ls); pushdown(rs); siz[cur] = siz[ls] + siz[rs] + 1; sum[cur] = sum[ls] + val[cur] + sum[rs]; pref[cur] = max(pref[ls], sum[ls] + val[cur] + pref[rs]); suf[cur] = max(suf[rs], sum[rs] + val[cur] + suf[ls]); seg[cur] = max(max(seg[ls], seg[rs]), suf[ls] + val[cur] + pref[rs]);&#125;inline int side(int cur) &#123; return cur == son[fa[cur]][1];&#125;inline void rotate(int cur) &#123; int y = fa[cur], z = fa[y], sidecur = side(cur), s = son[cur][sidecur ^ 1]; if (z) &#123;son[z][side(y)] = cur;&#125;; fa[cur] = z; son[y][sidecur] = s; if (s) &#123;fa[s] = y;&#125; son[cur][sidecur ^ 1] = y; fa[y] = cur; pushup(y); pushup(cur);&#125;inline void splay(int cur, int goal = 0) &#123; int y, z; while (fa[cur] != goal) &#123; y = fa[cur], z = fa[y]; if (z != goal) &#123; if (side(cur) == side(y)) rotate(y); else rotate(cur); &#125; rotate(cur); &#125; if (!goal) root = cur;&#125;inline int RanktoId(int rank) &#123; int cur = root; while (cur) &#123; pushdown(cur); if (rank &lt;= siz[son[cur][0]]) &#123; cur = son[cur][0]; &#125; else if (rank == siz[son[cur][0]] + 1) &#123; return cur; &#125; else &#123; rank -= siz[son[cur][0]] + 1; cur = son[cur][1]; &#125; &#125; return -1;&#125;queue&lt;int&gt; que;inline void InitQue() &#123; for (int i = 1; i &lt;= MAXinque + 2; ++i) &#123; que.push(i); &#125;&#125;inline int Build(int l, int r, int *a) &#123; int cur = que.front(); que.pop(); int mid = (l + r) &gt;&gt; 1; son[cur][0] = son[cur][1] = fa[cur] = rev[cur] = 0; same[cur] = INF; val[cur] = a[mid]; if (mid &gt; l) &#123; son[cur][0] = Build(l, mid - 1, a); fa[son[cur][0]] = cur; &#125; if (mid &lt; r) &#123; son[cur][1] = Build(mid + 1, r, a); fa[son[cur][1]] = cur; &#125; if (l == r) &#123; sum[cur] = a[mid]; pref[cur] = suf[cur] = max(0ll, a[mid]); seg[cur] = a[mid]; siz[cur] = 1; &#125; else &#123; pushup(cur); &#125; return cur;&#125;inline void Insert(int p, int lena, int *a) &#123; int pre = RanktoId(p), nex = RanktoId(p + 1); splay(pre); splay(nex, pre); son[nex][0] = Build(1, lena, a); fa[son[nex][0]] = nex; pushup(nex); pushup(pre);&#125;inline void dfsdelete(int cur) &#123; que.push(cur); if (son[cur][0]) dfsdelete(son[cur][0]); if (son[cur][1]) dfsdelete(son[cur][1]);&#125;inline void Delete(int l, int r) &#123; int pre = RanktoId(l - 1), nex = RanktoId(r + 1); splay(pre); splay(nex, pre); if (son[nex][0]) dfsdelete(son[nex][0]); son[nex][0] = 0; pushup(nex); pushup(pre);&#125;inline void Same(int l, int r, int a) &#123; int pre = RanktoId(l - 1), nex = RanktoId(r + 1); splay(pre); splay(nex, pre); if (son[nex][0]) &#123; same[son[nex][0]] = a; pushup(nex); pushup(pre); &#125;&#125;inline void Reverse(int l, int r) &#123; int pre = RanktoId(l - 1), nex = RanktoId(r + 1); splay(pre); splay(nex, pre); if (son[nex][0]) &#123; rev[son[nex][0]] ^= 1; pushup(nex); pushup(pre); &#125;&#125;inline int Sum(int l, int r) &#123; int pre = RanktoId(l - 1), nex = RanktoId(r + 1); splay(pre); splay(nex, pre); if (!son[nex][0]) return 0; pushup(nex); pushup(pre); return sum[son[nex][0]];&#125;inline int MaxSeg() &#123; pushdown(root); return seg[root];&#125;int n, m, a[MAXinque + 10];signed main() &#123; InitQue(); seg[0] = -INF; read(n, m); a[0] = a[n + 1] = -INF; for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; root = Build(0, n + 1, a); char opt[20]; for (int i = 1, p, len; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, opt); if (opt[0] == &#x27;I&#x27;) &#123; read(p, len); for (int i = 1; i &lt;= len; ++i) &#123; read(a[i]); &#125; Insert(p + 1, len, a); &#125; else if (opt[0] == &#x27;D&#x27;) &#123; read(p, len); Delete(p + 1, p + len); &#125; else if (opt[0] == &#x27;M&#x27; &amp;&amp; opt[2] == &#x27;K&#x27;) &#123; read(p, len, a[1]); Same(p + 1, p + len, a[1]); &#125; else if (opt[0] == &#x27;R&#x27;) &#123; read(p, len); Reverse(p + 1, p + len); &#125; else if (opt[0] == &#x27;G&#x27;) &#123; read(p, len); printf(&quot;%lld\\n&quot;, Sum(p + 1, p + len)); &#125; else if (opt[0] == &#x27;M&#x27; &amp;&amp; opt[2] == &#x27;X&#x27;) &#123; printf(&quot;%lld\\n&quot;, MaxSeg()); &#125; else &#123; puts(&quot;Error!&quot;); exit(1); &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"St表","slug":"TemLib/St表","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/St表/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/St%E8%A1%A8/","excerpt":"","text":"P3865 【模板】ST 表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXlog2n = 17;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, a[MAXn + 10], power[MAXlog2n + 10], st[MAXn + 10][MAXlog2n + 10];double ln2;void BuildSt() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; st[i][0] = a[i]; &#125; int maxidx = log(n) / ln2; for (re int idx = 1; idx &lt;= maxidx; ++idx) &#123; for (re int l = n - power[idx] + 1; l; --l) &#123; st[l][idx] = max(st[l][idx - 1], st[l + power[idx - 1]][idx - 1]); &#125; &#125;&#125;int EvaMax(int l, int r) &#123; int idx = log(r - l + 1) / ln2; return max(st[l][idx], st[r - power[idx] + 1][idx]);&#125;int m;int main() &#123; ln2 = log(2); power[0] = 1; for (re int i = 1; i &lt;= MAXlog2n; ++i) &#123; power[i] = power[i - 1] &lt;&lt; 1; &#125; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildSt(); for (re int i = 1, l, r; i &lt;= m; ++i) &#123; read(l), read(r); printf(&quot;%d\\n&quot;, EvaMax(l, r)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"三分","slug":"TemLib/三分","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/三分/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%89%E5%88%86/","excerpt":"","text":"P3382 【模板】三分法123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define re registerconst int MAXn = 13 + 1;const double EPS = 1e-6;int n;double l, r, a[MAXn + 10];double f(double x) &#123; double ans = 0; for (re int i = n; ~i; --i) &#123; ans = ans * x + a[i]; &#125; return ans;&#125;void ThreeDiv() &#123; if (r - l &lt; EPS) return; double mid = (l + r) / 2; if (f(mid - EPS) &gt; f(mid + EPS)) &#123; r = mid; &#125; else &#123; l = mid; &#125; ThreeDiv();&#125;int main() &#123; scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;l, &amp;r); for (re int i = n; ~i; --i) &#123; scanf(&quot;%lf&quot;, &amp;a[i]); &#125; ThreeDiv(); printf(&quot;%.5lf\\n&quot;, l);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"严格次小生成树","slug":"TemLib/严格次小生成树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/严格次小生成树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P4180 [BJWC2010]严格次小生成树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = 3e5;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m, root = 1;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int fat[MAXn + 10];int anc(int x) &#123; return fat[x] = fat[x] == x ? x : anc(fat[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fat[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fat[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];bool intree[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); intree[i] = 1; &#125; &#125; return ans;&#125;void mergemax(int &amp;ansmax, int &amp;anscmx, int max1, int cmx1, int max2, int cmx2) &#123; if (max1 &gt; max2) &#123; ansmax = max1; anscmx = max(max2, cmx1); &#125; else if (max1 &lt; max2) &#123; ansmax = max2; anscmx = max(max1, cmx2); &#125; else &#123; ansmax = max1; anscmx = max(cmx1, cmx2); &#125;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], maxx[MAXn * 4 + 10], cmax[MAXn * 4 + 10];void pushup(int id) &#123; mergemax(maxx[id], cmax[id], maxx[id &lt;&lt; 1], cmax[id &lt;&lt; 1], maxx[(id &lt;&lt; 1) + 1], cmax[(id &lt;&lt; 1) + 1]);&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; maxx[id] = a[l]; cmax[id] = -INF; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(id &lt;&lt; 1, l, mid, a); BuildUseArr((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;pair&lt;int, int&gt; Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return make_pair(maxx[id], cmax[id]); &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid &amp;&amp; r &gt; mid) &#123; int ansmax, anscmx; pair&lt;int, int&gt; left, right; left = Eva(id &lt;&lt; 1, l, r); right = Eva((id &lt;&lt; 1) + 1, l, r); mergemax(ansmax, anscmx, left.first, left.second, right.first, right.second); return make_pair(ansmax, anscmx); &#125; else if (l &lt;= mid) &#123; return Eva(id &lt;&lt; 1, l, r); &#125; else &#123; return Eva((id &lt;&lt; 1) + 1, l, r); &#125; &#125;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; ndwei[to[i]] = wei[i]; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!intree[i &gt;&gt; 1]) continue; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125;&#125;pair&lt;int, int&gt; TreePathEva(int x, int y) &#123; int ansmax = -INF, anscmx = -INF; int tmpansmax, tmpanscmx; pair&lt;int, int&gt; tmp; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; tmp = Eva(1, nddfs[top[y]], nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; if (x == y) &#123; return make_pair(ansmax, anscmx); &#125; else &#123; tmp = Eva(1, nddfs[x] + 1, nddfs[y]); mergemax(tmpansmax, tmpanscmx, ansmax, anscmx, tmp.first, tmp.second); ansmax = tmpansmax; anscmx = tmpanscmx; return make_pair(ansmax, anscmx); &#125;&#125;int ans, diff = INF;signed main() &#123; cntnex = 1; read(n), read(m); int tmp = 0; for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); if (u == v) &#123; ++tmp; continue; &#125; edge[i - tmp] = Edge(u, v, w); &#125; m -= tmp; ans = Kruskal(); for (re int i = 1; i &lt;= m; ++i) &#123; Insert(edge[i].u, edge[i].v, edge[i].w); Insert(edge[i].v, edge[i].u, edge[i].w); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArr(1, 1, n, idxwei); for (re int i = 1; i &lt;= m; ++i) &#123; if (!intree[i]) &#123; pair&lt;int, int&gt; tmp = TreePathEva(edge[i].u, edge[i].v); if (tmp.first == edge[i].w) &#123; diff = min(diff, edge[i].w - tmp.second); &#125; else &#123; diff = min(diff, edge[i].w - tmp.first); &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans + diff);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"Treap","slug":"TemLib/Treap","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/Treap/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/Treap/","excerpt":"","text":"P3369 【模板】普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int INF = 0x3f3f3f3f;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int cntnd, son[MAXn + 10][2], siz[MAXn + 10], num[MAXn + 10], val[MAXn + 10], rd[MAXn + 10];inline void pushup(int cur) &#123; siz[cur] = siz[son[cur][0]] + siz[son[cur][1]] + num[cur];&#125;inline void rotate(int &amp;cur, int side) &#123; int y = son[cur][side ^ 1]; int z = son[y][side]; son[cur][side ^ 1] = z; son[y][side] = cur; pushup(cur); pushup(y); cur = y;&#125;inline void Insert(int &amp;cur, int v) &#123; if (!cur) &#123; cur = ++cntnd; siz[cur] = num[cur] = 1; val[cur] = v; rd[cur] = rand(); &#125; else if (v == val[cur]) &#123; ++siz[cur]; ++num[cur]; &#125; else &#123; int side = (v &gt; val[cur]); Insert(son[cur][side], v); if (rd[son[cur][side]] &gt; rd[cur]) &#123; rotate(cur, side ^ 1); &#125; else &#123; ++siz[cur]; &#125; &#125;&#125;inline void Delete(int &amp;cur, int v) &#123; if (!cur) &#123; ; &#125; else if (v == val[cur]) &#123; if (num[cur] &gt; 2) &#123; --num[cur]; &#125; else if (!son[cur][0] &amp;&amp; !son[cur][1]) &#123; --num[cur]; --siz[cur]; if (!siz[cur]) cur = 0; return; &#125; else if (son[cur][0] &amp;&amp; !son[cur][1]) &#123; rotate(cur, 1); Delete(son[cur][1], v); &#125; else if (!son[cur][0] &amp;&amp; son[cur][1]) &#123; rotate(cur, 0); Delete(son[cur][0], v); &#125; else &#123; int side = (rd[son[cur][0]] &lt; rd[son[cur][1]]); rotate(cur, side ^ 1); Delete(son[cur][side ^ 1], v); &#125; --siz[cur]; &#125; else &#123; int side = (v &gt; val[cur]); Delete(son[cur][side], v); pushup(cur); &#125;&#125;inline int valtorank(int cur, int v) &#123; if (!cur) return 0; if (v &lt; val[cur]) &#123; return valtorank(son[cur][0], v); &#125; else if (v &gt; val[cur]) &#123; return siz[son[cur][0]] + num[cur] + valtorank(son[cur][1], v); &#125; else &#123; return siz[son[cur][0]]; &#125;&#125;inline int ValtoRank(int cur, int v) &#123; return valtorank(cur, v) + 1;&#125;inline int RanktoVal(int cur, int rank) &#123; if (!cur) return -INF; if (rank &gt;= siz[son[cur][0]] + 1 &amp;&amp; rank &lt;= siz[son[cur][0]] + num[cur]) &#123; return val[cur]; &#125; else if (rank &lt;= siz[son[cur][0]]) &#123; return RanktoVal(son[cur][0], rank); &#125; else &#123; return RanktoVal(son[cur][1], rank - (siz[son[cur][0]] + num[cur])); &#125;&#125;inline int Pre(int cur, int v) &#123; if (!cur) return -INF; if (val[cur] &gt;= v) &#123; return Pre(son[cur][0], v); &#125; else &#123; return max(val[cur], Pre(son[cur][1], v)); &#125;&#125;inline int Nex(int cur, int v) &#123; if (!cur) return INF; if (val[cur] &lt;= v) &#123; return Nex(son[cur][1], v); &#125; else &#123; return min(val[cur], Nex(son[cur][0], v)); &#125;&#125;int n, root;signed main() &#123; read(n); for (int i = 1, opt, x; i &lt;= n; ++i) &#123; read(opt, x); if (opt == 1) Insert(root, x); else if (opt == 2) Delete(root, x); else if (opt == 3) printf(&quot;%d\\n&quot;, ValtoRank(root, x)); else if (opt == 4) printf(&quot;%d\\n&quot;, RanktoVal(root, x)); else if (opt == 5) printf(&quot;%d\\n&quot;, Pre(root, x)); else if (opt == 6) printf(&quot;%d\\n&quot;, Nex(root, x)); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"中国剩余定理(crt)","slug":"TemLib/中国剩余定理(crt)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/中国剩余定理(crt)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86(crt)/","excerpt":"","text":"P1495 【模板】中国剩余定理(CRT)/曹冲养猪$x=\\sum\\limits_{i=1}^{n}a_i\\times M_i\\times M^{-1}_i(\\operatorname{mod}~m_i)~\\operatorname{mod}m$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 10;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int ans, k; exgcd(n, mod, ans, k); return (ans % mod + mod) % mod;&#125;int n, a[MAXn + 10], m[MAXn + 10];int Crt() &#123; int ans = 0, mulm = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mulm = mulm * m[i]; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; int M = mulm / m[i]; ans = (ans + ((a[i] * M) % mulm * inv(M, m[i])) % mulm) % mulm; &#125; return ans;&#125;signed main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(m[i]), read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Crt());&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二分","slug":"TemLib/二分","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二分/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%88%86/","excerpt":"","text":"重点： $mid$ 取 $l+r$ 还是 $l+r+1$。 “ $=$ “ 的话应该算那种情况。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, x, arr[MAXn + 10];int a() &#123; //大于等于中最小的(lower_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int b() &#123; //大于中最小的(upper_bound) int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int c() &#123; //小于中最大的 int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt;= x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int d() &#123; //小于等于中最大的 int l = 1, r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (arr[mid] &gt; x) &#123; r = mid - 1; &#125; else &#123; l = mid; &#125; &#125; return l;&#125;int main() &#123; read(n), read(x); for (re int i = 1; i &lt;= n; ++i) &#123; read(arr[i]); &#125; printf(&quot;%d %d %d %d\\n&quot;, a(), b(), c(), d()); // printf(&quot;%d %d\\n&quot;, int(lower_bound(arr + 1, arr + 1 + n, x) - arr), int(upper_bound(arr + 1, arr + 1 + n, x) - arr));&#125; 结果：","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"主席树","slug":"TemLib/主席树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/主席树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"P3834【模板】可持久化线段树 2（主席树）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using std::map;using std::sort;using std::unique;const int MAXn = 2e5;const int MAXlogn = 20;const int MAXm = 2e5;const int MAXnd = MAXn * 4 + MAXm * MAXlogn;const int MAXroot = MAXm;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], sum[MAXnd + 10];int cntroot, root[MAXroot + 10];int end[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int Build0(int l, int r) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; ls[id] = Build0(l, mid); rs[id] = Build0(mid + 1, r); &#125; return id;&#125;int BuildUseArr(int l, int r, int *a) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; ls[id] = BuildUseArr(l, mid, a); rs[id] = BuildUseArr(mid + 1, r, a); pushup(id); &#125; return id;&#125;int Insert(int verid, int l, int r, int p, int k) &#123; int id = ++cntnd; if (l == r) &#123; end[id] = l; sum[id] = sum[verid] + k; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; ls[id] = Insert(ls[verid], l, mid, p, k); rs[id] = rs[verid]; &#125; else &#123; ls[id] = ls[verid]; rs[id] = Insert(rs[verid], mid + 1, r, p, k); &#125; pushup(id); &#125; return id;&#125;map&lt;int, int&gt; mapdown; int cntmap, mapup[MAXn + 10];int n1, n2, m, a[MAXn + 10];int Query(int lid, int rid, int k) &#123; if (end[lid]) &#123; return mapup[end[lid]]; &#125; else &#123; if (k &lt;= sum[ls[rid]] - sum[ls[lid]]) &#123; return Query(ls[lid], ls[rid], k); &#125; else &#123; return Query(rs[lid], rs[rid], k - (sum[ls[rid]] - sum[ls[lid]])); &#125; &#125;&#125;signed main() &#123; read(n1, m); for (int i = 1; i &lt;= n1; ++i) &#123; read(a[i]); mapup[i] = a[i]; &#125; sort(mapup + 1, mapup + 1 + n1); n2 = unique(mapup + 1, mapup + 1 + n1) - mapup - 1; for (int i = 1; i &lt;= n2; ++i) &#123; mapdown[mapup[i]] = i; &#125; cntroot = -1; root[++cntroot] = Build0(1, n2); for (int i = 1; i &lt;= n1; ++i) &#123; ++cntroot; root[cntroot] = Insert(root[cntroot - 1], 1, n2, mapdown[a[i]], 1); &#125; for (int i = 1, l, r, k; i &lt;= m; ++i) &#123; read(l, r, k); printf(&quot;%d\\n&quot;, Query(root[l - 1], root[r], k)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二分图","slug":"TemLib/二分图","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/二分图/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%88%86%E5%9B%BE/","excerpt":"","text":"Luogu P3386 【模板】二分图最大匹配 Luogu P1350 车的放置 Luogu P6062 USACO05JAN Muddy Fields G Luogu P3355 骑士共存问题 12345678910111213141516171819202122232425262728293031323334353637bool vis[MAXnd + 10];int match[MAXnd + 10];bool Dfs(int cur) &#123; if (vis[cur]) return 0; // vis[cur] = 1; // 如果只是求最大匹配，不求最小点覆盖和最大独立集可以不用给左部点打标记，可以不加这两行。 for (int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; vis[to[i]] = 1; if (!match[to[i]] || Dfs(match[to[i]])) &#123; match[to[i]] = cur; return 1; &#125; &#125; return 0;&#125;int ans1, ans2, mincover[MAXnd + 10];signed main() &#123; // ...... for (int i = 1; i &lt;= cntleft; ++i) &#123; memset(vis, 0, sizeof(vis)); if (Dfs(i)) ++ans1; &#125; for (int i = cntleft + 1, top = cntleft + cntright; i &lt;= top; ++i) &#123; if (match[i]) match[match[i]] = 1; &#125; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= cntleft; ++i) &#123; if (!match[i]) Dfs(i); &#125; for (int i = 1; i &lt;= cntleft; ++i) &#123; if (!vis[i]) mincover[++ans2] = i; &#125; for (int i = cntleft + 1, top = cntleft + cntright; i &lt;= top; ++i) &#123; if (vis[i]) mincover[++ans2] = i; &#125; // ans1 == ans2&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"二叉堆","slug":"TemLib/二叉堆","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二叉堆/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%8F%89%E5%A0%86/","excerpt":"","text":"P3378 【模板】堆大根堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; int opt; n = read(); while (n--) &#123; opt = read(); switch (opt) &#123; case 1: Insert(read()); break; case 2: printf(&quot;%d\\n&quot;, GetRoot()); break; case 3: PopRoot(); break; &#125; &#125;&#125; 小根堆123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1000000;inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;int heap[MAXn + 10];int heapn;int n;void Up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &gt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void Down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &lt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &gt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void Insert(int x) &#123; heap[++heapn] = x; Up(heapn);&#125;void Pop(int p) &#123; heap[p] = heap[heapn--]; Up(p); Down(p);&#125;void PopRoot() &#123; heap[1] = heap[heapn--]; Down(1);&#125;int GetRoot() &#123; return heap[1];&#125;int main() &#123; Insert(1); Insert(3); Insert(1); Insert(7); Insert(11); Insert(25); cout &lt;&lt; GetRoot() &lt;&lt; endl; PopRoot(); cout &lt;&lt; GetRoot() &lt;&lt; endl;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二叉搜索树","slug":"TemLib/二叉搜索树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二叉搜索树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"P5076 【深基16.例7】普通二叉树（简化版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e4;const int INF = 2147483647;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());register bool f = c == &#x27;-&#x27;;register T s = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -s : s;&#125;struct Node &#123; int l, r, siz, cnt, val;&#125;;Node nd[MAXn + 10];int cnt;void Insert(int id, int val) &#123; ++nd[id].siz; if (nd[id].val == val) &#123; ++nd[id].cnt; &#125; else if (nd[id].val &lt; val) &#123; if (!nd[id].r) &#123; nd[++cnt].val = val; nd[id].r = cnt; &#125; Insert(nd[id].r, val); &#125; else &#123; if (!nd[id].l) &#123; nd[++cnt].val = val; nd[id].l = cnt; &#125; Insert(nd[id].l, val); &#125;&#125; int ValtoRank(int id, int val) &#123; if (!id) &#123; return 1; &#125; if (nd[id].val == val) &#123; return nd[nd[id].l].siz + 1; &#125; else if (nd[id].val &lt; val) &#123; return nd[nd[id].l].siz + nd[id].cnt + ValtoRank(nd[id].r, val); &#125; else &#123; return ValtoRank(nd[id].l, val); &#125;&#125;int RanktoVal(int id, int rank) &#123; if (!id) &#123; return -123456789; &#125; if (rank &lt;= nd[nd[id].l].siz) &#123; return RanktoVal(nd[id].l, rank); &#125; else if (rank &gt; nd[nd[id].l].siz + nd[id].cnt) &#123; return RanktoVal(nd[id].r, rank - nd[nd[id].l].siz - nd[id].cnt); &#125; else &#123; return nd[id].val; &#125;&#125;int EvaPreVal(int id, int val) &#123; if (!id) &#123; return -INF; &#125; if (nd[id].val &gt;= val) &#123; return EvaPreVal(nd[id].l, val); &#125; else &#123; return max(nd[id].val, EvaPreVal(nd[id].r, val)); &#125;&#125;int EvaNexVal(int id, int val) &#123; if (!id) &#123; return INF; &#125; if (nd[id].val &lt;= val) &#123; return EvaNexVal(nd[id].r, val); &#125; else &#123; return min(nd[id].val, EvaNexVal(nd[id].l, val)); &#125;&#125;int root = 1, n, opt, x;int main() &#123; read(n); nd[1].cnt = 1; nd[1].l = 2; nd[1].siz = 2; nd[1].val = INF; nd[2].cnt = 1; nd[2].siz = 1; nd[2].val = -INF; cnt += 2; for (re int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: printf(&quot;%d\\n&quot;, ValtoRank(root, x) - 1); break; case 2: printf(&quot;%d\\n&quot;, RanktoVal(root, x + 1)); break; case 3: printf(&quot;%d\\n&quot;, EvaPreVal(root, x)); break; case 4: printf(&quot;%d\\n&quot;, EvaNexVal(root, x)); break; case 5: Insert(root, x); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二维凸包","slug":"TemLib/二维凸包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二维凸包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/","excerpt":"","text":"P2742 USACO5.1 圈奶牛Fencing the Cows /【模板】二维凸包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;struct Point &#123; double x, y; inline bool operator&lt;(const Point sec) const &#123; if (x == sec.x) &#123; return y &lt; sec.y; &#125; return x &lt; sec.x; &#125;&#125;;inline double cp(Point a1, Point a2, Point b1, Point b2) &#123; return (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);&#125;inline double dist(Point a, Point b) &#123; return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;int n; Point point[MAXn + 10];int top, stk[MAXn + 10]; bitset&lt;MAXn + 10&gt; instk;double ans;signed main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lf%lf&quot;, &amp;point[i].x, &amp;point[i].y); &#125; sort(point + 1, point + 1 + n); stk[++top] = 1; instk[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; while (top &gt; 1 &amp;&amp; cp(point[stk[top - 1]], point[stk[top]], point[stk[top]], point[i]) &lt;= 0) &#123; instk[stk[top--]] = 0; &#125; stk[++top] = i; instk[i] = 1; &#125; int tmptop = top - 1; for (int i = n - 1; i; --i) &#123; if (!instk[i]) &#123; while (top - tmptop &gt; 1 &amp;&amp; cp(point[stk[top - 1]], point[stk[top]], point[stk[top]], point[i]) &lt;= 0) &#123; instk[stk[top--]] = 0; &#125; stk[++top] = i; instk[i] = 1; &#125; &#125; while (top - tmptop &gt; 1 &amp;&amp; cp(point[stk[top - 1]], point[stk[top]], point[stk[top]], point[1]) &lt;= 0) &#123; instk[stk[top--]] = 0; &#125; for (int i = 1; i &lt; top; ++i) &#123; ans += dist(point[stk[i]], point[stk[i + 1]]); &#125; ans += dist(point[stk[top]], point[stk[1]]); printf(&quot;%.2lf\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"二维树状数组","slug":"TemLib/二维树状数组","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/二维树状数组/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"1234567891011121314151617181920212223int t[MAXn + 10][MAXn + 10];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline void Add(int x, int y, int k, int topx, int topy) &#123; for (int i = x; i &lt;= topx; i += lowbit(i)) &#123; for (int j = y; j &lt;= topy; j += lowbit(j)) &#123; t[i][j] += k; &#125; &#125;&#125;inline int Sum(int x, int y) &#123; int ans = 0; for (int i = x; i; i -= lowbit(i)) &#123; for (int j = y; j; j -= lowbit(j)) &#123; ans += t[i][j]; &#125; &#125; return ans;&#125;inline int Sec(int x1, int y1, int x2, int y2) &#123; return Sum(x2, y2) - Sum(x1 - 1, y2) - Sum(x2, y1 - 1) + Sum(x1 - 1, y1 - 1);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"二维费用背包","slug":"TemLib/二维费用背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/二维费用背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1855 榨取kkksc031234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW1 = 200;const int MAXW2 = 200;const int INF = 0x3f3f3f3f;int n, W1, W2;int d[MAXW1 + 10][MAXW2 + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;int eva_maxV(int W1, int W2) &#123; int ans = -INF; for (int i = 0; i &lt;= W1; i++) &#123; for (int j = 0; j &lt;= W2; j++) ans = max(ans, d[i][j]); &#125; return ans;&#125;int main() &#123; n = read(); W1 = read(); W2 = read(); int v, w1, w2; for (int i = 1; i &lt;= n; i++) &#123; v = 1; w1 = read(); w2 = read(); for (int j = W1; j &gt;= w1; j--) &#123; for (int k = W2; k &gt;= w2; k--) d[j][k] = max(d[j][k], d[j - w1][k - w2] + v); &#125; &#125; cout &lt;&lt; eva_maxV(W1, W2);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"分组背包","slug":"TemLib/分组背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/分组背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1757 通天之分组背包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 1000;const int MAXW = 1000;int n, W;int v[MAXn + 10];int w[MAXn + 10];int team[MAXn + 10][MAXn + 10];int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void put_in() &#123; W = read(); n = read(); int teamid; for (int i = 1; i &lt;= n; i++) &#123; w[i] = read(); v[i] = read(); teamid = read(); team[teamid][++team[teamid][0]] = i; &#125;&#125;void rec(int v[], int w[], int W)&#123; for (int i = 1; i &lt;= MAXn; i++) &#123; if (team[i][0]) &#123; for (int j = W; j &gt;= 0; j--) &#123; for (int k = 1; k &lt;= team[i][0]; k++) &#123; if (j &gt;= w[team[i][k]]) d[j] = max(d[j], d[j - w[team[i][k]]] + v[team[i][k]]); &#125; &#125; &#125; &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v, w, W); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"分块","slug":"TemLib/分块","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/分块/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%88%86%E5%9D%97/","excerpt":"","text":"P2357 守墓人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register#define int long longconst int MAXn = 2e6;const int MAXsqrtn = 500;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, m;int a[MAXn + 10], inpart[MAXn + 10], length;int cntpart, sum[MAXsqrtn + 10], add[MAXsqrtn + 10], le[MAXsqrtn + 10], ri[MAXsqrtn + 10];void BuildUseArray(int *a) &#123; length = cntpart = sqrt(n); for (re int i = 1, l = 1, r = cntpart; i &lt;= cntpart; ++i) &#123; le[i] = l; ri[i] = r; for (re int j = l; j &lt;= r; ++j) &#123; sum[i] += a[j]; inpart[j] = i; &#125; l = r + 1; r += length; &#125; if (ri[cntpart] &lt; n) &#123; ++cntpart; le[cntpart] = ri[cntpart - 1] + 1; ri[cntpart] = n; for (re int i = le[cntpart]; i &lt;= ri[cntpart]; ++i) &#123; sum[cntpart] += a[i]; inpart[i] = cntpart; &#125; &#125;&#125;void Add(int l, int r, int k) &#123; if (inpart[l] == inpart[r]) &#123; for (re int i = l; i &lt;= r; ++i) &#123; a[i] += k; &#125; sum[inpart[l]] += k * (r - l + 1); &#125; else &#123; for (re int i = l; i &lt;= ri[inpart[l]]; ++i) &#123; a[i] += k; &#125; sum[inpart[l]] += k * (ri[inpart[l]] - l + 1); for (re int i = le[inpart[r]]; i &lt;= r; ++i) &#123; a[i] += k; &#125; sum[inpart[r]] += k * (r - le[inpart[r]] + 1); for (re int i = inpart[l] + 1; i &lt; inpart[r]; ++i) &#123; add[i] += k; &#125; &#125;&#125;int EvaSum(int l, int r) &#123; int ans = 0; if (inpart[l] == inpart[r]) &#123; for (re int i = l; i &lt;= r; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[l]] * (r - l + 1); &#125; else &#123; for (re int i = l; i &lt;= ri[inpart[l]]; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[l]] * (ri[inpart[l]] - l + 1); for (re int i = le[inpart[r]]; i &lt;= r; ++i) &#123; ans += a[i]; &#125; ans += add[inpart[r]] * (r - le[inpart[r]] + 1); for (re int i = inpart[l] + 1; i &lt; inpart[r]; ++i) &#123; ans += sum[i] + add[i] * length; &#125; &#125; return ans;&#125;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArray(a); for (re int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(z); Add(x, y, z); break; case 2: read(x); a[1] += x; sum[1] += x; break; case 3: read(x); a[1] -= x; sum[1] -= x; break; case 4: read(x), read(y); printf(&quot;%lld\\n&quot;, EvaSum(x, y)); break; case 5: printf(&quot;%lld\\n&quot;, a[1] + add[1]); break; &#125; &#125;&#125; 本来我是用线段树的板题来测我的分块的，但是后来又用这道题测了一下，发现始终过不了，调了很久才发现 “EvaSum -&gt; if (inpart[l] == inpart[r]) -&gt; ans += add[inpart[l]] * (r - l + 1);” 这句没有写。但是线段树的板题竟然过了，就离谱，这就是我不推荐用线段树板题测分块的原因。（不是为了水题）。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"割点 & 点双连通分量","slug":"TemLib/割点 & 点双连通分量","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/割点 & 点双连通分量/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%B2%E7%82%B9%20&%20%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"P3388 【模板】割点（割顶）123456789101112131415161718192021222324252627282930313233int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXnd + 10&gt; iscut;void Tarjan(int cur, int root) &#123; dfs[cur] = low[cur] = ++cntdfs; int times = 0; bool havcnt = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], root); low[cur] = min(low[cur], low[to[i]]); if (!havcnt) &#123; if (low[to[i]] &gt;= dfs[cur]) &#123; ++times; if (cur != root || times &gt;= 2) &#123; havcnt = 1; ++cntcut; iscut[cur] = 1; &#125; &#125; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, i); &#125; &#125;&#125; T103492 【模板】点双连通分量12345678910111213141516171819202122232425262728293031323334353637int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntdcc; vector&lt;int&gt; dcc[MAXnd + 10];int top, stk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; if (!head[cur]) &#123; dcc[++cntdcc].push_back(cur); return; &#125; stk[++top] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt;= dfs[cur]) &#123; ++cntdcc; int x; do &#123; x = stk[top--]; dcc[cntdcc].push_back(x); &#125; while (x != to[i]); dcc[cntdcc].push_back(cur); &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"前缀积法求逆元","slug":"TemLib/前缀积法求逆元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/前缀积法求逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%8D%E7%BC%80%E7%A7%AF%E6%B3%95%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P5431 【模板】乘法逆元 2123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e6;#define int long longtemplate &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ans * x % mod; &#125; x = x * x % mod; y &gt;&gt;= 1; &#125; return ans;&#125;int inv(int n, int mod) &#123; int inv = power(n, mod - 2, mod); return (inv % mod + mod) % mod;&#125;int n, p, k, a[MAXn + 10], pi[MAXn + 10], mi[MAXn + 10], invv, ans;signed main() &#123; read(n), read(p), read(k); pi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); pi[i] = (pi[i - 1] * a[i]) % p; &#125; mi[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; mi[i] = (mi[i - 1] * k) % p; &#125; invv = inv(pi[n], p); for (re int i = n; i; --i) &#123; ans = (ans + mi[i] * (invv * pi[i - 1] % p)) % p; invv = (invv * a[i]) % p; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"割边 & 边双连通分量","slug":"TemLib/割边 & 边双连通分量","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/割边 & 边双连通分量/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%89%B2%E8%BE%B9%20&%20%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"T103481 【模板】割边123456789101112131415161718192021222324252627int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125;&#125; T103489 【模板】边双连通分量1234567891011121314151617181920212223242526272829303132333435363738394041int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntcut; bitset&lt;MAXeg * 2 + 10&gt; iscut;void Tarjan(int cur, int fromedge) &#123; dfs[cur] = low[cur] = ++cntdfs; for (int i = head[cur]; i; i = nex[i]) &#123; if (i == (fromedge ^ 1)) continue; if (dfs[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else &#123; Tarjan(to[i], i); low[cur] = min(low[cur], low[to[i]]); if (low[to[i]] &gt; dfs[cur]) &#123; ++cntcut; iscut[i] = iscut[i ^ 1] = 1; &#125; &#125; &#125;&#125;int cntdcc, indcc[MAXnd + 10];void EvaDcc(int cur) &#123; indcc[cur] = cntdcc; for (int i = head[cur]; i; i = nex[i]) &#123; if (indcc[to[i]] || iscut[i]) continue; EvaDcc(to[i]); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i, 0); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!indcc[i]) &#123; ++cntdcc; EvaDcc(i); &#125; &#125;&#125; 如果只让输出边双的个数，桥数+不连通的图数也是正确答案。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"动态开点线段树","slug":"TemLib/动态开点线段树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/动态开点线段树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"P5459 [BJOI2016]回转寿司1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#define int long longusing std::map;using std::sort;using std::unique;const int MAXn = 1e5;const int MAXa = 1e5;const int MAXsuma = MAXn * MAXa;const int MAXlogsuma = 34;const int MAXnd = MAXn * MAXlogsuma * 4;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int cntnd, ls[MAXnd + 10], rs[MAXnd + 10], le[MAXnd + 10], ri[MAXnd + 10], sum[MAXnd + 10];inline void pushup(int id) &#123; sum[id] = sum[ls[id]] + sum[rs[id]];&#125;int AddNew(int l, int r, int p, int k) &#123; int id = ++cntnd; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = k; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) &#123; ls[id] = AddNew(l, mid, p, k); &#125; else &#123; rs[id] = AddNew(mid + 1, r, p, k); &#125; pushup(id); &#125; return id;&#125;void AddOld(int id, int p, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] += k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (p &lt;= mid) &#123; if (ls[id]) &#123; AddOld(ls[id], p, k); &#125; else &#123; ls[id] = AddNew(le[id], mid, p, k); &#125; &#125; else &#123; if (rs[id]) &#123; AddOld(rs[id], p, k); &#125; else &#123; rs[id] = AddNew(mid + 1, ri[id], p, k); &#125; &#125; pushup(id); &#125;&#125;int Sec(int id, int l, int r) &#123; if (!id) return 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans += Sec(ls[id], l, r); if (r &gt; mid) ans += Sec(rs[id], l, r); return ans; &#125;&#125;int n1, n2, L, R, a[MAXn + 10], suma[MAXn + 10], ans;signed main() &#123; read(n1, L, R); for (int i = 1; i &lt;= n1; ++i) &#123; read(a[i]); suma[i] = suma[i - 1] + a[i]; &#125; ++cntnd; le[cntnd] = -MAXsuma; ri[cntnd] = MAXsuma; sum[cntnd] = 0; AddOld(1, 0, 1); for (int i = 1; i &lt;= n1; ++i) &#123; ans += Sec(1, suma[i] - R, suma[i] - L); AddOld(1, suma[i], 1); &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"卢卡斯定理","slug":"TemLib/卢卡斯定理","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/卢卡斯定理/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/","excerpt":"","text":"P3807 【模板】卢卡斯定理/Lucas 定理$\\operatorname{C}^mn\\operatorname{mod}p=\\operatorname{C}^{m/p}{n/p}\\times \\operatorname{C}^{m\\operatorname{mod}p}_{n \\operatorname{mod}p}\\operatorname{mod}p$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#define re registertypedef long long ll;const int MAXC = 1e5 + 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int inv(int x, int p) &#123; int ans, k; exgcd(x, p, ans, k); return (ans % p + p) % p;&#125;int fac[MAXC + 10];void EvaFac(int top, int p) &#123; fac[0] = 1; for (re int i = 1; i &lt;= top; ++i) &#123; fac[i] = ((ll)fac[i - 1] * i) % p; &#125;&#125;int C(int n, int m, int p) &#123; if (n &lt; m) return 0; return (ll)fac[n] * inv(fac[m], p) % p * inv(fac[n - m], p) % p;&#125;int Lucas(int n, int m, int p) &#123; if (!m) return 1; return (ll)Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;&#125;int T, n, m, p;int main() &#123; read(T); while (T--) &#123; read(n), read(m), read(p); EvaFac(MAXC, p); n += m; m = n - m; printf(&quot;%d\\n&quot;, Lucas(n, m, p)); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"可重集全排列","slug":"TemLib/可重集全排列","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/可重集全排列/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%8F%AF%E9%87%8D%E9%9B%86%E5%85%A8%E6%8E%92%E5%88%97/","excerpt":"","text":"P2518 [HAOI2010]计数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 50;int C[MAXn + 10][MAXn + 10];void EvaC(int top) &#123; for (re int i = 0; i &lt;= top; ++i) &#123; C[i][0] = C[i][i] = 1; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; for (re int j = 1; j &lt; i; ++j) &#123; C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; &#125; &#125;&#125;int Pmult(int top, int *cnt, int sum = -1) &#123; int ans = 1; if (sum == -1) &#123; sum = 0; for (re int i = 1; i &lt;= top; ++i) &#123; sum += cnt[i]; &#125; &#125; for (re int i = 1; i &lt;= top; ++i) &#123; if (cnt[i]) &#123; ans *= C[sum][cnt[i]]; sum -= cnt[i]; &#125; &#125; return ans;&#125;char str[MAXn + 10]; int len;int sumcnt, cnt[11], ans;signed main() &#123; EvaC(MAXn); scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); reverse(str + 1, str + 1 + len); for (re int i = 1; i &lt;= len; ++i) &#123; if (str[i] - &#x27;0&#x27;) &#123; ++cnt[str[i] - &#x27;0&#x27;]; ++sumcnt; &#125; &#125; for (re int i = len; i; --i) &#123; if (str[i] - &#x27;0&#x27;) &#123; cnt[10] = i - 1 - sumcnt; ans += Pmult(10, cnt, i - 1); cnt[10] = i - 1 - (sumcnt - 1); for (re int j = 1; j &lt; str[i] - &#x27;0&#x27;; ++j) &#123; if (cnt[j]) &#123; --cnt[j]; ans += Pmult(10, cnt, i - 1); ++cnt[j]; &#125; &#125; --cnt[str[i] - &#x27;0&#x27;]; --sumcnt; &#125; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"同余最短路","slug":"TemLib/同余最短路","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/同余最短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P3403 跳楼机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXnd = 5e5;const int MAXn = 12;const int MAXeg = MAXnd * MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXnd + 10], cntnex, nex[MAXeg + 10], to[MAXeg + 10], wei[MAXeg + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;bool vis[MAXnd + 10]; int dis[MAXnd + 10];priority_queue&lt;pair&lt;int, int&gt;&gt; q;void Dijkstra(int root, int rootdis) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = rootdis; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int n, l, r, a[MAXn + 10], ans;signed main() &#123; read(n, l, r); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; sort(a + 1, a + 1 + n); for (int i = 0; i &lt; a[1]; ++i) &#123; for (int j = 2; j &lt;= n; ++j) &#123; Insert(i, (i + a[j]) % a[1], a[j]); &#125; &#125; Dijkstra(0, 0); for (int i = 0; i &lt; a[1]; ++i) &#123; if (dis[i] &gt; r) continue; ans += (r - dis[i]) / a[1] + 1; if (dis[i] &gt; l - 1) continue; ans -= (l - 1 - dis[i]) / a[1] + 1; &#125; printf(&quot;%lld\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"哈希","slug":"TemLib/哈希","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/哈希/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%93%88%E5%B8%8C/","excerpt":"","text":"123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 2333;int ans = 0, num, mo;vector&lt;int&gt; hash[MOD + 10];void insert(int a) &#123; mo = a % MOD; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == a) return; ans++; hash[mo].push_back(a);&#125;int main() &#123; int n; int a; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a), insert(a); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"块状链表","slug":"TemLib/块状链表","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/块状链表/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8/","excerpt":"","text":"Poj 2887 BigString 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXtxtlen = 1e6;const int MAXsqrttxtlen = 1e3;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, sqrtn;struct Node &#123; int len; Node *pre, *nex; char txt[MAXsqrttxtlen * 2 + 10]; Node() &#123;len = 0, pre = nullptr, nex = nullptr, memset(txt, 0, sizeof(txt));&#125; inline void split(int p) &#123; Node *nw = new Node; nw-&gt;nex = nex; nex = nw; nw-&gt;pre = this; if (nw-&gt;nex != nullptr) nw-&gt;nex-&gt;pre = nw; copy(txt + p + 1, txt + len + 1, nw-&gt;txt + 1); nw-&gt;len = len - p; len = p; &#125; inline void insert(int p, char ch) &#123; for (int i = len; i &gt; p; --i) &#123; txt[i + 1] = txt[i]; &#125; txt[p + 1] = ch; ++len; if (len &gt; sqrtn) &#123; split(len &gt;&gt; 1); &#125; &#125;&#125;;Node *head;inline void Init(char *str) &#123; Node *last = nullptr; for (int l = 1, r = sqrtn; ; l += sqrtn, r += sqrtn) &#123; Node *nw = new Node; if (last != nullptr) &#123; nw-&gt;pre = last; last-&gt;nex = nw; &#125; else &#123; head = nw; &#125; nw-&gt;len = min(r, n) - l + 1; copy(str + l, str + l + nw-&gt;len, nw-&gt;txt + 1); last = nw; if (r &gt;= n) break; &#125;&#125;inline char Query(int p) &#123; --p; Node *cur = head; while (p &gt;= cur-&gt;len) &#123; p -= cur-&gt;len; cur = cur-&gt;nex; &#125; return cur-&gt;txt[1 + p];&#125;inline void Insert(int p, char ch) &#123; --p; Node *cur = head; if (p == -1) &#123; cur-&gt;insert(0, ch); return; &#125; while (p &gt;= cur-&gt;len) &#123; p -= cur-&gt;len; cur = cur-&gt;nex; &#125; cur-&gt;insert(1 + p, ch);&#125;int m;char str[MAXtxtlen + 10];signed main() &#123; scanf(&quot;%s&quot;, str + 1); n = strlen(str + 1); sqrtn = sqrt(n); Init(str); read(m); char opt, ch; for (int i = 1, p; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, &amp;opt); if (opt == &#x27;Q&#x27;) &#123; read(p); printf(&quot;%c\\n&quot;, Query(p)); &#125; else if (opt == &#x27;I&#x27;) &#123; scanf(&quot;%s&quot;, &amp;ch); read(p); Insert(p - 1, ch); &#125; else &#123; puts(&quot;Error!&quot;); exit(1); &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"基环树","slug":"TemLib/基环树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/基环树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9F%BA%E7%8E%AF%E6%A0%91/","excerpt":"","text":"P1453 城市环路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define re registerconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;double k;int n, a[MAXn + 10], deg[MAXn + 10];queue&lt;int&gt; q;bool vis[MAXn + 10];int cntring, ring[MAXn + 10];void EvaRing() &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 1) &#123; q.push(i); &#125; &#125; int cur; while (!q.empty()) &#123; cur = q.front(); q.pop(); vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (!vis[to[i]]) &#123; --deg[to[i]]; if (deg[to[i]] == 1) &#123; q.push(to[i]); &#125; &#125; &#125; &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (deg[i] == 2) &#123; vis[i] = 1; ring[++cntring] = i; break; &#125; &#125; bool ok = 1; while (ok) &#123; ok = 0; for (re int i = head[ring[cntring]]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 1) continue; vis[to[i]] = 1; ring[++cntring] = to[i]; ok = 1; break; &#125; &#125;&#125;int d[MAXn + 10][2];void dp(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]] || deg[to[i]] == 2) continue; dp(to[i]); d[cur][0] += max(d[to[i]][1], d[to[i]][0]); d[cur][1] += d[to[i]][0]; &#125; d[cur][1] += a[cur];&#125;void Dp() &#123; memset(vis, 0, sizeof(vis)); for (re int i = 1; i &lt;= cntring; ++i) &#123; dp(ring[i]); &#125;&#125;int f[MAXn + 10][2][2];int Dp2() &#123; f[1][0][0] = d[ring[1]][0]; f[1][1][1] = d[ring[1]][1]; f[1][0][1] = f[1][1][0] = -INF; for (re int i = 2; i &lt;= cntring; ++i) &#123; f[i][0][0] = max(f[i - 1][0][0], f[i - 1][0][1]) + d[ring[i]][0]; f[i][0][1] = f[i - 1][0][0] + d[ring[i]][1]; f[i][1][0] = max(f[i - 1][1][0], f[i - 1][1][1]) + d[ring[i]][0]; f[i][1][1] = f[i - 1][1][0] + d[ring[i]][1]; &#125; return max(max(f[cntring][0][0], f[cntring][0][1]), f[cntring][1][0]);&#125;int main() &#123; read(n); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (re int i = 1, u, v; i &lt;= n; ++i) &#123; read(u), read(v); ++u; ++v; ++deg[u]; ++deg[v]; Insert(u, v); Insert(v, u); &#125; scanf(&quot;%lf&quot;, &amp;k); EvaRing(); Dp(); printf(&quot;%.1lf\\n&quot;, (double)Dp2() * k);&#125; 基环树求环长度和环上每个节点前的边的长度：123456789101112int cntinring, ring[MAXnd + 10], ringdis;int ndwei[MAXnd + 10];void EvaRing(int cur, int fromedge, int begin) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (iscut[i] || i == (fromedge ^ 1)) continue; ring[++cntinring] = to[i]; ringdis += wei[i]; ndwei[to[i]] = wei[i]; if (to[i] != begin) EvaRing(to[i], i, begin); if (cur == begin) break; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"埃氏筛","slug":"TemLib/埃氏筛","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/埃氏筛/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%9F%83%E6%B0%8F%E7%AD%9B/","excerpt":"","text":"P3383 【模板】线性筛素数12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#define re register const int MAXn = 1e8;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, cntp, p[MAXn / 10 + 100];bool notp[MAXn + 10];void ES(int up) &#123; notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; if ((long long)i * i &lt;= up) for (re int j = i * i; j &lt;= up; j += i) notp[j] = 1; &#125; &#125;&#125;int main() &#123; read(n), read(m); ES(n); for (re int i = 1, q; i &lt;= m; ++i) &#123; read(q); printf(&quot;%d\\n&quot;, p[q]); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"多重背包","slug":"TemLib/多重背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/多重背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1776 宝物筛选1. 单调队列优化版12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXW = 4e4;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int le, ri; pair&lt;int, int&gt; q[MAXW + 10];inline void Init() &#123; le = 1; ri = 0;&#125;inline void Push_back(int x, int idx) &#123; while (le &lt;= ri &amp;&amp; q[ri].first &lt;= x) &#123; --ri; &#125; q[++ri] = make_pair(x, idx);&#125;inline int Front(int idx) &#123; while (le &lt;= ri &amp;&amp; q[le].second &lt; idx) &#123; ++le; &#125; return q[le].first;&#125;int n, W, d[MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, v, w, m; i &lt;= n; ++i) &#123; read(v, w, m); for (int j = 0; j &lt; w; ++j) &#123; Init(); for (int k = 0, l = j; l &lt;= W; ++k, l += w) &#123; Push_back(d[l] - k * v, k); d[l] = Front(k - m) + k * v; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, d[W]);&#125; 2. 二进制拆分版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXn = 100;const int MAXW = 40000;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; &#125;&#125;void rec(int v[], int w[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125;&#125;int eva_maxV(int d[], int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; n = read(); W = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; v = read(); w = read(); num = read(); bin_divide(v, w, num, v_new, w_new, num_new); &#125; rec(v_new, w_new, W, num_new); cout &lt;&lt; eva_maxV(d, W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"堆排序","slug":"TemLib/堆排序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/堆排序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 【模板】快速排序可以用快排的板测123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int heap[MAXn+10];int heapn;int n;void up(int p) &#123; int f = p / 2; while (p &gt; 1) &#123; if (heap[p] &lt; heap[f]) &#123; swap(heap[p], heap[f]); p = f; f /= 2; &#125; else break; &#125;&#125;void down(int p) &#123; int s = p * 2; while (s &lt;= heapn) &#123; if (heap[s] &gt; heap[s + 1] &amp;&amp; s &lt; heapn) &#123; s++; &#125; if (heap[s] &lt; heap[p]) &#123; swap(heap[s], heap[p]); p = s; s *= 2; &#125; else break; &#125;&#125;void insert(int x) &#123; heap[++heapn] = x; up(heapn);&#125;void pop(int p) &#123; heap[p] = heap[heapn--]; up(p); down(p);&#125;void pop_root() &#123; heap[1] = heap[heapn--]; down(1);&#125;int get_root() &#123; return heap[1];&#125;int main()&#123; n = read(); for(int i = 0; i &lt; n; i++) &#123; insert(read()); &#125; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, get_root()); pop_root(); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"字符串dp","slug":"TemLib/字符串dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2dp/","excerpt":"","text":"P3082 [USACO13MAR]Necklace G1. Kmp上Dp（会T）12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::ios;using std::cin;using std::cout;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int INF = 0x3f3f3f3f;char txt[MAXltxt + 10], wrd[MAXlwrd + 10]; int ltxt, lwrd;int fail[MAXlwrd + 10];int d[MAXltxt + 10][MAXlwrd + 10];void EvaFail() &#123; fail[1] = 0; int j = 0; for (int i = 2; i &lt;= lwrd; ++i) &#123; while (j &amp;&amp; (wrd[j + 1] != wrd[i] || j == lwrd)) j = fail[j]; if (wrd[j + 1] == wrd[i]) ++j; fail[i] = j; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; while (k &amp;&amp; (wrd[k + 1] != txt[i + 1] || k == lwrd)) k = fail[k]; if (wrd[k + 1] == txt[i + 1]) ++k; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125; 2. Ac自动机上Dp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using std::ios;using std::cin;using std::cout;using std::queue;using std::min;const int MAXlwrd = 1e3;const int MAXltxt = 1e4;const int MAXnd = 1e3;const int INF = 0x3f3f3f3f;int cntnd, son[MAXnd + 10][26], fail[MAXnd + 10];int Insert(char *str) &#123; int len = strlen(str + 1); int cur = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (!son[cur][str[i] - &#x27;a&#x27;]) &#123; son[cur][str[i] - &#x27;a&#x27;] = ++cntnd; &#125; cur = son[cur][str[i] - &#x27;a&#x27;]; &#125; return cur;&#125;queue&lt;int&gt; q;void EvaFail() &#123; for (int i = 0; i &lt; 26; ++i) &#123; if (son[0][i]) &#123; q.push(son[0][i]); &#125; &#125; while (!q.empty()) &#123; int j = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) &#123; if (son[j][i]) &#123; fail[son[j][i]] = son[fail[j]][i]; q.push(son[j][i]); &#125; else &#123; son[j][i] = son[fail[j]][i]; &#125; &#125; &#125;&#125;char wrd[MAXlwrd + 10], txt[MAXltxt + 10];int n, lwrd, ltxt, d[MAXltxt + 10][MAXlwrd + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; (txt + 1) &gt;&gt; (wrd + 1); ltxt = strlen(txt + 1); lwrd = strlen(wrd + 1); Insert(wrd); EvaFail(); memset(d, 0x3f, sizeof(d)); d[0][0] = 0; for (int i = 0; i &lt; ltxt; ++i) &#123; for (int j = 0; j &lt; lwrd; ++j) &#123; int k = j; k = son[k][txt[i + 1] - &#x27;a&#x27;]; d[i + 1][k] = min(d[i + 1][k], d[i][j]); d[i + 1][j] = min(d[i + 1][j], d[i][j] + 1); &#125; &#125; int ans = INF; for (int i = 0; i &lt; lwrd; ++i) &#123; ans = min(ans, d[ltxt][i]); &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"字符串哈希","slug":"TemLib/字符串哈希","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串哈希/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/","excerpt":"","text":"P3370 【模板】字符串哈希1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1510;const int base = 261;const int MOD = 23333;int n, ans = 0;char s[MAXn];vector&lt;string&gt; hash[MOD + 2];inline void insert() &#123; int mo = 1; for (int i = 0; s[i]; i++) mo = (mo * 1ll * base + s[i]) % MOD; string s2 = s; for (int i = 0; i &lt; hash[mo].size(); i++) if (hash[mo][i] == s2) return; hash[mo].push_back(s2); ans++;&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, &amp;s), insert(); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"字符串哈希解最小循环节","slug":"TemLib/字符串哈希解最小循环节","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串哈希解最小循环节/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E8%A7%A3%E6%9C%80%E5%B0%8F%E5%BE%AA%E7%8E%AF%E8%8A%82/","excerpt":"","text":"P3538 POI2012\\OKR-A Horrible Poem1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e5;const int BASE = 107;const int MOD = 1e9 + 7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, cntp, p[MAXn + 10], minpf[MAXn + 10];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) &#123; p[++cntp] = i; minpf[i] = i; &#125; int up2 = up / i; for (int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; minpf[i * p[j]] = p[j]; if (!(i % p[j])) &#123; break; &#125; &#125; &#125;&#125;int hashpre[MAXn + 10], poww[MAXn + 10];inline int hash(int l, int r) &#123; return ((hashpre[r] - hashpre[l - 1] * poww[r - l + 1]) % MOD + MOD) % MOD;&#125;char str[MAXn + 10];signed main() &#123; read(n); LS(n); scanf(&quot;%s&quot;, str + 1); for (int i = 1; i &lt;= n; ++i) &#123; hashpre[i] = (hashpre[i - 1] * BASE + str[i] - &#x27;a&#x27;) % MOD; &#125; poww[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; poww[i] = (poww[i - 1] * BASE) % MOD; &#125; read(m); for (re int i = 1; i &lt;= m; ++i) &#123; int l, r, len, ans; read(l), read(r); ans = len = r - l + 1; if (hash(l + 1, r) == hash(l, r - 1)) &#123; printf(&quot;1\\n&quot;); &#125; else &#123; while (len &gt; 1) &#123; if (hash(l + ans / minpf[len], r) == hash(l, r - ans / minpf[len])) &#123; ans /= minpf[len]; //ans: 循环节长度 &#125; //minpf: 最小质因数，循环次数 len /= minpf[len]; //len: 无实际意义，用于提取所有质因数 &#125; printf(&quot;%lld\\n&quot;, ans); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"完全背包","slug":"TemLib/完全背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/完全背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1616 疯狂的采药12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 10000;const LL MAXW = 10000000;inline LL read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register LL x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;inline LL max(LL a, LL b) &#123; return a &gt; b ? a : b;&#125;LL n, W;LL d[MAXW + 10];int main() &#123; W = read(); n = read(); LL w, v; for (LL i = 0; i &lt; n; i++) &#123; w = read(); v = read(); for (LL i = w; i &lt;= W; i++) &#123; d[i] = max(d[i], d[i - w] + v); &#125; &#125; printf(&quot;%lld&quot;, d[W]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"字符串最小表示法","slug":"TemLib/字符串最小表示法","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/字符串最小表示法/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","excerpt":"","text":"P1368 【模板】最小表示法1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::min;const int MAXn = 3e5;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, a[MAXn * 2 + 10], begin;signed main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); a[i + n] = a[i]; &#125; int i = 1, j = 2, k = 0; while (true) &#123; if (i &gt; n || j &gt; n) &#123; begin = min(i, j); break; &#125; k = 0; while (a[i + k] == a[j + k] &amp;&amp; k &lt; n) ++k; if (k == n) &#123; begin = i; break; &#125; if (a[i + k] &gt; a[j + k]) &#123; i = i + k + 1; if (i == j) ++i; &#125; else &#123; j = j + k + 1; if (i == j) ++j; &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; printf(&quot;%d &quot;, a[begin + i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"容斥原理","slug":"TemLib/容斥原理","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/容斥原理/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"","text":"P1450 HAOI2008 硬币购物123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 4;const int MAXn2 = 16;const int MAXW = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int T, n = 4, W, w[MAXn + 10], cnt[MAXn + 10], d[MAXW + 10];signed main() &#123; read(w[1]), read(w[2]), read(w[3]), read(w[4]), read(T); d[0] = 1; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = w[i]; j &lt;= MAXW; ++j) &#123; d[j] += d[j - w[i]]; &#125; &#125; while (T--) &#123; read(cnt[1]), read(cnt[2]), read(cnt[3]), read(cnt[4]), read(W); int ans = 0; for (re int i = 0; i &lt; MAXn2; ++i) &#123; int p = W; for (re int j = 1; j &lt;= n; ++j) &#123; if ((i &gt;&gt; (j - 1)) &amp; 1) &#123; p -= w[j] * (cnt[j] + 1); &#125; &#125; if (p &lt; 0) &#123; continue; &#125; ans += __builtin_popcount(i) &amp; 1 ? -d[p] : d[p]; &#125; printf(&quot;%lld\\n&quot;, ans); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"对顶栈","slug":"TemLib/对顶栈","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/对顶栈/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AF%B9%E9%A1%B6%E6%A0%88/","excerpt":"","text":"P2201 数列编辑器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;struct Ele &#123; int val, sum, maxsum; Ele()&#123;&#125; Ele(int val_):val(val_)&#123;&#125;&#125;;struct Stack &#123; int top; Ele stk[MAXn + 10]; inline void Push(int x) &#123; stk[++top] = Ele(x); &#125; inline int Pop() &#123; return stk[top--].val; &#125;&#125;fro, beh;int n;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; char opt; for (re int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; opt; switch (opt) &#123; case &#x27;I&#x27;: cin &gt;&gt; x; fro.Push(x); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;D&#x27;: fro.Pop(); break; case &#x27;L&#x27;: beh.Push(fro.Pop()); break; case &#x27;R&#x27;: fro.Push(beh.Pop()); fro.stk[fro.top].sum = fro.stk[fro.top - 1].sum + fro.stk[fro.top].val; fro.stk[fro.top].maxsum = (fro.top == 1) ? fro.stk[fro.top].sum : max(fro.stk[fro.top - 1].maxsum, fro.stk[fro.top].sum); break; case &#x27;Q&#x27;: cin &gt;&gt; x; cout &lt;&lt; fro.stk[x].maxsum &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"实用小高精","slug":"TemLib/实用小高精","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/实用小高精/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%AE%9E%E7%94%A8%E5%B0%8F%E9%AB%98%E7%B2%BE/","excerpt":"","text":"不实用的高精 推荐一个实用小高精： 1234567891011121314151617181920212223struct BigInt &#123; const static long long base = 1e13; long long s[2]; friend BigInt operator + (BigInt a, const BigInt b) &#123; a.s[0] += b.s[0]; a.s[1] += b.s[1]; if (a.s[0] &gt;= base) ++a.s[1], a.s[0] -= base; return a; &#125; friend int operator % (BigInt a, int b) &#123; return ((a.s[1] % b) * base + a.s[0]) % b; &#125; friend BigInt operator / (BigInt a, int b) &#123; BigInt c; c.s[1] = a.s[1] / b; c.s[0] = ((a.s[1] % b) * base + a.s[0]) / b; return c; &#125; void print() &#123; if (s[1]) printf(&quot;%lld%13lld&quot;, s[1], s[0]); else printf(&quot;%lld&quot;, s[0]); &#125;&#125;; 乘法不用考虑，用 s[1] * s[1] 就炸了。减法还要考虑负数（如果需要的话）。","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"带权并查集","slug":"TemLib/带权并查集","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/带权并查集/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"带权并查集的适用前提：维护的关系具有可传递性 带权并查集操作需保证的条件：执行了 Find 函数或 Merge 函数的节点的所有信息一定会被更新 P2024 NOI2001 食物链1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e4;const int MAXm = 1e5;int fa[MAXn + 10], dis[MAXn + 10];void Init(int top) &#123; for (int i = 0; i &lt;= top; ++i) &#123; fa[i] = i; &#125; memset(dis, 0, sizeof(dis));&#125;int Find(int x) &#123; if (fa[x] == x) &#123; return x; &#125; else &#123; int lastfa = fa[x]; fa[x] = Find(fa[x]); dis[x] = dis[x] + dis[lastfa]; return fa[x]; &#125;&#125;void Merge(int x, int y, int dist) &#123; int ancx = Find(x), ancy = Find(y); fa[ancx] = ancy; dis[ancx] = -dis[x] + dist + dis[y];&#125;int Query(int x, int y) &#123; int ancx = Find(x), ancy = Find(y); if (ancx != ancy) &#123; return -1; &#125; else &#123; return ((dis[x] - dis[y]) % 3 + 3) % 3; &#125;&#125;int n, m, cntfalse;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; Init(n); for (int i = 1, opt, x, y; i &lt;= m; ++i) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; if (x &gt; n || y &gt; n) &#123; ++cntfalse; continue; &#125; if (opt == 1) &#123; int qu = Query(x, y); if (qu == -1) &#123; Merge(x, y, 0); &#125; else if (qu != 0) &#123; ++cntfalse; &#125; &#125; else &#123; int qu = Query(x, y); if (qu == -1) &#123; Merge(x, y, 1); &#125; else if (qu != 1) &#123; ++cntfalse; &#125; &#125; &#125; cout &lt;&lt; cntfalse &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"并查集","slug":"TemLib/并查集","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/并查集/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"P3367 【模板】并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#define re registerconst int MAXn = 1e4;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;int n, m;int main() &#123; read(n), read(m); Init(n); for (re int i = 1, opt, x, y; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y); Merge(x, y); break; case 2: read(x), read(y); SameAnc(x, y) ? printf(&quot;Y\\n&quot;) : printf(&quot;N\\n&quot;); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"康托展开 & 逆康托展开","slug":"TemLib/康托展开 & 逆康托展开","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/康托展开 & 逆康托展开/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%20&%20%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/","excerpt":"","text":"P3014 [USACO11FEB]Cow Line S 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 20;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : c ^ &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int t[MAXn + 10];inline int lowbit(int x) &#123; return x &amp; (-x);&#125;inline void BuildUseSum(int *sum, int top) &#123; for (int i = 1; i &lt;= top; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;inline void Add(int p, int x, int top) &#123; while (p &lt;= top) &#123; t[p] += x; p += lowbit(p); &#125;&#125;inline int Sum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;inline int Div(int l, int r, int x) &#123; int mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (Sum(mid) &gt;= x) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int fac[MAXn + 10];void EvaFac(int top) &#123; fac[0] = 1; for (int i = 1; i &lt;= top; ++i) &#123; fac[i] = fac[i - 1] * i; &#125;&#125;int sum[MAXn + 10];void EvaSum(int top) &#123; for (int i = 1; i &lt;= top; ++i) &#123; sum[i] = i; &#125;&#125;int n, q;int x, a[MAXn + 10];int cnt[MAXn + 10], ans[MAXn + 10];void InvCantor() &#123; BuildUseSum(sum, n); int tmpx = x - 1; for (int i = n; i; --i) &#123; cnt[i] = tmpx / fac[i - 1]; tmpx %= fac[i - 1]; &#125; for (int i = n; i; --i) &#123; ans[i] = Div(1, n, cnt[i] + 1); Add(ans[i], -1, n); &#125;&#125;int Cantor() &#123; BuildUseSum(sum, n); int ans = 1; for (int i = n; i; --i) &#123; Add(a[i], -1, n); ans += fac[i - 1] * Sum(a[i]); &#125; return ans;&#125;signed main() &#123; read(n, q); EvaFac(n); EvaSum(n); char opt; for (int i = 1; i &lt;= q; ++i) &#123; cin &gt;&gt; opt; if (opt == &#x27;P&#x27;) &#123; read(x); InvCantor(); for (int i = n; i; --i) &#123; printf(&quot;%lld &quot;, ans[i]); &#125; puts(&quot;&quot;); &#125; else &#123; for (int i = n; i; --i) &#123; read(a[i]); &#125; printf(&quot;%lld\\n&quot;, Cantor()); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"强连通分量","slug":"TemLib/强连通分量","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/强连通分量/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"","text":"B3609 [图论与代数结构 701] 强连通分量1234567891011121314151617181920212223242526272829303132int cntdfs, dfs[MAXnd + 10], low[MAXnd + 10];int cntscc; vector&lt;int&gt; scc[MAXnd + 10];int top, stk[MAXnd + 10]; bool instk[MAXnd + 10];void Tarjan(int cur) &#123; dfs[cur] = low[cur] = ++cntdfs; stk[++top] = cur; instk[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (dfs[to[i]] &amp;&amp; instk[to[i]]) &#123; low[cur] = min(low[cur], dfs[to[i]]); &#125; else if (!dfs[to[i]]) &#123; Tarjan(to[i]); low[cur] = min(low[cur], low[to[i]]); &#125; &#125; if (dfs[cur] == low[cur]) &#123; int x; ++cntscc; do &#123; x = stk[top--]; instk[x] = 0; scc[cntscc].push_back(x); &#125; while (x != cur); &#125;&#125;signed main() &#123; // ...... for (int i = 1; i &lt;= n; ++i) &#123; if (!dfs[i]) &#123; Tarjan(i); &#125; &#125;&#125; 缩点：12345for (int i = 1; i &lt;= m; ++i) &#123; if (inscc[from1[i]] != inscc[to1[i]]) &#123; Insert2(inscc[from1[i]], inscc[to1[i]]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"归并排序","slug":"TemLib/归并排序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/归并排序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 【模板】快速排序可以用快排的板测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x=x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];int tmp[MAXn + 10];void merge(int l, int r) &#123; if (r - l &lt;= 1) &#123; return; &#125; int mid = l + (r - l &gt;&gt; 1); merge(l, mid); merge(mid, r); int p = l, q = mid, s = l; while (s &lt; r) &#123; if (p &gt;= mid || (q &lt; r &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = l; i &lt; r; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"异或高斯消元","slug":"TemLib/异或高斯消元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/异或高斯消元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BC%82%E6%88%96%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"P2447 SDOI2010 外星千足虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 2e3; // 本代码中n和m和题面中的是反的，代码中n代表矩阵的行数，m代表列数const int MAXm = 1e3;int n, m, ans;bitset&lt;MAXm + 10&gt; a[MAXn + 10];signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin &gt;&gt; m &gt;&gt; n; char tmp; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m + 1; ++j) &#123; cin &gt;&gt; tmp; a[i][j] = tmp - &#x27;0&#x27;; &#125; &#125; int row = 1; for (int col = 1; col &lt;= m; ++col) &#123; int maxer = row; for (int i = row + 1; i &lt;= n; ++i) &#123; if (a[maxer][col] &lt; a[i][col]) &#123; maxer = i; &#125; &#125; if (!a[maxer][col]) &#123; cout &lt;&lt; &quot;Cannot Determine\\n&quot;; return 0; &#125; ans = max(ans, maxer); swap(a[row], a[maxer]); for (int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; if (a[i][col]) &#123; a[i] = a[i] ^ a[row]; &#125; &#125; ++row; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; for (int i = 1; i &lt;= m; ++i) &#123; if (a[i][m + 1]) &#123; cout &lt;&lt; &quot;?y7M#\\n&quot;; &#125; else &#123; cout &lt;&lt; &quot;Earth\\n&quot;; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快读","slug":"TemLib/快读","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/快读/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E8%AF%BB/","excerpt":"","text":"12345678template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"归并法求逆序对数","slug":"TemLib/归并法求逆序对数","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/归并法求逆序对数/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BD%92%E5%B9%B6%E6%B3%95%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0/","excerpt":"","text":"P1908 逆序对123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//Inverted Sequence Numbers//different from only Merge Sort:&quot;//Diff&quot; #include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn=500000;inline int read()&#123; register char c; while(c=getchar(),c&lt;&#x27;0&#x27;||c&gt;&#x27;9&#x27;); register int x(c-&#x27;0&#x27;); while(c=getchar(),c&gt;=&#x27;0&#x27;&amp;&amp;c&lt;=&#x27;9&#x27;) &#123; x=x*10+c-&#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn+10];int tmp[MAXn+10];long long ans;//Diffvoid merge(int ll, int rr) &#123; if (rr - ll &lt;= 1) &#123; return; &#125; int mid = ll + (rr - ll &gt;&gt; 1); merge(ll, mid); merge(mid, rr); int p = ll, q = mid, s = ll; while (s &lt; rr) &#123; if (p &gt;= mid || (q &lt; rr &amp;&amp; a[p] &gt; a[q])) &#123; tmp[s++] = a[q++]; ans += mid - p;//Diff &#125; else &#123; tmp[s++] = a[p++]; &#125; &#125; for (int i = ll; i &lt; rr; i++) &#123; a[i] = tmp[i]; &#125;&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; merge(0, n); printf(&quot;%lld&quot;, ans);//Diff&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快速乘","slug":"TemLib/快速乘","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/快速乘/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E4%B9%98/","excerpt":"","text":"龟速乘 12345678910111213template&lt;class T&gt;inline T mul(T x, T y, T mod) &#123; x %= mod; y %= mod; T ans = 0; while (y) &#123; if (y &amp; 1) &#123; ans = (ans + x) % mod; &#125; x = (x + x) % mod; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快速幂","slug":"TemLib/快速幂","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/快速幂/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"P1226 【模板】快速幂||取余运算12345678910111213typedef long long LL;const int MOD = 1e7 + 7;inline int power(int x, int y) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = ((LL)ans * x) % MOD; &#125; x = ((LL)x * x) % MOD; y &gt;&gt;= 1; &#125; return ans;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"快速排序","slug":"TemLib/快速排序","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/快速排序/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"P1177 【模板】快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = x * 10 + c - &#x27;0&#x27;; &#125; return x;&#125;int n;int a[MAXn + 10];void _QuickSort_(int* a, int l, int r) &#123; int i = l, j = r, f = a[(l + r) / 2]; do &#123; while (a[i] &lt; f) &#123; i++; &#125; while (a[j] &gt; f) &#123; j--; &#125; if (i &lt;= j) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; &#125; while (i &lt;= j); if (l &lt; j) &#123; _QuickSort_(a, l, j); &#125; if (i &lt; r) &#123; _QuickSort_(a, i, r); &#125;&#125;void QuickSort(int* a, int l, int r) &#123; _QuickSort_(a, l, r - 1);&#125;int main() &#123; n = read(); for (int i = 0; i &lt; n; i++) &#123; a[i] = read(); &#125; QuickSort(a, 0, n); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"折半搜索","slug":"TemLib/折半搜索","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/折半搜索/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/","excerpt":"","text":"P4799 [CEOI2015 Day2]世界冰球锦标赛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 40;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;map&lt;int, int&gt; map1, map2;int n, midn, W, w[MAXn + 10];signed main() &#123; read(n, W); midn = n &gt;&gt; 1; for (int i = 1; i &lt;= n; ++i) &#123; read(w[i]); &#125; map1[0] = map2[0] = 1; for (int i = 1; i &lt;= midn; ++i) &#123; auto j = end(map1), bottomj = begin(map1); for (--j; ; --j) &#123; map1[(*j).first + w[i]] += map1[(*j).first]; if (j == bottomj) break; &#125; &#125; for (int i = midn + 1; i &lt;= n; ++i) &#123; auto j = end(map2), bottomj = begin(map2); for (--j; ; --j) &#123; map2[(*j).first + w[i]] += map2[(*j).first]; if (j == bottomj) break; &#125; &#125; int sum = 0, ans = 0; auto j = begin(map2), topj = end(map2); auto i = end(map1), bottomi = begin(map1); for (--i; ; --i) &#123; int topmapj = W - (*i).first; while (j != topj &amp;&amp; (*j).first &lt;= topmapj) &#123; sum += (*j).second; ++j; &#125; ans += (*i).second * sum; if (i == bottomi) break; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"扩展欧几里得定理(exgcd)","slug":"TemLib/扩展欧几里得定理(exgcd)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/扩展欧几里得定理(exgcd)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86(exgcd)/","excerpt":"","text":"P1082 [NOIP2012 提高组] 同余方程P5656 【模板】二元一次不定方程 (exgcd)123456789101112131415161718192021#include&lt;cstdio&gt;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; else &#123; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d; &#125;&#125;int a, b, d, x, y;int main() &#123; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); d = exgcd(a, b, x, y); x *= d; x = (x % b + b) % b; printf(&quot;%d\\n&quot;, x);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"整体二分解静态区间第k小","slug":"TemLib/整体二分解静态区间第k小","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/整体二分解静态区间第k小/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E8%A7%A3%E9%9D%99%E6%80%81%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/","excerpt":"","text":"P3834【模板】可持久化线段树 2（主席树）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#define re registerconst int MAXn = 2e5;const int MAXm = 2e5;const int MAXai = 1e9;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int top, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x)))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= top) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int n, m, cnt, ans[MAXm + 10];struct Ele &#123; int idx, v, l, r, opt; Ele(): idx(0), v(0), l(0), r(0), opt(0) &#123;&#125; Ele(int idx_, int v_, int l_, int r_, int opt_): idx(idx_), v(v_), l(l_), r(r_), opt(opt_) &#123;&#125;&#125;a[MAXn + MAXm + 10], a1[MAXn + MAXm + 10], a2[MAXn + MAXm + 10];void Div(int L, int R, int l, int r) &#123; if (l &gt; r) return; if (L == R) &#123; for (re int i = l; i &lt;= r; ++i) &#123; if (a[i].opt) &#123; ans[a[i].idx] = L; &#125; &#125; &#125; else &#123; int mid = (L + R) &gt;&gt; 1; int cnt1 = 0; int cnt2 = 0; for (re int i = l; i &lt;= r; ++i) &#123; if (!a[i].opt) &#123; if (a[i].v &lt;= mid) &#123; a1[++cnt1] = a[i]; Add(a[i].idx, 1); &#125; else &#123; a2[++cnt2] = a[i]; &#125; &#125; else &#123; int x = EvaSum(a[i].r) - EvaSum(a[i].l - 1); if (a[i].v &lt;= x) &#123; a1[++cnt1] = a[i]; &#125; else &#123; a[i].v -= x; a2[++cnt2] = a[i]; &#125; &#125; &#125; for (re int i = 1; i &lt;= cnt1; ++i) &#123; if (!a1[i].opt) &#123; Add(a1[i].idx, -1); &#125; &#125; for (re int i = 1; i &lt;= cnt1; ++i) &#123; a[l + i - 1] = a1[i]; &#125; for (re int i = 1; i &lt;= cnt2; ++i) &#123; a[l + cnt1 + i - 1] = a2[i]; &#125; Div(L, mid, l, l + cnt1 - 1); Div(mid + 1, R, l + cnt1, r); &#125;&#125;int main() &#123; read(n), read(m); top = n; for (re int i = 1, v; i &lt;= n; ++i) &#123; read(v); a[++cnt] = Ele(i, v, 0, 0, 0); &#125; for (re int i = 1, l, r, k; i &lt;= m; ++i) &#123; read(l), read(r), read(k); a[++cnt] = Ele(i, k, l, r, 1); &#125; Div(-MAXai, MAXai, 1, cnt); for (re int i = 1; i &lt;= m; ++i) &#123; printf(&quot;%d\\n&quot;, ans[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"斜率优化dp & Luogu P3195 [HNOI2008]玩具装箱","slug":"TemLib/斜率优化dp & Luogu P3195 [HNOI2008]玩具装箱","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/斜率优化dp & Luogu P3195 [HNOI2008]玩具装箱/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%20&%20Luogu%20P3195%20[HNOI2008]%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1/","excerpt":"","text":"题目传送门 本题状转方程： \\begin{aligned} d_i&=\\min_{j","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"}]},{"title":"最小生成树","slug":"TemLib/最小生成树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最小生成树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"P3366 【模板】最小生成树Kruskal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 5e3;const int MAXm = 2e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m;int fa[MAXn + 10];int anc(int x) &#123; return fa[x] = fa[x] == x ? x : anc(fa[x]);&#125;void Merge(int x, int y) &#123; if (anc(x) != anc(y)) &#123; fa[anc(x)] = y; &#125;&#125;bool SameAnc(int x, int y) &#123; return anc(x) == anc(y);&#125;void Init(int top) &#123; for (re int i = 1; i &lt;= top; ++i) &#123; fa[i] = i; &#125;&#125;struct Edge &#123; int u, v, w; Edge():u(0), v(0), w(0)&#123;&#125; Edge(int u_, int v_, int w_):u(u_), v(v_), w(w_)&#123;&#125; inline bool operator&lt;(Edge x) &#123; return this-&gt;w &lt; x.w; &#125;&#125;edge[MAXm + 10];int Kruskal() &#123; int ans = 0; sort(edge + 1, edge + 1 + m); Init(n); for (re int i = 1; i &lt;= m; ++i) &#123; if (!SameAnc(edge[i].u, edge[i].v)) &#123; ans += edge[i].w; Merge(edge[i].u, edge[i].v); &#125; &#125; return ans;&#125;int ans;signed main() &#123; read(n), read(m); for (re int i = 1, u, v, w; i &lt;= m; ++i) &#123; read(u), read(v), read(w); edge[i] = Edge(u, v, w); &#125; ans = Kruskal(); for (re int i = 1; i &lt; n; ++i) &#123; if (!SameAnc(i, i + 1)) &#123; printf(&quot;orz\\n&quot;); return 0; &#125; &#125; printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"最短路","slug":"TemLib/最短路","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P3371 【模板】单源最短路径（弱化版）P4779 【模板】单源最短路径（标准版）1. Dijkstra1234567891011121314151617181920bool vis[MAXn + 10]; int dis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;Dijkstra(root); 2. SPFA1234567891011121314151617181920bool inque[MAXn + 10]; int dis[MAXn + 10];queue&lt;int&gt; q;void SPFA(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(root); inque[root] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;SPFA(root); 3. Floyd12345678for (re int k = 1; k &lt;= n; ++k) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); //传递闭包：con[i][j] |= con[i][k] &amp; con[k][j]; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"最近公共祖先(lca)","slug":"TemLib/最近公共祖先(lca)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最近公共祖先(lca)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88(lca)/","excerpt":"","text":"P3379 【模板】最近公共祖先（LCA）1. 倍增123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 500000;const int MAXlogdep = 19;const int MAXm = MAXn - 1;int anc[MAXn + 10][MAXlogdep + 10], dep[MAXn + 10], n, q, s;int head[MAXn + 10], next[MAXm * 2 + 10], toid[MAXm * 2 + 10], nown;int lg2[MAXn + 10];void Insert(int from, int to) &#123; next[++nown] = head[from]; head[from] = nown; toid[nown] = to;&#125;inline int read() &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;; &#125; return x;&#125;void Dfs(int nodeid, int fa) &#123; anc[nodeid][0] = fa; for (int i = 1; i &lt;= MAXlogdep; ++i) &#123; anc[nodeid][i] = anc[anc[nodeid][i - 1]][i - 1]; &#125; dep[nodeid] = dep[fa] + 1; for (int i = head[nodeid]; i; i = next[i]) &#123; if (toid[i] != fa) &#123; Dfs(toid[i], nodeid); &#125; &#125;&#125;void Init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; lg2[i] = lg2[i - 1] + (1 &lt;&lt; lg2[i - 1] == i); &#125; for (int i = 0; i &lt;= n; ++i) &#123; lg2[i]--; &#125;&#125;int Lca(int x, int y) &#123; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; while (dep[x] &lt; dep[y]) &#123; y = anc[y][lg2[dep[y] - dep[x]]]; &#125; if (x == y) &#123; return y; &#125; for (int i = lg2[dep[y]]; i &gt;= 0; --i) &#123; if (anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main() &#123; n = read(); q = read(); s = read(); Init(); int x, y; for (int i = 1; i &lt; n; ++i) &#123; x = read(); y = read(); Insert(x, y); Insert(y, x); &#125; Dfs(s, 0); for (int i = 0; i &lt; q; ++i) &#123; x = read(); y = read(); printf(&quot;%d\\n&quot;, Lca(x, y)); &#125; return 0;&#125; 2. 树剖12345678910int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; x = fa[top[x]]; &#125; else &#123; y = fa[top[y]]; &#125; &#125; return dep[x] &gt; dep[y] ? y : x;&#125; 3. 离线Tarjan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#define re registerconst int MAXn = 5e5;const int MAXm = MAXn;const int MAXq = 5e5;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int headq[MAXn + 10], cntnexq, nexq[MAXq + 10], q[MAXq + 10];void Insertq(int u, int v) &#123; nexq[++cntnexq] = headq[u]; headq[u] = cntnexq; q[cntnexq] = v;&#125;int fa[MAXn + 10]; bool vis[MAXn + 10];void Dfs1(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; fa[to[i]] = cur; Dfs1(to[i]); &#125;&#125;int times[MAXn + 10], ans[MAXq + 10];void Dfs2(int cur) &#123; ++times[cur]; for (re int i = headq[cur]; i; i = nexq[i]) &#123; int id = q[i]; while (times[id] != 1) &#123; id = fa[id]; &#125; ans[i] = id; &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (times[to[i]]) continue; Dfs2(to[i]); &#125; ++times[cur];&#125;int n, Q, root, qid_nexq[MAXq + 10];int main() &#123; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;Q, &amp;root); for (re int i = 1, u, v; i &lt; n; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); for (re int i = 1, u, v; i &lt;= Q; ++i) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); Insertq(u, v); qid_nexq[i] = cntnexq; &#125; Dfs2(root); for (re int i = 1; i &lt;= Q; ++i) &#123; printf(&quot;%d\\n&quot;, ans[qid_nexq[i]]); &#125;&#125; 4. 欧拉序请见 一位dalao的博客。（我懒得写了）","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"最长上升子序列(lis)","slug":"TemLib/最长上升子序列(lis)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最长上升子序列(lis)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(lis)/","excerpt":"","text":"本解法时间复杂度$O(nlogn)$，还有一种 DP 的 $O(n^2)$ 的求法，感兴趣的可以上网了解一下 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e5;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, s[MAXn + 10], cnt;int main() &#123; read(n); for (re int i = 1, a; i &lt;= n; ++i) &#123; read(a); if (a &gt; s[cnt]) &#123; s[++cnt] = a; &#125; else &#123; *lower_bound(s + 1, s + 1 + cnt, a) = a; &#125; &#125; printf(&quot;%d\\n&quot;, cnt);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"有理数取余","slug":"TemLib/有理数取余","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/有理数取余/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%89%E7%90%86%E6%95%B0%E5%8F%96%E4%BD%99/","excerpt":"","text":"P2613 【模板】有理数取余 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#define re register#define int long longconst int MOD = 19260817;inline void read(int &amp;a) &#123; register char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;); register int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; x = (x * 10 + c - &#x27;0&#x27;) % MOD; &#125; a = x;&#125;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int inv(int n, int mod) &#123; int inv, k; exgcd(n, mod, inv, k); return (inv % mod + mod) % mod;&#125;int frac(int a, int b, int mod) &#123; return (a * inv(b, mod)) % mod;&#125;int a, b;signed main() &#123; read(a), read(b); if (!(b % MOD)) &#123; printf(&quot;Angry!\\n&quot;); return 0; &#125; printf(&quot;%lld\\n&quot;, frac(a, b, MOD));&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"最长公共子序列(lcs)","slug":"TemLib/最长公共子序列(lcs)","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/最长公共子序列(lcs)/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(lcs)/","excerpt":"","text":"P1439 【模板】最长公共子序列本解法时间复杂度$O(nlogn)$，还有一种 DP 的 $O(n^2)$ 的求法，感兴趣的可以上网了解一下 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100000;const int INF = 0x3f3f3f3f;inline int read() &#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;int id[MAXn + 10];int mapping[MAXn + 10];int d[MAXn + 10];int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) id[read()] = i; for (int i = 1; i &lt;= n; i++) mapping[i] = id[read()]; memset(d, 0x3f, sizeof(d)); int len = 0; d[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; int l = 0, r = len, mid; if (mapping[i] &gt; d[len]) d[++len] = mapping[i]; else &#123; while (l &lt; r) &#123; mid = (l + r) / 2; if (d[mid] &gt; mapping[i]) r = mid; else l = mid + 1; &#125; d[l] = min(mapping[i], d[l]); &#125; &#125; cout &lt;&lt; len; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树上启发式合并","slug":"TemLib/树上启发式合并","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树上启发式合并/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","excerpt":"","text":"U41492 树上数颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int fa[MAXn + 10], hson[MAXn + 10], siz[MAXn + 10];void Dfs1(int cur, int f) &#123; fa[cur] = f; siz[cur] = 1; int mx = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; Dfs1(to[i], cur); siz[cur] += siz[to[i]]; if (mx &lt; siz[to[i]]) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int color[MAXn + 10], ans[MAXn + 10];int cntbuc, buc[MAXn + 10];void Dfs3(int cur, int hson) &#123; if (!buc[color[cur]]) ++cntbuc; ++buc[color[cur]]; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson) continue; Dfs3(to[i], hson); &#125;&#125;void Dfs2(int cur) &#123; if (!hson[cur]) &#123; ans[cur] = 1; buc[color[cur]] = 1; cntbuc = 1; &#125; else &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur] || to[i] == hson[cur]) continue; Dfs2(to[i]); memset(buc, 0, sizeof(buc)); cntbuc = 0; &#125; Dfs2(hson[cur]); Dfs3(cur, hson[cur]); ans[cur] = cntbuc; &#125;&#125;int n, q;signed main() &#123; read(n); for (int i = 1, u, v; i &lt; n; ++i) &#123; read(u, v); Insert(u, v); Insert(v, u); &#125; for (int i = 1; i &lt;= n; ++i) &#123; read(color[i]); &#125; Dfs1(1, 0); Dfs2(1); read(q); for (int i = 1, cur; i &lt;= q; ++i) &#123; read(cur); printf(&quot;%d\\n&quot;, ans[cur]); &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树上关键点","slug":"TemLib/树上关键点","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树上关键点/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E4%B8%8A%E5%85%B3%E9%94%AE%E7%82%B9/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e6;const int MAXm = MAXn;const int INF = 0x3f3f3f3f;template&lt;class T&gt;inline void read(T &amp;a) &#123; re char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());re bool f = c == &#x27;-&#x27;;re T x = f ? 0 : c - &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n, k, ans, root = 1;bool vis[MAXn + 10];pair&lt;int, bool&gt; Dfs(int cur) &#123; // 0: hav, 1: ned vis[cur] = 1; int ned = -INF, hav = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; pair&lt;int, bool&gt; tmp = Dfs(to[i]); if (tmp.second) &#123; ned = max(ned, tmp.first); &#125; else &#123; hav = max(hav, tmp.first); &#125; &#125; if (cur == root) &#123; if (ned == -INF &amp;&amp; hav == -INF) &#123; ++ans; &#125; else if (ned == -INF) &#123; ; &#125; else if (hav == -INF) &#123; ++ans; &#125; else &#123; if (ned &gt; hav) &#123; ++ans; &#125; else &#123; ; &#125; &#125; return make_pair(-1, -1); &#125; if (ned == -INF &amp;&amp; hav == -INF) &#123; return make_pair(1, 1); &#125; else if (ned == -INF) &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; else if (hav == -INF) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (ned &gt; hav) &#123; if (ned == k) &#123; ++ans; return make_pair(k - 1, 0); &#125; else &#123; return make_pair(ned + 1, 1); &#125; &#125; else &#123; if (hav == 0) &#123; return make_pair(0, 1); &#125; else &#123; return make_pair(hav - 1, 0); &#125; &#125; &#125;&#125;int main() &#123; read(n); read(k); if (k == 0) &#123; printf(&quot;%d\\n&quot;, n); return 0; &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs(root); printf(&quot;%d\\n&quot;, ans);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树形dp","slug":"TemLib/树形dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树形dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%BD%A2dp/","excerpt":"","text":"P1352 没有上司的舞会123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 6000;const int NEGINF = 0xc0c0c0c0;int n;int d[MAXn + 10][2];int v[MAXn + 10];int edgenum;int head[MAXn + 10];int next[MAXn + 10];int to[MAXn + 10];inline int read()&#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void first()&#123; memset(d, 0xc0c0, sizeof(d));&#125;void insert_edge(int from, int too)&#123; next[++edgenum] = head[from]; head[from] = edgenum; to[edgenum] = too;&#125;void put_in()&#123; n = read(); for (int i = 1; i &lt;= n; i++) v[i] = read(); for (int i = 1; i &lt; n; i++)&#123; int to = read(); int from = read(); insert_edge(from, to); &#125;&#125;int dp(int nodeid, bool have_root)&#123; if (d[nodeid][have_root] != NEGINF) return d[nodeid][have_root]; int&amp; ans = d[nodeid][have_root] = 0; if (!have_root) for (int i = head[nodeid]; i; i = next[i]) ans += max(dp(to[i], 0), dp(to[i], 1)); else&#123; ans += v[nodeid]; for (int i = head[nodeid]; i; i = next[i]) ans += dp(to[i], 0); &#125; return ans;&#125;int find_root()&#123; bool have_in_deg[MAXn + 10] = &#123; 0 &#125;; for (int i = 1; i &lt;= edgenum; i++) have_in_deg[to[i]] = 1; for (int i = 1; i &lt;= n; i++) if (!have_in_deg[i]) return i;&#125;int main()&#123; first(); put_in(); int rootid = find_root(); cout &lt;&lt; max(dp(rootid, 0), dp(rootid, 1)) &lt;&lt; endl;&#125; P2015 二叉苹果树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 100;const int MAXq = 100;const int INF = 0x3f3f3f3f;int n, q;int d[MAXn + 10][MAXq + 10];int to[MAXn + 10][2];//ÏÂ±ê1ÎªfromµÄidint edgew[MAXn + 10][2];//ÏÂ±ê1ÎªfromµÄidinline int read()&#123; char c; while (c = getchar(), c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;); int x(c - &#x27;0&#x27;); while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = x * 10 + c - &#x27;0&#x27;; return x;&#125;void Init()&#123; memset(d, -1, sizeof(d));&#125;void insert_edge(int nodeid1, int nodeid2, int edge_w)&#123; if (!to[nodeid1][0])&#123; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; to[nodeid1][0] = nodeid2; edgew[nodeid1][0] = edge_w; &#125;else&#123; to[nodeid1][1] = nodeid2; edgew[nodeid1][1] = edge_w; &#125;&#125;int dp(int nodeid, int keepnum)&#123; if (d[nodeid][keepnum] != -1) return d[nodeid][keepnum]; int&amp; ans = d[nodeid][keepnum] = 0; if (!keepnum) return ans = 0; if (!to[nodeid][0]) return ans = -INF; for (int knuml = 0; knuml &lt;= keepnum; knuml++)&#123; int knumr = keepnum - knuml; int tmp_ans = 0; if (knuml) tmp_ans += edgew[nodeid][0] + dp(to[nodeid][0], knuml - 1); if (knumr) tmp_ans += edgew[nodeid][1] + dp(to[nodeid][1], knumr - 1); ans = max(ans, tmp_ans); &#125; return ans;&#125;int main()&#123; Init(); n = read(); q = read(); for (int i = 1; i &lt; n; i++)&#123; int nodeid1 = read(); int nodeid2 = read(); int edgew = read(); insert_edge(nodeid1, nodeid2, edgew); &#125; cout &lt;&lt; dp(1, q);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树形背包","slug":"TemLib/树形背包","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树形背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/","excerpt":"","text":"1. size优化解树形背包注意：该方法无法解决带权树形背包。 P3177 HAOI2015 树上染色 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 2e3;const int MAXm = MAXn;const int MAXk = 2e3;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int head[MAXm + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, fa[MAXn + 10], siz[MAXn + 10], d[MAXn + 10][MAXk + 10];void Dfs(int cur) &#123; siz[cur] = 1; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs(to[i]); siz[cur] += siz[to[i]]; &#125;&#125;void DfsDp(int cur) &#123; d[cur][0] = d[cur][1] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; DfsDp(to[i]); for (int j = min(m, siz[cur]); ~j; --j) &#123; for (int k = 0; k &lt;= min(j, siz[to[i]]); ++k) &#123; d[cur][j] = max(d[cur][j], d[cur][j - k] + d[to[i]][k] + wei[i] * (k * (m - k) + (siz[to[i]] - k) * (n - siz[to[i]] - (m - k)))); &#125; &#125; &#125;&#125;signed main() &#123; memset(d, 0xc0, sizeof(d)); read(n, m); if (n &lt; m * 2) &#123; m = n - m; &#125; for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1); DfsDp(1); printf(&quot;%lld\\n&quot;, d[1][m]);&#125; 2. dfs序优化解树形背包U189430 带权树形背包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e3;const int MAXW = 1e4;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm + 10], from[MAXm + 10], to[MAXm + 10];inline void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; from[cntnex] = u; to[cntnex] = v;&#125;int n, W, ndw[MAXn + 10], ndv[MAXn + 10];int cntdfs, idxdfs[MAXn + 10], bottom[MAXn + 10];void Dfs(int cur) &#123; idxdfs[++cntdfs] = cur; for (int i = head[cur]; i; i = nex[i]) &#123; Dfs(to[i]); &#125; bottom[cur] = cntdfs;&#125;int d[MAXn * 2 + 10][MAXW + 10];signed main() &#123; read(n, W); for (int i = 1, f; i &lt;= n; ++i) &#123; read(ndw[i], f, ndv[i]); if (f == i) &#123; Insert(n + 1, i); &#125; else &#123; Insert(f, i); &#125; &#125; Dfs(n + 1); // 主干部分 for (int i = cntdfs; i; --i) &#123; int cur = idxdfs[i]; for (int j = W; j &gt;= ndw[cur]; --j) &#123; d[i][j] = max(d[bottom[cur] + 1][j], d[i + 1][j - ndw[cur]] + ndv[cur]); &#125; for (int j = ndw[cur] - 1; ~j; --j) &#123; d[i][j] = d[bottom[cur] + 1][j]; &#125; &#125; // 主干部分 int ans = 0; for (int j = 0; j &lt;= W; ++j) &#123; ans = max(ans, d[1][j]); &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树状数组","slug":"TemLib/树状数组","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树状数组/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"P3374 【模板】树状数组 1P3368 【模板】树状数组 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#define re register#define int long longconst int MAXn = 5e5;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;;&#125;a = f ? -x : x;&#125;int n, t[MAXn + 10];#define lowbit(x) ((x) &amp; (-(x))void BuildUseSum(int *sum) &#123; for (re int i = 1; i &lt;= n; ++i) &#123; t[i] = sum[i] - sum[i - lowbit(i)]; &#125;&#125;void Add(int p, int v) &#123; while (p &lt;= n) &#123; t[p] += v; p += lowbit(p); &#125;&#125;int EvaSum(int p) &#123; int ans = 0; while (p) &#123; ans += t[p]; p -= lowbit(p); &#125; return ans;&#125;int a[MAXn + 10], m;signed main() &#123; read(n), read(m); for (re int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseSum(a); for (re int i = 1, opt, x, y, k; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(k); Add(x, k); Add(y + 1, -k); break; case 2: read(x); printf(&quot;%lld\\n&quot;, EvaSum(x)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树的直径","slug":"TemLib/树的直径","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树的直径/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","excerpt":"","text":"U81904 【模板】树的直径 1. 两次Dfs注意：该方法无法解决负权树。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re registerusing namespace std;const int MAXn = 5e5;const int MAXm = MAXn;const int FINF = 0xc0c0c0c0;int n;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int dis[MAXn + 10]; bool vis[MAXn + 10];void Dfs(int cur) &#123; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; dis[to[i]] = dis[cur] + wei[i]; Dfs(to[i]); &#125;&#125;int EvaFar(int root) &#123; memset(dis, 0xc0, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[root] = 0; Dfs(root); int mx = FINF, maxer = 0; for (re int i = 1; i &lt;= n; ++i) &#123; if (mx &lt; dis[i]) &#123; mx = dis[i]; maxer = i; &#125; &#125; return maxer;&#125;int side1, side2;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1, u, v, w; i &lt; n; ++i) &#123; scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); Insert(u, v, w); Insert(v, u, w); &#125; side1 = EvaFar(1); side2 = EvaFar(side1); printf(&quot;%d %d\\n&quot;, side1, side2); printf(&quot;%d\\n&quot;, dis[side2]);&#125; 2. 树形Dp12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e5;const int MAXm = MAXn;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10], wei[MAXm * 2 + 10];inline void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int ans, d[MAXn + 10];void Dfs(int cur, int fath) &#123; for (int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fath) continue; Dfs(to[i], cur); ans = max(ans, d[cur] + d[to[i]] + wei[i]); d[cur] = max(d[cur], d[to[i]] + wei[i]); &#125;&#125;int n;signed main() &#123; read(n); for (int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u, v, w); Insert(u, v, w); Insert(v, u, w); &#125; Dfs(1, 0); printf(&quot;%d\\n&quot;, ans); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树的重心","slug":"TemLib/树的重心","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/树的重心/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/","excerpt":"","text":"P1395 会议 1234567891011121314151617181920212223242526int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int n;bool vis[MAXn + 10]; int siz[MAXn + 10], w[MAXn + 10], cen[2];void EvaCen(int cur) &#123; vis[cur] = 1; siz[cur] = 1; w[cur] = 0; for (re int i = head[cur]; i; i = nex[i]) &#123; if (vis[to[i]]) continue; EvaCen(to[i]); siz[cur] += siz[to[i]]; w[cur] = max(w[cur], siz[to[i]]); &#125; w[cur] = max(w[cur], n - siz[cur]); if (w[cur] &lt;= n / 2) &#123; cen[cen[0] != 0] = cur; &#125;&#125;EvaCen(1);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"树链剖分","slug":"TemLib/树链剖分","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/树链剖分/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","excerpt":"","text":"P3384 【模板】轻重链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define re register#define int long longconst int MAXn = 1e5;const int MAXm = MAXn;const int INF = 0x3f3f3f3f3f3f3f3f;template &lt;class T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;int n, k, root, mod;int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10], add[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[id &lt;&lt; 1] + sum[(id &lt;&lt; 1) + 1];&#125;inline void pushdown(int id) &#123; sum[id &lt;&lt; 1] += add[id] * (ri[id &lt;&lt; 1] - le[id &lt;&lt; 1] + 1); sum[(id &lt;&lt; 1) + 1] += add[id] * (ri[(id &lt;&lt; 1) + 1] - le[(id &lt;&lt; 1) + 1] + 1); add[id &lt;&lt; 1] += add[id]; add[(id &lt;&lt; 1) + 1] += add[id]; add[id] = 0;&#125;void BuildUseArray(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArray(id &lt;&lt; 1, l, mid, a); BuildUseArray((id &lt;&lt; 1) + 1, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int w) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] += w * (ri[id] - le[id] + 1); add[id] += w; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(id &lt;&lt; 1, l, r, w); if (r &gt; mid) Add((id &lt;&lt; 1) + 1, l, r, w); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; int ans = 0; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; ans += sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) ans += Eva(id &lt;&lt; 1, l, r); if (r &gt; mid) ans += Eva((id &lt;&lt; 1) + 1, l, r); &#125; return ans;&#125;int fa[MAXn + 10], dep[MAXn + 10], siz[MAXn + 10], hson[MAXn + 10];void Dfs1(int cur) &#123; dep[cur] = dep[fa[cur]] + 1; siz[cur] = 1; int mx = -INF; for (re int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == fa[cur]) continue; fa[to[i]] = cur; Dfs1(to[i]); siz[cur] += siz[to[i]]; if (siz[to[i]] &gt; mx) &#123; mx = siz[to[i]]; hson[cur] = to[i]; &#125; &#125;&#125;int cntdfs, nddfs[MAXn + 10], idxdfs[MAXn + 10], top[MAXn + 10], bottom[MAXn + 10];void Dfs2(int cur) &#123; nddfs[cur] = ++cntdfs; idxdfs[cntdfs] = cur; if (hson[cur]) &#123; top[hson[cur]] = top[cur]; Dfs2(hson[cur]); &#125; for (re int i = head[cur]; i; i = nex[i]) &#123; if (to[i] == hson[cur] || to[i] == fa[cur]) continue; top[to[i]] = to[i]; Dfs2(to[i]); &#125; bottom[cur] = idxdfs[cntdfs];&#125;void TreePathAdd(int x, int y, int w) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; Add(1, nddfs[top[y]], nddfs[y], w); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; Add(1, nddfs[x], nddfs[y], w);&#125;int TreePathEva(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; ans += Eva(1, nddfs[top[y]], nddfs[y]); y = fa[top[y]]; &#125; if (dep[x] &gt; dep[y]) &#123; swap(x, y); &#125; ans += Eva(1, nddfs[x], nddfs[y]); return ans;&#125;void SonTreeAdd(int x, int w) &#123; Add(1, nddfs[x], nddfs[bottom[x]], w);&#125;int SonTreeEva(int x) &#123; return Eva(1, nddfs[x], nddfs[bottom[x]]);&#125;int Lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &gt; dep[top[y]]) &#123; swap(x, y); &#125; y = fa[top[y]]; &#125; return dep[x] &gt; dep[y] ? y : x;&#125;int ndwei[MAXn + 10], idxwei[MAXn + 10];signed main() &#123; read(n), read(k), read(root), read(mod); for (re int i = 1; i &lt;= n; ++i) &#123; read(ndwei[i]); &#125; for (re int i = 1, u, v; i &lt; n; ++i) &#123; read(u), read(v); Insert(u, v); Insert(v, u); &#125; Dfs1(root); Dfs2(root); for (re int i = 1; i &lt;= n; ++i) &#123; idxwei[i] = ndwei[idxdfs[i]]; &#125; BuildUseArray(1, 1, n, idxwei); for (re int i = 1, opt, x, y, w; i &lt;= k; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(w); TreePathAdd(x, y, w); break; case 2: read(x), read(y); printf(&quot;%lld\\n&quot;, TreePathEva(x, y) % mod); break; case 3: read(x), read(w); SonTreeAdd(x, w); break; case 4: read(x); printf(&quot;%lld\\n&quot;, SonTreeEva(x) % mod); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"根号分治","slug":"TemLib/根号分治","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/根号分治/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/","excerpt":"","text":"P3396 哈希冲突 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5 + 5e4;const int MAXsqrtn = 387;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : (c ^ &#x27;0&#x27;);for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;a, Argv &amp;...argv) &#123; read(a), read(argv...);&#125;int n, sqrtn, m, a[MAXn + 10];int small[MAXsqrtn + 10][MAXsqrtn + 10];signed main() &#123; read(n, m); sqrtn = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); for (int j = 1; j &lt;= sqrtn; ++j) &#123; small[j][i % j] += a[i]; &#125; &#125; char opt; for (int i = 1; i &lt;= m; ++i) &#123; scanf(&quot;%s&quot;, &amp;opt); if (opt == &#x27;A&#x27;) &#123; int mod, yu; read(mod, yu); if (mod &lt;= sqrtn) &#123; printf(&quot;%d\\n&quot;, small[mod][yu]); &#125; else &#123; int ans = 0; for (int i = (yu ? yu : mod); i &lt;= n; i += mod) &#123; ans += a[i]; &#125; printf(&quot;%d\\n&quot;, ans); &#125; &#125; else &#123; int idx, val; read(idx, val); for (int i = 1; i &lt;= sqrtn; ++i) &#123; small[i][idx % i] += -a[idx] + val; &#125; a[idx] = val; &#125; &#125; return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"欧拉路径","slug":"TemLib/欧拉路径","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/欧拉路径/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/","excerpt":"","text":"1. 无向图欧拉路径P2731 [USACO3.3]骑马修栅栏 Riding the Fences 之所以要用邻接矩阵是因为一条边只能走一次，走过一条边这条边的另一个方向也不能走了，邻接矩阵便于删除走过的边的另一个方向。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 5e2;const int MAXm = 1024;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int n, m, source = 1, edge[MAXn + 10][MAXn + 10], deg[MAXn + 10];int top, stk[MAXm * 2 + 10];void Dfs(int cur) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (edge[cur][i]) &#123; --edge[cur][i]; --edge[i][cur]; Dfs(i); &#125; &#125; stk[++top] = cur;&#125;signed main() &#123; read(m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); ++edge[u][v]; ++edge[v][u]; ++deg[u]; ++deg[v]; n = max(n, max(u, v)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (deg[i] &amp; 1) &#123; source = i; break; &#125; &#125; Dfs(source); for (int i = top; i; --i) &#123; printf(&quot;%d\\n&quot;, stk[i]); &#125;&#125; 空间开不下 $O(n^2)$ 怎么办，听别人说要用什么当前弧优化，留坑待补…… 2. 有向图欧拉路径P7771 【模板】欧拉路径 有向图求欧拉路径，因为边没有另一个方向，所以不用删另一个方向。直接用邻接表即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 1e5;const int MAXm = 2e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; char c;for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar());bool f = c == &#x27;-&#x27;;T x = f ? 0 : c ^ &#x27;0&#x27;;for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123;x = x * 10 + (c ^ &#x27;0&#x27;);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;inline bool cmp(int a, int b) &#123; return a &gt; b;&#125;vector&lt;int&gt; edge[MAXn + 10];int top, stk[MAXm + 10];void Dfs(int cur) &#123; while (!edge[cur].empty()) &#123; int to = edge[cur].back(); edge[cur].pop_back(); Dfs(to); &#125; stk[++top] = cur;&#125; int n, m;int indeg[MAXn + 10], outdeg[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1, u, v; i &lt;= m; ++i) &#123; read(u, v); edge[u].push_back(v); ++outdeg[u]; ++indeg[v]; &#125; int cnt1 = 0, cnt2 = 0, bg = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (indeg[i] == outdeg[i] + 1) &#123; ++cnt1; &#125; else if (indeg[i] == outdeg[i] - 1) &#123; ++cnt2; bg = i; &#125; else if (indeg[i] != outdeg[i]) &#123; puts(&quot;No&quot;); return 0; &#125; &#125; if (!((cnt1 == 1 &amp;&amp; cnt2 == 1) || (cnt1 == 0 &amp;&amp; cnt2 == 0))) &#123; puts(&quot;No&quot;); return 0; &#125; if (bg == 0) &#123; bg = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; sort(begin(edge[i]), end(edge[i]), cmp); &#125; Dfs(bg); for (int i = top; i; --i) &#123; printf(&quot;%d &quot;, stk[i]); &#125; puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"次短路","slug":"TemLib/次短路","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/次短路/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%AC%A1%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"P2865 [USACO06NOV]Roadblocks G 1. Dijkstra123456789101112131415161718192021222324252627int dis[MAXn + 10], secdis[MAXn + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); memset(secdis, 0x3f, sizeof(secdis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second, d = -q.top().first; q.pop(); if (secdis[cur] &lt; d) continue; for (re int i = head[cur]; i; i = nex[i]) &#123; int dist = d + wei[i]; if (dis[to[i]] &gt; dist) &#123; swap(dis[to[i]], dist); q.push(make_pair(-dis[to[i]], to[i])); &#125; if (secdis[to[i]] &gt; dist) &#123; secdis[tod[i]] = dist; q.push(make_pair(-secdis[to[i]], to[i])); &#125; &#125; &#125;&#125;// main函数中Dijkstra(root);printf(&quot;%d\\n&quot;, secdis[cur]); 2. Spfa1234567891011121314151617181920212223242526272829303132333435int secdis[MAXn + 10], dis[MAXn + 10];bool inque[MAXn + 10];queue&lt;int&gt; q;int tmp[4];bool update(int &amp;dis1, int &amp;secdis1, int dis2, int secdis2) &#123; tmp[0] = dis1, tmp[1] = secdis1, tmp[2] = dis2, tmp[3] = secdis2; sort(tmp, tmp + 4); unique(tmp, tmp + 4); if (dis1 != tmp[0] || secdis1 != tmp[1]) &#123; dis1 = tmp[0], secdis1 = tmp[1]; return 1; &#125; else &#123; return 0; &#125;&#125;void Spfa(int sour) &#123; memset(secdis, 0x3f, sizeof(secdis)); memset(dis, 0x3f, sizeof(dis)); dis[sour] = 0; q.push(sour); inque[sour] = 1; while (!q.empty()) &#123; int cur = q.front(); q.pop(); inque[cur] = 0; for (int i = head[cur]; i; i = nex[i]) &#123; if (update(dis[to[i]], secdis[to[i]], dis[cur] + wei[i], secdis[cur] + wei[i])) &#123; if (!inque[to[i]]) &#123; q.push(to[i]); inque[to[i]] = 1; &#125; &#125; &#125; &#125;&#125;// main函数中Spfa(root);printf(&quot;%d\\n&quot;, secdis[cur]);","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"点分治","slug":"TemLib/点分治","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/点分治/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%82%B9%E5%88%86%E6%B2%BB/","excerpt":"","text":"P3806 【模板】点分治1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;#define re registertypedef long long LL;const int MAXn = 2e5;const int MAXm = 2e5;const int MAXpathlen = 1e8;const int INF = 0x3f3f3f3f;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;inline int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int cntnext, head[MAXn + 10], next[MAXm + 10], to[MAXm + 10], wei[MAXm + 10];inline void Insert(int from, int too, int w) &#123; next[++cntnext] = head[from]; head[from] = cntnext; to[cntnext] = too; wei[cntnext] = w;&#125;int root, nsontree, size[MAXn + 10], weight[MAXn + 10];bool vis[MAXn + 10]; //vis代表的是在Solve中是否访问过 void GetCore(int u, int fa) &#123; size[u] = 1; weight[u] = 0; for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(v == fa || vis[v]) &#123; continue; &#125; GetCore(v, u); size[u] += size[v]; weight[u] = max(weight[u], size[v]); &#125; weight[u] = max(weight[u], nsontree - size[u]); if(weight[u] &lt; weight[root]) &#123; root = u; &#125;&#125;int dis[MAXn + 10], cntrem, rem[MAXn + 10];void GetDis(int u, int fa) &#123; rem[++cntrem] = dis[u]; for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(v == fa || vis[v]) continue; dis[v] = dis[u] + wei[i]; GetDis(v, u); &#125; &#125;int nque;int test[MAXn + 10], q[MAXn + 10], query[MAXn + 10];bool judge[MAXpathlen + 10];void Calc(int u) &#123; int cnt = 0; for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(vis[v]) continue; cntrem = 0; dis[v] = wei[i]; GetDis(v, u); for(re int j = cntrem; j &gt; 0; --j) &#123; for(re int k = 1; k &lt;= nque; ++k)&#123; if(query[k] &gt;= rem[j])test[k] |= judge[query[k] - rem[j]]; &#125; &#125; for(re int j = cntrem; j &gt; 0; --j) &#123; judge[rem[j]] = true; q[++cnt] = rem[j]; &#125; &#125; for(re int i = 1; i &lt;= cnt; ++i) &#123; judge[q[i]] = false; &#125;&#125;void DivRule(int u) &#123; vis[u] = true; judge[0] = true; Calc(u); for(re int i = head[u]; i; i = next[i]) &#123; int v = to[i]; if(vis[v]) continue; nsontree = size[v]; weight[root = 0] = INF; GetCore(v, 0); DivRule(root); &#125;&#125;int n;int main() &#123; read(n); read(nque); for(re int i = 1, u, v, w; i &lt; n; ++i) &#123; read(u); read(v); read(w); Insert(u, v, w); Insert(v, u, w); &#125; for(re int i = 1; i &lt;= nque; ++i) &#123; read(query[i]); &#125; weight[root] = INF; nsontree = n; GetCore(1, 0); DivRule(root); for(re int i = 1; i &lt;= nque; ++i) &#123; if(test[i]) &#123; printf(&quot;AYE\\n&quot;); &#125; else &#123; printf(&quot;NAY\\n&quot;); &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"混合背包","slug":"TemLib/混合背包","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/混合背包/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85/","excerpt":"","text":"P1833 樱花1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXn = 10000;const int MAXW = 1000;const int INF = 0x3f3f3f3f;int n, W;int v_new[MAXn * 10 + 10];int w_new[MAXn * 10 + 10];bool is_limit[MAXn * 10 + 10];int num_new;int d[MAXW + 10];inline int read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c&gt;&#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register int s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar())s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; return f ? -s : s;&#125;void bin_divide(int v, int w, int num, int v_new[], int w_new[], int&amp; num_new, bool is_limit[]) &#123; for (int i = 1; num &gt;= i; i &lt;&lt;= 1) &#123; v_new[++num_new] = v * i; w_new[num_new] = w * i; is_limit[num_new] = 1; num -= i; &#125; if (num &gt; 0) &#123; v_new[++num_new] = v * num; w_new[num_new] = w * num; is_limit[num_new] = 1; &#125;&#125;void put_in() &#123; W = read(); n = read(); int v, w, num; for (int i = 1; i &lt;= n; i++) &#123; w = read(); v = read(); num = read(); if (num) bin_divide(v, w, num, v_new, w_new, num_new, is_limit); else &#123; v_new[++num_new] = v; w_new[num_new] = w; is_limit[num_new] = 0; &#125; &#125;&#125;void rec(int v[], int w[], bool is_limit[], int W, int num) &#123; for (int i = 1; i &lt;= num; i++) &#123; if (is_limit[i]) &#123; for (int j = W; j &gt;= w[i]; j--) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; else &#123; for (int j = w[i]; j &lt;= W; j++) d[j] = max(d[j], d[j - w[i]] + v[i]); &#125; &#125;&#125;int eva_maxV(int W) &#123; int ans = -INF; for (int i = 0; i &lt;= W; i++) ans = max(ans, d[i]); return ans;&#125;int main() &#123; put_in(); rec(v_new, w_new, is_limit, W, num_new); cout &lt;&lt; eva_maxV(W);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"矩阵运算","slug":"TemLib/矩阵运算","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/矩阵运算/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/","excerpt":"","text":"P3390 【模板】矩阵快速幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Mat &#123; int mat[MAXmat][MAXmat]; Mat() &#123; memset(mat, 0, sizeof(mat)); &#125; Mat(int a[MAXmat][MAXmat]) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = a[i][j]; &#125; &#125; &#125; inline void operator=(Mat x) &#123; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; mat[i][j] = x.mat[i][j]; &#125; &#125; &#125; inline Mat operator+(Mat x) &#123; Mat ans; for (int i = 0; i &lt; MAXmat; ++i) &#123; for (int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (mat[i][j] + x.mat[i][j]) % MOD; &#125; &#125; return ans; &#125; inline Mat operator*(Mat x) &#123; Mat ans; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int k = 0; k &lt; MAXmat; ++k) &#123; int a = mat[i][k]; for (re int j = 0; j &lt; MAXmat; ++j) &#123; ans.mat[i][j] = (a * x.mat[k][j] + ans.mat[i][j]) % MOD; &#125; &#125; &#125; return ans; &#125; inline Mat operator^(int x) &#123; Mat ans, base; for (re int i = 0; i &lt; MAXmat; ++i) &#123; ans.mat[i][i] = 1; &#125; for (re int i = 0; i &lt; MAXmat; ++i) &#123; for (re int j = 0; j &lt; MAXmat; ++j) &#123; base.mat[i][j] = mat[i][j]; &#125; &#125; while (x) &#123; if (x &amp; 1) &#123; ans = ans * base; &#125; base = base * base; x &gt;&gt;= 1; &#125; return ans; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"笛卡尔树","slug":"TemLib/笛卡尔树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/笛卡尔树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/","excerpt":"","text":"P5854 【模板】笛卡尔树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL MAXn = 1e7;struct Node &#123; LL p; LL ls; LL rs;&#125;;Node node[MAXn + 10];LL n;LL nowid;LL stk[MAXn + 10];LL top;inline LL read() &#123; register char c; for (c = getchar(); (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;; c = getchar()); register bool f = c == &#x27;-&#x27;; register LL s = f ? 0 : c - &#x27;0&#x27;; for (c = getchar(); c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) &#123; s = (s &lt;&lt; 3) + (s &lt;&lt; 1) + c - &#x27;0&#x27;; &#125; return f ? -s : s;&#125;void insert(LL p) &#123; nowid++; node[nowid].p = p; LL newtop = top; while (newtop &amp;&amp; node[stk[newtop]].p &gt; node[nowid].p) newtop--; if (newtop) node[stk[newtop]].rs = nowid; if (newtop &lt; top) node[nowid].ls = stk[newtop + 1]; stk[++newtop] = nowid; top = newtop;&#125;int main() &#123; n = read(); LL p; for (LL i = 0; i &lt; n; i++) &#123; p = read(); insert(p);/*这里 insert 的数字的值(p)没有单调的要求， 但数字的标号(id)要求单增，若不单增要先排序*/ &#125; for (LL i = 1; i &lt;= n; i++) &#123; printf(&quot;%lld %lld %lld\\n&quot;, node[i].p, node[i].ls, node[i].rs); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性求区间欧拉函数","slug":"TemLib/线性求区间欧拉函数","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/线性求区间欧拉函数/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#define re register#define DEBUGconst int MAXn = 1e3;int minpf[MAXn + 10], cntp, prime[MAXn / 5 + 100], phi[MAXn + 10];void EvaEuler(int up) &#123; phi[1] = 1; minpf[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!minpf[i]) &#123; minpf[i] = i; prime[++cntp] = i; phi[i] = i - 1; &#125; for (re int j = 1; j &lt;= cntp &amp;&amp; i * prime[j] &lt;= up &amp;&amp; minpf[i] &gt;= prime[j]; ++j) &#123; minpf[i * prime[j]] = prime[j]; phi[i * prime[j]] = phi[i] * (i % prime[j] ? prime[j] - 1 : prime[j]); &#125; &#125;&#125;int main() &#123; int up = 10; EvaEuler(up);#ifdef DEBUG for (re int i = 1; i &lt;= up; ++i) &#123; printf(&quot;%4d&quot;, i); &#125; printf(&quot;\\n&quot;); for (re int i = 1; i &lt;= up; ++i) &#123; printf(&quot;%4d&quot;, minpf[i]); &#125; printf(&quot;\\n&quot;); for (re int i = 1; i &lt;= up; ++i) &#123; printf(&quot;%4d&quot;, phi[i]); &#125; printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); for (re int i = 1; i &lt;= cntp; ++i) &#123; printf(&quot;%4d&quot;, prime[i]); &#125;#endif&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性求区间逆元","slug":"TemLib/线性求区间逆元","date":"un44fin44","updated":"un00fin00","comments":true,"path":"1970/01/01/TemLib/线性求区间逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E6%B1%82%E5%8C%BA%E9%97%B4%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 【模板】乘法逆元$invi=(p-\\left\\lfloor\\dfrac{p}{i}\\right\\rfloor)\\times inv{p\\operatorname{mod}i}\\operatorname{mod}p$ 123456void EvaSectionInvLine(int n, int mod, int inv[]) &#123; inv[1] = 1; for(int i = 2; i &lt;= n; i++) &#123; inv[i] = (long long) (mod - mod / i) * inv[mod % i] % mod; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线性筛","slug":"TemLib/线性筛","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/线性筛/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%80%A7%E7%AD%9B/","excerpt":"","text":"P3383 【模板】线性筛素数123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#define re register const int MAXn = 1e8;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt;&#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - &#x27;0&#x27;;a = x; &#125;int n, m, cntp, p[MAXn / 10 + 100];bool notp[MAXn + 10];void LS(int up) &#123; notp[1] = 1; for (re int i = 2; i &lt;= up; ++i) &#123; if (!notp[i]) p[++cntp] = i; int up2 = up / i; for (re int j = 1; j &lt;= cntp &amp;&amp; p[j] &lt;= up2; ++j) &#123; notp[i * p[j]] = 1; if (!(i % p[j])) break; &#125; &#125;&#125; int main() &#123; read(n), read(m); LS(n); for (re int i = 1, q; i &lt;= m; ++i) &#123; read(q); printf(&quot;%d\\n&quot;, p[q]); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线段树优化建图","slug":"TemLib/线段树优化建图","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/线段树优化建图/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define re registerconst int MAXn = 5e5;const int MAXm = 1e5;const int MAXedge = 3e7;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int head[MAXn * 11 + 10], cntnex, nex[MAXedge + 10], to[MAXedge + 10]; bool wei[MAXedge + 10];void Insert(int u, int v, int w) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v; wei[cntnex] = w;&#125;int n, m, root;struct Node&#123; int l, r, idx;&#125;out[MAXn * 4 + 10], in[MAXn * 4 + 10];int cntnd;void BuildOut(int id, int l, int r) &#123; out[id].idx = ++cntnd; out[id].l = l; out[id].r = r; if (l == r) &#123; Insert(l, out[id].idx, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildOut(id &lt;&lt; 1, l, mid); BuildOut((id &lt;&lt; 1) + 1, mid + 1, r); Insert(out[id &lt;&lt; 1].idx, out[id].idx, 0); Insert(out[(id &lt;&lt; 1) + 1].idx, out[id].idx, 0);&#125;void BuildIn(int id, int l, int r) &#123; in[id].idx = ++cntnd; in[id].l = l; in[id].r = r; if (l == r) &#123; Insert(in[id].idx, 10 * n + l, 0); return; &#125; int mid = (l + r) &gt;&gt; 1; BuildIn(id &lt;&lt; 1, l, mid); BuildIn((id &lt;&lt; 1) + 1, mid + 1, r); Insert(in[id].idx, in[id &lt;&lt; 1].idx, 0); Insert(in[id].idx, in[(id &lt;&lt; 1) + 1].idx, 0);&#125;int cntqin, qin[MAXn + 10], cntqout, qout[MAXn + 10];void GetSecIn(int id, int l, int r) &#123; if (in[id].l &gt;= l &amp;&amp; in[id].r &lt;= r) &#123; qin[++cntqin] = in[id].idx; return; &#125; int mid = (in[id].l + in[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecIn(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecIn((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void GetSecOut(int id, int l, int r) &#123; if (out[id].l &gt;= l &amp;&amp; out[id].r &lt;= r) &#123; qout[++cntqout] = out[id].idx; return; &#125; int mid = (out[id].l + out[id].r) &gt;&gt; 1; if (mid &gt;= l) &#123; GetSecOut(id &lt;&lt; 1, l, r); &#125; if (mid + 1 &lt;= r) &#123; GetSecOut((id &lt;&lt; 1) + 1, l, r); &#125;&#125;void InsertSec(int l1, int r1, int l2, int r2) &#123; cntqin = cntqout = 0; GetSecOut(1, l2, r2); GetSecIn(1, l1, r1); for (re int i = 1; i &lt;= cntqout; ++i) &#123; for (re int j = 1; j &lt;= cntqin; ++j) &#123; Insert(qout[i], qin[j], 1); &#125; &#125;&#125;bool vis[MAXn * 11 + 10]; int dis[MAXn * 11 + 10];priority_queue&lt;pair&lt;int, int&gt; &gt; q;void Dijkstra(int root) &#123; memset(dis, 0x3f, sizeof(dis)); dis[root] = 0; q.push(make_pair(0, root)); while (!q.empty()) &#123; int cur = q.top().second; q.pop(); if (vis[cur]) continue; vis[cur] = 1; for (re int i = head[cur]; i; i = nex[i]) &#123; if (dis[to[i]] &gt; dis[cur] + wei[i]) &#123; dis[to[i]] = dis[cur] + wei[i]; q.push(make_pair(-dis[to[i]], to[i])); &#125; &#125; &#125;&#125;int main() &#123; read(n), read(m), read(root); cntnd = n; BuildOut(1, 1, n); BuildIn(1, 1, n); for (re int i = 1, l1, r1, l2, r2; i &lt;= m; ++i) &#123; read(l1), read(r1), read(l2), read(r2); InsertSec(l1, r1, l2, r2); InsertSec(l2, r2, l1, r1); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; Insert(i, 10 * n + i, 0); Insert(10 * n + i, i, 0); &#125; Dijkstra(root); for (re int i = 10 * n + 1; i &lt;= 11 * n; ++i) &#123; printf(&quot;%d\\n&quot;, dis[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"莫队","slug":"TemLib/莫队","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/莫队/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%8E%AB%E9%98%9F/","excerpt":"","text":"P1494 [国家集训队]小Z的袜子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using std::sort;#define int long longconst int MAXn = 5e4;const int MAXm = 5e4;const int MAXc = 5e4;template &lt;typename T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;int b, cntblock, inblock[MAXn + 10];struct Query &#123; int l, r, id; inline bool operator&lt;(const Query &amp;y) const &#123; if (l / b == y.l / b) &#123; return (l / b) &amp; 1 ? r &lt; y.r : y.r &lt; r; &#125; return l &lt; y.l; &#125;&#125;q[MAXm + 10];int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;int n, m, a[MAXn + 10];int sum, cnt[MAXc + 10], ans1[MAXm + 10], ans2[MAXm + 10];inline void add(int x) &#123; sum += cnt[x]; ++cnt[x];&#125;inline void del(int x) &#123; --cnt[x]; sum -= cnt[x];&#125;void Mocap() &#123; int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (q[i].l &gt;= q[i].r) &#123; ans1[q[i].id] = 0; ans2[q[i].id] = 1; continue; &#125; while (l &gt; q[i].l) add(a[--l]); while (r &lt; q[i].r) add(a[++r]); while (l &lt; q[i].l) del(a[l++]); while (r &gt; q[i].r) del(a[r--]); ans1[q[i].id] = sum; ans2[q[i].id] = (r - l + 1) * (r - l) / 2; &#125;&#125;signed main() &#123; read(n, m); b = ceil((double)n / sqrt(ceil((double)m))); // b = sqrt(n); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; for (int i = 1; i &lt;= m; ++i) &#123; read(q[i].l, q[i].r); q[i].id = i; &#125; sort(q + 1, q + 1 + m); Mocap(); for (int i = 1; i &lt;= m; ++i) &#123; if (ans1[i] != 0) &#123; int g = gcd(ans1[i], ans2[i]); ans1[i] /= g, ans2[i] /= g; &#125; else &#123; ans2[i] = 1; &#125; printf(&quot;%lld/%lld\\n&quot;, ans1[i], ans2[i]); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"线段树","slug":"TemLib/线段树","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/线段树/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"P3372 【模板】线段树 11. 无懒标记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] == ri[id]) &#123; sum[id] = sum[id] + k; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125; 2. 有懒标记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXn = 1e5;template &lt;typename T&gt;inline void read(T &amp;a) &#123; register char c;while (c = getchar(), (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;);register bool f = c == &#x27;-&#x27;;register T x = f ? 0 : c - &#x27;0&#x27;;while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48);&#125;a = f ? -x : x;&#125;template &lt;typename T, typename ...Argv&gt;inline void read(T &amp;n, Argv &amp;...argv) &#123; read(n), read(argv...);&#125;#define ls (id &lt;&lt; 1)#define rs (id &lt;&lt; 1 | 1)int le[MAXn * 4 + 10], ri[MAXn * 4 + 10], add[MAXn * 4 + 10], sum[MAXn * 4 + 10];inline void pushup(int id) &#123; sum[id] = sum[ls] + sum[rs];&#125;inline void pushdown(int id) &#123; sum[ls] = sum[ls] + add[id] * (ri[ls] - le[ls] + 1); sum[rs] = sum[rs] + add[id] * (ri[rs] - le[rs] + 1); add[ls] = add[ls] + add[id]; add[rs] = add[rs] + add[id]; add[id] = 0;&#125;void Build0(int id, int l, int r) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; ; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; Build0(ls, l, mid); Build0(rs, mid + 1, r); &#125;&#125;void BuildUseArr(int id, int l, int r, int *a) &#123; le[id] = l; ri[id] = r; if (l == r) &#123; sum[id] = a[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; BuildUseArr(ls, l, mid, a); BuildUseArr(rs, mid + 1, r, a); pushup(id); &#125;&#125;void Add(int id, int l, int r, int k) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; sum[id] = sum[id] + k * (ri[id] - le[id] + 1); add[id] = add[id] + k; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1; if (l &lt;= mid) Add(ls, l, r, k); if (r &gt; mid) Add(rs, l, r, k); pushup(id); &#125;&#125;int Eva(int id, int l, int r) &#123; if (le[id] &gt;= l &amp;&amp; ri[id] &lt;= r) &#123; return sum[id]; &#125; else &#123; pushdown(id); int mid = (le[id] + ri[id]) &gt;&gt; 1, ans = 0; if (l &lt;= mid) ans = ans + Eva(ls, l, r); if (r &gt; mid) ans = ans + Eva(rs, l, r); return ans; &#125;&#125;#undef ls#undef rsint n, m, a[MAXn + 10];signed main() &#123; read(n, m); for (int i = 1; i &lt;= n; ++i) &#123; read(a[i]); &#125; BuildUseArr(1, 1, n, a); for (int i = 1, opt, x, y, z; i &lt;= m; ++i) &#123; read(opt); switch (opt) &#123; case 1: read(x, y, z); Add(1, x, y, z); break; case 2: read(x, y); printf(&quot;%lld\\n&quot;, Eva(1, x, y)); break; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"费马小定理求逆元","slug":"TemLib/费马小定理求逆元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/费马小定理求逆元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%B1%82%E9%80%86%E5%85%83/","excerpt":"","text":"P3811 【模板】乘法逆元此题不是求单个逆元的模板题，但可以用这道模板题检验这种求逆方法的正确性（没有WA） 123456789101112131415inline int power(int x, int y, int mod) &#123; int ans = 1; while (y) &#123; if (y &amp; 1) &#123; ans = (1LL * ans * x) % mod; &#125; y &gt;&gt;= 1; x = (1LL * x * x) % mod; &#125; return ans;&#125;int inv(int n, int mod) &#123; return power(n, mod - 2, mod);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"邻接表","slug":"TemLib/邻接表","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/邻接表/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%82%BB%E6%8E%A5%E8%A1%A8/","excerpt":"","text":"12345678910#include&lt;cstdio&gt;const int MAXn = 1e4;const int MAXm = 1e4 * 2;//无向图MAXM应开边数二倍int head[MAXn + 10], cntnex, nex[MAXm * 2 + 10], to[MAXm * 2 + 10];void Insert(int u, int v) &#123; nex[++cntnex] = head[u]; head[u] = cntnex; to[cntnex] = v;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"错排问题","slug":"TemLib/错排问题","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/错排问题/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"P1595 信封问题1234567891011121314#include&lt;cstdio&gt;#define int long long#define re registerconst int MAXn = 20;int n, a[MAXn + 10];signed main() &#123; a[1] = 0; a[2] = 1; scanf(&quot;%lld&quot;, &amp;n); for (re int i = 3; i &lt;= n; ++i) &#123; a[i] = (i - 1) * (a[i - 2] + a[i - 1]); &#125; printf(&quot;%lld\\n&quot;, a[n]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"高斯消元","slug":"TemLib/高斯消元","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/高斯消元/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"P2455 [SDOI2006]线性方程组高斯消元的模板我推荐这一道，而不是 Luogu P3389。原因是 P3389 数据确实太水了。我在 P3389 上 AC 的代码在 P2455 只有 20pts。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 50;int n;double a[MAXn + 10][MAXn + 1 + 10];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (re int i = 1; i &lt;= n; ++i) &#123; for (re int j = 1; j &lt;= n + 1; ++j) &#123; scanf(&quot;%lf&quot;, &amp;a[i][j]); &#125; &#125; int row = 1; for (re int col = 1; col &lt;= n; ++col) &#123; int maxer = row; for (re int i = row + 1; i &lt;= n; ++i) &#123; if (abs(a[maxer][col]) &lt; abs(a[i][col])) &#123; maxer = i; &#125; &#125; if (!a[maxer][col]) continue; for (re int j = 1; j &lt;= n + 1; ++j) &#123; swap(a[row][j], a[maxer][j]); &#125; for (re int i = 1; i &lt;= n; ++i) &#123; if (i == row) continue; double solve = a[i][col] / a[row][col]; for (re int j = col; j &lt;= n + 1; ++j) &#123; a[i][j] -= a[row][j] * solve; &#125; &#125; ++row; &#125; if (row &lt;= n) &#123; for (re int i = row; i &lt;= n; ++i) &#123; if (a[i][n + 1]) &#123; printf(&quot;-1\\n&quot;); return 0; &#125; &#125; printf(&quot;0\\n&quot;); &#125; else &#123; for (re int i = 1; i &lt;= n; ++i) &#123; if (int(a[i][n + 1] / a[i][i] * 100) == 0) &#123; printf(&quot;x%d=0\\n&quot;, i); &#125; else &#123; printf(&quot;x%d=%.2lf\\n&quot;, i, a[i][n + 1] / a[i][i]); &#125; &#125; &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"高斯消元解有后效性的dp","slug":"TemLib/高斯消元解有后效性的dp","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/高斯消元解有后效性的dp/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E6%9C%89%E5%90%8E%E6%95%88%E6%80%A7%E7%9A%84dp/","excerpt":"","text":"CF24D Broken robot123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define re registerconst int MAXn = 1e3;const int MAXm = 1e3;template &lt;class T&gt; inline void read(T &amp;a) &#123; register char c;while (c = getchar(), c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;);register T x(c - &#x27;0&#x27;);while (c = getchar(), c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48);&#125;a = x; &#125;int n, m, x, y;double mat[MAXm + 10][MAXm + 10], d[MAXn + 10][MAXm + 10];signed main() &#123; read(n), read(m); read(x), read(y); if (m == 1) &#123; printf(&quot;%d\\n&quot;, 2 * (n - x)); return 0; &#125; for (re int i = n - 1; i &gt;= x; --i) &#123; memset(mat, 0, sizeof(mat)); mat[1][1] = 2; mat[1][2] = -1; mat[1][m + 1] = d[i + 1][1] + 3; for (re int j = 2; j &lt; m; ++j) &#123; mat[j][j - 1] = mat[j][j + 1] = -1; mat[j][j] = 3; mat[j][m + 1] = d[i + 1][j] + 4; &#125; mat[m][m] = 2; mat[m][m - 1] = -1; mat[m][m + 1] = d[i + 1][m] + 3; // ------- 高斯消元 begin ------- for (re int i = 1; i &lt; m; ++i) &#123; double solve = mat[i + 1][i] / mat[i][i]; mat[i + 1][i] -= mat[i][i] * solve; if (i != m) &#123; mat[i + 1][i + 1] -= mat[i][i + 1] * solve; &#125; mat[i + 1][m + 1] -= mat[i][m + 1] * solve; &#125; for (re int i = m; i &gt; 1; --i) &#123; double solve = mat[i - 1][i] / mat[i][i]; mat[i - 1][i] -= mat[i][i] * solve; mat[i - 1][m + 1] -= mat[i][m + 1] * solve; &#125; // ------- 高斯消元 end ------- for (re int j = 1; j &lt;= m; ++j) &#123; d[i][j] = mat[j][m + 1] / mat[j][j]; &#125; &#125; printf(&quot;%.4f\\n&quot;, d[x][y]);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"}]},{"title":"高精运算","slug":"TemLib/高精运算","date":"un44fin44","updated":"un66fin66","comments":true,"path":"1970/01/01/TemLib/高精运算/","link":"","permalink":"http://rsdbkhusky.github.io/1970/01/01/TemLib/%E9%AB%98%E7%B2%BE%E8%BF%90%E7%AE%97/","excerpt":"","text":"实用小高精（推荐）P1601 A+B Problem（高精）P1303 A*B ProblemP1480 A/B Problem(转载的) 支持负数，压位，重载运算符 不过赛场上应该没人写一遍这个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 10000;const int BIT = 4;const int MOD = 1e4;struct bign &#123; int num[maxn], len; bool flag; friend bign abs(const bign &amp;x) &#123; bign k = x; k.flag = true; return k; &#125; friend void remove(bign &amp;x) &#123; while (x.num[x.len] == 0 &amp;&amp; x.len &gt; 1)x.len--; &#125; bign() &#123; memset(num, 0, sizeof(num)); flag = true; len = 1; &#125; bign(const int &amp;x) &#123; *this = bign(); if (x) &#123; int k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const ll &amp;x) &#123; *this = bign(); if (x) &#123; ll k = x; if (k &lt; 0)k = -k, flag = false; len = 0; while (k) &#123; num[++len] = k % MOD; k /= MOD; &#125; &#125; &#125; bign(const char *x) &#123; int l = strlen(x), s, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == 4) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign(const string x) &#123; int l = x.length(), s = 0, t = 0, p = 0, k = 1; *this = bign(); if (x[0] == &#x27;-&#x27;)flag = false, s = 1; len = 0; for (int i = l - 1; i &gt;= s; i--) &#123; p += k * (x[i] - &#x27;0&#x27;); k *= 10; t++; if (t == BIT) &#123; t = 0; num[++len] = p; p = 0; k = 1; &#125; &#125; if (p)num[++len] = p; &#125; bign operator=(const int &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const ll &amp;x) &#123; return *this = bign(x); &#125; bign operator=(const char *x) &#123; return *this = bign(x); &#125; bign operator=(const string &amp;x) &#123; return *this = bign(x); &#125; bool operator&lt;(const bign &amp;x) const &#123; if (flag != x.flag)return flag &lt; x.flag; if (len != x.len)return (len &lt; x.len) ^ flag ^ 1; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return (num[i] &lt; x.num[i]) ^ flag ^ 1; &#125; &#125; return false; &#125; bool operator&lt;(const int &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&lt;(const ll &amp;x) const &#123; return *this &lt; bign(x); &#125; bool operator&gt;(const bign &amp;x) const &#123; return x &lt; *this; &#125; bool operator&gt;(const int &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&gt;(const ll &amp;x) const &#123; return *this &gt; bign(x); &#125; bool operator&lt;=(const bign &amp;x) const &#123; return !(*this &gt; x); &#125; bool operator&lt;=(const int &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&lt;=(const ll &amp;x) const &#123; return *this &lt;= bign(x); &#125; bool operator&gt;=(const bign &amp;x) const &#123; return !(*this &lt; x); &#125; bool operator&gt;=(const int &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator&gt;=(const ll &amp;x) const &#123; return *this &gt;= bign(x); &#125; bool operator==(const bign &amp;x) const &#123; if (flag != x.flag)return false; if (len != x.len)return false; for (int i = len; i &gt;= 1; i--) &#123; if (num[i] != x.num[i]) &#123; return false; &#125; &#125; return true; &#125; bool operator==(const int &amp;x) const &#123; return *this == bign(x); &#125; bool operator==(const ll &amp;x) const &#123; return *this == bign(x); &#125; bool operator!=(const bign &amp;x) const &#123; return !(*this == x); &#125; bool operator!=(const int &amp;x) const &#123; return *this != bign(x); &#125; bool operator!=(const ll &amp;x) const &#123; return *this != bign(x); &#125; friend istream &amp;operator&gt;&gt;(istream &amp;in, bign &amp;x) &#123; string s; in &gt;&gt; s; x = s; return in; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const bign &amp;x) &#123; if (x.flag == false &amp;&amp; x != 0)out &lt;&lt; &quot;-&quot;; out &lt;&lt; x.num[x.len]; for (int i = x.len - 1; i &gt;= 1; i--)printf(&quot;%0*d&quot;, BIT, x.num[i]); return out; &#125; bign operator-() const &#123; bign k = *this; k.flag ^= 1; return k; &#125; bign operator+(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len || i &lt;= x.len; i++) &#123; int p = num[i] + x.num[i] + g; k.num[++k.len] = p % MOD; g = p / MOD; &#125; return k; &#125; if (flag &amp;&amp; !x.flag)return *this - (-x); if (!flag &amp;&amp; x.flag)return x - (-*this); return -((-x) + (-*this)); &#125; bign operator+(const int &amp;x) const &#123; return *this + bign(x); &#125; bign operator+=(const bign &amp;x) &#123; return *this = *this + x; &#125; bign operator+=(const int &amp;x) &#123; return *this += bign(x); &#125; bign operator+=(const ll &amp;x) &#123; return *this += bign(x); &#125; bign operator++() &#123; return *this += 1; &#125; bign operator++(int) &#123; bign k = *this; *this += 1; return k; &#125; bign operator-(const bign &amp;x) const &#123; if (flag &amp;&amp; x.flag &amp;&amp; *this &gt;= x) &#123; bign k = bign(); k.len = 0; for (int i = 1, g = 0; g || i &lt;= len; i++) &#123; int p = num[i] - x.num[i] + g; if (p &lt; 0)g = -1; else g = 0; k.num[++k.len] = (p % MOD + MOD) % MOD; &#125; remove(k); return k; &#125; if (flag &amp;&amp; x.flag)return -(x - *this); if (flag &amp;&amp; !x.flag)return *this + (-x); if (!flag &amp;&amp; x.flag)return -((-*this) + x); return (-x) - (-*this); &#125; bign operator-=(const bign &amp;x) &#123; *this = *this - x; return *this; &#125; bign operator-=(const int &amp;x) &#123; return *this -= bign(x); &#125; bign operator-=(const ll &amp;x) &#123; return *this -= bign(x); &#125; bign operator--() &#123; return *this -= 1; &#125; bign operator--(int) &#123; bign k = *this; *this -= 1; return k; &#125; bign operator*(const bign &amp;x) const &#123; bign k; k.flag = (flag == x.flag); k.len = len + x.len + 1; for (int i = 1; i &lt;= len; i++) &#123; for (int j = 1; j &lt;= x.len; j++) &#123; k.num[i + j - 1] += num[i] * x.num[j]; k.num[i + j] += k.num[i + j - 1] / MOD; k.num[i + j - 1] %= MOD; &#125; &#125; remove(k); return k; &#125; bign operator*(const int &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*(const ll &amp;x) const &#123; bign k = bign(); k.len = 0; long long t[maxn]; memset(t, 0, sizeof(t)); for (int i = 1; i &lt;= len; i++)t[i] = num[i] * x; for (int i = 1, g = 0; i &lt;= len || g; i++) &#123; k.num[++k.len] = (g + t[i]) % MOD; g = (g + t[i]) / MOD; &#125; return k; &#125; bign operator*=(const bign &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const int &amp;x) &#123; return *this = *this * x; &#125; bign operator*=(const ll &amp;x) &#123; return *this = *this * x; &#125; bign operator/(const bign &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(), a = bign(); k.flag = (flag == x.flag); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x)) &#123; a -= abs(x); k.num[i]++; &#125; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/(const int &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/(const ll &amp;x) const &#123; if (x == 0)return bign(); bign k = bign(); int a = 0; k.flag = (flag == (x &gt;= 0)); k.len = len; for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; k.num[i] = a / x; a %= x; &#125;// if ((flag != x.flag) &amp; a != 0)// k--; //È¡Ä£ remove(k); return k; &#125; bign operator/=(const bign &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const int &amp;x) &#123; return *this = *this / x; &#125; bign operator/=(const ll &amp;x) &#123; return *this = *this / x; &#125; bign operator%(const bign &amp;x) const &#123; if (x == 0)return bign(); bign a = bign(); for (int i = len; i &gt;= 1; i--) &#123; a = a * MOD + num[i]; while (a &gt;= abs(x))a -= abs(x); &#125;// if (a == 0)return a;// if (flag &amp;&amp; x.flag)return a;// if (flag &amp;&amp; !x.flag)return a + x;// if (!flag &amp;&amp; x.flag)return x - a;// return -a;//È¡Ä£ if (flag)return a; return -a; &#125; bign operator%(const int &amp;x) const &#123; return *this % bign(x); &#125; bign operator%(const ll &amp;x) const &#123; return *this % bign(x); &#125; bign operator%=(const bign &amp;x) &#123; return *this = *this % x; &#125; bign operator%=(const int &amp;x) &#123; return *this %= bign(x); &#125; bign operator%=(const ll &amp;x) &#123; return *this %= bign(x); &#125; friend bign pow(const bign &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const int &amp;x, const bign &amp;y) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans *= cnt; cnt *= cnt; w /= 2; &#125; return ans; &#125; friend bign pow(const bign &amp;x, const int &amp;y) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans *= cnt; cnt *= cnt; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const bign &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const int &amp;x, const bign &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x, w = y; while (w &gt; 0) &#123; if (w % 2 == 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w /= 2; &#125; return ans; &#125; friend bign powmod(const bign &amp;x, const int &amp;y, const int &amp;z) &#123; bign ans = 1, cnt = x; int w = y; while (w) &#123; if (w &amp; 1)ans = ans * cnt % z; cnt = cnt * cnt % z; w &gt;&gt;= 1; &#125; return ans; &#125; friend bign max(const bign &amp;x, const bign &amp;y) &#123; return x &gt; y ? x : y; &#125; friend bign min(const bign &amp;x, const bign &amp;y) &#123; return x &lt; y ? x : y; &#125;&#125;;int main() &#123; bign a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; a - b &lt;&lt; endl; cout &lt;&lt; a * b &lt;&lt; endl; cout &lt;&lt; a / b &lt;&lt; endl; cout &lt;&lt; a % b &lt;&lt; endl; return 0;&#125; 你竟然看完了！","categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"信息竞赛","slug":"编程/信息竞赛","permalink":"http://rsdbkhusky.github.io/categories/%E7%BC%96%E7%A8%8B/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"杂谈","slug":"杂谈","permalink":"http://rsdbkhusky.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://rsdbkhusky.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"代码","slug":"代码","permalink":"http://rsdbkhusky.github.io/tags/%E4%BB%A3%E7%A0%81/"},{"name":"软件","slug":"软件","permalink":"http://rsdbkhusky.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"信息竞赛","slug":"信息竞赛","permalink":"http://rsdbkhusky.github.io/tags/%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B/"},{"name":"OI","slug":"OI","permalink":"http://rsdbkhusky.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"http://rsdbkhusky.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://rsdbkhusky.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://rsdbkhusky.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","permalink":"http://rsdbkhusky.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"http://rsdbkhusky.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"字符串","slug":"字符串","permalink":"http://rsdbkhusky.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"模板","slug":"模板","permalink":"http://rsdbkhusky.github.io/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"几何","slug":"几何","permalink":"http://rsdbkhusky.github.io/tags/%E5%87%A0%E4%BD%95/"},{"name":"封装","slug":"封装","permalink":"http://rsdbkhusky.github.io/tags/%E5%B0%81%E8%A3%85/"}]}